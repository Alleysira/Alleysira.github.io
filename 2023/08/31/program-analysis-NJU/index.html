<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"alleysira.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="学习南京大学的静态程序分析技术课程 课程主页：Static Program Analysis | Tai-e (pascal-lab.net) 共计32小时">
<meta property="og:type" content="article">
<meta property="og:title" content="program_analysis_NJU">
<meta property="og:url" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/">
<meta property="og:site_name" content="Alleysira&#39;s blog">
<meta property="og:description" content="学习南京大学的静态程序分析技术课程 课程主页：Static Program Analysis | Tai-e (pascal-lab.net) 共计32小时">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230831102930623.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230831103339266.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230831104435688.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230831104701170.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230831105420735.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230831105711467.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230831150801393.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230831151433500.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230831152709196.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230831153019783.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230831153355882.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230831153713197.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230831154741536.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230831163003482.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230831163353046.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230831163931505.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230831164147119.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230831165004862.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230831170458580.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230831170815120.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230901090511569.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230901090643097.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230901091235279.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230901091633485.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230901091648122.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230901093246402.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230901093928280.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230901094252846.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230901101340886.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230901101445829.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230901101732041.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230901142516251.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230901143647456.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230901143914835.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230901144138225.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230901144554623.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230901145243994.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230901150349427.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230901150752423.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230901150828752.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230901152313029.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230901152523679.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230901154814673.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230901155156563.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230901155520326.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230901155548910.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230901161421363.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230901171055532.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230901171929909.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230901172108100.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230904094328736.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230904100041064.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230904155628294.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230904160245948.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230904160646443.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230904162203684.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230904162801564.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230904162854755.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230904165840491.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230904165925795.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230904172544309.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230904172906013.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230904185613558.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230904190155676.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230904191638058.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230904192251591.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230904192304012.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230904194220880.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230904194710101.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230904194725702.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230904195054862.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230905100158884.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230905100307750.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230905100734386.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230905101107238.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230905101527501.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230905101943246.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230905102005722.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230905102436174.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230905102707115.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230905110741805.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230905111254543.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230905110540907.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230905111616613.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230905112107491.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230905113959239.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230905114738987.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230905114859061.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230905151443765.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230905154855422.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230905155031011.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230905160510624.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230905164944314.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230905165647774.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230905172002679.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230905172123723.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230905172819265.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230905173425800.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230905174535083.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230906103700614.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230906103918799.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230906104601252.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230906104858404.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230906105336040.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230906105930450.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230906111532756.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230906111959118.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230906112920299.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230906113352119.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230906113916346.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230906114450105.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230906114617419.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230906114641085.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230906114815381.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230906115124716.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230906115354456.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230906115605922.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230906200743561.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230906201056655.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230906201244904.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230906201506211.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230906201707497.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230906211704923.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230906211826590.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230906211956325.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230907095105736.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230907100051983.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230907100501603.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230907100605564.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230907100725411.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230907101105920.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230907103248743.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230907104117327.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230907104201277.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230907105040021.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230907105101994.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230907105527714.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230907105536788.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230907105714714.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914182323812.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230911092021640.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230911093038934.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230911093309820.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230911093514885.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230911093643312.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230911093955437.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230911094118770.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230911100457311.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230911101619604.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230911104031780.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230911104343223.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230911105633949.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230911110032514.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230911110354258.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230911110406168.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230911110735865.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230911110905857.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230911111820078.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230911113127194.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230911113140353.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230911113613953.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230911113800642.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230911113809394.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230911160527617.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230911161609721.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230911161731273.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230911162000627.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230911163008942.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230911164230546.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230911170359600.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230911170411007.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230911170430735.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230911171405824.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230911172033462.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230912162251382.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230912162437486.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230912164701071.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230912165752464.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230912170440967.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230912170522098.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230912172112179.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230912172223253.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230912173001173.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230912184947416.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230912185840030.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230912190641848.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230912192345447.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230912192951269.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230912193211655.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230912194827600.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230912195049875.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230912201100384.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230912201119775.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230912201045606.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230912201334791.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230912201515062.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230912202332554.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230912205913463.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230912210139484.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230912213823131.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230912214053341.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230912214230647.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230912214620756.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230912215123422.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230912215631131.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230912220108442.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913152920936.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913153854777.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913153130047.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913154003008.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913154510890.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913154601481.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913162044882.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913162648159.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913164121180.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913164034410.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913164548268.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913165010456.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913170125124.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913172604357.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913172709985.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913193654682.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913195207715.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913195721511.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913201016340.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913201700466.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913202205377.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913202510805.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913201401242.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913202953061.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913205207631.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913205405562.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913205701513.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913205921749.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913210049720.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913210226746.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913210241719.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913210345697.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913211342441.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913211325855.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913211612588.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913211740289.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913212019260.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913212158190.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913212559603.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913212739282.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913213034386.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913213249693.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913213650461.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913213911354.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913214159779.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913214528489.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913214946878.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913215045186.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913215415014.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913215406095.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913215502781.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913220135749.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913220115069.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913220301552.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913221434446.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913221600990.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913221610803.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913221806951.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913222022073.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913222125660.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913222349159.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913222547175.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913222737380.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913222823795.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913222951872.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913223252088.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913223410217.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913223615033.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913223949083.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913224015374.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913224101296.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913224230753.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913224527154.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913224943480.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230913225056738.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914081639719.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914082014217.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914082257853.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914082932296.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914083536305.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914090327689.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914090712426.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914091418518.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914091438076.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914095905639.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914100142781.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914101547722.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914101250283.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914101854201.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914101908102.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914102037213.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914102223380.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914102916339.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914103028029.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914104300136.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914104707483.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914104809038.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914105259135.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914105804428.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914110511798.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914111707351.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914140129907.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914140322154.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914141003251.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914142144730.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914142834835.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914144611310.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914150855265.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914151715271.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914151704558.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914151857768.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914152005445.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914152618402.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914153507313.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914153649860.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914154323952.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914154812428.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914154937595.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914155709950.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914155955552.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914161155068.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914161603588.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914161732880.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914162225436.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914163513966.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914164026620.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914164317486.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914164531901.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914165357239.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914165556297.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914165745956.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914165932042.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914170548019.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914171130534.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914171721458.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914172026836.png">
<meta property="og:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230914172057149.png">
<meta property="article:published_time" content="2023-08-31T02:27:00.000Z">
<meta property="article:modified_time" content="2023-10-11T13:03:47.778Z">
<meta property="article:author" content="Alleysira">
<meta property="article:tag" content="static analysis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://alleysira.github.io/2023/08/31/program-analysis-NJU/image-20230831102930623.png">

<link rel="canonical" href="https://alleysira.github.io/2023/08/31/program-analysis-NJU/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>program_analysis_NJU | Alleysira's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Alleysira's blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Alleysira's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://alleysira.github.io/2023/08/31/program-analysis-NJU/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Alleysira">
      <meta itemprop="description" content="Eng.D student at School of Cyber Science and Teconology, BUAA.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alleysira's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          program_analysis_NJU
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-08-31 10:27:00" itemprop="dateCreated datePublished" datetime="2023-08-31T10:27:00+08:00">2023-08-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-11 21:03:47" itemprop="dateModified" datetime="2023-10-11T21:03:47+08:00">2023-10-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>学习南京大学的静态程序分析技术课程</p>
<p>课程主页：<a target="_blank" rel="noopener" href="https://tai-e.pascal-lab.net/lectures.html">Static Program Analysis | Tai-e (pascal-lab.net)</a></p>
<p>共计32小时</p>
<span id="more"></span>
<h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>PL的三个研究方向</p>
<ul>
<li>理论</li>
<li>环境</li>
<li>应用<ul>
<li>程序分析<ul>
<li>静态程序分析</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230831102930623.png" alt="image-20230831102930623"></p>
<p>静态分析：在编译时对程序进行检测</p>
<p>静态程序分析的应用</p>
<ul>
<li>程序可靠性</li>
<li>安全性</li>
<li>编译优化<ul>
<li>O(1)</li>
</ul>
</li>
<li>程序理解<ul>
<li>IDE实现的call的提示：利用静态分析实现</li>
</ul>
</li>
</ul>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230831103339266.png" alt="image-20230831103339266"></p>
<p>运行程序前了解程序的性质和行为（写一个程序来分析，分析器）</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230831104435688.png" alt="image-20230831104435688"></p>
<ul>
<li>运行时可能指向同一地址吗<ul>
<li>需要加锁解决竞争问题</li>
</ul>
</li>
</ul>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230831104701170.png" alt="image-20230831104701170"></p>
<p>对于一个正常的语言写的程序，我们感兴趣的运行时的性质是否满足 是不可判定的，即不存在完美的静态分析</p>
<p>perfect static analysis满足</p>
<ul>
<li>sound：包含所有truth，过近似</li>
<li>complete：是truth的子集，欠近似</li>
</ul>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230831105420735.png" alt="image-20230831105420735"></p>
<p>不存在perfect，因此想要一种useful的静态分析，可以仅满足一种性质，妥协另一种性质</p>
<ul>
<li>满足soundness：存在误报，false positive</li>
<li>满足complete：存在漏报，false negative</li>
</ul>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230831105711467.png" alt="image-20230831105711467"></p>
<p>绝大多数的程序分析都是sound，妥协complete</p>
<p>sound一般对应的是正确性，如下例，考虑到两条分支后才能得出正确的结论</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230831150801393.png" alt="image-20230831150753259"></p>
<p>可能有两个结论，都是sound的</p>
<p>平常的思维是动态思维，静态分析无法获得运行时的数据</p>
<p>第一个结论需要维护path branch和一个条件，比较昂贵；第二个比较cheap，速度快</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230831151433500.png" alt="image-20230831151433500"></p>
<p>确保（足够接近）soundness的情况下，在精度和分析速度上做平衡</p>
<p><strong>抽象</strong> <strong>过近似</strong> 是静态分析的核心思想</p>
<p>过近似包括transfer函数和控制流</p>
<p>抽象就是把具体值转变为符号</p>
<p>用bottom符号表示错误</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230831152709196.png" alt="image-20230831152709196"></p>
<p>transfer functions定义了转换规则，根据分析的具体问题和语句的语义设计</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230831153019783.png" alt="image-20230831153019783"></p>
<p>3说明静态分析会产生误报</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230831153355882.png" alt="image-20230831153355882"></p>
<p>控制流：在每个merge的地方进行抽象，可能出现过近似，默认采用的方式</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230831153713197.png" alt="image-20230831153713197"></p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230831154741536.png" alt="image-20230831154741536"></p>
<h1 id="Intermediate-Representation"><a href="#Intermediate-Representation" class="headerlink" title="Intermediate Representation"></a>Intermediate Representation</h1><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1zE411s77Z/?spm_id_from=333.788&amp;vd_source=fbfceeec0a697a64e4aba2132714eb9d">南京大学《软件分析》课程02（Intermediate Representation）_哔哩哔哩_bilibili</a></p>
<p>直接分析源代码存在弊端</p>
<p>静态分析需要一种程序表示的形式，没有严格的定义，因此介绍主流的IR</p>
<p>不介绍对C/C++的LLVM</p>
<h2 id="编译器和静态分析器"><a href="#编译器和静态分析器" class="headerlink" title="编译器和静态分析器"></a>编译器和静态分析器</h2><p>了解关系即可</p>
<p>编译的步骤：</p>
<ul>
<li><p>词法分析（符号和词的合法性），需要词法方法，正则表达式</p>
<ul>
<li>语法分析器parser，上下文无关文法</li>
</ul>
</li>
<li><p>语法分析，对AST进行分析，语义指简单的（类型检查）</p>
</li>
<li>代码生成，静态分析器在IR基础上做</li>
</ul>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230831163003482.png" alt="image-20230831163003482"></p>
<p>正常的IR需要所有前端模块才能生成</p>
<h2 id="AST-vs-IR"><a href="#AST-vs-IR" class="headerlink" title="AST vs. IR"></a>AST vs. IR</h2><p>3地址码3-address code</p>
<p>IR更接近于机器码，不依赖于编程语言（方舟编译器可以将不同语言生成为统一的IR）</p>
<p>AST缺乏对控制流的表达</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230831163353046.png" alt="image-20230831163353046"></p>
<h2 id="IR-3AC"><a href="#IR-3AC" class="headerlink" title="IR: 3AC"></a>IR: 3AC</h2><p>没有形式化的定义</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230831163931505.png" alt="image-20230831163931505"></p>
<p>指令右端只有1个操作符，每个语句只包含3个地址</p>
<ul>
<li>变量名 a,b</li>
<li>常量 3</li>
<li>编译器自动生成的临时变量 t1</li>
</ul>
<p>常见的形式</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230831164147119.png" alt="image-20230831164147119"></p>
<h2 id="Soot"><a href="#Soot" class="headerlink" title="Soot"></a>Soot</h2><p>java中最流行的静态分析器</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Sable/soot/wiki/Tutorials">https://github.com/Sable/soot/wiki/Tutorials</a></p>
<p>对应的IR是 Jimple，带有类型的3地址码</p>
<p>冒号是一种特殊的赋值</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230831165004862.png" alt="image-20230831165004862"></p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230831170458580.png" alt="image-20230831170458580"></p>
<p>JVM中的4种调用</p>
<ul>
<li><p>invokespecial: call constructor, call superclass methods, call private methods</p>
</li>
<li><p>invokevirtual: instance method call (virtual dispatch)</p>
</li>
<li><p>invokeinterface: cannot optimization, checking interface implementation 不能优化</p>
</li>
<li><p>invokestatic: call static methods</p>
</li>
</ul>
<p>Java7 invokedynamic -&gt; Jaava static typing, dynamic runs on JVM</p>
<p>meethod signature: class name, return type, method name, parameter types</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230831170815120.png" alt="image-20230831170815120"></p>
<p>所有类的父类，java.lang.object</p>
<p>默认生成的构造函数init</p>
<p>clinit 类的初始化的函数，compiler加载引用的变量进行初始化 class load init</p>
<h2 id="SSA"><a href="#SSA" class="headerlink" title="SSA"></a>SSA</h2><p>一种IR，有利于某些算法的设计，80年代提出的技术</p>
<p>和3AC的区别是每个变量的定义有新的命名，每个变量仅有一个等式</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230901090511569.png" alt="image-20230901090511569"></p>
<p>如果有控制流，采用$\phi$函数</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230901090643097.png" alt="image-20230901090643097"></p>
<p>为什么使用SSA</p>
<ul>
<li><p>flow-sensitive 维护程序执行顺序，精度更高，SSA本身带有部分flow的信息</p>
</li>
<li><p>数据的存储更清晰</p>
</li>
</ul>
<p>为什么不用SSA</p>
<ul>
<li>引入变量太多</li>
<li>译为机器码可能开销太大</li>
</ul>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230901091235279.png" alt="image-20230901091235279"></p>
<p>静态分析一般在CFG上分析，如何给定3AC建立CFG?</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230901091633485.png" alt="image-20230901091633485"></p>
<h2 id="Basic-Blocks"><a href="#Basic-Blocks" class="headerlink" title="Basic Blocks"></a>Basic Blocks</h2><p>basic blocks是最多的连续的3AC码的集合，满足以下指令：</p>
<ul>
<li>只能从第一个指令进入（没有其他控制流</li>
<li>出口是最后一个指令</li>
</ul>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230901091648122.png" alt="image-20230901091648122"></p>
<ul>
<li>如果指令是goto的地址，只能作为入口</li>
<li>goto只能作为出口<ul>
<li>goto的下一句一定是入口 </li>
</ul>
</li>
</ul>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230901093246402.png" alt="image-20230901093246402"></p>
<p>仅确定入口即可</p>
<p>BB是CFG的节点，补充边就有了CFG</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230901093928280.png" alt="image-20230901093928280"></p>
<h2 id="CFG"><a href="#CFG" class="headerlink" title="CFG"></a>CFG</h2><p><img src="/2023/08/31/program-analysis-NJU/image-20230901094252846.png" alt="image-20230901094252846"></p>
<p>条件jump有2两个出口</p>
<p>B2是B1的后继，前驱只能有一个，后继可以有多个</p>
<p>entry也可以有很多</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230901101340886.png" alt="image-20230901101340886"></p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230901101445829.png" alt="image-20230901101445829"></p>
<p>IR和AST的区别</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230901101732041.png" alt="image-20230901101732041"></p>
<p>企业可能认为content-insentive比较慢，学术界关注的是content-sensitive的技术</p>
<h1 id="Data-Flow-Analysis-Applications"><a href="#Data-Flow-Analysis-Applications" class="headerlink" title="Data Flow Analysis Applications"></a>Data Flow Analysis Applications</h1><p>编译后端优化的技术</p>
<p>3个应用</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230901142516251.png" alt="image-20230901142516251"></p>
<h2 id="Overview-of-Data-Flow-Analysis"><a href="#Overview-of-Data-Flow-Analysis" class="headerlink" title="Overview of Data Flow Analysis"></a>Overview of Data Flow Analysis</h2><p>研究数据怎样在CFG中流动</p>
<p>静态程序分析是过拟合的，输出可能是假阳</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230901143647456.png" alt="image-20230901143647456"></p>
<p>过拟合和欠拟合都是安全的分析，应该将over改成safe</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230901143914835.png" alt="image-20230901143914835"></p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230901144138225.png" alt="image-20230901144138225"></p>
<p>主要介绍不同的数据流分析的应用</p>
<h2 id="Preliminaries-of-Data-Flow-Analysis"><a href="#Preliminaries-of-Data-Flow-Analysis" class="headerlink" title="Preliminaries of Data Flow Analysis"></a>Preliminaries of Data Flow Analysis</h2><p>形式化方法</p>
<p>程序执行前后会产生状态变化，与程序点关联</p>
<p>顺序执行的语句前一条语句的输出和后一条的输入相关，具体还有分支的形式</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230901144554623.png" alt="image-20230901144554623"></p>
<p>操作符是meet operator，可以是union或者其他运算符</p>
<p>数据流分析需要对每个程序点的所有可能状态的抽象（data flow value，绿色的）</p>
<p>domain是value的值域</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230901145243994.png" alt="image-20230901145243994"></p>
<p>数据流分析是为了找到对输入输出状态的约束的解，有两类</p>
<ul>
<li>基于状态的语义（转移函数）<ul>
<li>前向分析</li>
<li>反向分析（可能会对逆向的CFG进行前向分析）</li>
<li><img src="/2023/08/31/program-analysis-NJU/image-20230901150349427.png" alt="image-20230901150349427"></li>
</ul>
</li>
<li>基于控制流的约束<ul>
<li>Basic Blocks里面的<ul>
<li>$IN[s_{i+1}]=OUT[s_i],\text{for all }i\in\{1,\dots,n-1\}$</li>
</ul>
</li>
<li>BB之间的<ul>
<li>复合函数</li>
<li><img src="/2023/08/31/program-analysis-NJU/image-20230901150752423.png" alt="image-20230901150752423"></li>
<li><img src="/2023/08/31/program-analysis-NJU/image-20230901150828752.png" alt="image-20230901150828752"></li>
<li>红色的是反向的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Reaching-Definitions-Analysis"><a href="#Reaching-Definitions-Analysis" class="headerlink" title="Reaching Definitions Analysis"></a>Reaching Definitions Analysis</h2><p>不涉及函数调用，讨论的是方法内的CFG</p>
<p>变量是别名的形式（指针分析，别名分析，指向分析）</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230901152313029.png" alt="image-20230901152313029"></p>
<p>reaching definition</p>
<ul>
<li>存在一条路径能到达</li>
<li>不能被二次赋值</li>
</ul>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230901152523679.png" alt="image-20230901152523679"></p>
<p>编译优化会用到，也可以用来分析undefined variable</p>
<p>是一种may-Analysis，过拟合</p>
<p>100个定义用100个definition来定义</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230901154814673.png" alt="image-20230901154814673"></p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230901155156563.png" alt="image-20230901155156563"></p>
<p>给出了转移函数的定义</p>
<p>因为无法确定BB之间的前驱关系，所有定义了当前BB内的定义的语句都需要被kill掉</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230901155520326.png" alt="image-20230901155520326"></p>
<p>对于control flow进行分析，定义</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230901155548910.png" alt="image-20230901155548910"></p>
<p>入口的output为空，entry没有定义 （may analyse一般为空，must analyse一般考虑为undefined）</p>
<p>除了entry的BB的output都为空（程序都没运行）</p>
<p>当任何OUT改变的话</p>
<p>会停机吗？</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230901161421363.png" alt="image-20230901161421363"></p>
<p>B3的Input=10110000</p>
<p>B3的Output=00000010 union (10110000 - 10001000) = 00000010 union 00110000 = 00110010</p>
<p>上一轮的BB的out都是空，全变了，再循环一轮</p>
<p>B2的out= 10111100    </p>
<p>B3的out= 00110110 </p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230901171055532.png" alt="image-20230901171055532"></p>
<p>根据转移函数的定义，当输入不变时输出不变</p>
<p>如何证明算法的收敛</p>
<p>$OUT[S]=gen_s\cup (IN[S] -kill_s)$</p>
<ul>
<li>$gen_s \text{和}kill_s$不变</li>
<li>more facts加入后，只会让多+1而不会多kill，单调递增的感觉</li>
<li>facts是有限的</li>
</ul>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230901171929909.png" alt="image-20230901171929909"></p>
<p>为什么每个out不再变化就说明停机了？</p>
<p>Out不变，In不变，Out不变</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230901172108100.png" alt="image-20230901172108100"></p>
<p>算法到达了不动点，和单调性相关</p>
<h2 id="Live-Variables-Analysis"><a href="#Live-Variables-Analysis" class="headerlink" title="Live Variables Analysis"></a>Live Variables Analysis</h2><p>数据流分析的应用，归结为在格上求解不动点的问题</p>
<p>一般分析算法求出的是最大不动点和最小不动点</p>
<p>定义：某处变量的值是否能够在后面可以使用（用之前是live，不能被重定义）</p>
<p>live变量的信息可以用于寄存器分配，当寄存器满了的时候</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230904094328736.png" alt="image-20230904094328736"></p>
<p>定义中指出是some path，因此是一种may analysis，定义的直观含义是某点的变量是否会被后续用到</p>
<p>变量和定义的区别在哪里？</p>
<p>都用bit vector表示</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230904100041064.png" alt="image-20230904100041064"></p>
<p>采用backward的方法进行分析</p>
<p>In[B]= use_B union (Out[B] - redine[B])</p>
<p>通过具体情况枚举分析</p>
<p>use在define之前</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230904155628294.png" alt="image-20230904155628294"></p>
<p>更正：此处的$OUT[B]=\cup_S IN[s]$</p>
<p>给定的out求in，边界条件为in=空</p>
<p>一般情况下may analyse的初始化是空，must analyse是all，和reaching definition定义很像</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230904160245948.png" alt="image-20230904160245948"></p>
<p>0001000 </p>
<p>B4有两个后继，out[b4]=in[b2] union in[b5] = 0001000 union 0000000 = 0001000</p>
<p>in[b4]= 0100000 union (0001000 - 1000000) = 0101000</p>
<p>B2的Input是 100 1001，因为m是在define后用的</p>
<p>B1的输入0011101</p>
<p>第二轮 </p>
<p>0101001 </p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230904160646443.png" alt="image-20230904160646443"></p>
<p>计算INPUT的顺序不同会影响迭代的次数</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230904162203684.png" alt="image-20230904162203684"></p>
<h2 id="Available-Expressions-Analysis"><a href="#Available-Expressions-Analysis" class="headerlink" title="Available Expressions Analysis"></a>Available Expressions Analysis</h2><p>一种must analysis，为了实现对程序的优化而不是解决安全问题</p>
<p>从程序入口到p的所有路径必须经过表达式 $x\  op\  y$，并且表达式最后的求值之后，$x$和$y$不能被重定义</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230904162801564.png" alt="image-20230904162801564"></p>
<p>类似于表达式简化的思想，p点之后对该表达式可以进行替代</p>
<p>首先给出抽象</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230904162854755.png" alt="image-20230904162854755"></p>
<p>是一种前向分析</p>
<p>out = gen union (input - kill)</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230904165840491.png" alt="image-20230904165840491"></p>
<p>两个分支后是available的</p>
<p>因为所有pass都必须available，输入是前驱输出的交集</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230904165925795.png" alt="image-20230904165925795"></p>
<p>优化而不是找bug，不能误报</p>
<p>初始化为全1（因为要交）</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230904172544309.png" alt="image-20230904172544309"></p>
<p>out[B1]=10000</p>
<p>out[B2]=01010 union (10000 - 10000)=01010</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230904172906013.png" alt="image-20230904172906013"></p>
<p>B4 input=11111, Output= 00110 union (01010-00010) =01110</p>
<p>先算kill再算gen，根据定义</p>
<p>01010 union (00010 - 00111)=01010</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230904185613558.png" alt="image-20230904185613558"></p>
<p>三类定义的对比</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230904190155676.png" alt="image-20230904190155676"></p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230904191638058.png" alt="image-20230904191638058"></p>
<h1 id="Data-Flow-Analysis-Foundation"><a href="#Data-Flow-Analysis-Foundation" class="headerlink" title="Data Flow Analysis Foundation"></a>Data Flow Analysis Foundation</h1><p><img src="/2023/08/31/program-analysis-NJU/image-20230904192251591.png" alt="image-20230904192251591"></p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230904192304012.png" alt="image-20230904192304012"></p>
<p>上节课3个应用的算法均是迭代式算法，回答存在的问题</p>
<p>从23的基础上定义格</p>
<p>复习核心内容是8</p>
<h2 id="Iterative-Algorithm-Another-View"><a href="#Iterative-Algorithm-Another-View" class="headerlink" title="Iterative Algorithm, Another View"></a>Iterative Algorithm, Another View</h2><p>给定CFG，有k个statement，迭代算法每次更新节点的OUT[n]</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230904194220880.png" alt="image-20230904194220880"></p>
<p>进行形式化</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230904194710101.png" alt="image-20230904194710101"></p>
<p>实际上是不动点</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230904194725702.png" alt="image-20230904194725702"></p>
<ul>
<li>迭代式算法一定能终止并给出一个解吗？</li>
<li>假设能达到不动点，只有一个不动点吗？如果有若干个不动点，迭代式算法得到的不动点足够精确吗？</li>
<li>迭代式算法到达不动点或得到解需要多长时间？（复杂度）</li>
</ul>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230904195054862.png" alt="image-20230904195054862"></p>
<h2 id="Partial-Order"><a href="#Partial-Order" class="headerlink" title="Partial Order"></a>Partial Order</h2><p>参考 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/365442689">偏序与等价关系 - 知乎 (zhihu.com)</a></p>
<p>偏序集的定义$P,\subseteq$，带有偏序关系的集合，并满足以下关系</p>
<ul>
<li>自反性</li>
<li>反对称性 </li>
<li>传递性</li>
</ul>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230905100158884.png" alt="image-20230905100158884"></p>
<p>整数集上的小于关系不是偏序关系</p>
<p>子串是偏序关系</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230905100307750.png" alt="image-20230905100307750"></p>
<p>偏序集的含义是不是所有的元素互相之间必须满足偏序关系，如pin和sin没有偏序关系，但是{pin,sin,sing,gin}和singing构成偏序集</p>
<p>幂集</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230905100734386.png" alt="image-20230905100734386"></p>
<h2 id="Upper-and-Lower-Bounds"><a href="#Upper-and-Lower-Bounds" class="headerlink" title="Upper and Lower Bounds"></a>Upper and Lower Bounds</h2><p><img src="/2023/08/31/program-analysis-NJU/image-20230905101107238.png" alt="image-20230905101107238"></p>
<p>最小上界lub和最大下界glb</p>
<p>bound可以不在S当中，在P中即可</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230905101527501.png" alt="image-20230905101527501"></p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230905101943246.png" alt="image-20230905101943246"></p>
<p>偏序集的glb和lub是唯一的</p>
<p>证明：反证法，反对称性</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230905102005722.png" alt="image-20230905102005722"></p>
<h2 id="Lattice-Semilattice-Complete-and-Product-Lattice"><a href="#Lattice-Semilattice-Complete-and-Product-Lattice" class="headerlink" title="Lattice, Semilattice, Complete and Product Lattice"></a>Lattice, Semilattice, Complete and Product Lattice</h2><p>在程序分析中学格（</p>
<p>每两个元素存在glb和lub的偏序集称为格</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230905102436174.png" alt="image-20230905102436174"></p>
<p>半格：任意两个元素只存在glb或者lub</p>
<ul>
<li>只存在glb，称为meet半格</li>
<li>只存在lub，称为join半格</li>
</ul>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230905102707115.png" alt="image-20230905102707115"></p>
<p>全格</p>
<p>格的任意一个子集，均存在glb和lub</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230905110741805.png" alt="image-20230905110741805"></p>
<p>整数集的子集为什么不是全格，但是格？</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230905111254543.png" alt="image-20230905111254543"></p>
<p>回顾格的定义，任意两个元素存在glb和lub即可；全格要求所有子集都有glb和lub</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230905110540907.png" alt="image-20230905110540907"></p>
<p>有限的格一定是全格，complete的lattice一定是有限的吗，不是</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230905111616613.png" alt="image-20230905111616613"></p>
<p>一般程序内的是有限的</p>
<p>积格的定义</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230905112107491.png" alt="image-20230905112107491"></p>
<ul>
<li>积格的lub：实际上是每个格内两个元素的lub</li>
<li>积格的glb：每个格内的两个元素的glb</li>
</ul>
<p>性质</p>
<ul>
<li>根据定义，积格也是格</li>
<li>积格是全格的积时，积格也是全格</li>
</ul>
<h2 id="Data-Flow-Analysis-Framework-via-Lattice"><a href="#Data-Flow-Analysis-Framework-via-Lattice" class="headerlink" title="Data Flow Analysis Framework via Lattice"></a>Data Flow Analysis Framework via Lattice</h2><p>介绍格是为了用格形式化数据流分析</p>
<p> <img src="/2023/08/31/program-analysis-NJU/image-20230905113959239.png" alt="image-20230905113959239"></p>
<p>有点类似沿着控制流上升到上界</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230905114738987.png" alt="image-20230905114738987"></p>
<p>试图回答第1个问题</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230905114859061.png" alt="image-20230905114859061"></p>
<p>需要单调性和不动点定理</p>
<h2 id="Monoticity-and-Fixed-point-Theorem"><a href="#Monoticity-and-Fixed-point-Theorem" class="headerlink" title="Monoticity and Fixed point Theorem"></a>Monoticity and Fixed point Theorem</h2><p>前面提到complete的格不一定是有限的，所以这里额外第二个条件是finite</p>
<p>从bottom出发，迭代f函数能够找到的第一个不动点叫做最小不动点；从top出发，求到的是最大不动点</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230905151443765.png" alt="image-20230905151443765"></p>
<p>证明不动点的存在：</p>
<p>根据$\perp$的定义，有$\perp \subseteq f(\perp)$</p>
<p>根据单调性的定义，$f(\perp)\subseteq f(f(\perp))$</p>
<p>递归地有 $\perp \subseteq f(\perp) \subseteq \dots f^i(\perp)$</p>
<p>根据$L$的有限性，存在一个$k$,$f^k(\perp)=f^{k+1}(\perp)=f^{fix}$</p>
<p>即存在不动点，回答了问题1</p>
<p>（可以假设不存在不动点，则根据单调性和有限性推出矛盾）</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230905154855422.png" alt="image-20230905154855422"></p>
<p>再证明得到的不动点是最小不动点</p>
<p>设存在另一个不动点为$x=f(x)$</p>
<p>根据$\perp$的定义，有$\perp \subseteq x$</p>
<p>根据单调性有 $f(\perp) \subseteq f(x)$ (数学归纳法的奠基)</p>
<p>采用数学归纳法，假设$f^i(\perp)\subseteq f^i(x)$</p>
<p>根据单调性，有$f^{i+1}(\perp)\subseteq f^{i+1}(x)=f(x)$</p>
<p>则有$f^{fix}=f^k(\perp)\subseteq f^k(x)=x$</p>
<p>即证明了求出的不动点是最小不动点，回答了问题2</p>
<p>间接证明了求出的不动点的唯一性</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230905155031011.png" alt="image-20230905155031011"></p>
<p>依然存在的问题，仅回答了lattice上函数的性质，没有和迭代式算法建立联系</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230905160510624.png" alt="image-20230905160510624"></p>
<h2 id="Relate-Iterative-Algorithm-to-Fixed-Point-Theorem"><a href="#Relate-Iterative-Algorithm-to-Fixed-Point-Theorem" class="headerlink" title="Relate Iterative Algorithm to Fixed Point Theorem"></a>Relate Iterative Algorithm to Fixed Point Theorem</h2><p><img src="/2023/08/31/program-analysis-NJU/image-20230905164944314.png" alt="image-20230905164944314"></p>
<p>关键是F的单调性</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230905165647774.png" alt="image-20230905165647774"></p>
<p>先证明两个运算的单调性</p>
<p>思路是利用最小上界的定义 偏序关系的传递性</p>
<p>证明下确界运算的思路类似</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230905172002679.png" alt="image-20230905172002679"></p>
<p>最后解答复杂性的问题</p>
<p>先介绍格的高度的定义</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230905172123723.png" alt="image-20230905172123723"></p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230905172819265.png" alt="image-20230905172819265"></p>
<p>复杂度取决于CFG节点个数和格的高度 </p>
<h2 id="May-Must-Analysis-A-Lattive-View"><a href="#May-Must-Analysis-A-Lattive-View" class="headerlink" title="May/Must Analysis, A Lattive View"></a>May/Must Analysis, A Lattive View</h2><p><img src="/2023/08/31/program-analysis-NJU/image-20230905173425800.png" alt="image-20230905173425800"></p>
<p>先抽象成一个积格进行理解，先看may alalysis</p>
<p>以reaching definition为例，作为一种may analysis 最下面No definitions can reach是所有变量都被初始化了，最上面是所有变量都可能被redefine，safe是指从找bug的角度，给所有变量报错是safe but useless，因此需要从下往上找到safe和unsafe的边界 truth</p>
<p>如何判断是否超过了truth（根据不动点</p>
<p>设计transfer function和cf merge的原则是safe approximation</p>
<p>根据单调性，求得的是最小不动点</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230905174535083.png" alt="image-20230905174535083"></p>
<p>must analyse解决的是优化问题，从top出发，所有表达式都能优化显然是错误的，bottom是安全的但是没用的，没有表达式可以优化</p>
<p>must analyse的分析不能有误报，要求是complete</p>
<p>另一个维度理解may的最小不动点：transfer function是固定的，join是求最小上界，每次迭代走的是minimal step，因此得到的是最小不动点</p>
<h2 id="Distributivity-and-MOP"><a href="#Distributivity-and-MOP" class="headerlink" title="Distributivity and MOP"></a>Distributivity and MOP</h2><p>考虑解的精确性，MOP是衡量的一个指标</p>
<p>总的transfer function就是各个f的组合</p>
<p>MOP是枚举所有的path的结果再join或meet（计算了每条路径最终的值</p>
<p>静态分析中有的路径可能是不可达的，导致结果不是完全精确的</p>
<p>实际上是不可枚举的</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230906103700614.png" alt="image-20230906103700614"></p>
<p>和迭代式算法的区别</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230906103918799.png" alt="image-20230906103918799"></p>
<p>x和y之间的关系</p>
<p>最小上界小于上界</p>
<p>所以MOP更准确</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230906104601252.png" alt="image-20230906104601252"></p>
<p>当F满足分配律，两者一样准确</p>
<p>之前提到的bit-vector或Gen/Kill问题都是distributive</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230906104858404.png" alt="image-20230906104858404"></p>
<h2 id="Constant-Propagation"><a href="#Constant-Propagation" class="headerlink" title="Constant Propagation"></a>Constant Propagation</h2><p>这个DFA不是distributive的</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230906105336040.png" alt="image-20230906105336040"></p>
<p>NAC: not a constant</p>
<p>一般不考虑未初始化的问题</p>
<p>对于两个常量分类讨论</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230906105930450.png" alt="image-20230906105930450"> </p>
<p> 关注赋值语句，kill掉与被赋值相关的常量</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230906111532756.png" alt="image-20230906111532756"></p>
<p>例子</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230906111959118.png" alt="image-20230906111959118"></p>
<h2 id="Worklist-Algorithm"><a href="#Worklist-Algorithm" class="headerlink" title="Worklist Algorithm"></a>Worklist Algorithm</h2><p>区别于迭代算法，实际的工具不采用迭代算法，worklist可以看做优化</p>
<p>回顾迭代式算法</p>
<p>仅遍历计算in变了的部分</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230906112920299.png" alt="image-20230906112920299"></p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230906113352119.png" alt="image-20230906113352119"></p>
<h1 id="Interprocedural-Analysis"><a href="#Interprocedural-Analysis" class="headerlink" title="Interprocedural Analysis"></a>Interprocedural Analysis</h1><p>过程间分析</p>
<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p><img src="/2023/08/31/program-analysis-NJU/image-20230906113916346.png" alt="image-20230906113916346"></p>
<p>过程内分析对方法调用进行最保守的假设，可以做任何事情</p>
<p>问题：过于保守，降低了精度</p>
<p>过程间分析需要call graph，调用的目的地址</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230906114450105.png" alt="image-20230906114450105"></p>
<h2 id="Call-graph"><a href="#Call-graph" class="headerlink" title="Call graph"></a>Call graph</h2><p>call edge连接call site和callee</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230906114617419.png" alt="image-20230906114617419"></p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230906114641085.png" alt="image-20230906114641085"></p>
<p>主要针对面向对象的语言，给出了4个算法</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230906114815381.png" alt="image-20230906114815381"></p>
<p>virtualcall实现多态，难以处理</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230906115124716.png" alt="image-20230906115124716"></p>
<p>具体调用的方法在运行时确定，取决于</p>
<ul>
<li>对象的类型</li>
<li>方法签名（可以唯一确定一个方法</li>
</ul>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230906115354456.png" alt="image-20230906115354456"></p>
<p>优先当前类有方法体的方法，不能是抽象的，如果没有则去父类找</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230906115605922.png" alt="image-20230906115605922"></p>
<p>CHA需要类的继承的信息，根据A的类型来决定对应的call</p>
<p>OO语言的顶会</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230906200743561.png" alt="image-20230906200743561"></p>
<p>算法采用分类讨论</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230906201056655.png" alt="image-20230906201056655"></p>
<p>static call最简单</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230906201244904.png" alt="image-20230906201244904"></p>
<p>B类可能没有foo，因此需要一个Dispatch而不是直接用B.foo()\</p>
<p>私有和构造函数都能用dispatch解决</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230906201506211.png" alt="image-20230906201506211"></p>
<p>对于virtual call，包含了所有的子类的方法，因为</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230906201707497.png" alt="image-20230906201707497"></p>
<p>例子都属于virtual call</p>
<p>{C.foo()}</p>
<p>{A.foo(), C.foo(), D.foo()}</p>
<p>{A.foo(), C.foo(), D.foo()}</p>
<p>如果B b =new B(), Resolve(b.foo())={A.foo(), C.foo(), D.foo()} 结果不变</p>
<p>这里是一个special call吗？不是因为Java支持动态方法分配，且涉及到了继承关系</p>
<p>因为算法只考虑变量的声明类型</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230906211704923.png" alt="image-20230906211704923"></p>
<p>一般用在IDE中</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230906211826590.png" alt="image-20230906211826590"></p>
<p>navigate菜单中</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230906211956325.png" alt="image-20230906211956325"></p>
<p>reachable是处理过的方法</p>
<p>通过resolve发现新的方法</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230907095105736.png" alt="image-20230907095105736"></p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230907100051983.png" alt="image-20230907100051983"></p>
<h2 id="Interprocedural-CFG"><a href="#Interprocedural-CFG" class="headerlink" title="Interprocedural CFG"></a>Interprocedural CFG</h2><p>ICFG表示的是整个程序的结构</p>
<p>紧跟着call site的就是return site，利用call graph来解决ICFG</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230907100501603.png" alt="image-20230907100501603"></p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230907100605564.png" alt="image-20230907100605564"></p>
<p>为什么还保留一条额外的边</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230907100725411.png" alt="image-20230907100725411"></p>
<h2 id="Interprocedural-Data-Flow-Analysis"><a href="#Interprocedural-Data-Flow-Analysis" class="headerlink" title="Interprocedural Data Flow Analysis"></a>Interprocedural Data Flow Analysis</h2><p><img src="/2023/08/31/program-analysis-NJU/image-20230907101105920.png" alt="image-20230907101105920"></p>
<p>遇到call node需要kill掉left hand side variable的值 </p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230907103248743.png" alt="image-20230907103248743"></p>
<p>edge transfer就是给形参赋值</p>
<p>保留call to return edge是为了保证本地数据流关系的保留，即函数内部的</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230907104117327.png" alt="image-20230907104117327"></p>
<p>如果没有这条边，相当于函数addOne内还需要维护a的值，如下图，效率很低</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230907104201277.png" alt="image-20230907104201277"></p>
<p>kill的具体原因，需要用返回值覆盖</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230907105040021.png" alt="image-20230907105040021"></p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230907105101994.png" alt="image-20230907105101994"></p>
<p>如果是过程内分析，会进行最保守的假设，所有调用返回值都是NAC，imprecise</p>
<p>过程间分析更加精确</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230907105527714.png" alt="image-20230907105527714"></p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230907105536788.png" alt="image-20230907105536788"></p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230907105714714.png" alt="image-20230907105714714"></p>
<h1 id="Pointer-Analysis-Introduction"><a href="#Pointer-Analysis-Introduction" class="headerlink" title="Pointer Analysis Introduction"></a>Pointer Analysis Introduction</h1><h2 id="Motivation-1"><a href="#Motivation-1" class="headerlink" title="Motivation"></a>Motivation</h2><p>利用CHA来求目标方法会有多个，不精确</p>
<p>CHA利用对象的类和子类来分析</p>
<p>如果对x进行常量传播，x是NAC</p>
<p>指针分析更精确</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914182323812.png" alt="image-20230914182323812"></p>
<h2 id="Introduction-to-Pointer-Analysis"><a href="#Introduction-to-Pointer-Analysis" class="headerlink" title="Introduction to Pointer Analysis"></a>Introduction to Pointer Analysis</h2><p>指针分析回答指针可以指向哪些地址</p>
<p>作为一种may analysis，过近似，给出可能指向的所有地址</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230911092021640.png" alt="image-20230911092021640"></p>
<p>OO语言内的指针包括filed和variable</p>
<p>指针分析的输入是一段程序，输出是如右表所示的表格</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230911093038934.png" alt="image-20230911093038934"></p>
<h3 id="Alias-Analysis别名分析"><a href="#Alias-Analysis别名分析" class="headerlink" title="Alias Analysis别名分析"></a>Alias Analysis别名分析</h3><ul>
<li><p>指针分析：指针可以指向哪些对象</p>
</li>
<li><p>别名分析：两个指针能否指向同一地址</p>
</li>
</ul>
<p>显然，可以利用指针分析实现别名分析</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230911093309820.png" alt="image-20230911093309820"></p>
<p>指针分析的应用：</p>
<ul>
<li>计算调用图</li>
<li>编译优化</li>
<li>漏洞检测 空指针</li>
<li>…</li>
</ul>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230911093514885.png" alt="image-20230911093514885"></p>
<h2 id="Key-Factors"><a href="#Key-Factors" class="headerlink" title="Key Factors"></a>Key Factors</h2><p>非常复杂，在精度和效率之间取舍</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230911093643312.png" alt="image-20230911093643312"></p>
<h3 id="Heap-Abstraction"><a href="#Heap-Abstraction" class="headerlink" title="Heap Abstraction"></a>Heap Abstraction</h3><p>堆抽象：如何对堆内存建模</p>
<p>因为在动态执行中，堆的对象可能是无穷的，静态分析需要在一定时间内得出结果，堆抽象需要将具体的对象抽象成有限数量的抽象的对象</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230911093955437.png" alt="image-20230911093955437"></p>
<p>了解有两大流派，学习allocation sites技术</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230911094118770.png" alt="image-20230911094118770"></p>
<p>根据对象的创建点来建模，$O_2$表示创建点</p>
<p>因为程序中创建对象的语句是有限的，显然抽象的对象数量是有限的</p>
<h3 id="Context-Sensitivity"><a href="#Context-Sensitivity" class="headerlink" title="Context Sensitivity"></a>Context Sensitivity</h3><p>上下文：考虑如何对调用点建模</p>
<p>方法可能被调用很多次，对应不同的上下文时，方法内的调用可能不同</p>
<ul>
<li><p>上下文敏感可以模拟 区分不同的上下文，上下文不同时，对同一个方法分析多次</p>
</li>
<li><p>上下文不敏感每个方法仅分析一次</p>
</li>
</ul>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230911100457311.png" alt="image-20230911100457311"></p>
<p>上下文敏感可以显著提高精度</p>
<p>学习计划是先学习不敏感，再学习敏感</p>
<h3 id="Flow-Sensitivity"><a href="#Flow-Sensitivity" class="headerlink" title="Flow Sensitivity"></a>Flow Sensitivity</h3><p>指如何对<strong>控制流</strong>进行建模</p>
<ul>
<li>控制流敏感：尊重语句的执行顺序</li>
<li>控制流不敏感：忽视控制流的顺序</li>
</ul>
<p>java的数据类型可以分为值类型和引用类型；</p>
<ul>
<li>基本类型也称为值类型，分别是字符类型 char，布尔类型 boolean以及数值类型 byte、short、int、long、float、double。</li>
<li>引用类型则包括类、接口、数组、枚举等。</li>
</ul>
<p>Java 将内存空间分为堆和栈。基本类型直接在栈中存储数值，而引用类型是将引用放在栈中，实际存储的值是放在堆中，通过栈中的引用指向堆中存放的数据。</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230911101619604.png" alt="image-20230911101619604"></p>
<p>右边是flow不敏感分析的结果，目前主流是flow insensitive（对精度影响不大）</p>
<h3 id="Analysis-Scope"><a href="#Analysis-Scope" class="headerlink" title="Analysis Scope"></a>Analysis Scope</h3><p>回答应该分析程序中的哪些部分</p>
<ul>
<li>所有程序</li>
<li>需求驱动的分析：计算量更小；效率差异可能不够明显，仅满足特定需求<ul>
<li>如果有多个client的需求，可能会有重叠，不如进行全程序分析效率高</li>
</ul>
</li>
</ul>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230911104031780.png" alt="image-20230911104031780"></p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230911104343223.png" alt="image-20230911104343223"></p>
<h2 id="Concerned-Statements"><a href="#Concerned-Statements" class="headerlink" title="Concerned Statements"></a>Concerned Statements</h2><p>只关心影响与指针有关的语句</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230911105633949.png" alt="image-20230911105633949"></p>
<ul>
<li>本地变量：x 数量最多</li>
<li>静态field：C.f 和变量类似，不是重点</li>
<li>Instance field：x.f 对象的field</li>
<li>数组元素 Array[i]，一般会忽略index，静态分析无法得到，抽象成 <em>只有一个field的对象</em>，所有指都可以能取到，因此和instance field类似了</li>
</ul>
<p>结论：学会1 3即可（不是</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230911110032514.png" alt="image-20230911110032514"></p>
<p>主要是5条语句</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230911110354258.png" alt="image-20230911110354258"></p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230911110406168.png" alt="image-20230911110406168"></p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230911110735865.png" alt="image-20230911110735865"></p>
<h1 id="Pointer-Analysis-Foundations-1"><a href="#Pointer-Analysis-Foundations-1" class="headerlink" title="Pointer Analysis Foundations 1"></a>Pointer Analysis Foundations 1</h1><p><img src="/2023/08/31/program-analysis-NJU/image-20230911110905857.png" alt="image-20230911110905857"></p>
<h2 id="Rules"><a href="#Rules" class="headerlink" title="Rules"></a>Rules</h2><p>首先分析没有方法调用的程序（前4条语句），再学习如何处理方法调用</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230911111820078.png" alt="image-20230911111820078"></p>
<p>规则是推导式的，$pt(p)$指的是p指向的对象</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230911113127194.png" alt="image-20230911113127194"></p>
<p>new是将$o_i$加入到$pt(x)$中去</p>
<p>赋值将$y$指向的加入到$x$指向的</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230911113140353.png" alt="image-20230911113140353"></p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230911113613953.png" alt="image-20230911113613953"></p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230911113800642.png" alt="image-20230911113800642"></p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230911113809394.png" alt="image-20230911113809394"></p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230911160527617.png" alt="image-20230911160527617"></p>
<h2 id="How-to-implement-pointer-analysis"><a href="#How-to-implement-pointer-analysis" class="headerlink" title="How to implement pointer analysis"></a>How to implement pointer analysis</h2><p>本质上是将指针信息传播给其他指针，也可以理解为求解包含约束</p>
<p>指针分析的关键是当指针集$pt(x)$变化时，将变化传播给其他相关的指针</p>
<p>利用图来传播</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230911161609721.png" alt="image-20230911161609721"></p>
<p>指针流图pointer flow graph</p>
<p>有向图，表示对象如何在图中流动</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230911161731273.png" alt="image-20230911161731273"></p>
<p>边的含义是x的变化可能流向y</p>
<p>如何建立PFG的边？根据程序的语句的4条规则</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230911162000627.png" alt="image-20230911162000627"></p>
<p>c.f仅是一个指针表达式，不是一个指针，指针必须是对象</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230911163008942.png" alt="image-20230911163008942"></p>
<p>实现包括两步</p>
<ul>
<li>构建指针流图</li>
<li>在PFG上传播指向信息</li>
</ul>
<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>分别对应4个语句</p>
<p>S是要分析的语句的集合</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230911164230546.png" alt="image-20230911164230546"></p>
<p>WL包含了指针和指针集，是后续要分析的对象</p>
<p>简化只有2种语句</p>
<p>集合的减法是为了去重，去掉ptn已经有的指针</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230911170359600.png" alt="image-20230911170359600"></p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230911170411007.png" alt="image-20230911170411007"></p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230911170430735.png" alt="image-20230911170430735"></p>
<p>已经是union了为什么要去重？不影响正确性，但是可以跳过</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230911171405824.png" alt="image-20230911171405824"></p>
<p>另外两条对称的语句</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230911172033462.png" alt="image-20230911172033462"></p>
<p>可能有其他同类的不同对象已经连接了实例方法，因此是may引入新的PFG边</p>
<p>执行这个例子</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230912162251382.png" alt="image-20230912162251382"></p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230912162437486.png" alt="image-20230912162437486"></p>
<h1 id="Pointer-Analysis-Foundations-2"><a href="#Pointer-Analysis-Foundations-2" class="headerlink" title="Pointer Analysis Foundations 2"></a>Pointer Analysis Foundations 2</h1><p>如何处理方法调用</p>
<p>过程间分析，需要call graph</p>
<p>与CHA方法对比，根据指针分析来确定call graph</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230912164701071.png" alt="image-20230912164701071"></p>
<p>实际上指针分析和call graph是一起构建的，on the fly</p>
<p>复杂起来了（</p>
<ul>
<li><p>disptach：根据接受者对象和方法签名去找目标方法m，在做call graph</p>
</li>
<li><p>传receiver对象：$m_{this}$，OO语言很多操作通过this实现</p>
</li>
<li>传参：实参传给形参，变量之间连起来</li>
<li>传回返回值</li>
</ul>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230912165752464.png" alt="image-20230912165752464"></p>
<p>solidity的dispatch只需要函数签名</p>
<p>问题：为什么this不加一个边？</p>
<p>连上会传递错误的信息，this只指向当前对象</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230912170440967.png" alt="image-20230912170440967"></p>
<p>实际的操作</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230912170522098.png" alt="image-20230912170522098"></p>
<p>从入口方法main函数进行分析，只分析reachable的方法，reachable对效率和精度有帮助</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230912172112179.png" alt="image-20230912172112179"></p>
<p>黄色部分是新增的步骤，和call graph相关</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230912172223253.png" alt="image-20230912172223253"></p>
<p>reachable方法</p>
<ul>
<li>入口方法</li>
<li>出现新的调用边</li>
</ul>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230912173001173.png" alt="image-20230912173001173"></p>
<p>为什么只处理new和assign，因为这两个语句不需要语境</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230912184947416.png" alt="image-20230912184947416"></p>
<p>为什么call graph存在$l\to m$就不再执行？实际上是对象的类型来决定目标方法的，虽然oi是新的对象，但是其他同类型的对象oj可能已经连过这一条边</p>
<p>这些判断条件存在的原因：为了实用性，减少不必要的操作</p>
<p>上下文非敏感，每个算法处理一次</p>
<p>算法的输出是每个变量的指针集以及调用图</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230912185840030.png" alt="image-20230912185840030"></p>
<p>例子，动笔自己写一写</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230912190641848.png" alt="image-20230912190641848"></p>
<p>和CHA的区别：更精确了</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230912192345447.png" alt="image-20230912192345447"></p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230912192951269.png" alt="image-20230912192951269"></p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230912193211655.png" alt="image-20230912193211655"></p>
<h1 id="Pointer-Analysis-Context-Sentivity"><a href="#Pointer-Analysis-Context-Sentivity" class="headerlink" title="Pointer Analysis Context Sentivity"></a>Pointer Analysis Context Sentivity</h1><p>Java指针分析中对精度提升最明显的技术 </p>
<p>动态执行时该程序时$i=1$</p>
<p>采用常量传播分析是NAC</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230912194827600.png" alt="image-20230912194827600"></p>
<p>需要上下文敏感的指针分析，每次调用id时对实参进行区分</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230912195049875.png" alt="image-20230912195049875"></p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>上下文不敏感为什么会不准确 </p>
<ul>
<li>动态执行时，一个方法可能在不同的语境下被多次调用</li>
<li>不同调用语境中方法的变量可能指向不同对象</li>
<li>不同语境下的对象 <em>混合</em> 并 <em>传播</em> 到了程序的其他部分</li>
</ul>
<p>提高上下文敏感分析的效率</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230912201100384.png" alt="image-20230912201100384"></p>
<p>最古老和最著名的技术是call-site当做上下文，对调用栈的抽象</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230912201119775.png" alt="image-20230912201119775"></p>
<p>下节课介绍其他变种，后续介绍都是call-site</p>
<p>具体关注的是变量的上下文</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230912201045606.png" alt="image-20230912201045606"></p>
<p>上下文敏感 堆</p>
<ul>
<li>OO程序会频繁操作对象，heap-intensive</li>
<li>为了提高精度需要对 对象加上下文<ul>
<li>粒度更细的抽象</li>
</ul>
</li>
</ul>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230912201334791.png" alt="image-20230912201334791"></p>
<p>为什么能提高精度？</p>
<p>动态执行时，每次调用都会创建新的对象</p>
<p>同一个语句，不同对象的操作可能不同</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230912201515062.png" alt="image-20230912201515062"></p>
<p>例子</p>
<p>动态执行指向n1，堆不敏感的程序分析指向n1 n2</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230912202332554.png" alt="image-20230912202332554"></p>
<p>有上下文敏感heap时，右边x.f语句会产生两个不同，意思是方法内对 对象的field也进行区分</p>
<p>如果没有变量上下文敏感，只做堆上下文敏感，相当于没做</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230912205913463.png" alt="image-20230912205913463"></p>
<p>都加上下文才能提高精度</p>
<h2 id="Rules-1"><a href="#Rules-1" class="headerlink" title="Rules"></a>Rules</h2><p>先给出定义域和记号</p>
<p>程序的变量、对象都加上 上下文</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230912210139484.png" alt="image-20230912210139484"></p>
<p>策略决定c的内容，可以理解为一系列call-site</p>
<p>注意field没有，具体的实例的field有，因为通过对象来访问</p>
<p>指针也分两类，分别是变量和对象的；因此表示方式是两类的并</p>
<p>具体实现指针分析器需要利用这些规则</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230912213823131.png" alt="image-20230912213823131"></p>
<p>具体的理解</p>
<p>对于new语句，语境当中的规则：假设在方法m中，上下文是c，则给对象也加上下文</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230912214053341.png" alt="image-20230912214053341"></p>
<p>对于assign语句，比较直观</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230912214230647.png" alt="image-20230912214230647"></p>
<p>先分别取出x和y指向的对象，为什么不是同一个上下文c？</p>
<p>因为x和y的上下文相同，但是x和y指向的对象的语境不一定相同，上下文c和c‘可以相同</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230912214620756.png" alt="image-20230912214620756"></p>
<p>load和store对称</p>
<p>对于调用的规则，如何决定c</p>
<p>假设调用在某个方法里，当前的语境是c</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230912215123422.png" alt="image-20230912215123422"></p>
<ul>
<li>先取出对象指向的上下文</li>
<li>选择对应方法，与上下文无关，取决于类型</li>
<li>选择上下文：为目标方法$m$选择上下文，根据当前调用点$l$能得到的信息<ul>
<li>具体怎么选，请看下集</li>
</ul>
</li>
<li>传receiver object</li>
<li>传返回值</li>
</ul>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230912215631131.png" alt="image-20230912215631131"></p>
<p>好像是直接用了L？考虑如果在例子外面套个循环，就需要一个方法select进行选择了；除了还有其他的表示方法</p>
<p>$c^t$ 是新的一个上下文</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230912220108442.png" alt="image-20230912220108442"></p>
<p>目前Java流敏感分析的效果不够好</p>
<h2 id="Algorithms"><a href="#Algorithms" class="headerlink" title="Algorithms"></a>Algorithms</h2><p>算法有两部分，构造PFG，在PFG上传播指针信息</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913152920936.png" alt="image-20230913152920936"></p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913153854777.png" alt="image-20230913153854777"></p>
<p>区别在于每个节点表示的都是上下文敏感的变量或者field，节点额外带有上下文，笛卡尔积多了一个维度</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913153130047.png" alt="image-20230913153130047"></p>
<p>连边就根据4条规则</p>
<p>对于call比较复杂，方法dispatch，传参数，this不连边，传返回值</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913154003008.png" alt="image-20230913154003008"></p>
<p>打码之后和上下文不敏感的算法几乎一样</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913154510890.png" alt="image-20230913154510890"></p>
<p>首先看solve算法</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913154601481.png" alt="image-20230913154601481"></p>
<p>下面的集合也带有上下文信息</p>
<p>比如RM foo在ct下可达</p>
<p>CG也是上下文敏感的call-site和callee都有上下文，$c\to c^t$</p>
<p>入口函数的上下文为空</p>
<p>同一个call-site，目标函数内的context是一样的</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913162044882.png" alt="image-20230913162044882"></p>
<p>Addedge和Propagate和CI分析一致</p>
<h2 id="Variants"><a href="#Variants" class="headerlink" title="Variants"></a>Variants</h2><p>其他技术</p>
<p>给出select函数的定义</p>
<p>最常用的三种上下文敏感的变量</p>
<ul>
<li>call-site敏感</li>
<li>object敏感</li>
<li>type敏感</li>
</ul>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913162648159.png" alt="image-20230913162648159"></p>
<p>如果是上下文不敏感，可以看做是上下文敏感的特殊情况，select返回为空</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913164121180.png" alt="image-20230913164121180"></p>
<p>每个context包括一系列的call-sites，将call site加入到caller，类似于调用栈，也叫call string，K-CFA(k-Context-Free Analysis)</p>
<h3 id="call-site-sentivity"><a href="#call-site-sentivity" class="headerlink" title="call site sentivity"></a>call site sentivity</h3><p><img src="/2023/08/31/program-analysis-NJU/image-20230913164034410.png" alt="image-20230913164034410"></p>
<p>怎么得到当前的代码行数呢</p>
<p>递归调用的时候（方法调用自己），会出现无穷多次call-site</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913164548268.png" alt="image-20230913164548268"></p>
<p>因此需要一个深度$k$，限制上下文的长度为$k$，一般$k\leq3$，会合并连续相同的callsite然后取队列末尾的$k$个</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913165010456.png" alt="image-20230913165010456"></p>
<p>上下文层数越多，精度越高，一般是至少2层</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913170125124.png" alt="image-20230913170125124"></p>
<p>分析x.get具体指向的方法</p>
<p>动态的理解：会返回1</p>
<p>静态分析：得到One.get()</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913172604357.png" alt="image-20230913172604357"></p>
<p>利用调用点区分了14和15两个调用，如果是CI分析</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913172709985.png" alt="image-20230913172709985"></p>
<h3 id="object-sensitivity"><a href="#object-sensitivity" class="headerlink" title="object sensitivity"></a>object sensitivity</h3><p><img src="/2023/08/31/program-analysis-NJU/image-20230913193654682.png" alt="image-20230913193654682"></p>
<p>另一种表现形式的select，根据receiver object和heap context来区分</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913195207715.png" alt="image-20230913195207715"></p>
<p>this指的是上下文本身（对象）</p>
<p>和1call site进行对比</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913195721511.png" alt="image-20230913195721511"></p>
<p>换成2 call site能区分</p>
<p>object是否一定比call site好呢</p>
<p>this一样，调用的方法也一样</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913201016340.png" alt="image-20230913201016340"></p>
<ul>
<li>一般情况下精度是不可比较的</li>
<li>但是对Java这种OO语言，object更准确</li>
</ul>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913201700466.png" alt="image-20230913201700466"></p>
<h3 id="type-sensitivity"><a href="#type-sensitivity" class="headerlink" title="type sensitivity"></a>type sensitivity</h3><p>实际上是对object的抽象</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913202205377.png" alt="image-20230913202205377"></p>
<p>InType得到的不是生成的对象的类型，而是语句所在类</p>
<p>精度不如对象敏感技术，牺牲了精度换取速度</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913202510805.png" alt="image-20230913202510805"></p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913201401242.png" alt="image-20230913201401242"></p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913202953061.png" alt="image-20230913202953061"></p>
<h1 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h1><p>抽象什么是安全：在敌手存在时达成某个目标</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913205207631.png" alt="image-20230913205207631"></p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913205405562.png" alt="image-20230913205405562"></p>
<p>美国的NVD发现最多的漏洞是injection</p>
<p>injection和leak实际上是一类问题，信息流</p>
<h2 id="Information-Flow-Security"><a href="#Information-Flow-Security" class="headerlink" title="Information Flow Security"></a>Information Flow Security</h2><p>目标：阻止不必要的信息流</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913205701513.png" alt="image-20230913205701513"></p>
<ul>
<li>Access Control：标准方法，检查是否具有权限来访问特定信息；考虑信息是如何被处理的<ul>
<li>得到信息后如何使用？</li>
</ul>
</li>
<li>信息流安全 end2end<ul>
<li>跟踪程序如何安全地处理信息</li>
<li>考虑信息如何传播</li>
</ul>
</li>
</ul>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913205921749.png" alt="image-20230913205921749"></p>
<p>信息论的定义</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913210049720.png" alt="image-20230913210049720"></p>
<p>给变量分级</p>
<p>不同等级变量之间信息如何流动</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913210226746.png" alt="image-20230913210226746"></p>
<p>最简单分法是2级分法（使用最广泛</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913210241719.png" alt="image-20230913210241719"></p>
<p>可以利用偏序关系（格）来建模</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913210345697.png" alt="image-20230913210345697"></p>
<p>可以有比较复杂的level设置</p>
<p>policy：限制信息如何在不同密级之间流动</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913211342441.png" alt="image-20230913211342441"></p>
<ul>
<li>高级变量不能影响低级变量</li>
<li>通过观测低级信息无法推测出高级信息</li>
</ul>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913211325855.png" alt="image-20230913211325855"></p>
<h2 id="Confidentiality-and-Integrity"><a href="#Confidentiality-and-Integrity" class="headerlink" title="Confidentiality and Integrity"></a>Confidentiality and Integrity</h2><p><img src="/2023/08/31/program-analysis-NJU/image-20230913211612588.png" alt="image-20230913211612588"></p>
<p>和密码学定义的Integrity不同，更像是真实性，外界信息的真实性</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913211740289.png" alt="image-20230913211740289"></p>
<p>给US air force提出的问题</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913212019260.png" alt="image-20230913212019260"></p>
<p>从完整性角度看，高级流向低级也不安全</p>
<p>扩展完整性的定义，之前的定义有点类似于正确性</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913212158190.png" alt="image-20230913212158190"></p>
<p>数据流和信息流的区别：</p>
<p>数据流可以看做具体的数据</p>
<p>信息流更加抽象，广义，可以将数据流看做是信息流</p>
<h2 id="Explicit-Flows-and-Covert-Channels"><a href="#Explicit-Flows-and-Covert-Channels" class="headerlink" title="Explicit Flows and Covert Channels"></a>Explicit Flows and Covert Channels</h2><p><img src="/2023/08/31/program-analysis-NJU/image-20230913212559603.png" alt="image-20230913212559603"></p>
<p>以上是显式流动</p>
<p>秘密可能作为条件语句的判断条件，称为隐式流</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913212739282.png" alt="image-20230913212739282"></p>
<p>while循环 是一个信息流，但不是数据流</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913213034386.png" alt="image-20230913213034386"></p>
<p>最后一个如果为负数，可能有error</p>
<p>统称上面这种类型为隐藏信道</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913213249693.png" alt="image-20230913213249693"></p>
<p>还有侧信道，观察缓存命中率</p>
<p>总结所有类型的CC非常有挑战性</p>
<p>一般情况下，Cover Channel泄露信息有限</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913213650461.png" alt="image-20230913213650461"></p>
<p>因此后续课程主要采用污点分析分析显式流</p>
<ul>
<li>感觉后者更有意义</li>
</ul>
<h2 id="Taint-Analysis"><a href="#Taint-Analysis" class="headerlink" title="Taint Analysis"></a>Taint Analysis</h2><p>使用最广泛的信息流分析工具</p>
<p>数据分类</p>
<ul>
<li>感兴趣的数据，label（同位素）</li>
<li>untainted </li>
</ul>
<p>污点数据来源于特定方法的返回值</p>
<p>关心污点数据是否会流动到特定的sink，一般是一些比较敏感的方法</p>
<p>是否存在从source到sink的流</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913213911354.png" alt="image-20230913213911354"></p>
<p>应用</p>
<ul>
<li>保密性： $\text{ secret data} \to \text{method}$</li>
<li>完整性：$\text{input} \to \text{critical command}$</li>
</ul>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913214159779.png" alt="image-20230913214159779"></p>
<p>两个性质的对称性</p>
<p>污点分析回答的问题</p>
<ul>
<li>标记数据是否会流动到某个sink（sink的指针会指向标记的数据吗？）</li>
</ul>
<p>两者是高度一致的，因此可以借助指针分析进行污点分析</p>
<ul>
<li>将标记的数据视为特殊的object</li>
<li>source是allocation site</li>
<li>利用指针分析进行污点数据传播</li>
</ul>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913214528489.png" alt="image-20230913214528489"></p>
<p>首先扩展指针分析的定义域，污点数据是指针分析的子集</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913214946878.png" alt="image-20230913214946878"></p>
<p>输入输出</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913215045186.png" alt="image-20230913215045186"></p>
<p>规则</p>
<p>call：如果dispatch方法来自source，认为可能是需要污点分析的</p>
<p>后续的传播和指针分析一样</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913215415014.png" alt="image-20230913215415014"></p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913215406095.png" alt="image-20230913215406095"></p>
<p>检查sink？调用sink方法时，参数是否是tainted</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913215502781.png" alt="image-20230913215502781"></p>
<p>例子</p>
<p>java中都是浅拷贝</p>
<p>x和y是别名</p>
<p>方便debug</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913220135749.png" alt="image-20230913220135749"></p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913220115069.png" alt="image-20230913220115069"></p>
<p>对于运算符重载，需要更复杂的机制设计</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913220301552.png" alt="image-20230913220301552"></p>
<h1 id="Datalog-Based-Program-Analysis"><a href="#Datalog-Based-Program-Analysis" class="headerlink" title="Datalog-Based Program Analysis"></a>Datalog-Based Program Analysis</h1><h2 id="Motivation-2"><a href="#Motivation-2" class="headerlink" title="Motivation"></a>Motivation</h2><p>命令式语言：</p>
<p>声明式语言：sql</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913221434446.png" alt="image-20230913221434446"></p>
<p>实现一个复杂的指针分析，采用不同语言的区别</p>
<p>回顾指针分析的rules和算法</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913221600990.png" alt="image-20230913221600990"></p>
<p>还需要考虑的细节</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913221610803.png" alt="image-20230913221610803"></p>
<p>如果用声明式语言实现</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913221806951.png" alt="image-20230913221806951"></p>
<p>可读性更强了</p>
<h2 id="Introduction-1"><a href="#Introduction-1" class="headerlink" title="Introduction"></a>Introduction</h2><p>声明式逻辑编程语言，Prolog的子集</p>
<p>曾经是数据库的查询语言</p>
<ul>
<li>程序分析</li>
<li>网络协议</li>
<li>吹牛</li>
</ul>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913222022073.png" alt="image-20230913222022073"></p>
<p>没有控制流？没有函数</p>
<p>表达能力不够</p>
<h3 id="data-predicate"><a href="#data-predicate" class="headerlink" title="data/predicate"></a>data/predicate</h3><p>事实</p>
<p>数据的表</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913222125660.png" alt="image-20230913222125660"></p>
<p>元组属于data，真的，称为fact</p>
<p>谓词由Atom表示</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913222349159.png" alt="image-20230913222349159"></p>
<p>原子可以判定真假 </p>
<p>下面这个类型也是原子</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913222547175.png" alt="image-20230913222547175"></p>
<h3 id="Rules-Logic"><a href="#Rules-Logic" class="headerlink" title="Rules/Logic"></a>Rules/Logic</h3><p>制定了如何推导fact</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913222737380.png" alt="image-20230913222737380"></p>
<p><code>，</code>是逻辑与</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913222823795.png" alt="image-20230913222823795"></p>
<p>如何理解规则</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913222951872.png" alt="image-20230913222951872"></p>
<p>考虑所有组合，如果一个组合可以让所有子目标为真，head为真，包含所有为真的谓词</p>
<p>交换subgoal不交换结果</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913223252088.png" alt="image-20230913223252088"></p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913223410217.png" alt="image-20230913223410217"></p>
<p>问题在于初始数据来源</p>
<ul>
<li><p>EDB：程序运行前定义好的；不变； </p>
</li>
<li><p>IDB：根据Rules定义，程序的输出，head只能是IDB</p>
</li>
</ul>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913223615033.png" alt="image-20230913223615033"></p>
<p>表示 或</p>
<p>写两条语句或者采用<code>;</code></p>
<p>优先级低</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913223949083.png" alt="image-20230913223949083"></p>
<p>表示非采用<code>!</code></p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913224015374.png" alt="image-20230913224015374"></p>
<p>否 是搜索所有情况吗</p>
<p>支持递归，能力强大的来源</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913224101296.png" alt="image-20230913224101296"></p>
<p>如果没有递归，只能支持基本的关系代数</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913224230753.png" alt="image-20230913224230753"></p>
<p>需要保证规则是safe，所有的变量是有限的</p>
<ul>
<li>表是有限的，表取反就是无限的</li>
</ul>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913224527154.png" alt="image-20230913224527154"></p>
<p>取反和递归必须分开</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913224943480.png" alt="image-20230913224943480"></p>
<p>程序如何执行？engine</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230913225056738.png" alt="image-20230913225056738"></p>
<p>只能产生facts</p>
<h2 id="Pointer-Analysis"><a href="#Pointer-Analysis" class="headerlink" title="Pointer Analysis"></a>Pointer Analysis</h2><p>指针分析的EDB是语法分析可以直接获得到的信息</p>
<p>IDB是指针分析的结果</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914081639719.png" alt="image-20230914081639719"></p>
<p>通过定义域定义4类语句</p>
<p>IDB只有2类，变量指向和fields指向</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914082014217.png" alt="image-20230914082014217"></p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914082257853.png" alt="image-20230914082257853"></p>
<p>程序的可读性非常强，代码实现很干净</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914082932296.png" alt="image-20230914082932296"></p>
<p>首先运行New，因为varpoints都是空</p>
<p>将整个New复制到Varpointsto</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914083536305.png" alt="image-20230914083536305"></p>
<p>终止条件：不再能产生新的facts</p>
<p>如何处理函数</p>
<p>引入新的谓词 EDB和IDB</p>
<p>k应该包含参数信息，不然无法处理多态</p>
<p>和之前类似，传4部分信息</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914090327689.png" alt="image-20230914090327689"></p>
<p>增加对入口方法的处理即有了全程序分析</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914090712426.png" alt="image-20230914090712426"></p>
<h2 id="Taint-Analysis-1"><a href="#Taint-Analysis-1" class="headerlink" title="Taint Analysis"></a>Taint Analysis</h2><p>在指针分析的基础上，修改EDB和IDB</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914091418518.png" alt="image-20230914091418518"></p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914091438076.png" alt="image-20230914091438076"></p>
<p>_是因为不关心当前的下标</p>
<p>优势和劣势</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914095905639.png" alt="image-20230914095905639"></p>
<ul>
<li>简洁、可读性强</li>
<li>engine优化，效率高</li>
</ul>
<p>缺点</p>
<ul>
<li>表达性受限，不是图灵完备<ul>
<li>如果需要删除facts，无法实现</li>
<li>对于all的逻辑不是很好表达</li>
</ul>
</li>
<li>engine是黑盒，无法自行优化效率</li>
</ul>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914100142781.png" alt="image-20230914100142781"></p>
<h1 id="CFL-Reachability-and-IFDS"><a href="#CFL-Reachability-and-IFDS" class="headerlink" title="CFL-Reachability and IFDS"></a>CFL-Reachability and IFDS</h1><p>context free language是IFDS的理论基础</p>
<p>利用图可达进行程序分析表达</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914101547722.png" alt="image-20230914101547722"></p>
<p>放松心态，学懂50%就算成功！</p>
<h2 id="Feasiable-and-Realizable-Paths"><a href="#Feasiable-and-Realizable-Paths" class="headerlink" title="Feasiable and Realizable Paths"></a>Feasiable and Realizable Paths</h2><p>存在一些路径是不可达的</p>
<p>希望程序分析尽可能不被这些不可达路径污染，然而静态分析中这个问题是不可判定的</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914101250283.png" alt="image-20230914101250283"></p>
<p>红色路径是静态分析无法避免的错误</p>
<p>绿色路径可以通过上下文敏感避免</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914101854201.png" alt="image-20230914101854201"></p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914101908102.png" alt="image-20230914101908102"></p>
<p>realizable path：跨函数调用的返回应该和call匹配</p>
<p>unrealizable一定是不会执行的，如何识别</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914102037213.png" alt="image-20230914102037213"></p>
<p>括号匹配，太复杂就不适用，寻找系统的方法</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914102223380.png" alt="image-20230914102223380"></p>
<h2 id="CFL-reachability"><a href="#CFL-reachability" class="headerlink" title="CFL-reachability"></a>CFL-reachability</h2><p>上下文无关文法生成的是上下文无关语言</p>
<p>没学过编译但学过计算理论</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914102916339.png" alt="image-20230914102916339"></p>
<p>编程语言文法一般是CFG</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914103028029.png" alt="image-20230914103028029"></p>
<p>部分 括号匹配</p>
<p>有右括号一定有左括号，反之不一定成立（call了不一定return）</p>
<p>通过call-site进行括号的索引</p>
<p>如何形式化括号匹配的问题？写CFL的语法</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914104300136.png" alt="image-20230914104300136"></p>
<p>从规则来看，没有单独产生右括号的规则</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914104707483.png" alt="image-20230914104707483"></p>
<h2 id="IFDS"><a href="#IFDS" class="headerlink" title="IFDS"></a>IFDS</h2><p><img src="/2023/08/31/program-analysis-NJU/image-20230914104809038.png" alt="image-20230914104809038"></p>
<p>可以通过图可达性来表达的图分析算法</p>
<p>不再是迭代式算法，用图的方式（没有传播的过程）</p>
<p>过程间的 <em>有限 可分配的</em> 子集问题</p>
<p>定义域有限 流函数是distributive</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914105259135.png" alt="image-20230914105259135"></p>
<p>具体可以认为是先meet再transfer和调换顺序结果一致</p>
<p>回顾MOP，利用IFDS能够给出MRP</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914105804428.png" alt="image-20230914105804428"></p>
<p>是所有edge上的f的复合函数</p>
<p>MOP是把所有path的结果并起来</p>
<p>MRP只考虑realizaable path（返回边和callsite对应，不能返回到之前已经返回过的边），不再沿着假的边去分析，可能更精准</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914110511798.png" alt="image-20230914110511798"></p>
<p>显然是MOP的子集</p>
<p>构造supergraph，定义flow func</p>
<p>构造explded supergraph</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914111707351.png" alt="image-20230914111707351"></p>
<p>$G^*$由一系列的$G_{main}$和$G_p$组成</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914140129907.png" alt="image-20230914140129907"></p>
<p>每个call site都有3条edge</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914140322154.png" alt="image-20230914140322154"></p>
<p>flow function的设计采用 可能未初始化的变量 的设计</p>
<p>具体的函数形式为lambda表达式</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914141003251.png" alt="image-20230914141003251"></p>
<p>lambda表达式类似于匿名函数，$\lambda e_{param}\cdot e_{body}$</p>
<p>无论输入，输出$x,g$</p>
<p>S是所有没有被初始化的值</p>
<p>$\lambda \ S.{S-x}$</p>
<p>减去g为了提高精度，真实情况不会有这条边，增加这一条边传播了本地变量的信息</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914142144730.png" alt="image-20230914142144730"></p>
<p>有了supergraph之后，建立exploded supergraph，拆分了flow function</p>
<p>D=2</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914142834835.png" alt="image-20230914142834835"></p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914144611310.png" alt="image-20230914144611310"></p>
<p>和传统的程序分析的定义区分，之前通过n4的out来判断存在</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914150855265.png" alt="image-20230914150855265"></p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914151715271.png" alt="image-20230914151715271"></p>
<p>利用tabulation算法判断可达性</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914151704558.png" alt="image-20230914151704558"></p>
<p>如果d可达就涂成蓝色</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914151857768.png" alt="image-20230914151857768"></p>
<p>这个算法比较复杂，不做详细介绍</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914152005445.png" alt="image-20230914152005445"></p>
<p>E是边的个数，D是domain size</p>
<p>处理exit节点时， 找到对应的call边</p>
<p>额外还有call到return的 summary edge，加速</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914152618402.png" alt="image-20230914152618402"></p>
<p>可分配性的理解</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914153507313.png" alt="image-20230914153507313"></p>
<p>具体问题能够利用IFDS解决需要用可分配性判断</p>
<p>IFDS的flow函数只能处理一个元素</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914153649860.png" alt="image-20230914153649860"></p>
<p>如果需要多个输入事实来判断能否产生正确的输出，不能用IFDS</p>
<p>最后的两个例子可以用IFDS</p>
<p>x,y,x.f指向o，正确吗</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914154323952.png" alt="image-20230914154323952"></p>
<p>缺少别名信息，这个信息同时需要x和y，因此指针分析不能用标准的IFDS</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914154812428.png" alt="image-20230914154812428"></p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914154937595.png" alt="image-20230914154937595"></p>
<h1 id="Soundness-and-Soundiness"><a href="#Soundness-and-Soundiness" class="headerlink" title="Soundness and Soundiness"></a>Soundness and Soundiness</h1><p>程序分析约有50年，soundiness是2015年提出的</p>
<p>前沿的话题</p>
<h2 id="soundness"><a href="#soundness" class="headerlink" title="soundness"></a>soundness</h2><p>保守的近似，近似所有可能的程序行为</p>
<ul>
<li>学术界：分析真实程序语言编写的完整的程序，没有sound</li>
<li>工业界：所有工具都不得不牺牲soundness</li>
</ul>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914155709950.png" alt="image-20230914155709950"></p>
<p>每个编程语言存在的难以分析的feature</p>
<p>比如js的eval，c对指针加减</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914155955552.png" alt="image-20230914155955552"></p>
<p>因此现在论文的结果可能声称是sound，对hard one是unsound；</p>
<p>或者忽略</p>
<p>不分析会导致严重的结果吗？Java</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914161155068.png" alt="image-20230914161155068"></p>
<p>soundiness指真实的程序没法分析一些困难的语言的特征</p>
<p>大佬振臂高呼，提soundiness</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914161603588.png" alt="image-20230914161603588"></p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914161732880.png" alt="image-20230914161732880"></p>
<p>三类概念的区别</p>
<p>为什么下面的两类很困难</p>
<h2 id="Hard-Language-Feature-Java-Reflection"><a href="#Hard-Language-Feature-Java-Reflection" class="headerlink" title="Hard Language Feature: Java Reflection"></a>Hard Language Feature: Java Reflection</h2><p>对java和安卓分析的噩梦，notorious</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914162225436.png" alt="image-20230914162225436"></p>
<p>为什么难分析</p>
<p>在Java编程语言中，反射（Reflection）是指在运行时动态地获取、检查和操作类、对象、方法和属性的能力。它允许程序在运行时通过名称来获取类的信息，调用方法，访问字段，创建对象等，而不需要在编译时明确地引用类或方法。</p>
<p>Java反射提供了一组类和接口，如<code>Class</code>、<code>Method</code>、<code>Field</code>等，用于在运行时检查和操作类的结构。通过使用反射，可以实现以下功能：</p>
<ol>
<li><strong>获取类的信息</strong>：通过反射，可以获取类的名称、父类、实现的接口、构造函数、方法和字段等信息。</li>
<li><strong>动态创建对象</strong>：通过反射，可以在运行时通过类名创建对象的实例，而无需提前知道类的具体类型。</li>
<li><strong>调用方法</strong>：通过反射，可以在运行时调用对象的方法，包括公共方法、私有方法和静态方法。</li>
<li><strong>访问和修改字段</strong>：通过反射，可以在运行时访问和修改对象的字段（即成员变量），包括公共字段和私有字段。</li>
<li><strong>操作数组</strong>：通过反射，可以动态创建、访问和修改数组对象。</li>
</ol>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914163513966.png" alt="image-20230914163513966"></p>
<p>反射是运行时行为</p>
<p>为什么需要分析呢（应用在哪里，松耦合，编程更灵活）</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914164026620.png" alt="image-20230914164026620"></p>
<p>右边这个例子可能是错误的</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914164317486.png" alt="image-20230914164317486"></p>
<p>分析反射的技术：字符串分析+指针分析</p>
<p>直观的想法</p>
<p>存在的问题：这些变量可能是从文件中读入的；编码过的</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914164531901.png" alt="image-20230914164531901"></p>
<p>李老师和谭老师的工作绕不过去</p>
<p>类型推理+字符串分析+指针分析</p>
<p>在调用的时候利用参数来推理</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914165357239.png" alt="image-20230914165357239"></p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914165556297.png" alt="image-20230914165556297"></p>
<p>目前最新的工作也是他俩做的</p>
<p>第三类方法，利用动态分析的结果，依赖于test case，给出的都是真的</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914165745956.png" alt="image-20230914165745956"></p>
<h2 id="Hard-Language-Feature-Native-Code"><a href="#Hard-Language-Feature-Native-Code" class="headerlink" title="Hard Language Feature: Native Code"></a>Hard Language Feature: Native Code</h2><p><img src="/2023/08/31/program-analysis-NJU/image-20230914165932042.png" alt="image-20230914165932042"></p>
<p>native声明指方法由外部语言实现的，如跨语言调用C/C++</p>
<p>JNI</p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914170548019.png" alt="image-20230914170548019"></p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914171130534.png" alt="image-20230914171130534"></p>
<p>现在的解决方案：</p>
<ul>
<li>手动建模native code<ul>
<li>用java简单模拟一下功能</li>
<li>大概比java实现快一个数量级</li>
</ul>
</li>
<li>binary分析</li>
</ul>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914171721458.png" alt="image-20230914171721458"></p>
<p><a target="_blank" rel="noopener" href="http://soundiness.org/">Soundiness Home Page</a></p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914172026836.png" alt="image-20230914172026836"></p>
<p><img src="/2023/08/31/program-analysis-NJU/image-20230914172057149.png" alt="image-20230914172057149"></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/static-analysis/" rel="tag"># static analysis</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/08/18/GearBox/" rel="prev" title="GearBox">
      <i class="fa fa-chevron-left"></i> GearBox
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/09/17/trusted-computing/" rel="next" title="trusted_computing">
      trusted_computing <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Intro"><span class="nav-number">1.</span> <span class="nav-text">Intro</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Intermediate-Representation"><span class="nav-number">2.</span> <span class="nav-text">Intermediate Representation</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%99%A8"><span class="nav-number">2.1.</span> <span class="nav-text">编译器和静态分析器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AST-vs-IR"><span class="nav-number">2.2.</span> <span class="nav-text">AST vs. IR</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IR-3AC"><span class="nav-number">2.3.</span> <span class="nav-text">IR: 3AC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Soot"><span class="nav-number">2.4.</span> <span class="nav-text">Soot</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SSA"><span class="nav-number">2.5.</span> <span class="nav-text">SSA</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Basic-Blocks"><span class="nav-number">2.6.</span> <span class="nav-text">Basic Blocks</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CFG"><span class="nav-number">2.7.</span> <span class="nav-text">CFG</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Data-Flow-Analysis-Applications"><span class="nav-number">3.</span> <span class="nav-text">Data Flow Analysis Applications</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Overview-of-Data-Flow-Analysis"><span class="nav-number">3.1.</span> <span class="nav-text">Overview of Data Flow Analysis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Preliminaries-of-Data-Flow-Analysis"><span class="nav-number">3.2.</span> <span class="nav-text">Preliminaries of Data Flow Analysis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reaching-Definitions-Analysis"><span class="nav-number">3.3.</span> <span class="nav-text">Reaching Definitions Analysis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Live-Variables-Analysis"><span class="nav-number">3.4.</span> <span class="nav-text">Live Variables Analysis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Available-Expressions-Analysis"><span class="nav-number">3.5.</span> <span class="nav-text">Available Expressions Analysis</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Data-Flow-Analysis-Foundation"><span class="nav-number">4.</span> <span class="nav-text">Data Flow Analysis Foundation</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Iterative-Algorithm-Another-View"><span class="nav-number">4.1.</span> <span class="nav-text">Iterative Algorithm, Another View</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Partial-Order"><span class="nav-number">4.2.</span> <span class="nav-text">Partial Order</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Upper-and-Lower-Bounds"><span class="nav-number">4.3.</span> <span class="nav-text">Upper and Lower Bounds</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lattice-Semilattice-Complete-and-Product-Lattice"><span class="nav-number">4.4.</span> <span class="nav-text">Lattice, Semilattice, Complete and Product Lattice</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Data-Flow-Analysis-Framework-via-Lattice"><span class="nav-number">4.5.</span> <span class="nav-text">Data Flow Analysis Framework via Lattice</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Monoticity-and-Fixed-point-Theorem"><span class="nav-number">4.6.</span> <span class="nav-text">Monoticity and Fixed point Theorem</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Relate-Iterative-Algorithm-to-Fixed-Point-Theorem"><span class="nav-number">4.7.</span> <span class="nav-text">Relate Iterative Algorithm to Fixed Point Theorem</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#May-Must-Analysis-A-Lattive-View"><span class="nav-number">4.8.</span> <span class="nav-text">May&#x2F;Must Analysis, A Lattive View</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Distributivity-and-MOP"><span class="nav-number">4.9.</span> <span class="nav-text">Distributivity and MOP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Constant-Propagation"><span class="nav-number">4.10.</span> <span class="nav-text">Constant Propagation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Worklist-Algorithm"><span class="nav-number">4.11.</span> <span class="nav-text">Worklist Algorithm</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Interprocedural-Analysis"><span class="nav-number">5.</span> <span class="nav-text">Interprocedural Analysis</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Motivation"><span class="nav-number">5.1.</span> <span class="nav-text">Motivation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Call-graph"><span class="nav-number">5.2.</span> <span class="nav-text">Call graph</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Interprocedural-CFG"><span class="nav-number">5.3.</span> <span class="nav-text">Interprocedural CFG</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Interprocedural-Data-Flow-Analysis"><span class="nav-number">5.4.</span> <span class="nav-text">Interprocedural Data Flow Analysis</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Pointer-Analysis-Introduction"><span class="nav-number">6.</span> <span class="nav-text">Pointer Analysis Introduction</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Motivation-1"><span class="nav-number">6.1.</span> <span class="nav-text">Motivation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Introduction-to-Pointer-Analysis"><span class="nav-number">6.2.</span> <span class="nav-text">Introduction to Pointer Analysis</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Alias-Analysis%E5%88%AB%E5%90%8D%E5%88%86%E6%9E%90"><span class="nav-number">6.2.1.</span> <span class="nav-text">Alias Analysis别名分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Key-Factors"><span class="nav-number">6.3.</span> <span class="nav-text">Key Factors</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Heap-Abstraction"><span class="nav-number">6.3.1.</span> <span class="nav-text">Heap Abstraction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Context-Sensitivity"><span class="nav-number">6.3.2.</span> <span class="nav-text">Context Sensitivity</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flow-Sensitivity"><span class="nav-number">6.3.3.</span> <span class="nav-text">Flow Sensitivity</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Analysis-Scope"><span class="nav-number">6.3.4.</span> <span class="nav-text">Analysis Scope</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Concerned-Statements"><span class="nav-number">6.4.</span> <span class="nav-text">Concerned Statements</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Pointer-Analysis-Foundations-1"><span class="nav-number">7.</span> <span class="nav-text">Pointer Analysis Foundations 1</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Rules"><span class="nav-number">7.1.</span> <span class="nav-text">Rules</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#How-to-implement-pointer-analysis"><span class="nav-number">7.2.</span> <span class="nav-text">How to implement pointer analysis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Algorithm"><span class="nav-number">7.3.</span> <span class="nav-text">Algorithm</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Pointer-Analysis-Foundations-2"><span class="nav-number">8.</span> <span class="nav-text">Pointer Analysis Foundations 2</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Pointer-Analysis-Context-Sentivity"><span class="nav-number">9.</span> <span class="nav-text">Pointer Analysis Context Sentivity</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Introduction"><span class="nav-number">9.1.</span> <span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Rules-1"><span class="nav-number">9.2.</span> <span class="nav-text">Rules</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Algorithms"><span class="nav-number">9.3.</span> <span class="nav-text">Algorithms</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Variants"><span class="nav-number">9.4.</span> <span class="nav-text">Variants</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#call-site-sentivity"><span class="nav-number">9.4.1.</span> <span class="nav-text">call site sentivity</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#object-sensitivity"><span class="nav-number">9.4.2.</span> <span class="nav-text">object sensitivity</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type-sensitivity"><span class="nav-number">9.4.3.</span> <span class="nav-text">type sensitivity</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Security"><span class="nav-number">10.</span> <span class="nav-text">Security</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Information-Flow-Security"><span class="nav-number">10.1.</span> <span class="nav-text">Information Flow Security</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Confidentiality-and-Integrity"><span class="nav-number">10.2.</span> <span class="nav-text">Confidentiality and Integrity</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Explicit-Flows-and-Covert-Channels"><span class="nav-number">10.3.</span> <span class="nav-text">Explicit Flows and Covert Channels</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Taint-Analysis"><span class="nav-number">10.4.</span> <span class="nav-text">Taint Analysis</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Datalog-Based-Program-Analysis"><span class="nav-number">11.</span> <span class="nav-text">Datalog-Based Program Analysis</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Motivation-2"><span class="nav-number">11.1.</span> <span class="nav-text">Motivation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Introduction-1"><span class="nav-number">11.2.</span> <span class="nav-text">Introduction</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#data-predicate"><span class="nav-number">11.2.1.</span> <span class="nav-text">data&#x2F;predicate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rules-Logic"><span class="nav-number">11.2.2.</span> <span class="nav-text">Rules&#x2F;Logic</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pointer-Analysis"><span class="nav-number">11.3.</span> <span class="nav-text">Pointer Analysis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Taint-Analysis-1"><span class="nav-number">11.4.</span> <span class="nav-text">Taint Analysis</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CFL-Reachability-and-IFDS"><span class="nav-number">12.</span> <span class="nav-text">CFL-Reachability and IFDS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Feasiable-and-Realizable-Paths"><span class="nav-number">12.1.</span> <span class="nav-text">Feasiable and Realizable Paths</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CFL-reachability"><span class="nav-number">12.2.</span> <span class="nav-text">CFL-reachability</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IFDS"><span class="nav-number">12.3.</span> <span class="nav-text">IFDS</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Soundness-and-Soundiness"><span class="nav-number">13.</span> <span class="nav-text">Soundness and Soundiness</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#soundness"><span class="nav-number">13.1.</span> <span class="nav-text">soundness</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hard-Language-Feature-Java-Reflection"><span class="nav-number">13.2.</span> <span class="nav-text">Hard Language Feature: Java Reflection</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hard-Language-Feature-Native-Code"><span class="nav-number">13.3.</span> <span class="nav-text">Hard Language Feature: Native Code</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Alleysira</p>
  <div class="site-description" itemprop="description">Eng.D student at School of Cyber Science and Teconology, BUAA.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">72</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/alleysira" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;alleysira" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Alleysira</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
