<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Alleysira&#39;s blog</title>
  
  
  <link href="https://alleysira.github.io/atom.xml" rel="self"/>
  
  <link href="https://alleysira.github.io/"/>
  <updated>2023-03-09T09:47:33.314Z</updated>
  <id>https://alleysira.github.io/</id>
  
  <author>
    <name>Alleysira</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>BIU</title>
    <link href="https://alleysira.github.io/2023/03/09/BIU/"/>
    <id>https://alleysira.github.io/2023/03/09/BIU/</id>
    <published>2023-03-09T08:43:56.000Z</published>
    <updated>2023-03-09T09:47:33.314Z</updated>
    
    <content type="html"><![CDATA[<h1 id="What-are-Blockchains-and-What-are-They-For-Dan-Boneh"><a href="#What-are-Blockchains-and-What-are-They-For-Dan-Boneh" class="headerlink" title="What are Blockchains and What are They For? - Dan Boneh"></a>What are Blockchains and What are They For? - Dan Boneh</h1><p><img src="/2023/03/09/BIU/image-20230309164910424.png" alt="image-20230309164910424"></p><p>如果有可信方，不需要区块链技术</p><p><img src="/2023/03/09/BIU/image-20230309165047176.png" alt="image-20230309165047176"></p><p><img src="/2023/03/09/BIU/image-20230309165442867.png" alt="image-20230309165442867"></p><p>比特币的创新：实际的公开可写的数据结构</p><p><img src="/2023/03/09/BIU/image-20230309165717210.png" alt="image-20230309165717210"></p><p>以太坊的创新：可编程的环境，应用可以互相调用</p><p><img src="/2023/03/09/BIU/image-20230309165846240.png" alt="image-20230309165846240"></p><p>区块链通过复制的方法实现只能写的功能</p><ul><li>persistence: 只能写，不能删除</li><li>liveness: 诚实节点可以添加新的交易<ul><li>抗审查</li></ul></li></ul><p><img src="/2023/03/09/BIU/image-20230309170207472.png" alt="image-20230309170207472"></p><p><img src="/2023/03/09/BIU/image-20230309170459366.png" alt="image-20230309170459366"></p><p>和web2的区别是真正的状态存储在链上，而不是数据库</p><p><img src="/2023/03/09/BIU/image-20230309170529887.png" alt="image-20230309170529887"></p><p>资产由DAPP管理，和现实的金融机构不同，具有透明性</p><p><img src="/2023/03/09/BIU/image-20230309170646811.png" alt="image-20230309170646811"></p><h2 id="2-application-areas"><a href="#2-application-areas" class="headerlink" title="2 application areas"></a>2 application areas</h2><h3 id="DeFi"><a href="#DeFi" class="headerlink" title="DeFi"></a>DeFi</h3><p>任何人都可以建立金融基础设施</p><p>应用之间可以交互，只要满足ERC-20标准 6个函数</p><p><img src="/2023/03/09/BIU/image-20230309170833011.png" alt="image-20230309170833011"></p><p>为什么需要DeFi</p><ul><li>垮境手续费</li><li>经济可能不稳定</li><li>经济状况不好时不适合使用银行</li></ul><p><img src="/2023/03/09/BIU/image-20230309171413201.png" alt="image-20230309171413201"></p><p>Time will tell</p><p><img src="/2023/03/09/BIU/image-20230309171601629.png" alt="image-20230309171601629"></p><h2 id="DAOs"><a href="#DAOs" class="headerlink" title="DAOs"></a>DAOs</h2><ul><li>运行在特定地址的的DAPP</li><li>任何人可以给DAO捐钱</li><li>任何人可以发起请求<ul><li>投票（链上投票，链下可以用snapshot.org，如果通过再上链）<ul><li>如何链下投票，安全地把结果转移到链上是个问题</li></ul></li><li>同意，执行</li></ul></li></ul><p><img src="/2023/03/09/BIU/image-20230309171903673.png" alt="image-20230309171903673"></p><p>甚至有全日制员工，自己的博物馆，工资被program支付</p><p><img src="/2023/03/09/BIU/image-20230309172134135.png" alt="image-20230309172134135"></p><p>gitcoin 写开源代码，给开源者打钱</p><p>直接民主，direct governance，导致了参与度非常低</p><p><img src="/2023/03/09/BIU/image-20230309172510515.png" alt="image-20230309172510515"></p><p><img src="/2023/03/09/BIU/image-20230309172614155.png" alt="image-20230309172614155"></p><p>liquid democracy，也就是代理民主</p><p>政治学家可以进行民主实验，而不用建立一个新的国家</p><p><img src="/2023/03/09/BIU/image-20230309172916272.png" alt="image-20230309172916272"></p><p>2021年 Constitution DAO 但是输了</p><p>如何建立一个有secret treasury的DAO</p><p><img src="/2023/03/09/BIU/image-20230309173401581.png" alt="image-20230309173401581"></p><p>一个dapp，管理DAO的集合</p><p>问题是不知道DAO为什么要投资呢</p><p><img src="/2023/03/09/BIU/image-20230309173805546.png" alt="image-20230309173805546"></p><p><img src="/2023/03/09/BIU/image-20230309174355621.png" alt="image-20230309174355621"></p><p><img src="/2023/03/09/BIU/image-20230309174520582.png" alt="image-20230309174520582"></p><p>跨链</p><p>现实生活中有审计员，区块链可能需要对付款能力的零知识证明</p><p><img src="/2023/03/09/BIU/image-20230309174609532.png" alt="image-20230309174609532"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;What-are-Blockchains-and-What-are-They-For-Dan-Boneh&quot;&gt;&lt;a href=&quot;#What-are-Blockchains-and-What-are-They-For-Dan-Boneh&quot; class=&quot;headerl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Dumbo</title>
    <link href="https://alleysira.github.io/2023/03/09/Dumbo/"/>
    <id>https://alleysira.github.io/2023/03/09/Dumbo/</id>
    <published>2023-03-09T02:08:27.000Z</published>
    <updated>2023-03-09T07:39:57.538Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1ns4y1Y7yo/?share_source=copy_web&amp;vd_source=4487439a1220fa77bb4a6f0079c98794">区块链异步共识——超速小飞象共识协议</a></p><span id="more"></span><h1 id="超速小飞象共识协议"><a href="#超速小飞象共识协议" class="headerlink" title="超速小飞象共识协议"></a>超速小飞象共识协议</h1><h2 id="健壮的区块链系统需要异步共识"><a href="#健壮的区块链系统需要异步共识" class="headerlink" title="健壮的区块链系统需要异步共识"></a>健壮的区块链系统需要异步共识</h2><ul><li><p>公共账本</p><ul><li><p>保证可以正确写入</p></li><li><p>保证可以正确读取</p></li></ul></li><li><p>智能合约</p><ul><li><p>正确执行</p></li><li><p>条件执行</p></li></ul></li></ul><h3 id="拜占庭共识"><a href="#拜占庭共识" class="headerlink" title="拜占庭共识"></a>拜占庭共识</h3><p>有效性规定了输出具有一定意义：输出是诚实节点的输出</p><p><img src="/2023/03/09/Dumbo/image-20230309100604319.png" alt="image-20230309100604319"></p><h3 id="区块链共识"><a href="#区块链共识" class="headerlink" title="区块链共识"></a>区块链共识</h3><p>BFA是一次性共识，区块链需要的是持续运行的共识协议</p><p><img src="/2023/03/09/Dumbo/image-20230309100647097.png" alt="image-20230309100647097"></p><p><img src="/2023/03/09/Dumbo/image-20230309101037056.png" alt="image-20230309101037056"></p><p>交换机出错6分钟，认为Raft的不够科学</p><p><img src="/2023/03/09/Dumbo/image-20230309101059583.png" alt="image-20230309101059583"></p><p>最终同步网络模型：已知分片有限，不知道什么时候可以恢复</p><p>异步网络模型：刻画了TCP的模型</p><p><img src="/2023/03/09/Dumbo/image-20230309101203507.png" alt="image-20230309101203507"></p><p><img src="/2023/03/09/Dumbo/image-20230309101417682.png" alt="image-20230309101417682"></p><p><img src="/2023/03/09/Dumbo/image-20230309101536669.png" alt="image-20230309101536669"></p><p><img src="/2023/03/09/Dumbo/image-20230309101705780.png" alt="image-20230309101705780"></p><h2 id="性能瓶颈"><a href="#性能瓶颈" class="headerlink" title="性能瓶颈"></a>性能瓶颈</h2><p>确定性算法无法解决异步共识问题</p><p><img src="/2023/03/09/Dumbo/image-20230309101801067.png" alt="image-20230309101801067"></p><p><img src="/2023/03/09/Dumbo/image-20230309101835990.png" alt="image-20230309101835990"></p><p><img src="/2023/03/09/Dumbo/image-20230309101945208.png" alt="image-20230309101945208"></p><p>蜜罐100个节点需要10分钟进行共识</p><p>小飞象主要在轮复杂度进行了优化</p><p><img src="/2023/03/09/Dumbo/image-20230309102125976.png" alt="image-20230309102125976"></p><p>P2P网络中如何实现广播通信：RBC协议，最终获得相同的消息或者都不获得消息</p><p>ABA:对0/1实现共识，保证输出一定来自于至少一个诚实节点，随机化算法，并行的多个实例的停机时间影响效率</p><p>RBC结束了就投票0，未结束投票1</p><p><img src="/2023/03/09/Dumbo/image-20230309102321412.png" alt="image-20230309102321412"></p><p><img src="/2023/03/09/Dumbo/image-20230309102450800.png" alt="image-20230309102450800"></p><p><img src="/2023/03/09/Dumbo/image-20230309102527408.png" alt="image-20230309102527408"></p><p>1个MVBA替换n个ABA，实际只需要2-3个ABA</p><p>思想是实现MVBA的输出是RBC是否完成的投票</p><p><img src="/2023/03/09/Dumbo/image-20230309102708864.png" alt="image-20230309102708864"></p><p><img src="/2023/03/09/Dumbo/image-20230309102814021.png" alt="image-20230309102814021"></p><p><img src="/2023/03/09/Dumbo/image-20230309102836473.png" alt="image-20230309102836473"></p><h2 id="超速小飞象"><a href="#超速小飞象" class="headerlink" title="超速小飞象"></a>超速小飞象</h2><p>解决提到的两个问题</p><p><img src="/2023/03/09/Dumbo/image-20230309102944264.png" alt="image-20230309102944264"></p><p><img src="/2023/03/09/Dumbo/image-20230309103021991.png" alt="image-20230309103021991"></p><p>Totality要求一个节点收到消息，其他节点也必须要收到</p><p>PB 即发送者收到足够多的签名时即可保证f+1个诚实节点收到相同的广播消息</p><p><img src="/2023/03/09/Dumbo/image-20230309103254589.png" alt="image-20230309103254589"></p><p><img src="/2023/03/09/Dumbo/image-20230309103358760.png" alt="image-20230309103358760"></p><p><img src="/2023/03/09/Dumbo/image-20230309103431821.png" alt="image-20230309103431821"></p><p>MVBA是导致延迟的主要原因</p><p><img src="/2023/03/09/Dumbo/image-20230309103519817.png" alt="image-20230309103519817"></p><p><img src="/2023/03/09/Dumbo/image-20230309103557798.png" alt="image-20230309103557798"></p><p><img src="/2023/03/09/Dumbo/image-20230309103645643.png" alt="image-20230309103645643"></p><p><img src="/2023/03/09/Dumbo/image-20230309103720267.png" alt="image-20230309103720267"></p><p><img src="/2023/03/09/Dumbo/image-20230309103800950.png" alt="image-20230309103800950"></p><p><img src="/2023/03/09/Dumbo/image-20230309103946281.png" alt="image-20230309103946281"></p><p><img src="/2023/03/09/Dumbo/image-20230309104051895.png" alt="image-20230309104051895"></p><p><img src="/2023/03/09/Dumbo/image-20230309104129598.png" alt="image-20230309104129598"></p><p><img src="/2023/03/09/Dumbo/image-20230309104210694.png" alt="image-20230309104210694"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1ns4y1Y7yo/?share_source=copy_web&amp;amp;vd_source=4487439a1220fa77bb4a6f0079c98794&quot;&gt;区块链异步共识——超速小飞象共识协议&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="Consensus" scheme="https://alleysira.github.io/tags/Consensus/"/>
    
  </entry>
  
  <entry>
    <title>LXY+22</title>
    <link href="https://alleysira.github.io/2023/03/07/LXY-22/"/>
    <id>https://alleysira.github.io/2023/03/07/LXY-22/</id>
    <published>2023-03-07T03:35:13.000Z</published>
    <updated>2023-03-09T08:26:42.479Z</updated>
    
    <content type="html"><![CDATA[<p>Li X Y, Xu J, Yin L Y, et al. Escaping from consensus: Instantly redactable blockchain protocols in permissionless setting[J]. IEEE Transactions on Dependable and Secure Computing, 2022.</p><span id="more"></span><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="主要工作"><a href="#主要工作" class="headerlink" title="主要工作"></a>主要工作</h2><ul><li>基于[DMT19]的思想进行改进，将投票机制和共识机制解耦，从而提高编辑的确认速度，实现即时编辑<ul><li>即节点对是否编辑的投票不再记录在区块上而是直接发送给委员会</li><li>由于安全性不依赖于共识，对恶意敌手的要求从小于1/3，降低为1/2</li><li>实现编辑性的方法是类似于[DMT19]，在区块头保存被编辑区块的$merkle_root$，验证区块的有效性时首先检查前一个区块的哈希，如果不满足则检查编辑策略和旧状态是否满足条件<ul><li>实际工程实现可以在新节点和旧节点之间可以保持一样的区块结构，新节点分别保存原区块链和修改</li><li>所有编辑请求和投票都可以用现有的插入OP RETURN等脚本码来实现</li><li>目前编辑功能只局限于修改非金融字段，提出可以像Reparo一样，在更新UTXO的情况下修改金融数据</li></ul></li></ul></li><li>给出了形式化的可编辑区块链理想模型和基于模拟的安全证明<ul><li>现有方案一般仅分析编辑带来的影响</li><li>证明了满足链质量、链增长和可编辑共同前缀</li></ul></li><li>提供了方案在PoS和PoW区块链中的具体构造<ul><li>实验使用c语言针对采用PoS的Cardano Settlement Layer进行实现</li></ul></li></ul><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><ul><li>利用$Cmt$随机选举委员会，保证委员会超过一定比例的委员一定诚实，恶意敌手无法生成足够投票</li><li>用户想要修改区块$B_j$就生成候选区块$B_j^\star$并广播</li><li>委员对候选区块投票</li></ul><h3 id="委员会选举实现方法"><a href="#委员会选举实现方法" class="headerlink" title="委员会选举实现方法"></a>委员会选举实现方法</h3><p>分析在PoS中实现的$Cmt$算法，使用VRF进行选择（包括Algorand、Cardano、Internet Computer和Polkadot在内的许多L1区块链都在共识机制中使用了VRF来随机选择出块节点）</p><p>$hash$的输出表明了$P_i$有多少投票，每个权益为$s_i$的用户相当于有$s_i$个子用户，每个子用户被选中的概率是$p=\frac{T}{S}$,T是当前委员会投票阶段的权益的和，S是区块链系统权益的和</p><p>$s_i$中$q$个子用户被选中的概率服从二项分布$B(p;q,s_i)=C_{s_i}^q p^q(1-p)^{s_i-q}$</p><p>将区间[0,1)分为连续的区间</p><script type="math/tex; mode=display">I^c=[\sum^c_{q=0}B(p;q,s_i),\sum_{q=0}^{c+1} B(p;q,s_i)),c\in\{1,\dots,s_i\}</script><p>如果$\frac{hash}{2^{hashlen} }$落在$I_c$，证明$c$个用户为$P_i$投票</p><p><img src="/2023/03/07/LXY-22/image-20230309113111623.png" alt="image-20230309113111623"></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li><p>一般将每个出块者任期称为一个epoch，每个epoch由多个slot/round组成，每次生成一个区块</p></li><li><p>本文的slot是怎么定义的没有明确给出</p></li><li><p>共识和投票的区别</p><ul><li>共识是输入状态，得到0,1</li><li>投票是将已经有的0,1进行收集</li></ul></li></ul><p><a href="https://blog.csdn.net/A33280000f/article/details/120683353?spm=1001.2014.3001.5502">参考师兄的博客</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Li X Y, Xu J, Yin L Y, et al. Escaping from consensus: Instantly redactable blockchain protocols in permissionless setting[J]. IEEE Transactions on Dependable and Secure Computing, 2022.&lt;/p&gt;</summary>
    
    
    
    <category term="Crypto" scheme="https://alleysira.github.io/categories/Crypto/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="Redactable Blockchain" scheme="https://alleysira.github.io/tags/Redactable-Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>LMW23</title>
    <link href="https://alleysira.github.io/2023/03/01/LMW23/"/>
    <id>https://alleysira.github.io/2023/03/01/LMW23/</id>
    <published>2023-03-01T09:49:14.000Z</published>
    <updated>2023-03-09T11:10:54.245Z</updated>
    
    <content type="html"><![CDATA[<p>Li J, Ma H, Wang J, et al. Wolverine: A Scalable and Transaction-Consistent Redactable Permissionless Blockchain[J]. IEEE Transactions on Information Forensics and Security, 2023.</p><span id="more"></span><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>区块链中有两种链接关系：hash链接和签名链接</p><ul><li>哈希链接存在于不同区块的区块头之间</li><li>签名链接存在于不同区块的区块体的交易之间，签名链接是满足了之前交易的challenge script的见证</li></ul><p><img src="/2023/03/01/LMW23/image-20230302095926899.png" alt="image-20230302095926899" style="zoom:67%;"></p><p>考虑删除区块$B_2$内的交易$tx^1_2$，可能导致四条交易链接失效$tx^0_0\gets tx^1_2,tx_0^1\gets tx^1_2,tx^1_2\gets tx_3^1 ,tx^1_2\gets tx_3^2 $</p><p>其中交易$tx^0_0\gets tx^1_2,tx_0^1\gets tx^1_2$可能被双花</p><p>交易$tx^1_2\gets tx_3^1 ,tx^1_2\gets tx_3^2$可能会失效</p><h2 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work"></a>Related work</h2><p>[DMT19]为了实现追责，扩展了区块头增加了$old_merkle_root$字段，Reparo相当于将这个字段单独存储在数据库中而不修改区块结构，存在投票周期长和$n=3f+1$；这两篇文章都考虑+了交易的一致性问题，因此将编辑操作限制在非金融字段，不适用于UTXO</p><h2 id="Preliminary"><a href="#Preliminary" class="headerlink" title="Preliminary"></a>Preliminary</h2><h3 id="DRB"><a href="#DRB" class="headerlink" title="DRB"></a>DRB</h3><p>对于参与者$\{P_1,\dots,P_n\}$，$(t,n)$去中心化随机信标包含如下算法：</p><ul><li>$Setup(1^\lambda)\to pp$</li><li>$CmteGen(pp,t,n)\to(cpk,sk_1,\dots,sk_n)$:交互式协议，输出委员会的公钥和参与方对应的私钥</li><li>$PartialRand(cpk,sk_i,st_{l-1})\to s_i$：输入$l-1$轮状态$st_{l-1}$，计算部分值$\sigma_{l,i}$和对应的证明$\pi_{l,i}$，并且$s_i=(i,\sigma_{l,i},\pi_{l,i})$</li><li>$CombRand(cpk,st_{l-1},\varepsilon)\to (\sigma_l,\pi_l)$：输入$\varepsilon=\{s_i\}_{i\in I},|I|\geq t+1$</li><li>$VerifyRand(cpk,st_{l-1},\sigma_l,\pi_l)\to d\in\{0,1\}$</li><li>$UpdState(cpk,st_{l-1},\sigma_l,\pi_l)\to st_l$：输入上一轮的状态，输出更新后的当前轮的状态</li></ul><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><h2 id="System-model"><a href="#System-model" class="headerlink" title="System model"></a>System model</h2><p>考虑在$N$个节点的p2p网络中，存在监管委员会$R$人数$n\ll N$</p><p>假设委员会大多数诚实，委员会成员之间共享变色龙哈希函数密钥</p><ul><li><p>区块链节点首先通过抗女巫攻击的方式生成身份（$pk，sk$）</p></li><li><p>执行去中心化自举协议协商委员会的大小（开销很大但是只执行一次）</p></li><li>网络中任何人都可以将编辑指令放进区块中来发起编辑请求</li><li>委员会成员根据编辑策略验证编辑指令</li><li>如果满足策略，委员会成员投票并作为交易广播</li><li>矿工检查投票并且将有效投票打包进下一个区块</li><li>来自不同委员会成员的投票超过$n/2$之后，每个参与者本地组合份额恢复变色龙哈希函数私钥，执行编辑</li><li>每轮epoch重新选举委员会，重新分发陷门密钥</li></ul><h2 id="Network-and-Threat-model"><a href="#Network-and-Threat-model" class="headerlink" title="Network and Threat model"></a>Network and Threat model</h2><p>同步网络，公有链广泛采用的假设，诚实节点之间的信道延迟至多为$\delta$</p><p>存在同步广播信道（区块链本身）</p><p>考虑PPT的拜占庭敌手，任意时刻腐化的敌手数量满足$\rho &lt; 1/2$，被腐化的敌手可以任意偏离协议，发送错误的消息或者保持沉默</p><p>假设敌手slowly adaptive，敌手可以在每一轮开始或中间选择腐化的集合，但是直到该轮结束腐化才能生效</p><h1 id="NITCH"><a href="#NITCH" class="headerlink" title="NITCH"></a>NITCH</h1><p>给出非交互式变色龙哈希函数的构造和在RO下的安全证明</p><ul><li>部分更新算法$Partial\ Adapt(sk_i,vk_i,m,m’)\to s_i=(i,c_i,\pi_i)$，输出更新后的份额$c_i$和对应的证明</li><li>部分验证算法$Partial \ Verify(pk,vk_i,s_i,m,m’)\to 0/1$ </li><li>$Combine(VK,(h,m,r),m’,\varepsilon) \to r’$，其中$\varepsilon=\{s_{i_1},\dots,s_{i_{ |I| } } \}$输出新的随机数或者空<ul><li>奇怪的是恢复密钥采用的不是原始的私钥份额，而是执行部分更新算法后份额</li></ul></li></ul><p>verification keys的作用</p><h2 id="Instantiation"><a href="#Instantiation" class="headerlink" title="Instantiation"></a>Instantiation</h2><ul><li>DKG采用如下方案，只需要一轮通信，但无法保证均匀，用到了RO假设<ul><li><img src="/2023/03/01/LMW23/image-20230303170611136.png" alt="image-20230303170611136"></li><li>Non-interactive and information-theoretic secure verifiable secret sharing</li><li>此处第二个生成元的作用：公开可验证常数项的正确性，每个份额的正确性只有拿到份额的人可以验证</li><li>$sk=\sum a_{i,0},sk_j=\sum s_{i,j}=\sum f_i(j),pk=g_2^{\sum a_{i,0}},vk_j=g_1^{\sum s_{i,j} }=g_1^{sk_j},i\in QUAL$</li><li>私钥份额$sk_j$即所有参与者多项式在$j$处的求值</li><li>此处的$l_i^I(0)=\prod\frac{x}{x-x’} \bmod q$<ul><li>参考一篇博客 <a href="https://medium.com/nethermind-eth/a-tour-of-verifiable-secret-sharing-schemes-and-distributed-key-generation-protocols-3c814e0d47e1">https://medium.com/nethermind-eth/a-tour-of-verifiable-secret-sharing-schemes-and-distributed-key-generation-protocols-3c814e0d47e1</a></li><li>DKG使用私钥而不泄露私钥是非常重要的</li></ul></li></ul></li></ul><p>利用NITCH构造DRB</p><p><img src="/2023/03/01/LMW23/image-20230304145041604.png" alt="image-20230304145041604"></p><h1 id="Construction"><a href="#Construction" class="headerlink" title="Construction"></a>Construction</h1><h2 id="Shadow-Transaction-stx"><a href="#Shadow-Transaction-stx" class="headerlink" title="Shadow Transaction(stx)"></a>Shadow Transaction(stx)</h2><ul><li>目的：实现交易级的修改</li><li>将可修改的、能够插入任意数据的字段称为admissible fields $AF(tx,out.script,tx.wit)$</li><li>实际就是复制原来的交易，将AF字段设置为对应的变色龙哈希的值</li><li>带来两个性质<ul><li>可编辑性：交易的AF字段可以被委员会编辑</li><li>不可篡改性：交易的stable fields无法修改（H是抗碰撞的）</li></ul></li></ul><p><img src="/2023/03/01/LMW23/image-20230304153332166.png" alt="image-20230304153332166"></p><h2 id="The-redactable-blockchain-Protocol"><a href="#The-redactable-blockchain-Protocol" class="headerlink" title="The redactable blockchain Protocol"></a>The redactable blockchain Protocol</h2><ul><li>Update local chain：每轮开始选择最长链进行本地更新</li><li>从链去掉末尾k个区块后，收集所有编辑请求<ul><li>将请求加入到RIP(research instruction pool)</li><li>对编辑请求投票，更新RIP中的$(RI,\phi)\to (RI,\{vote\})$</li></ul></li><li>收集投票：更新$(RI,shares\cup s_i)$</li><li>编辑交易：如果$len(shares)&gt;n/2$，执行$NITCH.Combine$算法</li><li>扩展链：产生新区块并广播</li><li>编辑结束之后，其他用户可以提出新的编辑请求</li></ul><h2 id="Committee-Evolution"><a href="#Committee-Evolution" class="headerlink" title="Committee Evolution"></a>Committee Evolution</h2><h3 id="随机数生成"><a href="#随机数生成" class="headerlink" title="随机数生成"></a>随机数生成</h3><p>$R^e$执行DRB为下一轮生成随机数串$\tau^{e+1}$，当前轮结束后揭示$\tau^{e+1}$</p><h3 id="下一轮委员会选举"><a href="#下一轮委员会选举" class="headerlink" title="下一轮委员会选举"></a>下一轮委员会选举</h3><p>下一轮$e+1$开始时，每个参与者本地选择公钥和地址$(PK,IP)$作为身份</p><ul><li>引进IP为了防止女巫攻击</li></ul><p>能够发现PoW的解的参与者作为下一轮委员会的成员（公平性）</p><p>经过$\Delta$时间后，停止选举（如何保证委员会人数正确）</p><h3 id="分布式密钥再分享"><a href="#分布式密钥再分享" class="headerlink" title="分布式密钥再分享"></a>分布式密钥再分享</h3><ul><li><p>处理阶段</p><ul><li>每个$R^e$中的参与者$P_i^e$随机选择多项式$f_i(x)=sk_i^e+\sum_{j=1}^{t^{e+1} } a_{i,j}x^j$（注意此时用的是下一轮的$t$）</li><li>$P_i^e$广播$A_{i,k}=g_1^{a_{i,k}},k=0,\dots,t$</li><li>$P_i^e$计算份额$s_{i,j}=f_i(j),j=1,\dots,n^{e+1}$，发送$f_i(j)\to j$</li></ul></li><li><p>验证阶段：验证发送的秘密份额是否正确，实现对委员会参与者的追责</p><ul><li>参与者$P_j^{e+1}$计算</li><li><script type="math/tex; mode=display">g_1^{ s_{i,j} } \mathop{=}\limits^{?} \prod_{k=0}^{t^{e+1} } (A_{i,j})^{j^k}</script></li><li><p>如果不成立，广播对参与者$P_i^e$的投诉</p></li></ul></li><li><p>投诉阶段（抱怨2333）</p><ul><li>如果每个参与者收到超过$t^{e+1}$个投票就失去委员会资格，$P_i^e$收到投诉时需要重新发送$s_{i,j}$的份额，如果新的份额依然不通过则失去资格</li></ul></li><li><p>恢复阶段 </p><ul><li>计算公共验证密钥</li><li><script type="math/tex; mode=display">\mathrm{vk}_j=\prod_{i \in U} \prod_{k=0}^{t^{(e+1)}} A_{i, k}^{\ell_i^U(0) \cdot j^k}, j \in \mathcal{R}^{(e+1)}</script></li></ul></li><li><p>每个参与者本地计算私钥份额</p><ul><li><script type="math/tex; mode=display">\mathrm{sk}_j=\sum_{i\in U} (\ell^U_i(0)\cdot s_{i,j})</script></li></ul></li></ul><h1 id="目的-amp-收获"><a href="#目的-amp-收获" class="headerlink" title="目的&amp;收获"></a>目的&amp;收获</h1><ul><li>学习如何构造非交互式的门限变色龙哈希<ul><li>显然还是需要交互的</li></ul></li><li>刷新委员会和密钥份额的区别<ul><li>抗女巫攻击的身份生成方案</li></ul></li><li>shadow transaction如何实现交易一致性</li><li>实现多项式插值的算法的加速</li><li>学习 decentralized bootstrapping protocol</li><li>记得学习<a href="https://missing-semester-cn.github.io/2020/">https://missing-semester-cn.github.io/2020/</a></li><li><p>本方案要求本地存储两个数据库</p><ul><li>redaction instruction pool：储存当前的编辑请求，超过门限就恢复秘密执行编辑<ul><li>如何保证这个数据库的同步性，可能有敌手宣称已经超过1/2</li></ul></li><li>check value revocation list：存储区块最新的$r’$<ul><li>为了保证这个字段的一致性，区块头增加了$h=HASH(CVRL)$</li></ul></li></ul></li><li><p>方案的轮数是如何定义的</p></li><li><p>无法实现对区块的删除</p></li><li><p>具体出块者是谁</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Li J, Ma H, Wang J, et al. Wolverine: A Scalable and Transaction-Consistent Redactable Permissionless Blockchain[J]. IEEE Transactions on Information Forensics and Security, 2023.&lt;/p&gt;</summary>
    
    
    
    <category term="Crypto" scheme="https://alleysira.github.io/categories/Crypto/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="Redactable Blockchain" scheme="https://alleysira.github.io/tags/Redactable-Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>ZZL22</title>
    <link href="https://alleysira.github.io/2023/03/01/ZZL22/"/>
    <id>https://alleysira.github.io/2023/03/01/ZZL22/</id>
    <published>2023-03-01T07:15:59.000Z</published>
    <updated>2023-03-06T09:22:52.986Z</updated>
    
    <content type="html"><![CDATA[<p>赵晓琦,张正昊,李勇.可编辑且可追责的区块链方案[J].信息安全学报,2022,7(5):19-28</p><span id="more"></span><h1 id="方案构造"><a href="#方案构造" class="headerlink" title="方案构造"></a>方案构造</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>存在Leader将陷门作为秘密，进行可验证的秘密分享，附带证明。</p><p>链中用户对编辑请求进行投票，利用公钥和Leader的随机数进行哈希并排序选择具有编辑权的用户。</p><p>用户向leader发送密钥并附带证明，编辑者收到t个份额后恢复密钥并进行编辑。</p><p>用户可对编辑后的区块进行验证，对相关方追责。</p><h2 id="秘密分享阶段"><a href="#秘密分享阶段" class="headerlink" title="秘密分享阶段"></a>秘密分享阶段</h2><ul><li>Share：Dealer计算<ul><li>计算$Y_i=(y_i)^{f(i)},i\in [n],C_j=g^{a_j},j\in\{0,t-1\}$<ul><li>这里为什么不能用g，用公钥类似于公钥加密</li></ul></li><li>承诺$c=H(g^{f(i)},y^{f(i)}_i,g^{w_i},y^{w_i}_i)$</li><li>应答$r_i\equiv w_i-f(i)c \bmod q$</li><li>证明$\pi=(c,r_1,\dots,r_n)$</li><li>广播$(Y_1,\dots,Y_n,C_0,\dots,C_{t-1},\pi)$</li></ul></li><li><p>Verify：用户计算</p><ul><li>$g^{w_i}\mathop{=}\limits^{?}g^{r_i}(\prod_{j=0}^{t-1} (C_j)^{i^j})^c$</li><li>$y_i^{w_i}\mathop{=}\limits^{?}y_i^{r_i}(\prod_{j=0}^{t-1} (C_j)^{i^j})^c$</li></ul></li><li><p>Dec：用户计算</p><ul><li>计算$s_i=Y_i^{x_i^{-1}},c_2=H(h^{t_i}|s_i^{t_i})$</li><li>证明$\pi_i=(c_2,t_i-x_ic_2)$（用于对编辑的追责，可能使用虚假的公钥）</li></ul></li></ul><h2 id="投票阶段"><a href="#投票阶段" class="headerlink" title="投票阶段"></a>投票阶段</h2><p>用户对编辑请求投票，需要保证修改的不是金融数据，同意则生成一个随机数加密发给Leader</p><h2 id="寻找编辑者阶段"><a href="#寻找编辑者阶段" class="headerlink" title="寻找编辑者阶段"></a>寻找编辑者阶段</h2><p>$hash_i=H(upk_i,r_{sum})$，用户计算并广播$hash_i$，其中$r_{sum}$相当于是参与者都提供了部分随机性，排序后选择最小的公钥对应的编辑者即可</p><h2 id="编辑阶段"><a href="#编辑阶段" class="headerlink" title="编辑阶段"></a>编辑阶段</h2><p>恢复秘密生成新的随机数即可</p><h2 id="验证追责阶段"><a href="#验证追责阶段" class="headerlink" title="验证追责阶段"></a>验证追责阶段</h2><ul><li>检查$r_{sum}$正确性</li><li>判断编辑权用户的公钥是不是最小的哈希值的输入<ul><li>还要考虑Leader的公钥与随机数的哈希值是否小于最小哈希，如果不满足说明Dealer可能作恶</li></ul></li><li>计算变色龙哈希值成立</li><li><strong>验证子密钥是否正确，即$\pi_i$</strong></li></ul><h1 id="追责性"><a href="#追责性" class="headerlink" title="追责性"></a>追责性</h1><p>定义：编辑后的内容广播到区块链中，用户可验证是否可被接受，出现错误时可以向相关责任方进行追责</p><p>分别考虑验证追责阶段的四个条件：</p><ul><li>Leader可能更改随机数的和来内定编辑者，计算和可以追责到leader</li><li>如果用户的公钥不是最小哈希值，可以追责到编辑者</li><li>如果哈希值不同，用户发送的子密钥正确，追责编辑者</li><li>子密钥错误，追责子密钥拥有者</li></ul><p>如果编辑发布后经公共验证不被接受，追责所有相关者</p><h1 id="目的-amp-收获"><a href="#目的-amp-收获" class="headerlink" title="目的&amp;收获"></a>目的&amp;收获</h1><ul><li>了解可追责的定义，学习可追责的方案设计思路，追责部分详细分析如何追责的思路和方法</li><li>寻找编辑者阶段的设计，每个人生成随机数，Dealer求和再下发和，将随机数的和以及公钥作为哈希输入，对结果排序</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;赵晓琦,张正昊,李勇.可编辑且可追责的区块链方案[J].信息安全学报,2022,7(5):19-28&lt;/p&gt;</summary>
    
    
    
    <category term="Crypto" scheme="https://alleysira.github.io/categories/Crypto/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="Redactable Blockchain" scheme="https://alleysira.github.io/tags/Redactable-Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>JCH22</title>
    <link href="https://alleysira.github.io/2023/02/27/JCH22/"/>
    <id>https://alleysira.github.io/2023/02/27/JCH22/</id>
    <published>2023-02-27T03:18:09.000Z</published>
    <updated>2023-03-06T02:14:19.067Z</updated>
    
    <content type="html"><![CDATA[<p>Jia M, Chen J, He K, et al. Redactable Blockchain From Decentralized Chameleon Hash Functions[J]. IEEE Transactions on Information Forensics and Security, 2022, 17: 2771-2783.</p><span id="more"></span><h1 id="去中心化变色龙哈希函数的构造"><a href="#去中心化变色龙哈希函数的构造" class="headerlink" title="去中心化变色龙哈希函数的构造"></a>去中心化变色龙哈希函数的构造</h1><p>包含五个算法：</p><ul><li><p>$Key\ generation$ 密钥生成算法：需要$t$个参与者$\{P_1,\dots,P_t\}$在线合作共同生成密钥，$g$是循环群生成元，参与者$P_i$ 如下执行</p><ul><li><p>随机生成$t-1$阶多项式：$f_i(x)=\sum_{j=0}^{t-1}a_{i,j}x^j$，秘密为常数项$f_i(0)$</p></li><li><p>给参与者$P_j$发送$f_i(ID(P_j)),(g^{f_i(ID(P_1))},\dots,g^{f_i(ID(P_t))}),g^{f_i(0)}$，类似于拉格朗日插值法，把秘密放在了幂指数上</p><ul><li>$f_i(x)$是否有必要放在幂指数上？如果不放在指数上任何参与者都可以拿到输出私钥的值了</li><li>$f_i(ID(P_j))$的意义在于构建系统的私钥，由于私钥是$s_i=\sum^t_{j=1}f_j(ID(P_i))$，需要其他人的多项式在自己身份处的取值</li></ul></li><li><p>参与者$P_i$收到参与者$P_j$发送的$f_j(ID(P_i)),(g^{f_j(ID(P_1))},\dots,g^{f_j(ID(P_t))}),g^{f_j(0)}$后，计算拉格朗日插值判断是否正确，即计算是否成立</p><ul><li><script type="math/tex; mode=display">f_j(0)=\sum_{k=1}^tf_j(ID(P_k))\prod^t_{l=1,l\neq k}\frac{ID(P_l)}{ID(P_l)-ID(P_k)}</script></li></ul></li><li><p>输出公钥$g^s=\prod_{j=1}^t f_j(0),s=\sum^t_{j=1}a_{j,0}$，相当于$t$个参与者每个人私钥的和，但任何参与者都无法计算出公钥的$s$；输出私钥$s_i=\sum^t_{j=1}f_j(ID(P_i))$，私钥可以用来恢复公钥</p><ul><li>公私钥生成体现了公平性，$t$个参与者</li><li>考虑敌手$P_j$偷听，尝试恢复$P_i$的私钥$s_i=\sum^t_{k=1}f_i(ID(P_k))$缺一个份额$f_i(ID(P_i)$，以下秘密分享同理，缺少对自己的取值</li></ul></li><li>密钥生成阶段通信复杂度为$O(t^2)$</li></ul></li><li><p>$Hashing$ 哈希算法：输入公钥$g^s$，任意长度消息m，先计算$\mu\gets H(g^s,m)$，$H$是密码学哈希函数，满足$H:\mathbb{G} \times \{0,1\}^{\star} \to \mathbb{G} $，随机选择$e\in \mathbb{Z}_p^*$，输出随机数$r=(g^e,g^{se})$，输出哈希$h=g^e\mu^m$</p><ul><li>此处的$H$选择会影响安全性</li><li>哈希算法里用到了两次m，密码学哈希函数的输入m相当于提供随机性，$\mu^m$保证难以寻找碰撞，m在外面方便计算，实际上并不是想要修改的内容，用的是$header$</li></ul></li><li><p>$Rehashing$算法：给定公钥$g^s$和原始的消息-随机数对$(m,r=g^e,g^{se})$，计算哈希$h\gets g^e\mu^m$并输出</p></li><li><p>$Adaptation$算法：输入私钥份额$s_i$，原始的消息-随机数对$(m,r=g^e,g^{se})$，新的消息$m’\in\{0,1\}^\star$，参与者$P_i,i\in[t]$如下执行：</p><ul><li><p>计算$g^{e’}\gets g^e\mu ^{m-m’}$</p></li><li><p>计算$\eta_i\gets(g^{e’})^{\lambda_i \cdot s_i },\lambda_i=\prod^t_{l=1,l\neq i}\frac{ID(P_l)}{ID(P_l)-ID(P_i)}$，把$\eta_i$发送给参与者$P_j,j\in[t],j\neq i$</p></li><li><p>参与者$P_i$收到$\eta_1,\dots,\eta_{i-1},\eta_{i+1},\dots,\eta_{t}$后，计算$g^{se’}\gets\prod^t_{j=1}\eta_j$，输出更新后的随机数$r’=(g^{e’},g^{se’})$</p></li><li><p>其实就是用$t$个私钥恢复出公钥的指数</p><ul><li><script type="math/tex; mode=display">g^{e'}\to (g^{e'})^s\to(g^{e'})^{\sum f_i(0)}\to(g^{e'})^{\sum \lambda_{i} \cdot s_i} \to \prod (g^{e'})^{\lambda_i \cdot s_i }</script></li></ul></li><li><p>通信复杂度为$O(t^2)$</p></li></ul></li><li><p>$Verification$：输入公钥$g^s$和原始的消息-随机数对$(m,r=g^e,g^{se})$以及修改后的消息-随机数对$(m’,r’=g^{e’},g^{se’})$，如果计算的哈希值$g^e\mu^m=g^{e’}\mu^{m’}$相等且$(g,g^s,g^{e’},g^{se’})$是DH组，输出1，否则输出0</p></li></ul><h2 id="密钥更新阶段"><a href="#密钥更新阶段" class="headerlink" title="密钥更新阶段"></a>密钥更新阶段</h2><p>目的：节点可能动态加入或离开，敌手可能掌握超过$t$个份额，需要在不改变秘密的情况下扩大门限到$t’$</p><p>目前已经有n个节点掌握多项式$F(ID(i),y)$，需要$t$个份额就能恢复秘密</p><ul><li><p>全节点$\{P_i,\dots,P_{2t’}\}$执行$Zero(\{F(ID(P_i),y),t’-1\}^{t})$</p><ul><li><p>随机选择$(t’-1,2t’-1)$阶多项式$R(x,y)$，满足$R(0,0)=0$</p></li><li><p>$\{F(x,ID(i))\}^{2t’} \gets Handout\{F(ID(i),y)\}^t$</p></li><li><p>$\{R(ID(i),y)\}^{2t’}\gets Transform\{R_i(x,ID(i))\}^{2t’},R_i(x,ID(i)$是$t’-1$阶</p></li><li><p>$\{R(x,ID(i))\}^{2t’} \gets Handout\{R(ID(i),y)\}^{2t’}$</p></li><li><p>实现了对份额的更新，新的$t’-1$阶多项式满足$F’(x,ID(P_i))=F(x,ID(P_i))+R(x,ID(i))$</p></li></ul></li><li><p>现在分发给$n’$即可，执行$\{F’(ID(i),y\}^{n’} \gets Handout\{F’(x,ID(i))\}^{2t’}$</p><ul><li>$F’(x,y)=F(x,y)+R(x,y),F’(0,0)=F(0,0)=s$</li><li>更新份额相较于重新生成私钥再分配的区别在于，省去了执行$DCH.KeyGen()$的时间</li></ul></li></ul><h1 id="RSA累加器"><a href="#RSA累加器" class="headerlink" title="RSA累加器"></a>RSA累加器</h1><p>主要参考知乎<a href="https://zhuanlan.zhihu.com/p/158976773">这篇文章</a>理解，本文写的不够清楚</p><ul><li>acc字段存当前RSA累加器的值，RSA累加器把所有区块的$last_hash$编码进去，同一高度的区块acc值一样<ul><li>当区块2内的编辑请求$tx_{req1}$修改$tx1$为$tx1’$后，生成区块3，区块2内的acc值更新</li></ul></li></ul><p><img src="/2023/02/27/JCH22/image-20230227165109508.png" alt="image-20230227165109508"></p><h2 id="一致性检查"><a href="#一致性检查" class="headerlink" title="一致性检查"></a>一致性检查</h2><p>编辑会导致同一区块高度可能存在不同的区块，客户端需要检查是否区块被编辑过</p><ul><li>客户端发送想要查询的区块$header,hash(header)$给任意节点，节点本地查询RSA累加器</li><li>节点收到成员证明或者非成员证明后验证即可</li></ul><h1 id="安全性分析"><a href="#安全性分析" class="headerlink" title="安全性分析"></a>安全性分析</h1><h2 id="Decentralization"><a href="#Decentralization" class="headerlink" title="Decentralization"></a>Decentralization</h2><p>如果敌手试图通过$(m,r=g^e,g^{se})$来恢复$s$实现高效寻找碰撞，考虑到在系统稳定时，密钥作为常数项</p><p>$F(x,0)=s+\sum_{i=1}^{t-1}a_ix^i$被分享给$n$个节点，节点拥有份额$(IP(P_i),F(IP(P_i),0))$，超过$t$个节点同意即可恢复私钥。由于敌手只能控制$t-1$个节点，无法恢复私钥</p><p>在私钥更新阶段，每个节点最多同时掌握$2t-1$阶多项式$F(i,y)$和$t-1$阶$F(x,i)$，节点能够获得$t-1$阶多项式</p><p>敌手最多获得$t-1$份$F(x,0)$和$F’(x,0)$，无法恢复私钥</p><h2 id="Traceability"><a href="#Traceability" class="headerlink" title="Traceability"></a>Traceability</h2><p>考虑到同一高度所有被编辑的区块组成一条编辑链，所有编辑可以被高效审计（RSA累加器的必要性体现在一致性检查）</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li>提到新的创世区块，应该是是自己新建一条链，如何集成到现有的区块链系统中</li><li>最初$t$个掌握变色龙哈希函数私钥的节点怎么选，安全性<ul><li>直接用节点身份的哈希值，属于半中心化信标</li></ul></li><li>在包含修改请求的交易上链后，其他区块链上的节点如何修改$header \to header’$</li><li>修改区块头的结构后，增加的3个字段会带来额外的存储开销</li><li>RSA累加器的必要性在哪里<ul><li>将编辑后的区块加入到RSA累加器中</li><li>每次生成新的区块，节点本地更新RSA累加器的值</li><li>节点验证区块的有效性时想要知道该区块是否被编辑过</li><li>如果不是使用RSA累加器，其他方案如何解决区块的区分问题</li><li>RSA累加器的值能保证同步吗？可能存在某个恶意节点的未即时更新acc，客户端向恶意节点查询本已经被修改过的区块，该恶意节点返回该区块未被编辑。如果不同步，下一次生成区块的acc计算会错误；如果编辑对自己不利，可能在出块时才更新acc<ul><li>[LMW+23]提到了扩展头部的作用是保证类似的本地数据结构的同步</li></ul></li></ul></li><li>初始化的RSA的$N$和$g_1$也需要分布式生成，论文给了参考的算法，没有仔细了解</li><li><p>需要的映射哈希函数，将$x$映射为素数$SH(x)$，这种映射怎么找</p><ul><li>github的RSA accumulator已找到</li></ul></li><li><p>last_hash字段是新产生区块更新后的头部的哈希，如果是对之前区块的编辑，$last_hash$是该区块的头部哈希，不是编辑的区块是否该字段为空？</p></li><li>每次秘密分享都是可验证的，不是公开可验证</li><li>如果将RSA累加器替换为bloom filter？<ul><li>思考可行性：布隆过滤器提供高效的成员证明，非成员证明很可能不出错</li><li>如何保证参与者的bloom filter一致，区块头加上布隆过滤器的哈希值？类似于RSA的acc</li><li><a href="https://zhuanlan.zhihu.com/p/601973839">https://zhuanlan.zhihu.com/p/601973839</a></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Jia M, Chen J, He K, et al. Redactable Blockchain From Decentralized Chameleon Hash Functions[J]. IEEE Transactions on Information Forensics and Security, 2022, 17: 2771-2783.&lt;/p&gt;</summary>
    
    
    
    <category term="Crypto" scheme="https://alleysira.github.io/categories/Crypto/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="Redactable Blockchain" scheme="https://alleysira.github.io/tags/Redactable-Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>overview on blockchain consensus mechanism</title>
    <link href="https://alleysira.github.io/2022/11/28/overview-on-blockchain-consensus-mechanism/"/>
    <id>https://alleysira.github.io/2022/11/28/overview-on-blockchain-consensus-mechanism/</id>
    <published>2022-11-28T01:46:11.000Z</published>
    <updated>2023-02-28T02:59:12.239Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>共识机制作为区块链技术的核心，从根本上决定了整个系统的安全性、可用性和系统性能等</p><span id="more"></span><h2 id="区块链概述"><a href="#区块链概述" class="headerlink" title="区块链概述"></a>区块链概述</h2><p>特点</p><ul><li>去中心化：网络中没有可信第三方</li><li>去信任化：节点之间不需要彼此信任，通过共识机制达成对账本的一致认识</li><li>公开透明性：任何节点可以随时加入退出，可以获得区块链的历史账本数据，接收到新生成的区块</li><li>不可篡改性：区块链中的历史数据不能被非法篡改</li><li>匿名性：保护隐私数据</li></ul><h2 id="共识概述"><a href="#共识概述" class="headerlink" title="共识概述"></a>共识概述</h2><p>决定参与节点以何种方式对某些特定的数据达成一致</p><p>分为经典的分布式共识机制和区块链共识机制</p><p>区块链共识机制：</p><ul><li><p>授权共识：网络节点通过了PKI身份认证后才能参与后续共识机制</p></li><li><p>非授权共识：节点随时加入退出，节点数量动态变化，通过特定算法完成出块者选举、区块生成和节点验证、更新</p></li></ul><p>区块链共识机制的基本流程</p><ul><li>选举出块者：目前的出块者可以分为两种，一种是单一节点作为出块者，另一种是多个节点构成委员会，整个委员会作为出块者。选举过程中需要考虑女巫攻击，需要完成一定的任务或者条件才能够成为出块者。目前大多数采用Pow和Pos</li><li>生成区块：出块者将一段时间内网络中的交易打包放进当前区块中，为了使区块链成为链状结构，在其中包含其他内容。区块分为区块头和区块体。区块头包含了上个区块的哈希值、时间戳；区块体包含完整的交易数据。目前可以按照出块者与区块的对应关系将区块生成过程分为两类：一类是一对一关系，一个出块者对应一个区块；一对多关系意味着一个出块者在其任期期间能够生成多个区块，一般将一个出块者的任职时间称为一个时期(epoch)，每个任期由多轮组成，每轮生成一个区块</li><li>节点验证更新区块链：出块者生成区块后，将区块在网络中广播，收到区块的节点验证区块正确性并更新本地区块链。部分共识机制中节点需要验证区块交易合法性和出块者的身份合法性</li></ul><p>评价标准</p><ul><li>安全性：考虑敌手存在且操纵一定的网络资源和其他资源的情况下，诚实用户在不可信的网络环境下达成一致</li><li>交易吞吐率：区块链系统的交易处理速度，一般采用每秒钟处理交易的数量作为评判标准，一般受到区块产生间隔、区块大小和网络延时等因素的影响</li><li>可扩展性：网络处理交易的性能是否随着节点的增多而增强，网络处理能力的可增长性，一般采用分片来实现，每个分片并行处理网络内部的数据</li><li>交易确认时间：交易被提交至网络到最终被完全确认所需要的时间，完全确认是指交易被写入区块且大概率不会被篡改，以此作为凭证完成交易过程。比特币中大概为60分钟。确定性共识中交易确认时间降低</li><li>去中心化：区块链采用的共识机制没有可信第三方，区块由参与公式的节点共同决定，而不是集中在少数几个节点上，网络中的权力应当分散化而不是集中化，矿池一定程度上影响了比特币的去中心化</li><li>资源占用：节点间的通信复杂度和节点的计算复杂度</li></ul><h1 id="模型和定义"><a href="#模型和定义" class="headerlink" title="模型和定义"></a>模型和定义</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>状态机复制：存在一组节点且所有节点共同维护一个线性增长的日志，就日志内容达成一致<ul><li>节点中存在一个主机。在可容忍的范围内，允许一定比例的节点出现故障或遭受敌手攻击。需要满足一致性和活性</li><li>一致性：满足诚实节点最终输出日志一致</li><li>活性：在一定时间内出现在所有诚实节点的日志中</li><li>常用于大型数据库的同步</li></ul></li><li>快速响应特性：交易确认时间与网络真实时延有关，与网络时延上限无关</li><li>授权共识：授权网络中PKI存在且为每个节点实施身份认证。注册完成后，每个节点都能活着所有参与者节点数量和身份。运行共识机制，实现状态机复制，完成账本的生成和维护，并将账本以区块链的形式实现。</li><li>非授权共识：节点不需要身份认证，无身份认证，由于网络动态变化，节点无法获知所有参与者节点数量和身份；通过一定的共识机制实现状态机复制</li><li>公共账本：能够满足一致性和活性的可信公告牌，任何人都能在上面存放消息，任何人都能读账本；对状态机复制的延伸，保证了在非授权网络中公开透明、任何节点能够随时访问、添加信息。满足以下两个安全特性<ul><li>持续性：诚实用户在某个位置上传了合法交易，则最终所有诚实用户的张本忠该位置一定存在该交易</li><li>活性：某个时间诚实用户上传了交易至公开账本，等待若干时间后，该交易一定出现在每个诚实用户账本中</li></ul></li><li>共同前缀：$Q_{cp}$表示。任意两个诚实节点提交的节点在去掉末尾k个区块后一定具有前缀关系</li><li><p>链质量：安全参数$\mu \in \mathbb{R},k,k_0 \in \mathbb{N}$，任何城市节点P的链C中除去最新的$k_0$区块后，任意k个连续的区块中，恶意区块的比例不超过$\mu$</p><ul><li>链质量属性是指连续的区块中必定有足够比例的区块由诚实用户产生</li></ul></li><li><p>链增长：安全参数为$\tau \in \mathbb{R},s,r_0 \in \mathbb{N}$，对于任意轮r（r&gt;$r_0$)，城市节点P在第r轮输出的区块链为$C_1$，在第$r+s$轮输出的区块链为链C_2，满足$|C_2|-|C_1|\geq \tau \cdot s$</p></li><li>弱一致性：根据出块者选举的方式，同一个时期可能有两个甚至以上合法的出块者，区块链可能出现分叉，但是很长一段时间后最终的区块链是确定的</li><li>强一致性：生成的区块是确定的，确定性共识方案。通过选择一个确定的委员会，再由委员会内部运行的分布式一致性算法生成新区块，每一轮的区块都是确定的，一般不会分叉<ul><li>无分叉，节点无需花费大量算力</li><li>交易确认速度快，上传的交易写入区块中便可以确保合法性</li><li>前向安全性（forward security），只要区块被写入到区块链上，可以确保区块不会被篡改，将一直保持在链上</li></ul></li><li><p>容错类型</p><ul><li><p>拜占庭容错：分布式系统中发生了任意类型的错误，错误的节点少于一定比例都能保证可靠性</p><ul><li>PBFT BFT-Smart</li><li>联盟链、公链</li></ul></li><li><p>非拜占庭容错：只能保证节点宕机等错误发生时系统的可靠性</p><ul><li>Paxos、Raft</li><li>私有链（没有恶意节点）</li></ul></li></ul></li></ul><h2 id="模型分类"><a href="#模型分类" class="headerlink" title="模型分类"></a>模型分类</h2><h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><ul><li>同步网络：诚实节点之间的消息按照轮来传播，在每一轮中诚实用户发出的消息能够在下一轮之前到达所有其他诚实用户。比较强的网络模型</li><li>部分同步网络：网络中的消息传输存在一定的上限$\Delta$，时延上限不能作为协议的参数使用，能够确保诚实用户发出的消息在$\Delta$时间后到达所有诚实用户；属于区块链协议分析中常用的网络模型</li><li>异步网络：敌手能够任意拖延诚实用户的消息或者打乱顺序，只需要保证最终诚实用户的消息能够到达彼此</li></ul><h3 id="腐化模型"><a href="#腐化模型" class="headerlink" title="腐化模型"></a>腐化模型</h3><p>腐化指敌手通过向目标节点发动攻击，获取目标节点的秘密信息，进而控制目标节点的输入输出消息，使其完全受到自身的控制</p><ul><li>静态敌手：敌手只能在协议开始前选定其腐化的目标，一旦协议开始运行便不能腐化诚实节点。敌手控制的节点数量在协议运行期间不会改变</li><li>$\tau-$温和敌手：敌手腐化一个节点需要一定的时间$\tau$，在该时间内节点仍然属于诚实节点。属于区块链协议分析中常用的腐化模型</li><li>适应性敌手：是指敌手能够根据协议运行过程中手机的信息，动态且适应性地对目标节点完成腐化</li></ul><h3 id="敌手模型"><a href="#敌手模型" class="headerlink" title="敌手模型"></a>敌手模型</h3><p>对敌手能够掌握的算力或财产占比做出一定的限制，一般用f代表敌手数量，n代表网络中节点总数，利用n与f的关系来刻画敌手模型</p><ul><li>$n=2f+1$：敌手算力占全网算力比例不超过1/2<ul><li>比特币</li></ul></li><li>$n=3f+1$：PBFT等经典分布式共识机制要求敌手模型；一些混合共识也需要这样的约束</li><li>$n=4f+1$：由于自私挖矿导致链质量下降，某些混合共识</li></ul><h1 id="经典分布式共识机制"><a href="#经典分布式共识机制" class="headerlink" title="经典分布式共识机制"></a>经典分布式共识机制</h1><p>在授权网络中，一组节点实现状态机复制。主要面向分布式数据库系统，Paxos针对网络中可能出现的崩溃节点；PBFT能够容忍一定的拜占庭错误节点。</p><p>根据网络模型可以分为：</p><ul><li>部分同步网络分布式一致算法</li><li>异步网络分布式一致算法</li><li>同步网络分布式一致算法</li></ul><h2 id="部分同步网络分布式一致算法"><a href="#部分同步网络分布式一致算法" class="headerlink" title="部分同步网络分布式一致算法"></a>部分同步网络分布式一致算法</h2><h3 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h3><p>包含了主节点和备份节点的概念，允许多个主节点同时进行提议，赋予不同的等级；等级高的主节点的提议可以打断低等级的主节点提议（即使低等级的主节点已经得到了备份节点的承诺消息）。广泛应用于分布式系统中数据库的维护，只能对恶意节点容错，无法对拜占庭节点（恶意节点）实现容错</p><ul><li>主节点向全网超过1/2的备份节点发送准备消息</li><li>备份节点验证消息合法性，通过后向主节点返回承诺信息</li><li>主节点收集足够多的承诺消息，组成承诺凭证，主节点向备份节点发送包含承诺凭证的accept消息</li><li>备份节点验证接受消息的合法性，通过后向主节点发送accepted消息</li></ul><p><img src="/2022/11/28/overview-on-blockchain-consensus-mechanism/v2-8d4eaf5fdeb145e8bdf5e3bb1af408c9_1440w.webp" alt="img"></p><p><a href="https://zhuanlan.zhihu.com/p/31780743">参考1</a>，<a href="https://www.cnblogs.com/linbingdong/p/6253479.html">参考2</a></p><h3 id="PBFT"><a href="#PBFT" class="headerlink" title="PBFT"></a>PBFT</h3><p>$n=3f+1$，网络模型为部分同步网络</p><p>分布式共识达成过程：</p><ul><li>请求：客户端上传请求消息m至网络中的节点，包括主节点和其他备份节点</li><li>预准备：主节点收到客户端上传的请求消息m，赋予消息序列号s，计算得到预准备消息$(pre-prepare,H(m),s,v)$</li><li>准备：备份节点收到主节点的预准备消息，验证$H(m)$的合法性，即对于视图v和序列号s来说，备份节点先前未收到其他消息。验证通过后，备份节点计算准备消息并广播。所有节点收集准备消息，大于2f+1则组成certificate发送</li><li>执行：</li></ul><h1 id="To-do"><a href="#To-do" class="headerlink" title="To do"></a>To do</h1><p>继续阅读</p><p>需要补充学习的经典机制：Paxos PBFT</p><p>学习女巫攻击 DOUCEUR J R. The Sybil attack[C]. In: Peer-to-Peer Systems—IPTPS 2002. Springer Berlin Heidelberg, 2002: 251–260. [DOI: 10.1007/3-540-45748-8_24]</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;共识机制作为区块链技术的核心，从根本上决定了整个系统的安全性、可用性和系统性能等&lt;/p&gt;</summary>
    
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="Consensus" scheme="https://alleysira.github.io/tags/Consensus/"/>
    
  </entry>
  
  <entry>
    <title>Decentralizing Privacy: Using Blockchain to Protect Personal Data</title>
    <link href="https://alleysira.github.io/2022/11/15/Decentralizing-Privacy-Using-Blockchain-to-ProtectPersonal-Data/"/>
    <id>https://alleysira.github.io/2022/11/15/Decentralizing-Privacy-Using-Blockchain-to-ProtectPersonal-Data/</id>
    <published>2022-11-15T07:21:40.000Z</published>
    <updated>2022-11-18T02:36:44.907Z</updated>
    
    <content type="html"><![CDATA[<p>本文的实质贡献是提出了在仅区块链存储加密数据的指针，结合数字签名提供认证性，使用去中心化的数据存储结构存储加密数据提供保密性</p><p><a href="https://ieeexplore.ieee.org/abstract/document/7163223">文献</a></p><p>Users should own and control their data without compromising security or limiting companies’ and authorities’ ability to provide personalized services.</p><span id="more"></span><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>用户对于企业收集的个人信息没有控制权、对于企业如何使用信息不知情</p><p>相关工作：</p><ul><li><p>OpenPDS，在密文上直接操作</p></li><li><p>$k$匿名要求每条记录中的敏感信息至少和其他$k-1$条记录不可区分，跟进工作有l-diversity，t-closeness</p></li><li><p>差分隐私</p></li><li>FHE</li></ul><p>本文贡献：</p><ul><li>将区块链与链下存储相结合，构造了一个聚焦于隐私的个人信息管理平台</li><li>阐述了未来区块链可能成为一种重要的可信计算资源</li></ul><h1 id="The-Privacy-Problem"><a href="#The-Privacy-Problem" class="headerlink" title="The Privacy Problem"></a>The Privacy Problem</h1><p>聚焦于移动平台用户使用第三方服务时在隐私方面的忧虑，这些第三方持续收集用户信息，用户不知情也无权掌控，因此主要解决的隐私问题有以下三类：</p><ul><li>数据拥有权：用户拥有并且控制个人数据，系统将用户作为数据的拥有者，服务作为委托权限的客体</li><li>数据透明性和可审计性：用户可以了解数据如何收集并且如何加工</li><li>细粒度的访问控制：任何时刻用户都可以更改权限集或者撤回之前已经收集的数据的权限；该方案的一个应用就是改善移动端应用程序现有的权限日志，用户接口依然相同，访问控制策略将会在区块链上安全地存储，只有用户可以更改</li></ul><h1 id="Proposed-Solution"><a href="#Proposed-Solution" class="headerlink" title="Proposed Solution"></a>Proposed Solution</h1><p>本方案有3类实体：</p><ul><li>手机用户：下载并且使用应用</li><li>服务：应用程序的提供者，为商业目的请求对用户个人数据进行处理</li><li>节点：维护区块链和一个分布式的私有键值对形式的数据库以换取奖励</li></ul><p>尽管用户在系统中仍然是匿名的，可以将服务配置文件存储在区块链上并且验证身份；</p><p>区块链接受两种类型的交易：</p><ul><li>$T_{access}$用于访问控制管理</li><li>$T_{data}$用于数据存储和取回</li></ul><p><img src="/2022/11/15/Decentralizing-Privacy-Using-Blockchain-to-ProtectPersonal-Data/image-20221116093213863.png" alt="image-20221116093213863" style="zoom: 50%;"></p><p>考虑以下实例：用户安装使用本平台保护隐私的应用程序，用户第一次登录，一个新的共享的身份将会被建立并且和相关联的权限一起通过$T_{access}$交易发送给区块链。手机手机的敏感信息在用共享的密钥加密后通过$T_{data}$发送给区块链，随后路由到链下的键值存储数据库，链上只保留了一个指向数据的指针</p><p>服务和用户都可以通过$T_{data}$上的数据指针来访问数据，区块链验证数字签名属于用户还是服务。用户可以通过发出$T_{access}$交易和新的权限集来更改已经授予服务的权限或者收回对之前存储的数据的访问权。可以开发dashboard提供了对数据和权限的概览</p><p>链下键值存储是Kademilia的实现，一个分布式的哈希表（DHT），使用LevelDB增加了一致性和区块链的接口。DHT由一个网络中的节点维护（大概率和区块链网络中的节点不重合），执行检验过的读/写交易。数据在节点之间充分地随机化并且复制，来确保高可用性。值得注意的是，可以考虑替代链下的存储解决方案。中心化的云服务器可能可以用来存储数据，虽然增加了对第三方可信度的要求，但是带来了扩展性和易于部署的好处</p><h1 id="The-Network-Protocol"><a href="#The-Network-Protocol" class="headerlink" title="The Network Protocol"></a>The Network Protocol</h1><h2 id="Building-Blocks"><a href="#Building-Blocks" class="headerlink" title="Building Blocks"></a>Building Blocks</h2><h3 id="Identities"><a href="#Identities" class="headerlink" title="Identities"></a>Identities</h3><p>在区块链中用户可以生成任意多个匿名身份来保护隐私。</p><p><em>复合身份</em>是两方或者更多人共享的身份，其中至少一个参与者属于拥有者，其他人权限受限，作为客体。协议1阐述了对于一个拥有者和一个客体的实现，实际就是两者共享同一个对称加密私钥，拥有各自的签名公私钥；同时此时要求了两者之间是secure channel</p><p><img src="/2022/11/15/Decentralizing-Privacy-Using-Blockchain-to-ProtectPersonal-Data/image-20221116103317693.png" alt="image-20221116103317693"></p><p>对外来看，复合身份是一个2元组</p><script type="math/tex; mode=display">Compound_{u,s}^{(public)}=(pk_{sig}^{u,s},pk_{sig}^{s,u})</script><p>完整的身份包括</p><script type="math/tex; mode=display">Compound_{u,s}=(pk_{sig}^{u,s},pk_{sig}^{s,u},sk_{sig}^{u,s},sk_{sig}^{s,u},sk_{enc}^{u,s})</script><h3 id="Blockchain-Memory"><a href="#Blockchain-Memory" class="headerlink" title="Blockchain Memory"></a>Blockchain Memory</h3><p>区块链的存储空间$L:\{0,1\}^{256}\to \{0,1\}^N$，假设存储在其他区块链中的标准敌手模型下是不可篡改的</p><h3 id="Policy"><a href="#Policy" class="headerlink" title="Policy"></a>Policy</h3><p>用户$u$给予服务$s$的的一系列权限记作$POLICY_{u,s}$，当服务忠实执行协议且正确地标记数据，任何类型的数据都可以进行安全地存储。</p><h3 id="Auxiliary-Functions"><a href="#Auxiliary-Functions" class="headerlink" title="Auxiliary Functions"></a>Auxiliary Functions</h3><p>$Parse(x)$将发送给交易的消息进行反序列化，该消息包含了$CheckPolicy(pk^{k}_{sig},x_p)$</p><p>首先将给定消息的公钥做哈希寻找到数据指针，在存储上找到该指针对应的消息，将找到的消息反序列化后如果公钥确实是主体公钥或者客体公钥，但是该客体的权限属于权限集中，则返回1；此处暗示了$L[\mathcal{H}(pk^{u,s}_{sig})]=L[\mathcal{H}(pk^{s,u}_{sig})]$</p><p><img src="/2022/11/15/Decentralizing-Privacy-Using-Blockchain-to-ProtectPersonal-Data/image-20221117090454251.png" alt="image-20221117090454251"></p><h2 id="Blockchain-Protocols"><a href="#Blockchain-Protocols" class="headerlink" title="Blockchain Protocols"></a>Blockchain Protocols</h2><p>协议3是链上节点收到$T_{access}$时执行的，类似的，协议4是链上节点收到$T_{data}$时执行的</p><p>$T_{access}$交易允许用户通过发送$POLICY_{u,s}$更改已经赋予服务的权限集，发送空集撤销所有之前赋予的权限。当发送一条新的复合身份的$T_{access}$交易时，该消息将被理解为用户注册服务</p><p>具体来看，将消息反序列化之后得到的主体公钥和收到的公钥对比，若相同则修改对应的指针位置存储的消息，相当于修改了权限</p><p><img src="/2022/11/15/Decentralizing-Privacy-Using-Blockchain-to-ProtectPersonal-Data/image-20221117091230415.png" alt></p><p>对于$T_{data}$交易执行读写操作，有了之前的$CheckPolicy(pk^{k}_{sig},x_p)$，可以判断该用户或服务能够获得数据访问权。</p><p>将收到的消息反序列化之后得到了加密后的数据，权限和读写标识；进行权限判断：如果此时判断为真，则取出对应的两个公钥以及权限集，私以为原文伪代码有误，此处应为$\gets Parse(L[\mathcal{H}(pk^{k}_{sig})])$，若此时需要写，则计算$c$对应的指针并添加到之前的指针集合内，再修改$DHT$对应的位置为$c$；若此时只读，可能只传一个指针，判断$h_c\in L[a_{xp}]$（此处记号和伪代码不同）</p><p><img src="/2022/11/15/Decentralizing-Privacy-Using-Blockchain-to-ProtectPersonal-Data/image-20221117091642675.png" alt="image-20221117091642675"></p><h2 id="Privacy-and-Security-analysis"><a href="#Privacy-and-Security-analysis" class="headerlink" title="Privacy and Security analysis"></a>Privacy and Security analysis</h2><p>假设：</p><ul><li><p>区块链不可随意篡改</p></li><li><p>假设需要足够大的互不信任的平等网络</p></li><li>假设用户安全地保管密钥</li></ul><p>在以上模型下，只有用户能够控制自己的数据，区块链去中心化的本质结合了数字签名的交易确保了敌手无法伪装为用户或者腐化网络，否则暗示了敌手能够伪造数字签名或者控制网络中的大多数资源。类似地，敌手无法获得公开账本上的任何信息，因为链上只存储了指针。</p><p>敌手控制1个或多个DHT节点无法学习到任何原始数据，因为被对称密钥加密了，该密钥的拥有者和DHT节点不重合。注意到尽管数据完整性无法保证，因为单个节点可以修改本次的复制或者以拜占庭的方式修改，本方案仍然可以通过对数据进行充分的分布和复制来最小化风险。</p><p>为每个符合身份生成新的密钥对保证了在敌手获得了加密和签名密钥后，只有一小部分数据会被损害。获得这两个密钥其中一个，数据仍然是安全的。注意在实践中我们可以进一步将身份分开来限制该复合身份密钥泄露带来的影响。比如每1k条消息换一次密钥。</p><h1 id="Discussion-of-future-extensions"><a href="#Discussion-of-future-extensions" class="headerlink" title="Discussion of future extensions"></a>Discussion of future extensions</h1><p>稍微偏题来呈现可能的未来区块链的扩展</p><h2 id="From-storage-to-Processing"><a href="#From-storage-to-Processing" class="headerlink" title="From storage to Processing"></a>From storage to Processing</h2><p>本文的实质贡献是提出了在仅区块链存储加密的数据的指针，该方案适合于存储和随机查询。对于处理数据效率不高。存在的问题是服务可以存储之前查询过的信息来进行未来的分析。</p><p>为解决上述问题可以采用秘密分享结合MPC的方法来计算任何函数[BGW88]，下图展示了在本文框架下MPC如何与区块链结合。考虑电子选举和投票的一个例子。投票结束后提交了后端的代码来聚合结果。网络随机选取节点的子集和一个解释程序来将代码转化为MPC协议，结果将被存储在公开账本上无法被篡改但是任何人可以看到选举结果。</p><p>左上角的方案是不安全的方案；本文提出的方案实际是一部分随机节点先计算正确的结果再把结果采用秘密分享广播出去，存储在链上（感觉没有任何意义）</p><p><img src="/2022/11/15/Decentralizing-Privacy-Using-Blockchain-to-ProtectPersonal-Data/image-20221117103847654.png" alt="image-20221117103847654"></p><p>比特币假设所有节点都是平等不可信的，节点在合作决策过程中的能力取决于算力，节点$n$的权重$trust_n \propto resources(n)$，导致了女巫攻击（PoW是抵抗女巫攻击的吧）、过度的能源消耗和高时延。PoW的思想是投入了大部分资源的节点不太可能作弊，采用类似的思想可以设计出方案来使得好的行为得到奖励。将每个节点好的和坏的行为统计起来采用sigmoid function转换为一个概率：</p><script type="math/tex; mode=display">trust_n^{(i)}=\frac{1}{1+e^{-\alpha(good-bad)}}</script><p>其中$\alpha$是步长。采用这样的思想可以给可信的节点更多权重并且更高效地计算区块。因为在该系统中获取权限花费很多时间，该设计应当抵抗女巫攻击。当然还存在其他攻击，比如节点增加信誉只为了日后作恶。可以采用随机选择一些绝点来对每个区块投票，采用相同权重多数赢得方式投票。可以防止某些节点权重过高。</p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>个人信息和敏感信息不应该被第三方来掌握，用户可以拥有自己的数据而不损害安全或者限制自己在企业获得个性化服务的能力。</p><p>法律法规应该在区块链中编程并被自然执行，账本可以作为法律证据。</p><h1 id="Thoughts"><a href="#Thoughts" class="headerlink" title="Thoughts"></a>Thoughts</h1><ul><li>链上存储公钥和加密后的指针<ul><li>公钥用于进行签名认证</li><li>指针用于读取加密后的数据</li></ul></li><li>链下采用分布式数据结构DHT存储加密数据</li><li>面向移动端，提供了应用权限管理和撤销的机制</li><li>对于未来的看法比较有启发性<ul><li>目前的系统服务读了原始数据之后可以自行保存用于后续分析<ul><li>采用MPC，服务只能得到函数结果，无法得到原始数据</li></ul></li><li>提出了采用信用管理来替代PoW</li></ul></li></ul><p>To be done</p><ul><li>后续的论文跟进</li><li>找一下具体实现</li><li>伪代码的一些问题<ul><li>$L[\mathcal{H}(pk^{u,s}_{sig})]=L[\mathcal{H}(pk^{s,u}_{sig})]$</li><li>标蓝的部分</li></ul></li><li>PoW和sybil</li><li>文献的实验类型和工程实践</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文的实质贡献是提出了在仅区块链存储加密数据的指针，结合数字签名提供认证性，使用去中心化的数据存储结构存储加密数据提供保密性&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://ieeexplore.ieee.org/abstract/document/7163223&quot;&gt;文献&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Users should own and control their data without compromising security or limiting companies’ and authorities’ ability to provide personalized services.&lt;/p&gt;</summary>
    
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>An Overview of Blockchain Technology：Architecture, Consensus, and Future Trends</title>
    <link href="https://alleysira.github.io/2022/11/15/An-Overview-of-Blockchain-Technology/"/>
    <id>https://alleysira.github.io/2022/11/15/An-Overview-of-Blockchain-Technology/</id>
    <published>2022-11-15T02:57:39.000Z</published>
    <updated>2022-12-04T09:53:58.884Z</updated>
    
    <content type="html"><![CDATA[<p>不学区块链的都该枪毙</p><span id="more"></span><h1 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h1><ul><li>非对称密码学</li><li>分布式共识算法</li></ul><p>存在的挑战</p><ul><li>scalability：每个块1MB，每10分钟出块，每秒7个交易<ul><li>无法处理高频交易</li><li>区块越大，存储空间越大，产生速度越慢，更少的用户愿意维护大型的链</li><li>tradeoff between block size and security</li></ul></li><li>selfish mining带来的区块分支较多<ul><li>前提矿工具备算力优势，挖出节点后不立刻公布，继续在私有链挖矿，当其他人公布1个新的节点时，立即公布2个节点</li></ul></li><li>privacy leakage</li><li>pow or pos 存在的问题：浪费电力/富者愈富</li></ul><h1 id="BLOCKCHAIN-ARCHITECTURE"><a href="#BLOCKCHAIN-ARCHITECTURE" class="headerlink" title="BLOCKCHAIN ARCHITECTURE"></a>BLOCKCHAIN ARCHITECTURE</h1><h2 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h2><p>每一个区块包含两部分：</p><ul><li>区块头<ul><li>block version：主要用于确定遵循的区块验证规则</li><li>Merkle树根节点的哈希</li><li>Timestamp：时间戳</li><li>nBits：有效的区块哈希的长度</li><li>Nonce：4字节，从0开始随每次哈希计算增加</li><li>父区块的哈希：256bit，指向前一个区块</li></ul></li><li>区块主体<ul><li>交易：可以容纳的交易的最大数量取决于区块的大小和每个交易的大小</li><li>交易计数器</li></ul></li></ul><p><img src="/2022/11/15/An-Overview-of-Blockchain-Technology/image-20221111095427304.png" alt="image-20221111095427304"></p><h2 id="Digital-signature"><a href="#Digital-signature" class="headerlink" title="Digital signature"></a>Digital signature</h2><p>每个用户都有一对公私钥，私钥用于签名并向整个网络公布</p><p>经典方案是ECDSA</p><h2 id="key-Characteristics-of-Blockchain"><a href="#key-Characteristics-of-Blockchain" class="headerlink" title="key Characteristics of Blockchain"></a>key Characteristics of Blockchain</h2><ul><li>去中心化：传统的中心化交易系统每笔交易都需要可信机构来验证，不可避免地带来了额外开销和中央服务器的性能瓶颈的问题；区块链中的共识算法取代了第三方来提供数据一致性</li><li>持久性：交易可以快速验证，无效的交易不会被诚实的节点接受，当交易添加到区块链之后几乎不可能删除或者回滚交易；包含无效交易的区块会被立即发现</li><li><p>匿名性：用户使用生成的地址与区块链交互，不会泄露用户真实身份；区块链无法保证完美的隐私保护</p></li><li><p>可审计性：比特币区块链使用Unspent Transaction Output（UTX-O）存储用户的余额，任何交易需要涉及到之前未使用的交易，一旦当前的交易被记录在区块链中，涉及到的未使用的交易的状态就从未使用转换为已使用，因此交易可以容易地验证和跟踪</p></li></ul><h2 id="Taxonomy-of-blockchain-systems"><a href="#Taxonomy-of-blockchain-systems" class="headerlink" title="Taxonomy of blockchain systems"></a>Taxonomy of blockchain systems</h2><p>粗略地分为：</p><ul><li>公开链：所有数据公开，每个人都可以参与共识过程</li><li>私有链：中心化，仅仅那些来自特定组织的节点将会被允许加入共识过程</li><li>联盟链：半中心化，只有一部分预先选择的节点参与共识过程</li></ul><p><img src="/2022/11/15/An-Overview-of-Blockchain-Technology/image-20221111105103019.png" alt="image-20221111105103019"></p><ul><li>共识决定：在联盟链中只有一部分节点对验证区块负责，私有链全部由一个组织决定</li><li>读权限：联盟链和私有链具体分析</li><li>不变性：记录保存在节点处，因此在联盟链和私有链上可以轻易篡改</li><li>效率：由于公链节点数量多因此导致了交易量受限、延迟较高</li><li>中心化：是最大的不同，只有公开链是去中心化的</li><li>共识过程：公链所有用户均可加入；私有链和联盟链需要权限</li></ul><p>公开链对全世界开放，能够吸引众多用户，活跃；联盟链可以应用在商业场景</p><h1 id="CONSENSUS-ALGORITHMS"><a href="#CONSENSUS-ALGORITHMS" class="headerlink" title="CONSENSUS ALGORITHMS"></a>CONSENSUS ALGORITHMS</h1><p>在互不信任和节点中达成共识是Byzantine Generals（BG）问题的同义转换</p><h2 id="Proof-of-Work"><a href="#Proof-of-Work" class="headerlink" title="Proof of Work"></a>Proof of Work</h2><p>比特币网络使用的共识策略，在去中心化的网络中需要选择一个节点来记录交易；随机选取是一种自然的方法，但是容易受到攻击，因此需要在发布交易之前证明节点不准备作恶</p><p>每个节点计算一个区块头的的hash值，必须满足小于某个值（前面有多少个0），header包含一个nonce</p><p>当一个节点计算出了hash值，将广播这个区块，其他所有节点需要验证这个节点的正确性；被验证后其他矿工会把该节点加入到自己的区块链中</p><p>矿工是指计算hash值的节点，PoW的过程叫做挖矿</p><p>在去中心化的网络中，当许多节点几乎同时发现了合适的nonce时，有效的区块可能被同时产生，导致了可能存在许多分支，协议的设计使得两个相互竞争的分支不会同时产生下一个区块。在POW中，较长的链被认为是可信的链(authentic chain)</p><p>在PoW中矿工需要做许多计算机计算，然而这些运算浪费了很多资源。为了减少损失，一些PoW协议中的运算可以有额外的应用。比如Primecoin中的PoW可以被用作数学研究</p><h2 id="Proof-of-Stake"><a href="#Proof-of-Stake" class="headerlink" title="Proof of Stake"></a>Proof of Stake</h2><p>PoS是PoW的节约能源的替代，矿工需要证明拥有一定数量的货币。<strong>我们相信拥有更多货币的人不太可能攻击网络。</strong>这样的选择是不公平的，最富有的人会统治网络。结果是许多方案都结合了权益大小来决定谁来产生下一个块。与PoW相比，PoS节约了能源并且更加高效。但是由于挖矿成本几乎为0，后果是可能存在攻击。许多Pow的链正在逐渐向PoS转变，ethereum已经于2022年全面弃用了PoW。</p><h2 id="PBFT"><a href="#PBFT" class="headerlink" title="PBFT"></a>PBFT</h2><p>可实现拜占庭容错(Practical byzantine fault tolerance)是一种拜占庭容错算法的复现。Hyperledger Fabric使用了PBFT作为共识算法，因为PBFT可以处理多达1/3的恶意节点。</p><p>每轮产生一个新区块，将按照一定规则选出每轮的候选人，候选人对交易排序负责，整个过程可以分为预准备、准备和执行三个阶段。在每个阶段如果节点获得了超过2/3的节点的投票，因此PBFT要求每个节点对网络都是已知的。</p><p>与PBFT类似，Stellar Consensus Protocol（SCP）同样是拜占庭共识协议。在PBFT中1每个节点需要询问其他节点，然而SCP给了参与者权利来选择相信哪些参与者的子集。dBFT（delegated）中一些专业的节点被投票选出来记录交易。</p><h2 id="DPOS"><a href="#DPOS" class="headerlink" title="DPOS"></a>DPOS</h2><p>代理权益证明（Delegated proof of stake）和Pos的区别在于代表民主和直接民主。权益持有者选举他们的代表来产生有效的区块。由于参与确认的区块显著减少，认证的过程更加快速，带来了交易的快速交易。同时，代表也可以调整网络的参数，例如区块大小和区块时间间隔。此外，用户不需要担心不诚实的代表因为他们可以被轻易地投票淘汰</p><h2 id="Ripple"><a href="#Ripple" class="headerlink" title="Ripple"></a>Ripple</h2><p>Ripple共识算法利用了在大规模网络中相互信任的子网。在网络中节点被分为两类：服务端和客户端。服务端参与共识过程，客户端只传递资金，每个服务端都有一个唯一节点列表Unique Node List (UNL)，当觉得是否将交易放进账本时，服务端将询问UNL中节点如果接受到一致的节点超过了80%，交易将被打包进入账本。对于一个节点，只要在UNL中的恶意节点少于20%，账本将会保证正确</p><h2 id="Tendermint"><a href="#Tendermint" class="headerlink" title="Tendermint"></a>Tendermint</h2><p>拜占庭共识协议，每轮产生一个新的区块，申请人将被选出来广播一个未经确认的区块。可以分为3个步骤：</p><ul><li>预投票步：验证者选择是否为提议的区块广播预投票</li><li>预执行步：如果节点收到了提议的区块的超过2/3预投票，为该区块广播预执行；如果节点收到超过超过2/3的预执行，进入执行阶段</li><li>执行步：节点验证区块并广播对区块的执行，如果节点收到了2/3的执行，就接受该区块。和PBFT相比，节点需要锁定他们的币来成为验证者；如果一个验证者被发现是不诚实，将会被惩罚</li></ul><h2 id="Consensus-algorithms-comparison"><a href="#Consensus-algorithms-comparison" class="headerlink" title="Consensus algorithms comparison"></a>Consensus algorithms comparison</h2><p><img src="/2022/11/15/An-Overview-of-Blockchain-Technology/image-20221114104559314.png" alt="image-20221114104559314"></p><ul><li>PBFT需要在每轮选择候选人；Tendermint需要提前了解验证者来选举每轮的申请人。两者更适用于商业场景而不是公开场景</li><li><p>Pos同样需要做hash，对区块头做哈希来搜索目标值，但是工作量受限；</p></li><li><p>consensus speed</p></li><li>blocks generation rate &amp; security</li></ul><h1 id="CHALLENGES-amp-RECENT-ADVANCES"><a href="#CHALLENGES-amp-RECENT-ADVANCES" class="headerlink" title="CHALLENGES &amp; RECENT ADVANCES"></a>CHALLENGES &amp; RECENT ADVANCES</h1><h2 id="Scalability"><a href="#Scalability" class="headerlink" title="Scalability"></a>Scalability</h2><p>随着交易量增加，区块链变得臃肿。每个节点都需要存储许多交易来确保当前交易确实是未花费的。除此之外，由于对区块大小和出块时间的限制，比特币只能处理大概每秒7个交易，无法满足现实需求。由于区块的容量有限，许多小数值的交易可能会延迟因为矿工更倾向于有高额手续费的交易。解决此类问题的主要由两种方法：</p><h3 id="Storage-optimization-of-blockchain"><a href="#Storage-optimization-of-blockchain" class="headerlink" title="Storage optimization of blockchain"></a>Storage optimization of blockchain</h3><p>节点运行账本的完整拷贝变得困难，Bruce提出了网络将旧的交易记录忘记的方案。采用一个叫做account tree的数据库来保存所有非空地址的余额。除此之外轻量的客户端也能够解决这个问题。VerSum允许轻量级客户端外包对于大的输入上昂贵的计算，通过对比多个服务器上的结果来保证结果的正确性</p><h3 id="redesigning-blockchain"><a href="#redesigning-blockchain" class="headerlink" title="redesigning blockchain"></a>redesigning blockchain</h3><p>Bitcoin-NG将传统的区块分离成两部分：key block负责进行领导选举；micro block负责存储交易。协议将时间分为时期，在每个时期，矿工需要哈希生成key block。一旦生成了key block，节点称为leader负责生成micro blocks。Bitcoin-NG同时扩展了最长链的策略，其中micro blocks没有权重。这种设计解决了区块大小和网络的安全的平衡。</p><h2 id="Privacy-leakage"><a href="#Privacy-leakage" class="headerlink" title="Privacy leakage"></a>Privacy leakage</h2><p>区块链无法保证交易的隐私（transactional privacy）因为交易的数值和公钥绑定关系是公开可见的，用户的交易可能泄露用户的个人信息；可能存在和IP之间的映射关系；每个用户都可以被该用户连接的节点来定义。提高区块链匿名性的方法可以分为两类：</p><ul><li>混淆：在区块链中，用户的地址是匿名的，但是当许多用户和同一个地址频繁交易时，仍然可能将地址与真实的身份连接起来。混淆是一种在多个输入地址和多个输出地址之间转移资金提供匿名性的操作<ul><li>存在的问题：<ul><li>输入输出之间的交易必须是等额面值；</li><li>混淆者可能不诚实：混淆者清楚具体的映射关系，可以进行追踪；可能携款而逃，将交易转移到自己的地址上去</li></ul></li></ul></li></ul><p><img src="/2022/11/15/An-Overview-of-Blockchain-Technology/image-20221115093818396.png" alt="image-20221115093818396"></p><ul><li>匿名性：使用零知识证明，矿工只需要验证币属于有效的币的列表即可。<ul><li>Zerocoin Zerocash zero-knowledge Succinct Non-interactive Arguments of Knowledge (zk-SNARKs) 提供这方面的解决思路</li><li>陕西师范大学老师的录屏也可以参考</li></ul></li></ul><h2 id="Selfish-mining"><a href="#Selfish-mining" class="headerlink" title="Selfish mining"></a>Selfish mining</h2><p>区块链容易受到合谋的自私矿工的攻击。在自私挖矿策略中，自私的矿工将已挖出的区块保存起来而不广播，知道满足某些条件时再公布私链，由于私链比其他现有的公开链长，它会被所有矿工承认。在私链公开发布致歉，诚实的矿工都在浪费资源在无用的分支上，然而自私的矿工在自己的私链上挖矿没有竞争者，因此更容易获得更多利润。</p><p>顽固挖矿（stubborn mining）中矿工可以通过不平凡地将挖矿攻击和网络层的日蚀攻击结合起来增加收益。trail-stubbornness是一种顽固挖矿的策略，尽管私链长度已经落后的情况下还继续挖矿。</p><p>如何应对自私挖矿：诚实的矿工选择跟随分支时倾向于选择有更多新鲜的区块的分支（时间戳和beacon，但是可能伪造该时间戳）；ZeroBlock提出每个区块必须在一定时间内被网络接受，此时自私的矿工获益不会超过期望值。</p><h1 id="POSSIBLE-FUTURE-DIRECTIONS"><a href="#POSSIBLE-FUTURE-DIRECTIONS" class="headerlink" title="POSSIBLE FUTURE DIRECTIONS"></a>POSSIBLE FUTURE DIRECTIONS</h1><h2 id="Blockchain-testing"><a href="#Blockchain-testing" class="headerlink" title="Blockchain testing"></a>Blockchain testing</h2><p>截止目前有约700种加密货币，一些开发者可能伪造区块链的性能表现来吸引投资者获益，当用户需要将区块链和业务结合起来时，需要连接哪个区块链符合用户的需求，因此需要区块链测试机制来解决问题</p><p>区块链测试可以被分为两个阶段：标准化阶段和测试阶段。在标准化阶段需要协商设立所有标准，当区块链产生之后，将会被协商好的标准进行测试和验证是否像开发者宣称的那样正常运行。在测试阶段，区块链将会在不同的标准下执行，如吞吐量等。</p><h2 id="Stop-the-tendency-to-centralization"><a href="#Stop-the-tendency-to-centralization" class="headerlink" title="Stop the tendency to centralization"></a>Stop the tendency to centralization</h2><p>区块链被设计为去中心化系统，然而存在矿工在矿池中心化的趋势。迄今为止，前5的矿池拥有Bitcoin超过51%的算力。自私挖矿的策略在算力超过总算力的25%即可获得比平均股权更多的收益，因此理智的矿工将被吸引进入自私的矿池并且最终矿池将轻易超过51%的算力。区块链并不是只为若干组织设计的，因此需要有方法来解决这样的问题。</p><h2 id="Big-data-analytics"><a href="#Big-data-analytics" class="headerlink" title="Big data analytics"></a>Big data analytics</h2><ul><li>data management：区块链可以用来存储重要的数据<ul><li>因为去中心化和安全的特性</li><li>可以保证数据是原始的</li></ul></li><li>data analytics<ul><li>交易可以用来分析用户的交易习惯</li><li>预测用户的交易行为</li></ul></li></ul><h2 id="Block-applications"><a href="#Block-applications" class="headerlink" title="Block applications"></a>Block applications</h2><p>目前多数区块链被应用在金融领域，越来越多在不同领域的应用正在复现。传统企业可以应用区块链来提高系统化，例如可以存储用户信誉。新兴行业可以使用区块链来提高性能。</p><p>智能合约是执行合同内容的计算机化的交易协议，目前已经被区块链实现。在区块链中智能合约是代码碎片可以被矿工自动化执行。智能合约在许多领域都有变革性的潜力。</p><h1 id="CONCLUSION"><a href="#CONCLUSION" class="headerlink" title="CONCLUSION"></a>CONCLUSION</h1><p>本文首先给出区块链技术的概述，包括区块链的体系架构和区块链的关键特征。然后讨论了区块链中使用的典型的共识算法，在不同方面分析和比较了这些协议。此外，列出了一些阻碍区块链开发的挑战和问题，并汇总了一些现有的方法来解决这些问题，也提出了一些可能的未来方向。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;不学区块链的都该枪毙&lt;/p&gt;</summary>
    
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>A Pragmatic Introduction to Secure Multi-Party Computation</title>
    <link href="https://alleysira.github.io/2022/11/09/A-Pragmatic-Introduction-to-Secure-Multi-Party-Computation/"/>
    <id>https://alleysira.github.io/2022/11/09/A-Pragmatic-Introduction-to-Secure-Multi-Party-Computation/</id>
    <published>2022-11-09T03:19:41.000Z</published>
    <updated>2022-11-15T03:04:04.170Z</updated>
    
    <content type="html"><![CDATA[<p>老老实实打基础 <a href="https://securecomputation.org/main/">https://securecomputation.org/main/</a></p><span id="more"></span><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>1980年代提出的安全多方计算理论如今成为了构建密码系统的实用工具</p><p>安全多方计算允许一个群组成员联合进行一次计算，同时任何参与者都不会泄露自己隐私的输入</p><p>用户协商一个需要计算的函数，用户的隐私信息作为输入，函数的结果作为输出</p><p>secure computation：范围更大的概念，包括了所有在数据上执行运算同时保护数据隐私的方法</p><p>verifiable computation：允许参与者确认函数的输出是否是给定输入下的函数输出</p><p>主要有两种满足了安全和可验证的计算：outsourced computation 和 multi-party computation</p><h2 id="Outsourced-Computation"><a href="#Outsourced-Computation" class="headerlink" title="Outsourced Computation"></a>Outsourced Computation</h2><p>一方拥有数据，想要得到对数据进行运算的结果</p><p>另一方接受并存储加密的数据，在加密后的数据上执行运算，将结果返回给数据拥有者，无法得知输入、中间值和最终的结果</p><p>数据拥有者解密后得到正确的输出</p><p>同态加密天然具备在加密数据上进行运算的能力</p><p>部分同态方案：Paillier，Naccache and Stern</p><p>全同态加密能够执行加法和乘法，有常量0/1，可以计算任何有限函数</p><p>Rivest提出了概念，Gentry提出第一个全同态方案，基于格；目前效率仍然不够高</p><p>FHE和MPC在概念上有区别，不能直接比较；但是从功能和实现的角度联系紧密</p><p>目前的MPC比FHE快几千倍</p><h2 id="Multi-Party-Computation"><a href="#Multi-Party-Computation" class="headerlink" title="Multi-Party Computation"></a>Multi-Party Computation</h2><p>MPC的目标是使得一组独立的互不信任的数据拥有者能够共同计算一个依赖各自隐私输入的函数</p><p>MPC和外包计算的区别是所有的协议参与者执行着一个协议</p><p>Andrew Yao在1980s提出了安全多方计算的概念，$m$个参与者拥有隐私数据$x$共同计算$f(x_1,x_2,\cdots,x_m)$</p><p>直到2000年算法的进步才使得安全多方计算实际可用</p><p>Yao的混淆电路协议属于通用协议，可以计算任何离散函数</p><p>专用协议（比如PSI）可能比通用协议更高效</p><h2 id="MPC-Applications"><a href="#MPC-Applications" class="headerlink" title="MPC Applications"></a>MPC Applications</h2><p>主要实现了隐私保护</p><ul><li><p>Yao’s Millionaires Problem</p><ul><li>两个富人想要比较谁更富有但是不想泄露关于财富的信息，相当于完成$boolean \ x_1 \leq x_2$</li></ul></li><li><p>Secure auctions</p><ul><li><p>需要保护出价人和出售人的隐私，以及对已投标的不可延展性</p></li><li><p>Bid privacy：出价人不能得知其他参与者的出价</p></li><li><p>Bid non-malleability：参与者的出价值不能被用来产生一个相关的出价（前者无法推出后者</p></li></ul></li><li><p>Voting</p><ul><li>安全的电子投票即是执行加法，同样需要满足隐私性和不可延展性</li><li>额外的需要标准MPC不具备的性质：coercion resistance，投票人能向第三方证明自己如何投票</li></ul></li><li><p>Secure machine learning</p><ul><li><p>Oblivious model inference允许client向已经有预训练好模型的服务器发送请求，请求和模型均为隐私输入，输出是模型对请求的预测</p></li><li><p>在训练阶段MPC可以使得参与者保护自己的数据</p></li></ul></li></ul><h3 id="Deployments"><a href="#Deployments" class="headerlink" title="Deployments"></a>Deployments</h3><p>实现仍然处于早期阶段，具有若干问题，包括：</p><ul><li>系统是否会执行协议</li><li>从输出推理敏感信息</li><li>没有密码学背景的人如何理解隐患</li></ul><p>当前MPC是为了实现数据共享才得以部署的，而不是为了增加一层隐私保护（可能是未来的方向</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;老老实实打基础 &lt;a href=&quot;https://securecomputation.org/main/&quot;&gt;https://securecomputation.org/main/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="MPC" scheme="https://alleysira.github.io/categories/MPC/"/>
    
    
    <category term="Crypto" scheme="https://alleysira.github.io/tags/Crypto/"/>
    
    <category term="MPC" scheme="https://alleysira.github.io/tags/MPC/"/>
    
  </entry>
  
  <entry>
    <title>Secret_sharing</title>
    <link href="https://alleysira.github.io/2022/10/22/Secret-sharing/"/>
    <id>https://alleysira.github.io/2022/10/22/Secret-sharing/</id>
    <published>2022-10-22T01:43:23.000Z</published>
    <updated>2023-03-06T09:22:56.995Z</updated>
    
    <content type="html"><![CDATA[<h1 id="秘密分享经典方案"><a href="#秘密分享经典方案" class="headerlink" title="秘密分享经典方案"></a>秘密分享经典方案</h1><h2 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h2><p>秘密分享的概念最早由Shamir和Blakley提出，秘密分享主要由两个算法构成：</p><ul><li>分配算法：分发者将秘密$s$分割成若干个份额，在一组参与者$P=\{P_1,P_2,\cdots,P_n\}$中进行分配，是得每一个参与者都得到关于该秘密的一个份额</li><li>恢复算法：保证只有$P$的一部分特定的子集才能有效地恢复秘密，甚至可能得不到关于$s$的任何有用信息</li></ul><span id="more"></span><h2 id="门限秘密分享"><a href="#门限秘密分享" class="headerlink" title="门限秘密分享"></a>门限秘密分享</h2><p>如果秘密分发为n份且分配给一个参与者后满足：</p><ul><li>$n$个参与者中任何$k$个或者多于$k$个合作可以恢复秘密</li><li>任何少于$k$个参与者都无法获得该秘密</li></ul><p>称以上方案为$(k,n)$秘密分享门限方案，其中$k$称为方案的门限值</p><p>如果满足任何少于$k$个参与者的子秘密都无法获得该秘密的任何信息，则称该方案是完善的(perfect)</p><h3 id="朴素构造秘密分享方案"><a href="#朴素构造秘密分享方案" class="headerlink" title="朴素构造秘密分享方案"></a>朴素构造秘密分享方案</h3><h4 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h4><p>考虑一个$n$次多项式$f(x)=a_nx^n+a_{n-1}x^{n-1}+\cdots+a_0$，若有$t$对$(x_i,f(x_i))满足x_i\neq x_j,i\neq j$</p><script type="math/tex; mode=display">\left(\begin{matrix}x_{0}^{n} & x_0^{n-1} & \cdots& x_0 & 1\\x_{1}^{n} & x_1^{n-1} & \cdots& x_1 & 1\\\vdots  & \vdots  & \vdots  &\vdots & \vdots\\x_{t}^{n} & x_t^{n-1} & \cdots& x_t & 1\\\end{matrix}\right)\left(\begin{matrix}a_{n}\\a_{n-1}\\\vdots\\a_0\\\end{matrix}\right)=\left(\begin{matrix}f(x_{0})\\f(x_{1})\\\vdots\\f({x_t})\\\end{matrix}\right)</script><p>若设此时的秘密值为常系数$a_n,a_{n-1},\cdots,a_0$，则解线性方程组即可恢复秘密</p><p>考虑解非齐次线性方程组，由于此时等式左侧为范德蒙矩阵，</p><p>对于$n$阶的范德蒙行列式，有</p><script type="math/tex; mode=display">D_n=\prod\limits_{1\leq j<i\leq n}(x_i-x_j)</script><p>行列式的值不为0，系数矩阵满秩，增广矩阵满秩</p><p>由于有$n+1$个未知数，需要满足$t\geq n$</p><h4 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h4><ul><li><p>秘密分享阶段：随机选择一个$Z_q$上的$n$次多项式$f(x)=a_nx^n+a_{n-1}x^{n-1}+\cdots+a_0$，并随机选取$t$个点对$(x_i,f(x_i))满足x_i\neq x_j,i\neq j,t\geq n$，将点对分发给$t$个用户，此时的门限值为$n$</p></li><li><p>秘密恢复阶段：任意$n$个用户或多于$n$个用户合作可以求解线性方程组恢复出常系数</p></li></ul><h3 id="Shamir门限秘密分享"><a href="#Shamir门限秘密分享" class="headerlink" title="Shamir门限秘密分享"></a>Shamir门限秘密分享</h3><h4 id="Lagrange插值公式"><a href="#Lagrange插值公式" class="headerlink" title="Lagrange插值公式"></a>Lagrange插值公式</h4><script type="math/tex; mode=display">f(x)=\sum\limits_{j=1}^{k}[f(i_j)\prod\limits_{l=1,l\neq j}^k \frac{x-i_l}{i_j-i_l}]\bmod q</script><p>满足$f(x_i)=y_i,i=1,2,\cdots,k,x_i\neq x_j$的$k-1$次多项式$f(x)=a_{k-1}x^{k-1}+a_{k-2}x^{k-2}+\cdots+a_0$是存在且唯一的</p><p>和平凡的秘密分享不同的是直接$a_0$作为秘密，只需要计算$f(0)$</p><p>利用插值公式，可以直接计算</p><script type="math/tex; mode=display">f(0)=(-1)^{k-1}\sum\limits_{j=1}^{k}[f(i_j)\prod\limits_{l=1,l\neq j}^k \frac{i_l}{i_j-i_l}]\bmod q</script><h3 id="基于中国剩余定理的门限方案"><a href="#基于中国剩余定理的门限方案" class="headerlink" title="基于中国剩余定理的门限方案"></a>基于中国剩余定理的门限方案</h3><h4 id="CRT"><a href="#CRT" class="headerlink" title="CRT"></a>CRT</h4><p>中国剩余定理可用于求解多个线性同余方程组</p><p>设$m_1,m_2,\cdots,m_k$是<em>k</em>个两两互素的自然数，令$m=m_1m_2\cdots m_k,\ m=m_iM_i,\ M_iM_i^{‘}\equiv1 \bmod m_i$</p><p>则方程组</p><script type="math/tex; mode=display">\left \{\begin{align*}& x \equiv b_1 \bmod m_1 \\& x \equiv b_2 \bmod m_2 \\& \vdots \\& x \equiv b_k \bmod m_k \end{align*}\right.</script><p>解为</p><script type="math/tex; mode=display">x\equiv M_1M_1^{'}b_1+M_2M_2^{'}b_2+\cdots+M_kM_k^{'}b_k \bmod m</script><h4 id="选择参数"><a href="#选择参数" class="headerlink" title="选择参数"></a>选择参数</h4><p>取$m_1&lt;m_2&lt;\cdots&lt;m_n$满足</p><ul><li><p>$gcd(m_i,m_j)=1$</p></li><li><p>$m_1m_2\cdots m_k&gt;m_{n-k+2}\cdots m_{n-1}m_n$最小的k个数的乘积也大于最大的$k-1$个数，保证了任意的$k$个数的乘积也大于$k-1$个数的乘积</p></li></ul><h4 id="秘密分割"><a href="#秘密分割" class="headerlink" title="秘密分割"></a>秘密分割</h4><p>保证$m_{n-k+2}\cdots m_{n-1}m_n&lt;s&lt;m_1m_2\cdots m_k$</p><p>满足在$k-1$个数乘积和$k$个数乘积下做模运算数值不等</p><p>$s_i\equiv s \bmod m_i$</p><p>子秘密包括$\{(s_i,m_i,m)\}$</p><h4 id="秘密恢复"><a href="#秘密恢复" class="headerlink" title="秘密恢复"></a>秘密恢复</h4><p>任意$k$个参与者求解中国剩余定理即可</p><h2 id="可验证的秘密分享"><a href="#可验证的秘密分享" class="headerlink" title="可验证的秘密分享"></a>可验证的秘密分享</h2><p>允许参与者验证收到份额的正确性</p><ul><li>防止dealer作恶</li><li>防止在秘密恢复阶段上传错误份额</li></ul><h2 id="Feldman’s-VSS"><a href="#Feldman’s-VSS" class="headerlink" title="Feldman’s VSS"></a>Feldman’s VSS</h2><p>引入承诺使得参与者能够验证多项式的取值</p><script type="math/tex; mode=display">v_0 v_1^i v_2^{i^2} \ldots v_t^{i^t}=g^{\sigma+a_1 i+a_2 i^2+\ldots a_t i^t} \equiv g^{f(i)}\bmod p</script><p>Hence $v_0 v_1^i v_2^{i^2} \ldots v_t^{i^t} \equiv g^{s_i}(\bmod p)$ if and only if $s_i \equiv f(i)\bmod q$</p><h2 id="The-Joint-Feldman-DKG-protocol"><a href="#The-Joint-Feldman-DKG-protocol" class="headerlink" title="The Joint-Feldman DKG protocol"></a>The Joint-Feldman DKG protocol</h2><p>每个参与者在一轮中作为Dealer，其他轮作为接收者</p><p>n个参与者，每个参与者随机选择$f_i(x)=\sum_{j=0}^t a_{i,j}x^j \bmod q,f_i(0)=a_{i,0}=secret$</p><p>$pk=g^{\sum^t_1 a_{i,0}},sk=\sum^t_1 a_{i,0}$</p><p>每个参与者的私钥份额为$sk_j=\sum f_i(j)$</p><p>公开验证参数 $A_k=g^{\sum a_{i,k}}$</p><h3 id="恢复秘密"><a href="#恢复秘密" class="headerlink" title="恢复秘密"></a>恢复秘密</h3><p>定义$h(x)=\sum f_i(x),sk_j=h(j)$，$h(x)$极大概率是t阶多项式，因此需要t+1个份额即可恢复h(x)</p><p>验证份额正确性</p><script type="math/tex; mode=display">\begin{aligned}A_1^{j^1} \cdots A_t^{j^t} & \equiv\left(g^{a_{11}} \cdots g^{a_{r 1}}\right)^j \cdots\left(g^{a_{1 t}} \cdots g^{a_{r t}}\right)^{j^t} \\& \equiv g^{\sum_{k=0}^t \sum_{\ell=1}^r a_{\ell k} j^k} \\& \equiv g^{\sum_{\ell=1}^r \sum_{k=0}^t a_{\ell k} j^k} \\& \equiv g^{\sum_{\ell=1}^r\left(a_{0 k}+a_{1 k} j+\ldots+a_{t k} j^t\right)} \\& \equiv g^{\sum_{\ell=1}^r f_{\ell}(j)} \equiv g^{s k_j}(\bmod p) .\end{aligned}</script><p><a href="https://link.springer.com/article/10.1007/s00145-006-0347-3">Gennaro et al. (2006)</a> 指出了这种构造不安全，敌手可以多次利用投诉机制来控制公钥的最后一个比特，因此JF DKG不能用做安全的DKG方案</p><h2 id="Gennaro-et-al-’s-DKG-protocol"><a href="#Gennaro-et-al-’s-DKG-protocol" class="headerlink" title="Gennaro et al.’s DKG protocol"></a>Gennaro et al.’s DKG protocol</h2><p>信息论安全</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;秘密分享经典方案&quot;&gt;&lt;a href=&quot;#秘密分享经典方案&quot; class=&quot;headerlink&quot; title=&quot;秘密分享经典方案&quot;&gt;&lt;/a&gt;秘密分享经典方案&lt;/h1&gt;&lt;h2 id=&quot;基本定义&quot;&gt;&lt;a href=&quot;#基本定义&quot; class=&quot;headerlink&quot; title=&quot;基本定义&quot;&gt;&lt;/a&gt;基本定义&lt;/h2&gt;&lt;p&gt;秘密分享的概念最早由Shamir和Blakley提出，秘密分享主要由两个算法构成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分配算法：分发者将秘密$s$分割成若干个份额，在一组参与者$P=\{P_1,P_2,\cdots,P_n\}$中进行分配，是得每一个参与者都得到关于该秘密的一个份额&lt;/li&gt;
&lt;li&gt;恢复算法：保证只有$P$的一部分特定的子集才能有效地恢复秘密，甚至可能得不到关于$s$的任何有用信息&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Crypto" scheme="https://alleysira.github.io/categories/Crypto/"/>
    
    
    <category term="Crypto" scheme="https://alleysira.github.io/tags/Crypto/"/>
    
  </entry>
  
  <entry>
    <title>Federated Machine Learning: Concept and Application</title>
    <link href="https://alleysira.github.io/2022/10/19/Federated-Machine-Learning-Concept-and-Application/"/>
    <id>https://alleysira.github.io/2022/10/19/Federated-Machine-Learning-Concept-and-Application/</id>
    <published>2022-10-19T03:07:13.000Z</published>
    <updated>2022-11-05T09:36:19.971Z</updated>
    
    <content type="html"><![CDATA[<p>学习杨强老师的综述论文 <a href="https://arxiv.org/abs/1902.04885">https://arxiv.org/abs/1902.04885</a></p><span id="more"></span><h1 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h1><p>许多领域的数据受限/质量较低</p><p>了解欧盟的GDPR</p><p>用户理应对数据和训练出的模型知情</p><p>呼吁将AI的工作重心从提高效率转向与隐私和法规的数据融合方法</p><h1 id="AN-OVERVIEW-OF-FEDERATED-LEARNING"><a href="#AN-OVERVIEW-OF-FEDERATED-LEARNING" class="headerlink" title="AN OVERVIEW OF FEDERATED LEARNING"></a>AN OVERVIEW OF FEDERATED LEARNING</h1><p>优化的方向</p><ul><li>非平衡数据集 </li><li>通信开销</li><li>设备的可靠性</li></ul><h2 id="Definition-of-Federated-Learning"><a href="#Definition-of-Federated-Learning" class="headerlink" title="Definition of Federated Learning"></a>Definition of Federated Learning</h2><p>定义$n$个数据拥有者$\{\mathcal{F}_1,\mathcal{F}_2,\cdots ,\mathcal{F}_n\}$，这些用户想要通过将各自的数据$\{\mathcal{D}_1,\mathcal{D}_2,\cdots ,\mathcal{D}_n\}$合并起来训练一个模型$\mathcal{M_{sum}}$，传统的方法是采用$\mathcal{D=D_1 \cup D_2 \cdots D_n}$进行训练；联邦学习要求各参与者协作共同训练</p><p>$\mathcal{M_{fed}}$，但是参与者$\mathcal{F_1}$不会将自己的数据$\mathcal{D_1}$暴露给其他参与者。</p><p>分别将训练的准确度记为$\mathcal{V_sum,V_fed}$，设$\delta$为非负实数，如果满足</p><script type="math/tex; mode=display">|\mathcal{V_sum,V_fed}|<\delta</script><p>则称该联邦学习算法满足$\delta$精度损失</p><h2 id="Privacy-of-Federated-Learning"><a href="#Privacy-of-Federated-Learning" class="headerlink" title="Privacy of Federated Learning"></a>Privacy of Federated Learning</h2><h3 id="MPC"><a href="#MPC" class="headerlink" title="MPC"></a>MPC</h3><ul><li><p>安全多方计算模型天然还有多个参与方，在良定义的模拟框架中提供安全证明，保证了完全的零知识</p></li><li><p>通常包括复杂的计算，效率不够高</p></li><li><p>在部分场景中，泄露部分知识是可以接受的，可能可以构造安全要求稍低的协议来提供更好的效率</p></li><li><p>给出了若干的具体论文与实现</p></li></ul><h3 id="Differential-Privacy"><a href="#Differential-Privacy" class="headerlink" title="Differential Privacy"></a>Differential Privacy</h3><ul><li><p>与k匿名类似，通过向数据中添加噪声，使得第三方无法区分来进行隐私保护</p></li><li><p>依然需要将数据发送到其他参与者</p></li><li>存在隐私和准确性之间的trade-off</li><li>Robin C. Geyer, Tassilo Klein, and Moin Nabi. 2017. Differentially Private Federated Learning: A Client Level Perspective.CoRR abs/1712.07557 (2017). arXiv:1712.07557 <a href="http://arxiv.org/abs/1712.07557">http://arxiv.org/abs/1712.07557</a></li></ul><h3 id="Homomorphic-Encryption"><a href="#Homomorphic-Encryption" class="headerlink" title="Homomorphic Encryption"></a>Homomorphic Encryption</h3><ul><li>与差分隐私不同的地方在于，数据和模型本身是不会发送的</li><li>原始数据泄露的可能性很小</li></ul><h3 id="Indirect-information-leakage"><a href="#Indirect-information-leakage" class="headerlink" title="Indirect information leakage"></a>Indirect information leakage</h3><p>早期的联邦学习算法泄露了中间参数，如随机参数下降的参数更新，可能泄露重要的信息</p><p>可能存在恶意的参与者上传有后门的数据（数据中毒）</p><p>利用区块链来进行联邦学习</p><h2 id="A-categorization-of-Federated-Learning"><a href="#A-categorization-of-Federated-Learning" class="headerlink" title="A categorization of Federated Learning"></a>A categorization of Federated Learning</h2><p>设矩阵中的每一行为一个样本，每一列为一个特征（某些数据集还可能有标签，视为一种特殊的特征）</p><p>利用样本的ID空间$I$，特征空间$X$，标签的空间$Y$可以表示一个数据集$(I,X,Y)$</p><h3 id="Horizontal-Federated-learning"><a href="#Horizontal-Federated-learning" class="headerlink" title="Horizontal Federated learning"></a>Horizontal Federated learning</h3><p>横向联邦学习，或者基于样本的联邦学习</p><p>$X_i=X_j,Y_i=Y_j,I_i\neq I_j,\forall D_i,D_j,i\neq j$</p><p>本质：表现在于两个数据集特征空间相同但是样本空间不同，即相当于用户数目不同</p><p>安全定义：一般假设参与者诚实，服务器honest-but-curious；也存在恶意的参与者对数据投毒</p><p>应用：不同公司的用户群体不同（交集很小），但是公司的业务类似（特征空间相同）</p><p>其他研究：</p><ul><li><p>CCS17应用了安全聚合方案来保护本地更新的隐私</p></li><li><p>TIFS18使用了同态加密进行模型参数的安全聚合</p></li><li><p>NIPS17 多任务联邦学习系统允许多个站点在分享只是保护安全的前提下执行不同的训练任务，能够解决通信开销、straggler和容错率</p></li></ul><p><img src="/2022/10/19/Federated-Machine-Learning-Concept-and-Application/image-20221105161403972.png" alt="image-20221105161403972" style="zoom:80%;"></p><h3 id="Vertical-Federated-Learning"><a href="#Vertical-Federated-Learning" class="headerlink" title="Vertical Federated Learning"></a>Vertical Federated Learning</h3><p>本质：两个数据集的样本id相同但是特征空间不同，即相当于同一批用户（交集大），不同的业务</p><p>$X_i\neq X_j,Y_i\neq Y_j,I_i=I_j,\forall D_i,D_j,i\neq j$</p><p>相当于一个聚合不同特征的过程，以隐私保护的方式计算训练损失和梯度，达到联合不同参与方的数据共同构建模型的目的。在这样一种联邦机制下，每个参与方的身份和状态是相同的，并且联邦系统帮助每一个参与方建立一个“共同富裕”的策略。</p><p>安全定义：假定参与者honest-but-curious，两个参与者的情况下参与者之间不会串通，最多一个可能被敌手控制，攻击者此时只能学习到已经被控制的参与者的数据；优势引入了半诚实的第三方semi-honest third party</p><p><img src="/2022/10/19/Federated-Machine-Learning-Concept-and-Application/image-20221105163229227.png" alt="image-20221105163229227" style="zoom: 80%;"></p><h3 id="Federated-Transfer-Learning"><a href="#Federated-Transfer-Learning" class="headerlink" title="Federated Transfer Learning"></a>Federated Transfer Learning</h3><p>本质：两个数据集的样本空间与特征空间均不相同，使用有限的共同样本来学习两个特征空间的表示，并使用该结果来使用单方面的特征进行预测</p><p>$X_i\neq X_j,Y_i\neq Y_j,I_i\neq I_j,\forall D_i,D_j,i\neq j$</p><p><img src="/2022/10/19/Federated-Machine-Learning-Concept-and-Application/image-20221105164703371.png" alt="image-20221105164703371" style="zoom:67%;"></p><p>安全定义：与纵向联邦学习类似</p><h2 id="Architecture-for-a-federated-learning-system"><a href="#Architecture-for-a-federated-learning-system" class="headerlink" title="Architecture for a federated learning system"></a>Architecture for a federated learning system</h2><h3 id="Horizontal-Federated-Learning"><a href="#Horizontal-Federated-Learning" class="headerlink" title="Horizontal Federated Learning"></a>Horizontal Federated Learning</h3><p>$k$个参与者的数据结构相同，在服务器的帮助下，共同学习机器学习模型</p><p>常用的假设是，参与方honest，而服务器honest-but-curious。</p><p><img src="/2022/10/19/Federated-Machine-Learning-Concept-and-Application/image-20221105164232236.png" alt="image-20221105164232236" style="zoom:67%;"></p><ul><li><p>Step 1：参与方本地计算训练梯度，使用加密、差分隐私或秘密分享技术来掩盖梯度，并发送掩盖后的梯度结果给服务器。</p></li><li><p>Step 2：服务器执行安全聚合，而不学习有关任何参与者的信息。</p></li><li><p>Step 3：服务器将聚合结果发送给各个参与方。</p></li><li><p>Step 4：参与方使用解密后的梯度更新他们各自的模型。</p></li></ul><p>循环上述步骤，直到损失函数收敛，训练过程完成，所有参与者共享最终的模型参数。</p><p>安全性：使用CCS17安全聚合方案或者同态加密的方案已被证明在服务器半诚实的模型下安全；当服务器为恶意时可能被攻击</p><h3 id="Vertical-Federated-Learning-1"><a href="#Vertical-Federated-Learning-1" class="headerlink" title="Vertical Federated Learning"></a>Vertical Federated Learning</h3><p>考虑当服务器为honest，参与方A、B均为honest-but-curious</p><p><img src="/2022/10/19/Federated-Machine-Learning-Concept-and-Application/image-20221105173139227.png" alt="image-20221105173139227" style="zoom:80%;"></p><p>参考：<a href="https://www.zhihu.com/search?type=content&amp;q=Federated%20Machine%20Learning%3A%20Concept%20and%20Application">https://www.zhihu.com/search?type=content&amp;q=Federated%20Machine%20Learning%3A%20Concept%20and%20Application</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习杨强老师的综述论文 &lt;a href=&quot;https://arxiv.org/abs/1902.04885&quot;&gt;https://arxiv.org/abs/1902.04885&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Federated Learning" scheme="https://alleysira.github.io/tags/Federated-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Security proof</title>
    <link href="https://alleysira.github.io/2022/10/17/Security-proof/"/>
    <id>https://alleysira.github.io/2022/10/17/Security-proof/</id>
    <published>2022-10-17T09:21:12.000Z</published>
    <updated>2022-10-22T09:05:09.470Z</updated>
    
    <content type="html"><![CDATA[<h1 id="密码学安全归约技术：壬寅年的见解"><a href="#密码学安全归约技术：壬寅年的见解" class="headerlink" title="密码学安全归约技术：壬寅年的见解"></a>密码学安全归约技术：壬寅年的见解</h1><p>学习郭福春老师面向西电的安全规约分享录屏： <a href="https://www.bilibili.com/video/BV1AY4y1n775?share_source=copy_web&amp;vd_source=4487439a1220fa77bb4a6f0079c98794">https://www.bilibili.com/video/BV1AY4y1n775?share_source=copy_web&amp;vd_source=4487439a1220fa77bb4a6f0079c98794</a></p><span id="more"></span><p>Outputs Force Inputs.</p><p><img src="/2022/10/17/Security-proof/image-20221019170832942.png" alt="image-20221019170832942"></p><h2 id="小白成长路线"><a href="#小白成长路线" class="headerlink" title="小白成长路线"></a>小白成长路线</h2><p>密码学对安全的定义</p><p>PPT的敌手只能以可忽略的概率解决问题</p><p>计算安全：随着时间投入增加，解决问题的概率增加（公钥密码常用的概念）</p><p>信息论安全：one-time pad（无法实际使用）</p><p>安全规约</p><ul><li>假设存在PPT敌手能够在安全模型下攻破方案</li><li>构造一个中间方案，面对已知的困难问题，敌手可以攻破该困难问题</li><li>困难问题确实是困难的，假设错误</li></ul><p>规约基础问题</p><p>simulated game和proposed game之间需要满足不可区分，两者的区别在于敌手同时得到了两个公钥，而不是有先后顺序</p><p><img src="/2022/10/17/Security-proof/image-20221019171830985.png" alt="image-20221019171830985"></p><p><img src="/2022/10/17/Security-proof/image-20221019172439903.png" alt="image-20221019172439903"></p><p>abort和不可区分：敌手是一个算法，没有记忆，可以重新初始化</p><h2 id="小专如何看看待研究问题和研究内容"><a href="#小专如何看看待研究问题和研究内容" class="headerlink" title="小专如何看看待研究问题和研究内容"></a>小专如何看看待研究问题和研究内容</h2><p><img src="/2022/10/17/Security-proof/image-20221019174231071.png" alt="image-20221019174231071" style="zoom:80%;"></p><p><img src="/2022/10/17/Security-proof/image-20221019174507793.png" alt="image-20221019174507793" style="zoom:80%;"></p><p><img src="/2022/10/17/Security-proof/image-20221019174756033.png" alt="image-20221019174756033"><img src="/2022/10/17/Security-proof/image-20221019174756092.png" alt="image-20221019174756092"></p><h2 id="安全规约相关的研究内容"><a href="#安全规约相关的研究内容" class="headerlink" title="安全规约相关的研究内容"></a>安全规约相关的研究内容</h2><p>安全规约究竟好不好</p><p>考虑以下4部分</p><ul><li>security model</li><li>proof model</li><li>reduction cost</li><li>strong/week assumption</li></ul><p><img src="/2022/10/17/Security-proof/image-20221019175153652.png" alt="image-20221019175153652"></p><p>（之前的签名论文就是q type）</p><p>有安全证明的方案只在安全模型内安全</p><h2 id="安全规约和其他证明的区别"><a href="#安全规约和其他证明的区别" class="headerlink" title="安全规约和其他证明的区别"></a>安全规约和其他证明的区别</h2><ul><li>game-based proof</li><li>simulation-based proof</li></ul><p><img src="/2022/10/17/Security-proof/image-20221019175859049.png" alt="image-20221019175859049"></p><p><img src="/2022/10/17/Security-proof/image-20221019175948438.png" alt="image-20221019175948438"></p><p>game hopping类似于Hybrid</p><p><img src="/2022/10/17/Security-proof/image-20221019180319854.png" alt="image-20221019180319854"></p><p>清楚定义了敌手会输出什么，能够知晓哪些信息</p><p><img src="/2022/10/17/Security-proof/image-20221019180355680.png" alt="image-20221019180355680"></p><p>敌手没有特定的输出</p><p><img src="/2022/10/17/Security-proof/image-20221019180616201.png" alt="image-20221019180616201"></p><p><img src="/2022/10/17/Security-proof/image-20221019180653862.png" alt="image-20221019180653862"></p><p><img src="/2022/10/17/Security-proof/image-20221019180908743.png" alt="image-20221019180908743"></p><h1 id="Random-oracle"><a href="#Random-oracle" class="headerlink" title="Random oracle"></a>Random oracle</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>An idealized model ，尚无人证明random oracle存在，但可以使用可信方的形式来实现</p><p>假设存在一个完全随机、公开可访问的哈希函数，只能通过查询oracle来取值</p><p>可采用以下形式化的方法来设计密码方案：</p><ul><li>假设世界上存在random oracle，并且方案在random oracle模型下可证明安全</li><li>需要在现实世界中实现方案时，采用一个恰当设计的密码学哈希函数$H(x)$即可，即当需要查询random oracle时，计算$H(x)$</li></ul><p>以上的设计需要实际上使用的密码学哈希函数能够<em>足够好</em>地模拟random oracle，所以第一步的证明在现实世界中是安全的。问题在于没有理论证明以上的模拟是<em>足够好</em>的，具体的哈希函数代码实现也不能与随机函数的行为一致</p><p>random oracle下的证明实际是在证明方案没有<em>固有的设计缺陷</em>，并没有证明任何实际的方案实现是安全的</p><!-- more --><h2 id="Details"><a href="#Details" class="headerlink" title="Details"></a>Details</h2><p>将random oracle理解为一个黑盒，接收输入为比特串，输出为比特串，内部的工作机理是未知且不可构造的，任何参与者（包括敌手）可以和黑盒交互；查询是隐私的，其他人无法观察参与者的输入$x$，甚至无法得知某个参与者是否查询过（合理性在于，参考本地调用哈希函数）</p><p>黑盒具有一致性，对于同一输入的输出保证不发生变化</p><p>如何构造$H$,考虑一个初始为空的$(x_i,y_i)$表，对于输入$x\neq x_i \in box$，随机选择$y\in \{0,1\}^l$并存入表内即可；如果输入$x = x_i \in box$，则输出对应的$y_i$。显然需要提前定义输出的域</p><p>Cons</p><ul><li><p>存在方案在RO下安全但是使用任何现实的哈希函数时都不安全</p></li><li><p>在许多现有方案中可能安全性要求过高</p></li></ul><p>Pros</p><ul><li>没有已知的在RO下安全但在现实世界中受到攻击的方案</li><li>如果攻击被发现了，可以更换哈希函数</li><li>有证明总比没有好（摆烂.jpg）</li></ul><p>参考 Page187  <a href="http://www.cs.umd.edu/~jkatz/imc.html">Introduction to Modern Cryptography, 3rd edition</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;密码学安全归约技术：壬寅年的见解&quot;&gt;&lt;a href=&quot;#密码学安全归约技术：壬寅年的见解&quot; class=&quot;headerlink&quot; title=&quot;密码学安全归约技术：壬寅年的见解&quot;&gt;&lt;/a&gt;密码学安全归约技术：壬寅年的见解&lt;/h1&gt;&lt;p&gt;学习郭福春老师面向西电的安全规约分享录屏： &lt;a href=&quot;https://www.bilibili.com/video/BV1AY4y1n775?share_source=copy_web&amp;amp;vd_source=4487439a1220fa77bb4a6f0079c98794&quot;&gt;https://www.bilibili.com/video/BV1AY4y1n775?share_source=copy_web&amp;amp;vd_source=4487439a1220fa77bb4a6f0079c98794&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Crypto" scheme="https://alleysira.github.io/categories/Crypto/"/>
    
    
    <category term="Crypto" scheme="https://alleysira.github.io/tags/Crypto/"/>
    
  </entry>
  
  <entry>
    <title>short randomizable signatures</title>
    <link href="https://alleysira.github.io/2022/10/17/short-randomizable-signatures/"/>
    <id>https://alleysira.github.io/2022/10/17/short-randomizable-signatures/</id>
    <published>2022-10-17T01:32:38.000Z</published>
    <updated>2022-10-22T09:05:32.772Z</updated>
    
    <content type="html"><![CDATA[<p>学习论文（<a href="https://eprint.iacr.org/2015/525.pdf）">https://eprint.iacr.org/2015/525.pdf）</a></p><span id="more"></span><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>数字签名的要点在于提高效率以及适配协议（blind signature在隐私保护协议中）</p><h1 id="Preliminaries"><a href="#Preliminaries" class="headerlink" title="Preliminaries"></a>Preliminaries</h1><h2 id="Bilinear-Groups"><a href="#Bilinear-Groups" class="headerlink" title="Bilinear Groups"></a>Bilinear Groups</h2><p> 三个素数阶$p$的循环群$\mathbb{G_1,G_2,G}_T$之间存在如下双线性映射$e:\mathbb{G_1}\times\mathbb{G_2}\to\mathbb{G}_T$并满足三条性质：</p><ul><li>双线性：for all $g\in\mathbb{G_1},\tilde{g}\in\mathbb{G_2}$ and $a,b\in\mathbb{Z}_p,e(g^a,\tilde{g}^b)=e(g,\tilde{g})^{a\cdot b}$</li><li>非退化性：for $g\neq 1_{\mathbb{G}_1}$ and $\tilde{g} \neq 1_{\mathbb{G}_2},e(g,\tilde{g})\neq 1_{\mathbb{G}_T}$</li><li>可计算性：for all $g\in\mathbb{G_1},\tilde{g}\in\mathbb{G_2}$存在多项式时间算法可高效计算$e(g,\tilde{g})$</li></ul><p>[GPS08] 定义了以下三类双线性群</p><ul><li>Type 1：$ \mathbb{G_1=G_2}$，对称双线性群</li><li>Type 2：$ \mathbb{G_1\neq G_2}$但存在efficient的同态映射$\phi:\to \mathbb{G_2} \to \mathbb{G_1}$;另一个方向不存在efficient的映射</li><li>Type 3：$ \mathbb{G_1\neq G_2}$并且任何方向都不存在高效可计算的的同态映射</li></ul><p>Type 1正在逐渐被弃用，Type 3 具有更好的效率 并和 <a href="https://cryptography.fandom.com/wiki/XDH_assumption#:~:text=The%20external%20Diffie%E2%80%93Hellman%20%28XDH%29%20assumption%20is%20a%20mathematic,elliptic%20curves%20which%20have%20useful%20properties%20for%20cryptography.">XDH assumption</a> 协调</p><p><img src="/2022/10/17/short-randomizable-signatures/image-20221017103406919.png" alt="image-20221017103406919"></p><h2 id="Digital-Signature-Scheme"><a href="#Digital-Signature-Scheme" class="headerlink" title="Digital Signature Scheme"></a>Digital Signature Scheme</h2><p>一个数字签名方案由四个算法定义：</p><ul><li>$Setup(k)\to pp$</li><li>$Keygen(pp)\to (sk,pk)$</li><li>$Sign(m,sk)\to \sigma $</li><li>$Verify(m,\sigma,pk)\to True \ or\ False$</li></ul><h3 id="EUF-CMA"><a href="#EUF-CMA" class="headerlink" title="EUF-CMA"></a>EUF-CMA</h3><p>existential unforgeability under chosen message attacks</p><p><img src="/2022/10/17/short-randomizable-signatures/image-20221017112239553.png" alt="image-20221017112239553"></p><h2 id="Sequential-Aggregate-Signature"><a href="#Sequential-Aggregate-Signature" class="headerlink" title="Sequential Aggregate Signature"></a>Sequential Aggregate Signature</h2><ul><li>$AS.setup(k)\to pp$</li><li>$AS.keygen(pp)\to(sk,pk)$</li><li><p>$AS.sign(\sigma,m,sk)\to\sigma’$，其中$\sigma\gets sign((m_1,m_2,\cdots,m_n),(sk_1,sk_2,\cdots,sk_n))$此处相当于追加了一条消息再签名，且使用的私钥不能和$\{m_i\}^n$签名时使用的私钥对应</p></li><li><p>$AS.verify((m_1,m_2,\cdots,m_n),\sigma,(pk_1,pk_2,\cdots,pk_n))\to True \ or\ False$</p></li></ul><p>以下是<a href="https://hovav.net/ucsd/papers/lmrs04.html">LMRS04</a>定义的聚合签名方案</p><p><img src="/2022/10/17/short-randomizable-signatures/image-20221017152732484.png" alt="image-20221017152732484"></p><h3 id="security-model——EUF-CMA"><a href="#security-model——EUF-CMA" class="headerlink" title="security model——EUF-CMA"></a>security model——EUF-CMA</h3><p>安全性类似普通签名的EUF-CMA，由如下游戏定义:</p><p><img src="/2022/10/17/short-randomizable-signatures/image-20221017154222186.png" alt="image-20221017154222186"></p><h1 id="Assumption"><a href="#Assumption" class="headerlink" title="Assumption"></a>Assumption</h1><p>LRSW假设</p><p><img src="/2022/10/17/short-randomizable-signatures/image-20221017162918439.png" alt="image-20221017162918439"></p><p><img src="/2022/10/17/short-randomizable-signatures/image-20221017164456363.png" alt="image-20221017164456363"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习论文（&lt;a href=&quot;https://eprint.iacr.org/2015/525.pdf）&quot;&gt;https://eprint.iacr.org/2015/525.pdf）&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Crypto" scheme="https://alleysira.github.io/categories/Crypto/"/>
    
    
    <category term="Crypto" scheme="https://alleysira.github.io/tags/Crypto/"/>
    
    <category term="Digital Signature" scheme="https://alleysira.github.io/tags/Digital-Signature/"/>
    
  </entry>
  
  <entry>
    <title>ccs17</title>
    <link href="https://alleysira.github.io/2022/10/13/ccs17/"/>
    <id>https://alleysira.github.io/2022/10/13/ccs17/</id>
    <published>2022-10-13T08:15:07.000Z</published>
    <updated>2022-10-19T02:08:41.026Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Notes-on-CCS-17-Practical-Secure-Aggregation-for-Privacy-Preserving-Machine-Learning"><a href="#Notes-on-CCS-17-Practical-Secure-Aggregation-for-Privacy-Preserving-Machine-Learning" class="headerlink" title="Notes on CCS 17 Practical Secure Aggregation for Privacy-Preserving Machine Learning"></a>Notes on CCS 17 Practical Secure Aggregation for Privacy-Preserving Machine Learning</h1><p>学习论文（<a href="https://eprint.iacr.org/2017/281.pdf）">https://eprint.iacr.org/2017/281.pdf）</a></p><p><img src="/2022/10/13/ccs17/image-20221013103701919.png" alt="image-20221013103701919"></p><span id="more"></span><p>安全模型</p><ul><li>honest-but-curious</li><li>active adversary</li></ul><h2 id="Secure-aggregation-for-federated-learning"><a href="#Secure-aggregation-for-federated-learning" class="headerlink" title="Secure aggregation for federated learning"></a>Secure aggregation for federated learning</h2><p>利用用户的输入习惯训练神经网络，预测用户下一个可能输入的词</p><p>用户上传的参数是基于私人数据库的高维向量</p><p>使用mini-batch随机梯度下降算法</p><p>考虑中央服务器可能会观察某个用户多次上传的参数来学习该用户最常输入的词汇；实际上服务器只需要获得全体用户的子集的向量的加权平均即可</p><p>采用安全聚合协议能够保证服务器只可能学习到随机选取的子集用户群体的特征，但无法确定是哪一个用户</p><h3 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h3><ul><li>移动设备可能随时掉线，需要保证协议的鲁棒性</li><li>由于上传的参数可能比较大，对流量计费的用户来说是额外负担</li><li>移动设备无法直接与其他移动设备建立通信信道（通常需要服务器）</li></ul><h3 id="安全聚合协议的需求："><a href="#安全聚合协议的需求：" class="headerlink" title="安全聚合协议的需求："></a>安全聚合协议的需求：</h3><ul><li>在高维数据上运行</li><li>通信效率高，甚至包括对于每个实例上新的一群用户的情况</li><li>对用户掉线鲁棒</li><li>在服务器协调有限、无认证的网络中的提供尽可能强的安全性</li></ul><h2 id="Cryptographic-primitives"><a href="#Cryptographic-primitives" class="headerlink" title="Cryptographic primitives"></a>Cryptographic primitives</h2><h3 id="Secret-sharing"><a href="#Secret-sharing" class="headerlink" title="Secret sharing"></a>Secret sharing</h3><p>本文采用Shamir的秘密分享方案</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>有限域$\mathbb{F}=\mathbb{Z}_p,p$是公开的大素数，有限域的大小$l&gt;2^k$，$k$是方案的安全参数（由于协议需要秘密分享参与者的私钥）</p><h4 id="秘密分享算法"><a href="#秘密分享算法" class="headerlink" title="秘密分享算法"></a>秘密分享算法</h4><p>$SS.share(s,t,\mathcal{U})\to \{(u,s_u)\}_{(u\in\mathcal{U})}$ </p><p>$\mathcal{U}$是$n$个用户ID的集合,$t$是门限,满足$|t|\leq \mathcal{U}$。算法输出秘密碎片和用户id对的集合</p><h4 id="秘密重构算法"><a href="#秘密重构算法" class="headerlink" title="秘密重构算法"></a>秘密重构算法</h4><p>$SS.recon(\{(u,s_u)\}_{u\in \mathcal{U}},t)\to s$</p><p>需要保证此时输入的秘密碎片和用户id对的集合$\mathcal{|V|}\geq t$</p><h4 id="正确性"><a href="#正确性" class="headerlink" title="正确性"></a>正确性</h4><script type="math/tex; mode=display">\forall s \in \mathbb{F}, \forall t ,1 \leq t\leq n,\forall \mathcal{U} \subseteq \mathbb{F}, |\mathcal{U}|=n</script><p>如果<script type="math/tex">\{(u,s_u)\}_{(u\in\mathcal{U})}\gets SS.share(s,t,\mathcal{U}),\mathcal{V}\subseteq\mathcal{U},|\mathcal{V}|\geq t,]</script></p><p>满足<script type="math/tex">SS.recon(\{(u,s_u)\}_{u\in \mathcal{V}},t)= s</script></p><script type="math/tex; mode=display">\{\{(u,s_u)\}_{(u\in\mathcal{U})}\gets SS.share(s,t,\mathcal{U}):{(u,s_u)}_{u\in \mathcal{V}}\} \equiv \{\{(u,s_u)\}_{(u\in\mathcal{U})}\gets SS.share(s^`,t,\mathcal{U}):{(u,s_u)}_{u\in \mathcal{V}}\}</script><p>即不同的密文产生的碎片是同分布的</p><h3 id="Key-agreement"><a href="#Key-agreement" class="headerlink" title="Key agreement"></a>Key agreement</h3><p>密钥协商协议包括3个算法$(KA.param,KA.gen,KA.agree)$，具体采用了DH密钥协商协议和哈希函数</p><p>$KA.param()$产生公开参数，$KA.gen()$允许用户生成公私钥对，$KA.agree()$允许用户采用自己的私钥和另一用户的公钥协商一个新的密钥</p><ul><li>$KA.param(k)\to (\mathbb{G^{‘}},g,q,H)$</li><li>$KA.gen(\mathbb{G^{‘}},g,q,H)\to(x,g^x),x \in \mathbb{Z}_q$</li><li>$KA.aggree(x_u,g^{x_v})\to s_{u,v}=H(g^{x_ux_v})$</li></ul><p>面对honest-but-curious的敌手，安全性参考DDH假设</p><p><img src="/2022/10/13/ccs17/image-20221013141833553.png" alt="image-20221013141833553" style="zoom: 50%;"></p><p>考虑active adversary，敌手可以获得任意$s_u^{PK},s_v^{PK},KA.agree(s_u^{SK},s^{PK}),KA.agree(s_v^{SK},s^{PK})$，仍然无法分辨$s_{u,v}$和随机串（$s^{PK}$显然不能是$u/v$的）</p><p><img src="/2022/10/13/ccs17/image-20221013142756384.png" alt="image-20221013142756384" style="zoom: 50%;"></p><h3 id="Authenticated-Encryption"><a href="#Authenticated-Encryption" class="headerlink" title="Authenticated Encryption"></a>Authenticated Encryption</h3><p>参考Introduction to Modern Cryptography中的定义，满足CCA安全和不可伪造</p><p><img src="/2022/10/13/ccs17/image-20221014145121973.png" alt="image-20221014145121973"></p><p><img src="/2022/10/13/ccs17/image-20221014145241663.png" alt="image-20221014145241663"></p><p>不可伪造的非形式化理解是敌手可以任意查询带有正确密钥的加密算法Oracle，最后输出密文，满足密文正确解密且不在之前查询的序列中<img src="/2022/10/13/ccs17/image-20221014145241663.png" alt="image-20221014145241663"></p><p>CCA安全的非形式化理解是敌手可以查询加解密Oracle，自行生成2个明文无法区分加密结果</p><p><img src="/2022/10/13/ccs17/image-20221014150315360.png" alt="image-20221014150315360"></p><p><img src="/2022/10/13/ccs17/image-20221014150437583.png" alt="image-20221014150437583"></p><ul><li><p>提供保密性和完整性</p></li><li><p>包括三个算法：$Key.gen(),AE.enc(),AE.dec()$</p></li><li><p>满足IND-CPA与IND-CTXT</p></li></ul><p>考虑使用MAC和symmetric encryption认证加密的三种实现方式：</p><ul><li><p>加密和MAC同时执行：$c\gets Enc_{k_E}(m),t\gets MAC_{K_M}(m)$</p></li><li><p>先加密再MAC：$c\gets Enc_{k_E}(m),t\gets MAC_{K_M}(c)$</p></li><li>先MAC再加密：$t\gets MAC_{K_M}(m),c\gets Enc_{k_E}(m|t)$</li></ul><h3 id="PRG"><a href="#PRG" class="headerlink" title="PRG"></a>PRG</h3><p>保证接受定长的种子，输出和输出空间内随机均匀取值计算上不可区分</p><h3 id="Signature-Scheme"><a href="#Signature-Scheme" class="headerlink" title="Signature Scheme"></a>Signature Scheme</h3><p>UF-CMA secure signature scheme</p><p>包括三个算法$(SIG.gen,SIG.sign,SIG.ver)$</p><h3 id="PKI"><a href="#PKI" class="headerlink" title="PKI"></a>PKI</h3><p>防止服务器模拟任意的数量的客户端，需要引入PKI使得客户端注册身份，注册得到$(u,d_u^{PK})$</p><h2 id="Technical-Intuition"><a href="#Technical-Intuition" class="headerlink" title="Technical Intuition"></a>Technical Intuition</h2><p>协议的目标：server只能得到来自大部分用户的$\sum_{u\in \mathcal{U}}x_u$，用户无法得知任何其他人的信息</p><h3 id="Masking-with-One-Time-Pads"><a href="#Masking-with-One-Time-Pads" class="headerlink" title="Masking with One-Time Pads."></a>Masking with One-Time Pads.</h3><p>aggregato# r计算并发送$y_u$</p><script type="math/tex; mode=display">y_u=x_u+\sum\limits_{v\in\mathcal{U}:u< v}s_{u,v}-\sum\limits_{u\in \mathcal{U}:u>v}s_{v,u} \bmod R</script><p>server计算</p><script type="math/tex; mode=display">\begin{align}z&=\sum\limits_{u\in \mathcal{U}}y_u\\&=\sum\limits_{u\in \mathcal{U}}(x_u+\sum\limits_{v\in\mathcal{U}:u<v}s_{u,v}-\sum\limits_{v\in\mathcal{U}:u>v}s_{u,v})\\&=\sum\limits_{u\in \mathcal{U}}x_u \bmod R\\\end{align}</script><p>存在的问题是用户必须交换$s_{u,v}$即与其他用户协商的密钥，带来的通信开销是$|\mathcal{U}|\times|x|$；以及用户不能离线</p><h3 id="Efficient-Communication-and-Handling-Dropped-Users"><a href="#Efficient-Communication-and-Handling-Dropped-Users" class="headerlink" title="Efficient Communication and Handling Dropped Users"></a>Efficient Communication and Handling Dropped Users</h3><ul><li>优化通信开销——令$s_{u,v}$为伪随机数生成器的输出，只需要约定种子即可</li><li>解决离线问题，最朴素的做法是要求其余在线用户上传和离线用户协商的种子。如此做可能带来大的通信开销以及可能存在在线用户也掉线的情况，轮数可能等于用户个数$n$<ul><li>采用门限秘密分享来解决这个问题，但可能用户的隐私信息可能会被服务器恢复，即$y_u-恢复的值$。恶意的敌手可以通过宣称用户掉线来获得该用户的隐私</li></ul></li></ul><h3 id="Double-Masking-to-Protect-Security"><a href="#Double-Masking-to-Protect-Security" class="headerlink" title="Double-Masking to Protect Security"></a>Double-Masking to Protect Security</h3><ul><li>通过添加新的值$b_u$来防御中心服务器不可信的情况，同样采用秘密分享分享出去</li></ul><script type="math/tex; mode=display">\begin{align}y_u&=x_u+\sum\limits_{v\in\mathcal{U}:u<v}PRG(s_{u,v})-\sum\limits_{v\in\mathcal{U}:u>v}PRG(s_{u,v})\end{align}</script><ul><li>服务器对于每个用户$u$，必须选择向在线用户$v$请求$b_u$碎片还是$s_{u,v}$碎片；</li><li>诚实的用户$v$不会同时泄露同一个用户的两个碎片</li></ul><h3 id="Putting-it-all-Together"><a href="#Putting-it-all-Together" class="headerlink" title="Putting it all Together"></a>Putting it all Together</h3><p><img src="/2022/10/13/ccs17/image-20221014100912932.png" alt="image-20221014100912932" style="zoom:80%;"></p><p><img src="/2022/10/13/ccs17/image-20221014100609602.png" alt="image-20221014100609602" style="zoom:80%;"></p><h2 id="A-Practical-Secure-Aggregation-Protocol"><a href="#A-Practical-Secure-Aggregation-Protocol" class="headerlink" title="A Practical Secure Aggregation Protocol"></a>A Practical Secure Aggregation Protocol</h2><h3 id="Set-up"><a href="#Set-up" class="headerlink" title="Set up"></a>Set up</h3><p><img src="/2022/10/13/ccs17/image-20221014143442154.png" alt="image-20221014143442154"></p><p>此处标记的算法应该是$KA.para(k)$</p><p>考虑参与的用户列表</p><ul><li>$\mathcal{U_1}$是指正确生成了两对公私钥并发送给服务器的用户，$\mathcal{U_1} \subseteq \mathcal{U}$</li><li>$\mathcal{U_2}$是指收到了服务器下发的用户公私钥集合，生成了自己的$b_u$并将$b_u \ s_u^{SK}$进行了秘密分享，与另一用户进行密钥协商并认证加密两者之间的对应关系和两个秘密分享的碎片，上传密文之后的用户 $\mathcal{U_2} \subseteq \mathcal{U_1}$</li><li>$\mathcal{U_3}$是指协商$s_{u,v}$计算并加密上传了自己的参数之后的用户 $\mathcal{U_3} \subseteq \mathcal{U_2}$</li><li>$\mathcal{U_4}$指的是上传之后掉线的用户，该用户的$s_{u,v}$已经被计算在结果中需要减去；$\mathcal{U_4} \subseteq \mathcal{U_3}$（方便理解，与原文记号不同）</li><li>$\mathcal{U_5}$是指未掉线的用户（与原文记号不同）</li></ul><h3 id="Advertise-keys"><a href="#Advertise-keys" class="headerlink" title="Advertise keys"></a>Advertise keys</h3><p>每个用户生成两对公私钥，$c$用于进行密钥协商作为认证加密的密钥；$s$进行密钥协商后作为伪随机数生成器的种子</p><p><img src="/2022/10/13/ccs17/image-20221014144120142.png" alt="image-20221014144120142"></p><h3 id="Share-Keys"><a href="#Share-Keys" class="headerlink" title="Share Keys"></a>Share Keys</h3><p>$e_{u,v}$采用用户$u,v$协商的密钥加密了用户间的对应关系以及$u\to v$的私钥碎片和$b_u$的碎片，服务器无法解密</p><p><img src="/2022/10/13/ccs17/image-20221014153010286.png" alt="image-20221014153010286"></p><h3 id="MaskedInput-Collection"><a href="#MaskedInput-Collection" class="headerlink" title="MaskedInput Collection"></a>MaskedInput Collection</h3><p>用户之间协商出PRG的种子$s_{u,v}$之后，在本地计算$y_u\gets x_u+PRG(b_u)+\sum_{v\in\mathcal{U_2}}P_{u,v}$并发送</p><p><img src="/2022/10/13/ccs17/image-20221014154240414.png" alt="image-20221014154240414"></p><h3 id="Unmasking"><a href="#Unmasking" class="headerlink" title="Unmasking"></a>Unmasking</h3><p>服务器进行求和，由于服务器维护参与者的集合，能够发现用户掉线。对于掉线的用户，重构$s_u^{SK}$来计算需要加上的值</p><p><img src="/2022/10/13/ccs17/image-20221014155201142.png" alt="image-20221014155201142"></p><h2 id="Performance-analysis"><a href="#Performance-analysis" class="headerlink" title="Performance analysis"></a>Performance analysis</h2><p>考虑单一服务器和$n$个用户的情况，用户数据的维度为$m$</p><p><img src="/2022/10/13/ccs17/image-20221017085837210.png" alt="image-20221017085837210"></p><h2 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work"></a>Related work</h2><p>基于MPC的方案</p><ul><li><p>基于混淆电路的MPC适用于2-3个参与者</p></li><li><p>基于秘密分享的MPC可以扩展到数百规模的用户</p><ul><li>通信开销比较高</li></ul></li></ul><p>基于Dining Cryptographers Networks</p><ul><li>有待学习</li></ul><p>基于门限同态加密的方案</p><ul><li>计算昂贵/需要额外的安全假设</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Notes-on-CCS-17-Practical-Secure-Aggregation-for-Privacy-Preserving-Machine-Learning&quot;&gt;&lt;a href=&quot;#Notes-on-CCS-17-Practical-Secure-Aggregation-for-Privacy-Preserving-Machine-Learning&quot; class=&quot;headerlink&quot; title=&quot;Notes on CCS 17 Practical Secure Aggregation for Privacy-Preserving Machine Learning&quot;&gt;&lt;/a&gt;Notes on CCS 17 Practical Secure Aggregation for Privacy-Preserving Machine Learning&lt;/h1&gt;&lt;p&gt;学习论文（&lt;a href=&quot;https://eprint.iacr.org/2017/281.pdf）&quot;&gt;https://eprint.iacr.org/2017/281.pdf）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2022/10/13/ccs17/image-20221013103701919.png&quot; alt=&quot;image-20221013103701919&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Federated Learning" scheme="https://alleysira.github.io/tags/Federated-Learning/"/>
    
  </entry>
  
  <entry>
    <title>git</title>
    <link href="https://alleysira.github.io/2022/10/12/git/"/>
    <id>https://alleysira.github.io/2022/10/12/git/</id>
    <published>2022-10-12T11:16:53.000Z</published>
    <updated>2022-10-12T11:49:27.238Z</updated>
    
    <content type="html"><![CDATA[<h2 id="配置bash代理"><a href="#配置bash代理" class="headerlink" title="配置bash代理"></a>配置bash代理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//配置部分代理</span><br><span class="line">git config --global http.https://github.com.proxy https://127.0.0.1:xxx</span><br><span class="line">git config --global https.https://github.com.proxy https://127.0.0.1:xxx</span><br><span class="line">//配置全局代理</span><br><span class="line">git config --global https.proxy http://127.0.0.1:xxx</span><br><span class="line">git config --global http.proxy https://127.0.0.1:xxx</span><br><span class="line">//取消部分代理</span><br><span class="line">git config --global --<span class="built_in">unset</span> https.https://github.com.proxy</span><br><span class="line">git config --global --<span class="built_in">unset</span> http.https://github.com.proxy</span><br><span class="line">//取消全局代理</span><br><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br><span class="line">//查看当前局部代理</span><br><span class="line">git config --global --get https.https://github.com.proxy</span><br><span class="line">git config --global --get http.https://github.com.proxy</span><br><span class="line">//查看当前全局代理</span><br><span class="line">git config --global --get https.proxy</span><br><span class="line">git config --global --get http.proxy</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;配置bash代理&quot;&gt;&lt;a href=&quot;#配置bash代理&quot; class=&quot;headerlink&quot; title=&quot;配置bash代理&quot;&gt;&lt;/a&gt;配置bash代理&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla</summary>
      
    
    
    
    
    <category term="Web" scheme="https://alleysira.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm and Data Structure</title>
    <link href="https://alleysira.github.io/2022/10/03/algorithm/"/>
    <id>https://alleysira.github.io/2022/10/03/algorithm/</id>
    <published>2022-10-03T03:24:07.000Z</published>
    <updated>2022-11-02T03:06:26.172Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章：绪论"><a href="#第一章：绪论" class="headerlink" title="第一章：绪论"></a>第一章：绪论</h1><h2 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h2><ul><li><p>计算=信息处理</p></li><li><p>计算：借助某种工具，遵照一定规则，以明确而机械的方法进行</p></li><li><p>计算模型=计算机=信息处理工具</p></li></ul><span id="more"></span><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>算法：特定计算模型下，解决特定问题的指令序列</p><ul><li>正确性：的确可以解决指定的问题</li><li>确定性：基本操作组成的序列</li><li>可行性：每一基本操作可实现，可以在常数时间内完成</li><li><em>有穷性</em>：对于任何输入，经过有穷次基本操作可以得到输出；下例</li></ul><script type="math/tex; mode=display">\begin{align} Hailstone(n)= \left\{ \begin{array}{l} \{1\} ,n\leq1 \\\{n\} \cup  Hailstone(n/2),\ n \ is \  even\\\{n\} \cup  Hailstone(3n+1),\ n \ is \ odd\end{array}\right.\end{align}\\</script><script type="math/tex; mode=display">|Hailstone(n)|<\infty \ ?</script><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hailstone</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>&lt;n)&#123;</span><br><span class="line">(n%<span class="number">2</span>)?n=<span class="number">3</span>*n+<span class="number">1</span>;n/=<span class="number">2</span>;</span><br><span class="line">len++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">程序\neq算法</script><h3 id="好的算法"><a href="#好的算法" class="headerlink" title="好的算法"></a>好的算法</h3><ul><li>正确性</li><li>健壮性</li><li>可读</li><li>效率：速度快；存储空间尽可能少<ul><li>算法+数据结构=程序</li></ul></li></ul><h2 id="计算模型"><a href="#计算模型" class="headerlink" title="计算模型"></a>计算模型</h2><p>性能测度：To measure is to know.</p><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><ul><li>正确性</li><li>成本：运行时间+所需空间<ul><li>如何进行度量？划分等价类</li><li>如何划分？问题规模</li><li>规模接近，计算成本接近；规模增加；计算成本上升</li><li>$T_A(n)=用算法A求解某一问题规模为n的实例$</li><li>可能存在较好/较坏的情况</li><li>$T_A(n)=用算法A求解某一问题规模为n的实例，T(n)=max\{T(P)||P|=n\}$</li></ul></li></ul><h3 id="理想模型"><a href="#理想模型" class="headerlink" title="理想模型"></a>理想模型</h3><p>如何评价针对同一问题多种算法的优劣？</p><p>实验统计不准确；采用理想的模型</p><h4 id="图灵机模型"><a href="#图灵机模型" class="headerlink" title="图灵机模型"></a>图灵机模型</h4><ul><li>tape：分为很多cell，默认均标记为特定符号</li><li>alphabet：有限字符表</li><li>head：读写头，任何时刻对准某一个cell</li><li>state：有限种状态中的某一种；</li><li>transition function：状态转移函数；</li></ul><h4 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h4><ul><li>无限空间，顺序编号的寄存器：$R[0],R[1],…,R[n]$</li><li>每一操作仅需要常数时间<ul><li>R[i] &lt;- c</li><li>R[i] &lt;- R[j]</li><li>R[i] &lt;- R[R[j]]</li><li>R[R[i]] &lt;- R[j]</li><li>R[i] &lt;- R[j] +/- R[k]</li><li>IF … GOTO; GOTO; STOP</li></ul></li></ul><p>提供简化的计算工具，独立于平台进行比较合评判</p><p>算法的运行时间 算法需要执行的基本操作次数</p><p>$T(n)$ 算法为求解规模为n的问题，所需执行的基本操作次数</p><p>实例：<img src="/2022/10/03/algorithm/image-20221003153853927.png" alt="image-20221003153853927"></p><h2 id="渐进复杂度"><a href="#渐进复杂度" class="headerlink" title="渐进复杂度"></a>渐进复杂度</h2><p>将输入规模视作决定计算成本的主要因素</p><h3 id="大-O-记号"><a href="#大-O-记号" class="headerlink" title="大$O$记号"></a>大$O$记号</h3><p>长远、主流：好读书不求甚解 每有会意 便欣然忘食</p><p>渐进上界定义：$T(n)=\mathcal{O}(f(n)),if\ \exist c&gt;0,n\gg2,T(n) &lt; c\cdot f(n)$</p><p>$T(n)$更加简洁，依然能够反映前者的增长趋势</p><ul><li><p>常系数可以忽略 $\mathcal{O}(f(n))=\mathcal{O}(c \cdot f(n))$</p></li><li><p>低次项可以忽略 $\mathcal{O}(n^a+n^b)=\mathcal{O}(n^a),a&gt;b&gt;0$</p></li></ul><h3 id="大-Omega-记号"><a href="#大-Omega-记号" class="headerlink" title="大$\Omega$记号"></a>大$\Omega$记号</h3><p>大$\Omega$代表渐进的下界，算法运行的最好情况</p><p>大$\Theta$表示算法的确界</p><p><img src="/2022/10/03/algorithm/image-20221019091129989.png" alt="image-20221019091129989"></p><p>刻度</p><ul><li><p>$\mathcal{O}(1)$</p><ul><li>常数复杂度</li><li>甚至包括高阶的常数$2022^{2022}$</li><li>效率最高</li><li>特征：不含循环、调用、递归（不严谨</li></ul></li><li><p>$\mathcal{O}(\log^cn)$</p><ul><li>常数无所谓（换底公式）</li><li>$n$常数次幂无所谓</li><li>非常高效，复杂度无限接近于常数</li></ul></li><li>$\mathcal{O}(n^c)$<ul><li>多项式复杂度</li><li>由多项式中次数最高的项决定</li><li>$\mathcal{O}(n)$<ul><li>线性复杂度</li><li>实际的编程问题</li></ul></li><li>令人满意的复杂度</li></ul></li><li>$\mathcal{O}(2^n)$<ul><li>指数复杂度</li><li>增长过快，不可接受的</li><li>问题在于指数复杂度的算法显而易见，设计出多项式时间的算法极其不易</li><li>实例：幂集的个数$|2^s|=s^{|s|}=2^n$<ul><li>子集的划分是NPC问题，不存在多项式时间内回答此问题的算法</li></ul></li></ul></li></ul><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>学习目的：去粗存精的估算</p><h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><p>算法分析的任务=正确性（不变性、单调性）+复杂度</p><p>c++的基本指令等效于常数条RAM的基本指令，渐进意义下两者大体相当</p><p>主要的分析方法：</p><ul><li>迭代：级数求和</li><li>递归：递归跟踪+递推方程</li><li>猜测+验证</li></ul><h3 id="级数"><a href="#级数" class="headerlink" title="级数"></a>级数</h3><ul><li>算数级数：与末阶平方同阶</li><li>幂方级数：比幂次高一阶</li><li>几何级数：与末项同阶</li><li>收敛级数：$\mathcal{O}(1)$</li><li>调和级数：$\Theta(\log n)$</li><li>对数级数：$\Theta(n\log n)$</li></ul><p><img src="/2022/10/03/algorithm/image-20221019155129457.png" alt="image-20221019155129457"></p><p><img src="/2022/10/03/algorithm/image-20221019155340771.png" alt="image-20221019155340771"></p><p>利用二维图形理解复杂度，面积即是需要执行的时间</p><p>虽然面积减少了，但是根据复杂度是相同的</p><p><img src="/2022/10/03/algorithm/image-20221019160010772.png" alt="image-20221019160010772"></p><p><img src="/2022/10/03/algorithm/image-20221102085845427.png" alt="image-20221102085845427"></p><h3 id="实例：Bubble-Sort"><a href="#实例：Bubble-Sort" class="headerlink" title="实例：Bubble Sort"></a>实例：Bubble Sort</h3><p>消除相邻逆序元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">bool</span> sorted=<span class="literal">false</span>;sorted=!sorted;n--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i]&gt;A[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="built_in">swap</span>(A[i],A[i<span class="number">-1</span>]);</span><br><span class="line">                sorted=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来证明算法的正确性 中止 复杂度</p><ul><li><p>不变性：当经过$k$轮扫描后，最大的$k$个元素必然已经出现在集合最后</p></li><li><p>单调性：当经过$k$轮扫描后，问题的规模缩减至$n-k$</p></li><li>正确性：经过至多$n$次扫描后，算法必然中止且能给出正确解答</li></ul><h3 id="封底运算"><a href="#封底运算" class="headerlink" title="封底运算"></a>封底运算</h3><p>Back of the envelope calculation</p><p>1天=$10^5$秒</p><p>1生=1世纪=$3\times10^9$秒</p><p>三生三世=$10^{10}$秒</p><p>CPU 1GHZ 每秒进行的运算$10^9$</p><p><img src="/2022/10/03/algorithm/image-20221102092935505.png" alt="image-20221102092935505"></p><h2 id="迭代与递归"><a href="#迭代与递归" class="headerlink" title="迭代与递归"></a>迭代与递归</h2><p>核心思想：削减问题有效规模</p><p>为求解一个大规模的问题，可以将其划分为两个子问题：</p><ul><li><p>一个平凡</p></li><li><p>另一个规模递减</p></li></ul><p>分别求解子问题，由子问题的解得到原问题的解</p><p><img src="/2022/10/03/algorithm/image-20221102094154619.png" alt="image-20221102094154619"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(A[],n)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (n&lt;<span class="number">1</span>)?<span class="number">0</span>:<span class="built_in">sum</span>(A,n<span class="number">-1</span>)+A[n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>累积所需递归实例所需的时间即可获得算法执行时间</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;第一章：绪论&quot;&gt;&lt;a href=&quot;#第一章：绪论&quot; class=&quot;headerlink&quot; title=&quot;第一章：绪论&quot;&gt;&lt;/a&gt;第一章：绪论&lt;/h1&gt;&lt;h2 id=&quot;计算&quot;&gt;&lt;a href=&quot;#计算&quot; class=&quot;headerlink&quot; title=&quot;计算&quot;&gt;&lt;/a&gt;计算&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;计算=信息处理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;计算：借助某种工具，遵照一定规则，以明确而机械的方法进行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;计算模型=计算机=信息处理工具&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Algorithm" scheme="https://alleysira.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>FHE</title>
    <link href="https://alleysira.github.io/2022/09/26/FHE/"/>
    <id>https://alleysira.github.io/2022/09/26/FHE/</id>
    <published>2022-09-26T01:35:44.000Z</published>
    <updated>2023-02-28T02:44:33.420Z</updated>
    
    <content type="html"><![CDATA[<p>学习 【双语字幕】全同态加密十（几）年的发展历程】<a href="https://www.bilibili.com/video/BV1rY411V7Ko?share_source=copy_web&amp;vd_source=4487439a1220fa77bb4a6f0079c98794">https://www.bilibili.com/video/BV1rY411V7Ko?share_source=copy_web&amp;vd_source=4487439a1220fa77bb4a6f0079c98794</a></p><span id="more"></span><h1 id="A-Decade-or-so-of-Fully-Homomorphic-Encryption"><a href="#A-Decade-or-so-of-Fully-Homomorphic-Encryption" class="headerlink" title="A Decade (or so) of Fully Homomorphic Encryption"></a>A Decade (or so) of Fully Homomorphic Encryption</h1><ul><li><p>Arthur: Craig Gentry, the first FHE </p></li><li><p>GSW BGV</p></li><li><p>Eurocrypt 2021 <a href="https://eurocrypt.iacr.org/2021/slides/gentry.pdf">https://eurocrypt.iacr.org/2021/slides/gentry.pdf</a></p></li><li><p>processing and access of data </p></li><li><p>cloud computing on Encrypted data</p><p><img src="/2022/09/26/FHE/image-20220926094256541.png" alt="image-20220926094256541" style="zoom:80%;"></p></li><li><p>except length of the data nothing about of the data will be leaked. </p></li><li><p>FHE bootstrapping four generations</p></li></ul><h2 id="Past"><a href="#Past" class="headerlink" title="Past"></a>Past</h2><p>Proof of Concept -&gt; Useable Tool</p><ul><li><p>First</p><p><img src="/2022/09/26/FHE/image-20220926100358511.png" alt="image-20220926100358511"></p></li><li><p>Second: LWE Based</p></li></ul><p><img src="/2022/09/26/FHE/image-20220926100424032.png" alt="image-20220926100424032"></p><ul><li><p>Third: BGV </p><ul><li>parameter improvement</li></ul><p><img src="/2022/09/26/FHE/image-20220926100932030.png" alt="image-20220926100932030"></p><p>​    <img src="/2022/09/26/FHE/image-20220926101035267.png" alt="image-20220926101035267"></p><p>not supporting packing</p></li><li><p>Four: CKKS SIMD operation</p><p><img src="/2022/09/26/FHE/image-20220926100615012.png" alt="image-20220926100615012"></p></li></ul><p>climeric FHE: switch between different schemes</p><h3 id="application"><a href="#application" class="headerlink" title="application"></a>application</h3><ul><li>gene analysis</li><li>Idash challenges: MPC and FHE</li><li>neural network</li><li>PIR retrieval: like AES</li></ul><p>hardware accleration of FHE</p><h3 id="usability"><a href="#usability" class="headerlink" title="usability"></a>usability</h3><p><img src="/2022/09/26/FHE/image-20220926102737018.png" alt="image-20220926102737018"></p><p>google transpiler</p><h2 id="Present"><a href="#Present" class="headerlink" title="Present"></a>Present</h2><p>divorce form lattice</p><p><img src="/2022/09/26/FHE/image-20220926103035092.png" alt="image-20220926103035092"></p><ul><li>Key generation and Encryption should be probalistic  </li></ul><p><img src="/2022/09/26/FHE/image-20220926103404636.png" alt="image-20220926103404636"></p><p><img src="/2022/09/26/FHE/image-20220926103504388.png" alt="image-20220926103504388"></p><p><img src="/2022/09/26/FHE/image-20220926103701950.png" alt="image-20220926103701950"></p><p><img src="/2022/09/26/FHE/image-20220926104017854.png" alt="image-20220926104017854"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习 【双语字幕】全同态加密十（几）年的发展历程】&lt;a href=&quot;https://www.bilibili.com/video/BV1rY411V7Ko?share_source=copy_web&amp;amp;vd_source=4487439a1220fa77bb4a6f0079c98794&quot;&gt;https://www.bilibili.com/video/BV1rY411V7Ko?share_source=copy_web&amp;amp;vd_source=4487439a1220fa77bb4a6f0079c98794&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Crypto" scheme="https://alleysira.github.io/tags/Crypto/"/>
    
    <category term="Homomorphic Encryption" scheme="https://alleysira.github.io/tags/Homomorphic-Encryption/"/>
    
  </entry>
  
  <entry>
    <title>GRE</title>
    <link href="https://alleysira.github.io/2022/09/20/GRE/"/>
    <id>https://alleysira.github.io/2022/09/20/GRE/</id>
    <published>2022-09-20T06:35:35.000Z</published>
    <updated>2022-10-13T08:48:08.862Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GRE"><a href="#GRE" class="headerlink" title="GRE"></a>GRE</h1><p>6 sections</p><ul><li>作文 6<ul><li>AW：analytical writing section</li><li>ISSUE：30min : Writing task 2 in IELTS</li></ul></li><li>语文 verbal 170</li><li>数学 quant 170</li></ul><p>计划有变，被迫退考（</p><span id="more"></span><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><ul><li><p>OG</p><ul><li><p><a href="https://www.ets.org/gre/revised_general/prepare">https://www.ets.org/gre/revised_general/prepare</a></p></li><li><p>Verbal Reasoning Measure</p><ul><li><p>Text Completion Questions</p><ul><li>Single correct answer, consisting of one choice for each blank; no credit for partially correct answers</li><li>The answer choices for different blanks function independently</li></ul></li></ul></li><li>Sentence Equivalence Questions<ul><li>a single sentence </li><li>one blank</li><li>six answer choices</li><li>select 2 <ul><li>Reading Comprehension Questions</li></ul></li></ul></li></ul></li><li>词汇、真题<ul><li>单词：同义词</li><li>verbal：填空1200 阅读240 考满分</li><li>quant：整理数学公式；坑题难题 张巍170</li><li>作文：模板</li></ul></li><li>模考<ul><li>官方模考</li><li>时间规划</li></ul></li></ul><h2 id="词汇"><a href="#词汇" class="headerlink" title="词汇"></a>词汇</h2><h3 id="9-19"><a href="#9-19" class="headerlink" title="9.19"></a>9.19</h3><ul><li>[x] 地基词 sec1 sec2 sec3</li><li>[x] 不背50个</li></ul><h3 id="9-20"><a href="#9-20" class="headerlink" title="9.20"></a>9.20</h3><ul><li>[x] 地基词 sec4 sec5 sec6</li><li>[x] 学习OG</li><li>[x] 高高频 六选二 sec1 sec2</li><li>sparseness n.稀疏，稀少</li><li>superficiality n. 浅薄；肤浅的</li><li>plausibility  n. 可信；花言巧语；</li><li>entitlement n. 权利；资格；应得的</li><li>eminence n. 优秀；卓越 prominence</li><li>notoriety n.坏名声</li><li>tumultuous a. 动荡的；狂暴的；热烈的</li><li>providential a. 天缘巧合的</li><li>dispassionate a. 冷静的；心平气和的</li><li>imperceptibly adv 无法察觉的</li><li>precarious a. 危险的</li><li>technocrat n. 技术专家</li><li>counterproductive a. 事与愿违</li><li>irracibility n. 易怒 exasperation</li><li>diffidence confidence</li><li>表示复杂的词语 <ul><li>intricate a.</li><li>convoluted </li><li>intricacy noun.错综复杂</li><li>obscure a.难懂的</li><li>perplex v. 迷惑 perplexing a.复杂的</li></ul></li><li>confound confounding a. 使困惑的</li><li>fairness objectivity</li><li>novelty 新奇；新颖</li><li>paradigm 范例；范式 model</li><li>hodgepodge 大杂烩 patchwork 拼缝物</li><li>heterogeneous 多种的；disparate 不同的 异类的</li><li>intrigue v. 引起 ；阴谋，秘密策划<ul><li>intriguing adj. 有趣的；迷人的</li></ul></li><li>mediocre a.平凡的；平庸的</li><li>engage 吸引 <ul><li>engaging a. 吸引人的 </li><li>engaged 订婚的 建立密切关系</li><li>开战</li></ul></li><li>adduce 举出；引证</li><li>nonindigenous: not local or native</li><li>conspicuous  a. 显著的；marked</li><li>inbreeding 近亲繁殖</li><li>trivial inconsequential</li><li>precarious 不稳的；不确定的；危险的 perilous</li><li>belie v. 掩盖；证明错误 mask</li><li>unfounded <ul><li>groundless </li><li>baseless </li><li>untenable </li><li>unwarranted 没有根据的</li></ul></li><li>conjecture n. 猜测 speculate v. 猜测；投机</li><li>cliche 陈词滥调</li><li>condescending a.居高临下的；优越感的</li><li>proclaim 声明 profess </li><li>disown 否认；脱离关系</li><li>discern 觉察出 discover</li><li>disregard neglect overlook ignore </li><li>opaque 不透明的 隐晦的</li><li>refutation n. 反驳</li><li>arduous a. 艰难的</li><li>covert a.隐秘的  clandestine 秘密地</li><li>exhilarating a.使人兴奋的</li><li>nullify 使无效</li><li>accentuate 强调；重读</li><li>problematic knotty complicated</li><li>disheartening 使丧失信心 depressing</li><li>pedestrian a. 无聊的 noun. 行人</li><li>yield 产生 engender</li><li>polemical a. 争论的；挑起辩论的 pole</li><li>rapacious a. 贪婪的 avarcious greedy</li><li>enterprising a. 有开拓精神的 有事业心的；</li><li>profusion noun. 丰富 大量 </li><li>resurgence noun. 复苏 renaissance文艺复兴</li><li>spike 猛增 upsurge </li><li>harbinger 坏的预兆  portent</li><li>lull 平静期；间歇  respite</li><li>commodity  n. 商品commercial</li></ul><h3 id="9-21"><a href="#9-21" class="headerlink" title="9.21"></a>9.21</h3><ul><li>[x] 地基词 sec7 sec8 sec9 sec10</li><li>[x] 高高频 六选二 sec3 </li><li>[ ] 修改文书1稿</li><li>exhaustive a. 全面的，彻底的 <ul><li>encyclopedic a.百科全书的；知识渊博的</li></ul></li><li>long-winded a.冗长枯燥的<ul><li>rambling 冗长而含糊的 ； 杂乱的</li><li>incoherent 冗长的</li></ul></li><li>overbearing a. 专横的</li><li>undiscriminating a. 不加区别的；一视同仁的；没有鉴别力的<ul><li>impartial: not supporting sb than any ohter</li><li>evenhanded</li></ul></li><li>unimpeachable a. 无可指摘的；<ul><li>blameless</li><li>innocent </li></ul></li><li>high-minded a.高尚的；高洁的</li><li>practitioner n. （医学法律）从业者</li><li>allege v. 断言；声称 <ul><li>proclaim</li><li>profess</li></ul></li><li>overly 过度地</li><li>ingenious a. 聪明的；灵巧的<ul><li>smart</li><li>clever</li></ul></li><li>revision noun. 修正 修订</li><li>evanescent a. 瞬息即逝的<ul><li>ephemeral a. 短暂的</li></ul></li><li>cumbersome a. 笨重的；不方便<ul><li>unwieldy</li></ul></li><li>immutable a. 不可改变的</li><li>peculiarity noun. 特点；怪癖</li><li>gravitate  v. 受吸引的 gravity</li><li>predilection 喜爱；偏爱；钟爱<ul><li>proclivity 倾向，癖好</li></ul></li><li>vacillation noun. 观点（或立场等）摇摆；动摇<ul><li>waver noun. wavering</li></ul></li><li>cowardice noun. 懦弱</li><li>ethereal 轻飘的；缥缈的；</li><li>omnipresent 无所不在的；<ul><li>ubiquitous </li></ul></li><li>diminutive 极小的；<ul><li>minuscule 极小的</li></ul></li><li>startling 惊人的；（标记取反）</li><li>aerial a. 空中的 </li><li>gigantic a. 巨大的</li><li>reveal 显示<ul><li>manifest verb. 表明</li></ul></li><li>mitigate 减轻、缓和；mild<ul><li>diminish: become smaller or waker</li><li>undercut: sell at a lower prece; undermine</li></ul></li><li>heartfelt: show strong fellings that are sincere</li><li>intelligible: can be easily understood<ul><li>readable: easy to read</li></ul></li><li>voluble a. talk a lot and with enthusiasm</li><li>crudely adv. not very careful </li><li>slumber sleep</li><li>fatiguling: making you very tired both physically and mentally </li><li>somnolent: almost sleep<ul><li>lethargic : without energy or enthusiasm </li></ul></li><li>laconic: using only few words to say </li><li>befuddle a. confused</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;GRE&quot;&gt;&lt;a href=&quot;#GRE&quot; class=&quot;headerlink&quot; title=&quot;GRE&quot;&gt;&lt;/a&gt;GRE&lt;/h1&gt;&lt;p&gt;6 sections&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作文 6&lt;ul&gt;
&lt;li&gt;AW：analytical writing section&lt;/li&gt;
&lt;li&gt;ISSUE：30min : Writing task 2 in IELTS&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;语文 verbal 170&lt;/li&gt;
&lt;li&gt;数学 quant 170&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;计划有变，被迫退考（&lt;/p&gt;</summary>
    
    
    
    
    <category term="Language" scheme="https://alleysira.github.io/tags/Language/"/>
    
  </entry>
  
  <entry>
    <title>buffer_overflow</title>
    <link href="https://alleysira.github.io/2022/05/14/buffer-overflow/"/>
    <id>https://alleysira.github.io/2022/05/14/buffer-overflow/</id>
    <published>2022-05-14T00:25:31.000Z</published>
    <updated>2023-02-28T02:43:51.911Z</updated>
    
    <content type="html"><![CDATA[<h1 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h1><p>函数调用时入栈情况</p><p><img src="https://s2.loli.net/2022/05/14/6oJeyQ27MnrwL3R.png" alt="image-20220514082742104"></p><p>call指令压入返回地址</p><p>ret弹出返回地址</p><span id="more"></span><h1 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h1><p><img src="https://s2.loli.net/2022/05/14/JMnBTvjI2s19eXO.png" alt="image-20220514084505285"></p><p>堆溢出更加困难</p><h1 id="BSS溢出"><a href="#BSS溢出" class="headerlink" title="BSS溢出"></a>BSS溢出</h1><p>全局和静态的未初始化变量，连续存放</p><p>格式化串溢出</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;栈溢出&quot;&gt;&lt;a href=&quot;#栈溢出&quot; class=&quot;headerlink&quot; title=&quot;栈溢出&quot;&gt;&lt;/a&gt;栈溢出&lt;/h1&gt;&lt;p&gt;函数调用时入栈情况&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/05/14/6oJeyQ27MnrwL3R.png&quot; alt=&quot;image-20220514082742104&quot;&gt;&lt;/p&gt;
&lt;p&gt;call指令压入返回地址&lt;/p&gt;
&lt;p&gt;ret弹出返回地址&lt;/p&gt;</summary>
    
    
    
    <category term="Architecture" scheme="https://alleysira.github.io/categories/Architecture/"/>
    
    
    <category term="Architecture" scheme="https://alleysira.github.io/tags/Architecture/"/>
    
  </entry>
  
</feed>
