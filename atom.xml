<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Alleysira&#39;s blog</title>
  
  
  <link href="https://alleysira.github.io/atom.xml" rel="self"/>
  
  <link href="https://alleysira.github.io/"/>
  <updated>2024-03-05T13:53:11.472Z</updated>
  <id>https://alleysira.github.io/</id>
  
  <author>
    <name>Alleysira</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>EtherDiffer</title>
    <link href="https://alleysira.github.io/2024/03/01/EtherDiffer/"/>
    <id>https://alleysira.github.io/2024/03/01/EtherDiffer/</id>
    <published>2024-03-01T07:53:45.000Z</published>
    <updated>2024-03-05T13:53:11.472Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Kim S, Hwang S. EtherDiffer: Differential Testing on RPC Services of Ethereum Nodes[C]//Proceedings of the 31st ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering. 2023: 1333-1344.</p><span id="more"></span><p>挑战</p><ul><li>测试用例生成<ul><li>语义有效的测试用例</li><li>语义无效但是可执行的测试用例：变异生成</li></ul></li><li>执行交易前的初始状态一致</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Kim S, Hwang S. EtherDiffer: Differential Testing on RPC Services of Ethereum Nodes[C]//Proceedings of the 31st ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering. 2023: 1333-1344.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>consensus_fuzz</title>
    <link href="https://alleysira.github.io/2024/02/26/consensus-fuzz/"/>
    <id>https://alleysira.github.io/2024/02/26/consensus-fuzz/</id>
    <published>2024-02-26T01:48:02.000Z</published>
    <updated>2024-02-29T11:43:11.876Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>配置区块链共识漏洞检测工具</p><span id="more"></span><h1 id="Fluffy"><a href="#Fluffy" class="headerlink" title="Fluffy"></a>Fluffy</h1><p>Yang Y, Kim T, Chun B G. Finding consensus bugs in ethereum via multi-transaction differential fuzzing[C]//15th USENIX Symposium on Operating Systems Design and Implementation (OSDI 21). 2021: 349-365.</p><p>项目地址：<a href="https://github.com/snuspl/fluffy">https://github.com/snuspl/fluffy</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone  https://github.com/snuspl/fluffy</span><br><span class="line">sudo docker build -t fuzzer . </span><br></pre></td></tr></table></figure><p>发现存在ethereum-forkid和aes包的依赖问题</p><p>修改Cargo.toml，增加</p><p><code>ethereum-forkid = &quot;0.12.0&quot;</code></p><p>以及</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[patch.crates-io]</span><br><span class="line">syn = &#123; git = &quot;https://github.com/johnyangk/syn&quot;, branch = &quot;fix&quot;, optional = true &#125;</span><br><span class="line">aes = &#123; git = &quot;https://github.com/RustCrypto/block-ciphers&quot;,rev=&quot;aes-v0.3.2&quot;&#125;</span><br><span class="line">aes-soft = &#123; git = &quot;https://github.com/RustCrypto/block-ciphers&quot;,rev = &quot;aes-soft-v0.3.0&quot;&#125;</span><br><span class="line">aesni = &#123; git = &quot;https://github.com/RustCrypto/block-ciphers&quot;,rev = &quot;aesni-v0.6.0&quot;&#125;</span><br><span class="line">block-cipher-trait = &#123; git = &quot;https://github.com/RustCrypto/traits&quot;, rev = &quot;block-cipher-trait-v0.6.0&quot; &#125;</span><br><span class="line">stream-cipher = &#123; git = &quot;https://github.com/RustCrypto/traits&quot;, rev = &quot;stream-cipher-v0.3.0&quot;&#125;</span><br></pre></td></tr></table></figure><p>问题诸多，相关问题已经在<a href="https://github.com/snuspl/fluffy/issues/2">issue</a>中提出</p><h1 id="LOKI"><a href="#LOKI" class="headerlink" title="LOKI"></a>LOKI</h1><p><a href="https://github.com/ConsensusFuzz/LOKI/tree/main">https://github.com/ConsensusFuzz/LOKI/tree/main</a></p><p>缺少对Geth的实现</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;配置区块链共识漏洞检测工具&lt;/p&gt;</summary>
    
    
    
    
    <category term="consensus" scheme="https://alleysira.github.io/tags/consensus/"/>
    
  </entry>
  
  <entry>
    <title>ITYFuzz</title>
    <link href="https://alleysira.github.io/2024/02/22/ITYFuzz/"/>
    <id>https://alleysira.github.io/2024/02/22/ITYFuzz/</id>
    <published>2024-02-22T02:48:06.000Z</published>
    <updated>2024-03-05T13:52:02.224Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Shou C, Tan S, Sen K. Ityfuzz: Snapshot-based fuzzer for smart contract[C]//Proceedings of the 32nd ACM SIGSOFT International Symposium on Software Testing and Analysis. 2023: 322-333.</p><span id="more"></span><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>作者个人主页：<a href="https://scf.so/">https://scf.so/</a></p><p>因为智能合约依赖于复杂的区块链状态，难以fuzz。对交易序列进行变异很复杂，并且通常会导致对输入和程序空间的次优探索空间。</p><p>创新点：</p><ul><li><p>ItyFuzz是基于快照的模糊测试器，对状态和单个交易进行快照。</p></li><li><p>引入了数据流路径点（waypoint）机制来辨认更有潜力的状态。</p></li><li>利用比较航点机制来删减状态空间。</li></ul><p>结论：通过维护状态快照，ITYFUZZ能够综合考虑具体的漏洞（重入），响应时间快，支持对链上合约及时验证</p><p>实验：对真实世界合约和被黑的Defi项目进行了实验，指令覆盖率和发现的漏洞均优于现有fuzzer。</p><p>项目开源地址：<a href="https://github.com/fuzzland/ityfuzz">https://github.com/fuzzland/ityfuzz</a></p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>智能合约审计现在是十亿美元规模的行业，审计的目的是确保合约没有漏洞，不会导致存储在合约内的资产损失。目前的模糊测试工具仅支持在本地环境中模糊测试，而不是直接在区块链上。链上模糊测试的挑战在于对给定状态的探索要足够快，因为链上状态在不断变化；攻击者可能在任何时候发起攻击。现有fuzzer效率不够高，不能即时获得链上状态并迅速完成审计。</p><p>链上审计的必要性可以通过以下场景来说明：</p><ul><li>特定代码只能在特定的链上状态下才能到达（确实），本地执行永远无法到达</li><li>目前的合约依赖外部的合约作为信息来源，链上审计可以即时获得信息（如预言机）</li></ul><p>链上审计的挑战在于必须要在攻击者执行攻击前暂停合约</p><ul><li>链上审计需要的时间需要是秒级，现有的工具对时间优化不足，覆盖合约的全部指令需要若干小时<ul><li>ITYFuzz能在几秒内达到较高的覆盖率</li></ul></li><li>fuzz合约的挑战在于：合约依赖状态，合约的依赖复杂<ul><li>为了解决状态的问题，一些之前的工作每次fuzz均从全新状态开始，以一系列交易作为输入；变异阶段部分交易序列被变异，因此现有工具在重新执行交易以返回到先前状态时存在较高的开销。对于需要通过多个交易建立的深层状态进行探索，重新执行的成本呈线性增长。此外，现有工具只针对交易具有反馈机制，而不针对状态，然而状态和交易具有不同的探索难度。</li><li>作者认为，对于具有状态的模糊测试，状态的有趣性与事务的有趣性同样重要，而当前的状态模糊测试工具中不存在选择有趣状态进行探索的反馈机制。（即不再从fresh state开始）</li></ul></li></ul><p>快照（Snapshot）本质上是某些交易触发的中间状态的复制，通过将所有有趣的快照存储在状态语料库（corpus）中，能够以O(1)的复杂度“时间穿越”到先前的状态，支持对交易和状态空间的高效探索</p><p>重构了一个现有的EVM实现来支持快速的快照</p><p>由于运行时内存资源有限，将所有快照存储到语料库中仍然不现实，而快照的数量随着总执行时间的增加而线性增加。存储的快照大小可能在几秒钟内增长到几个千兆字节。为了解决这个问题并优先探索最有趣的状态，作者设计了两种反馈机制（即路径点）来对有趣的状态进行分类，并设计了一种语料库修剪技术，在必要时减少有趣状态的数量。</p><p>同样可以适用到其他领域，如现代硬件设计</p><p>贡献</p><ul><li>提出一种基于快照的模糊测试算法，以减少有状态智能合约模糊测试的重新执行开销</li><li>提出了新的路径点机制，支持高效程序探索<ul><li>数据流路径点：基于未来加载的内存</li><li>对比路径点：概率性采样和固定采样结合</li></ul></li><li>开发了模糊测试工具，展示了其有效性</li><li>提出了一种新的智能合约审计方法，该方法基于从区块链上获取的状态进行测试，检测和复现了价值数百万美元的在线项目的漏洞。</li></ul><h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><h2 id="fuzzing"><a href="#fuzzing" class="headerlink" title="fuzzing"></a>fuzzing</h2><p>为了提高探索效率，模糊测试器一般会采用启发式方法或反馈机制来变异已有的输入生成新的输入</p><p>算法例子：初始时的语料库为空，如果某次执行覆盖了新的点则该执行</p><p>这里的伪代码多少有点问题：</p><ul><li><code>if</code>后面一行应该是 $I\gets I\  \cup \ i_m$</li><li>corpus可能会变为空</li></ul><p><img src="/2024/02/22/ITYFuzz/image-20240222163752301.png" alt="image-20240222163752301"></p><p>合约的fuzzer必须输入为一系列的交易</p><h2 id="waypoint"><a href="#waypoint" class="headerlink" title="waypoint"></a>waypoint</h2><p>FuzzFactory[OOPSLA19]引入了一般化的反馈机制waypoint。路径点是在执行目标程序后提供有趣反馈的中间输入。例如，在覆盖引导的模糊测试算法中，如果运行目标程序产生新的覆盖，就会记录新的输入（路径点）。然而，路径点不仅限于覆盖点，其他常见的路径点还包括执行时间、内存使用和两个比较值之间的距离等。为了实现定制的路径点，我们需要在程序执行过程中收集其他目标动态信息，并提供一个新的谓词函数 <code>is_interesting</code>替换图1中的 第9行</p><h1 id="Motivating-Example"><a href="#Motivating-Example" class="headerlink" title="Motivating Example"></a>Motivating Example</h1><p><img src="/2024/02/22/ITYFuzz/image-20240223110801874.png" alt="image-20240223110801874"></p><p>对于上面的合约，调用inc 0, inc 1, buggy() 即可出发漏洞</p><p>现实世界中的交易序列可能会相当复杂和长，当T增大时，现有的漏洞检测工具 如SMARTIAN不能即时检测出漏洞</p><p>直观来想，如果随机调用函数，抵达某个指定深度的时间是指数级的，重复执行来到达某个指定状态的（比如目标是10，到达8）的操作架重执行。SMARTIAN中，重新执行占据了总模糊测试时间的90%以上。</p><p>如果在执行一系列交易后到达的状态可以被记忆，那么重新执行的时间可以被消除。然而，记忆化需要保存的状态数量与交易序列的指数成正比。ItyFuzz的关键在于是只能记忆化一组“有趣的状态”，称为快照，而不是记忆化所有中间状态，并且仅使用这些有趣的状态来探索新状态而无需重新执行。一个状态的“有趣程度”是通过两个新颖的航点概念来定义的。</p><p><img src="/2024/02/22/ITYFuzz/image-20240223112037082.png" alt="image-20240223112037082"></p><h1 id="Methodology"><a href="#Methodology" class="headerlink" title="Methodology"></a>Methodology</h1><h2 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h2><p><img src="/2024/02/22/ITYFuzz/image-20240225101344843.png" alt="image-20240225101344843"></p><p>可以把EVM理解为$S\times T \to S$，状态在输入交易下发生变化</p><p>和现有工具一样，ITYFuzz的输入是<strong>种子输入语料库</strong>，每次从库中选一个种子（交易和状态）作为输入交给EVM执行，执行后使用 <strong>执行路径点</strong> 来判断当前执行是否增加了覆盖率，如果增加了把(s,t)就加入到语料库中。(会记录当前的执行状态$s$，这就是快照的含义)</p><h2 id="snapshot-based-fuzzing"><a href="#snapshot-based-fuzzing" class="headerlink" title="snapshot-based fuzzing"></a>snapshot-based fuzzing</h2><p>为了返回到某个中间状态，现有方法是重新执行交易。本文直接记录状态并保存</p><p>由于快照仅记录执行交易前的状态s和交易，丢失了执行交易后的状态$s’$，本文设计了另外一个语料库infant state corpus”，来记录执行后的状态，以判断当前状态是否能导致未来的有趣的执行。</p><p><img src="/2024/02/22/ITYFuzz/image-20240225111932947.png" alt="image-20240225111932947"></p><p>变异有两种可能，变异后的st永远是sound的（交易可以随便造，状态是从历史状态中得到的，意味着可能从一个交易序列到达记录的状态）</p><ul><li>变异交易：变异器来执行</li><li>变异状态，从$C_s$ 中选一个</li></ul><p>执行完交易后进行两个路径点判断</p><h2 id="Dataflow-Waypoint"><a href="#Dataflow-Waypoint" class="headerlink" title="Dataflow Waypoint"></a>Dataflow Waypoint</h2><p>目前有了对输入有趣程度进行度量的waypoint机制（FuzzFactory），没有对状态的路程点定义。设置航点的目标是判断从这些状态出发的的未来执行是否有趣，因此设计需要获得关于状态有趣程度的语义信息。</p><p>主要从两个方面来思考</p><ul><li><p>如果内存是未来的load指令的目标，可能是有趣的</p></li><li><p>如果状态变化包括了对某些特殊内存位置的写</p></li></ul><p>作者利用字节码插桩来进行动态数据流分析，通过观察运行时的load和store指令。由于传统的数据流分析是通过对源代码进行静态分析来实现的。然而，静态分析工具在智能合约模糊测试中效果不佳，因为智能合约可能会动态地调用外部合约。然而，仅从目标合约获取的静态数据流信息是不够的。</p><p>由于决定内存位置的“有趣程度”的load指令发生在未来，因此目前无法确定store指令的“有趣程度”。为了解决这个问题，本文提出了利用过去的load来估计未来可能的有趣的地址。</p><p>ItyFuzz跟踪过去加载过的内存位置以及被加载的值的抽象。如果当前执行中的值存储操作写入了这样一个内存位置，并且被写入的值的抽象与该位置之前存储的所有抽象值都不同，那么我们称这个存储操作是有趣的，并且在存储之后产生的状态也是有趣的。</p><p>插桩算法维护了两个map，分别记录是否执行过load和是否执行过store以及store的值</p><p><img src="/2024/02/22/ITYFuzz/image-20240225164440432.png" alt="image-20240225164440432"></p><p>Loc % MAP_SIZE是对Loc的粗略抽象，为了创建一个较小的抽象地址空间。较小的抽象地址空间有助于降低存储和查找开销。</p><p>桶抽象是类似于AFL中使用的分桶机制。分桶有助于减少插入映射的总值量，从而减少存储和评估成本，以换取插入数据的粒度损失。每个桶是实际值域的一个分区，在EVM的上下文中，实际值是一个256位整数。使用桶来避免存储所有状态。执行Store(Loc, Value)时，首先抽象出值该在的桶，再检查S(loc%size)(bucket(v))是否为true。</p><p>执行后，如果存储map中的一个桶从false变为true，并且L(Loc % MAP_SIZE)的相应位置也为true（算法2的第2行），则认为新状态是有趣的。每个桶的大小和范围可以作为超参数进行调整。每个槽中的桶数量越多，评估为有趣的状态就越多，$C_s$的大小也会增加。随着$C_s$的增大，选择下一个要探索的状态变得更加困难，并且会引起存储开销。</p><p><img src="/2024/02/22/ITYFuzz/image-20240225164449714.png" alt="image-20240225164449714"></p><h2 id="Comparison-Waypoint"><a href="#Comparison-Waypoint" class="headerlink" title="Comparison Waypoint"></a>Comparison Waypoint</h2><p>只采用dataflow航点存在的问题，由于过于抽象，如果桶2-4已经有了2,3的状态就不再被认为是有趣的了。如果只使用数据流航点，如果域的划分（即桶）对于目标智能合约来说不够精细，那么可能无法包含某些状态。</p><p>细粒度划分的问题在于初始状态语料库中的状态数量庞大，这会导致对于大型智能合约而言，随着时间的推移内存使用开销巨大。为了有效地解决这个开销问题，本文提出使用比较航点。比较航点只考虑所有<strong>中间状态</strong>，其中一些比较指令的操作数相比之前的执行更接近彼此，这对于达到更高的覆盖率是必需的，被认为是有趣的。</p><p><img src="/2024/02/22/ITYFuzz/image-20240225174337363.png" alt="image-20240225174337363"></p><p>ItyFuzz使用最大可能值初始化一个局部映射$C_{local}$，该映射仅针对当前执行。在执行过程中，对于每个比较指令，ItyFuzz根据程序计数器%MAP_SIZE（即比较指令的位置）更新键值对应的距离（第4行less than和第6行）。距离反映了两个值在比较中实现平衡的接近程度，由它们之间差值的绝对值确定。例如，如果ItyFuzz处理EQ(1, 3)操作，距离将为2。当执行中的任何比较指令更有可能为真时，执行被认为是有趣的。换句话说，在算法4中描述的方式，如果当前执行在local映射中显示的距离比记录在先前执行中最小距离的映射（）中的距离更小，则认为该执行是有趣的。</p><p>比较点能够用于判断是否该将状态从$C_s$中移除，算法4是具体的投票算法，票数反应了状态的有趣程度。</p><p><img src="/2024/02/22/ITYFuzz/image-20240225192248662.png" alt="image-20240225192248662"></p><h1 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h1><p>基于LibAFL，revm作为EVM的执行引擎；支持从支持Geth的链的某个状态开始fuzz</p><p>开源地址：<a href="https://github.com/fuzzland/ityfuzz">https://github.com/fuzzland/ityfuzz</a></p><h1 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h1><p>考虑</p><ul><li>覆盖率：在3个数据集上，对比1个工具</li><li>能否发现现实世界中的漏洞<ul><li>36/42个项目中已知的漏洞</li><li>45000个合约项目（BSC和以太坊，均有&gt;100个交易），1384项目发现了漏洞</li></ul></li><li>存储快照带来的内存开销，以及能否被waypoint解决</li><li>链上审计对发现合约漏洞的帮助<ul><li>研究了两个被黑的defi项目，给出的实例证明了，仅仅在开发环境中测试室不够的，还需要链上审计</li><li><img src="/2024/02/22/ITYFuzz/image-20240305205240351.png" alt="image-20240305205240351"></li></ul></li><li>效率是否支持链上审计</li></ul><p>数据集</p><ul><li>论文里的数据集 57个合约<ul><li>Sunbeom So, Myungho Lee, Jisu Park, Heejo Lee, and Hakjoo Oh. 2020. VERISMART: A Highly Precise Safety Verier for Ethereum Smart Contracts. In 2020 IEEE Symposium on Security and Privacy, SP 2020, San Francisco, CA, USA, May 18-21, 2020. IEEE, 1678–1694. <a href="https://doi.org/10.1109/SP40000.2020.00032">https://doi.org/10.1109/SP40000.2020.00032</a></li></ul></li><li>以太坊收集的572个合约</li></ul><p>对比工作</p><ul><li>SMARTIAN：比较了覆盖率</li></ul><p>时间优势来源于快照缩减了re-execution时间；comparison waypoints能够快速提高覆盖率</p><p><img src="/2024/02/22/ITYFuzz/image-20240305203726288.png" alt="image-20240305203726288"></p><p><img src="/2024/02/22/ITYFuzz/image-20240305203735599.png" alt="image-20240305203735599" style="zoom:67%;"></p><p>对比实验不够，做消融实验ablation study</p><p><img src="/2024/02/22/ITYFuzz/image-20240305204523492.png" alt="image-20240305204523492"></p><p>为了研究对内存开销的依赖</p><p><img src="/2024/02/22/ITYFuzz/image-20240305204653257.png" alt="image-20240305204653257"></p><h1 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work"></a>Related work</h1><h2 id="反馈驱动的模糊测试"><a href="#反馈驱动的模糊测试" class="headerlink" title="反馈驱动的模糊测试"></a>反馈驱动的模糊测试</h2><ul><li>基于覆盖率的模糊测试：AFL HonggFuzz FairFuzz</li><li>自定义的waypoint：<ul><li>Validity fuzzing利用输入的有效性作为反馈</li><li>采用程序执行的深度；</li><li>FuzzFatory形式化了waypoint机制</li></ul></li></ul><h2 id="带状态的模糊测试"><a href="#带状态的模糊测试" class="headerlink" title="带状态的模糊测试"></a>带状态的模糊测试</h2><ul><li>SMARTIAN 从0状态开始，发送一系列交易到达目的状态</li><li>Nyx采用了操作系统层面的快照策略 Nyx-Net</li><li>CorbFuzz对web应用程序进行fuzz，对状态进行了建模</li></ul><h2 id="智能合约安全工具"><a href="#智能合约安全工具" class="headerlink" title="智能合约安全工具"></a>智能合约安全工具</h2><ul><li><p>ContractFuzzer</p></li><li><p>Echidna Harvey 工业界的fuzzer</p></li><li>SMARTIAN hybrid，混合了静态分析和动态 数据流分析</li></ul><h1 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h1><ul><li>什么是链上审计？如果链上进行模糊测试，支持的每秒测试次数是多少</li><li>快照带来的额外存储代价评估</li><li>从语料库中选择种子的算法</li><li>每个桶的大小和范围如何设置和调节<ul><li>参考了AFL的设计，AFL的桶是1-2,2-4,4-8</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Shou C, Tan S, Sen K. Ityfuzz: Snapshot-based fuzzer for smart contract[C]//Proceedings of the 32nd ACM SIGSOFT International Symposium on Software Testing and Analysis. 2023: 322-333.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>conference deadlines</title>
    <link href="https://alleysira.github.io/2024/01/21/ddl/"/>
    <id>https://alleysira.github.io/2024/01/21/ddl/</id>
    <published>2024-01-21T08:30:43.000Z</published>
    <updated>2024-02-29T11:25:53.438Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>ddl是第一生产力</p><span id="more"></span><h1 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h1><ul><li><p>NDSS24</p><ul><li>开会时间：26 February to 1 March 2024</li><li>summer: Wed, 19 Apr 2023</li><li><strong>fall: Wed, 28 Jun 2023</strong></li></ul></li><li><p>USENIX Security24 </p><ul><li>开会时间：AUGUST 14–16, 2024</li><li><strong>Summer Deadline: Tuesday, June 6, 2023</strong></li><li><strong>Fall Deadline: Tuesday, October 17, 2023</strong></li><li>Winter Deadline: Thursday, February 8, 2024</li></ul></li><li><p>CCS 2024 </p><ul><li>开会时间：October 14-18</li><li>Jan 28, 2024 </li><li>April 29th Deadline</li></ul></li><li><p>S&amp;P 2024 </p><ul><li>开会时间：MAY 20-23</li><li>April 13 2023</li><li><strong>August 3 2023</strong></li><li><strong>December 6, 2023</strong></li></ul></li><li><p>ESORICS 2024</p><ul><li>开会：September 16-20, 2024</li><li>January 8, 2024</li><li>Sat Apr 20th 2024 19:59:59 CST (2024-04-19 23:59:59 UTC-12)</li></ul></li></ul><h1 id="Software-engineering"><a href="#Software-engineering" class="headerlink" title="Software engineering"></a>Software engineering</h1><ul><li>ICSE 2025 <ul><li>开会：April 26-May 4 2025 </li><li>Mar 22, 2024</li><li><strong>Aug 2, 2024</strong></li></ul></li><li>ASE 2024<ul><li>开会：Sun 27 October - Fri 1 November 2024</li><li><strong>Fri 7 Jun 2024</strong></li></ul></li><li>ESEC/FSE 2024<ul><li>开会：Mon 15 - Fri 19 July 2024</li><li><strong>Thursday, September 28, 2023</strong></li></ul></li><li>ISSTA 2024<ul><li>开会： Mon 16 - Fri 20 September 2024</li><li><strong>Fri 15 Dec 2023</strong></li><li>Fri 12 Apr 2024</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;ddl是第一生产力&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>WRTester</title>
    <link href="https://alleysira.github.io/2024/01/13/WRTester/"/>
    <id>https://alleysira.github.io/2024/01/13/WRTester/</id>
    <published>2024-01-13T14:33:54.000Z</published>
    <updated>2024-01-13T15:14:31.327Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Cao S, He N, She X, et al. WRTester: Differential Testing of WebAssembly Runtimes via Semantic-aware Binary Generation[J]. arXiv preprint arXiv:2312.10456, 2023.</p><span id="more"></span><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>现有的测试框架受到测试用例质量的限制，即它们在生成语义丰富和语法正确的Wasm二进制文件方面面临挑战，因此无法触发复杂的错误。对真实世界Wasm二进制文件的反汇编和汇编来生成复杂的Wasm测试用例，从而触发Wasm运行时之间的隐藏不一致性。为了进一步确定意外行为的根本原因，我们设计了一种与运行时无关的根本原因定位方法，可以准确地定位错误。广泛的评估表明，WRTester在效率和效果方面优于现有技术。</p><p>在流行的Wasm运行时中发现了33个漏洞，其中25个已经得到确认。</p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>尽管最近的自动化测试方法通过Wasm二进制生成在识别Wasm运行时错误方面取得了有希望的结果，但它们受到无法生成语义丰富二进制文件的限制，因此无法触发复杂的错误。</p><p>例如，WADIFF只能测试单个指令级别的实现错误，因为它无法生成具有大量指令的测试用例，而真实世界的Wasm二进制文件实际上要复杂得多。具体而言，Wasm中存在超过430种指令和13种具有不同功能的部分类型，这表明Wasm是一种具有丰富语义的字节码格式。为了进行全面的测试，确保生成的Wasm二进制文件尽可能涵盖多样的语义是至关重要和必要的。</p><p>此外，不可能任意生成Wasm二进制文件，因为每个Wasm二进制文件在执行之前都应该经过语法正确性验证，包括堆栈平衡验证等，这确保了生成的Wasm二进制文件应该是符合语法的。</p><p>主要工作：从真实世界的Wasm二进制文件中提取基本元素，并将它们随机组装成具有有效语法和丰富语义的Wasm二进制文件的算法。</p><p>NeoDiff是随机在已有字节码后拼接、翻转比特、插入字节或进行特殊操作</p><p><img src="/2024/01/13/WRTester/image-20240113223841937.png" alt="image-20240113223841937"></p><p>对应的CVE，确认时间</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Cao S, He N, She X, et al. WRTester: Differential Testing of WebAssembly Runtimes via Semantic-aware Binary Generation[J]. arXiv preprint arXiv:2312.10456, 2023.&lt;/p&gt;</summary>
    
    
    
    
    <category term="Wasm" scheme="https://alleysira.github.io/tags/Wasm/"/>
    
    <category term="Differential Testing" scheme="https://alleysira.github.io/tags/Differential-Testing/"/>
    
  </entry>
  
  <entry>
    <title>minGasPoc</title>
    <link href="https://alleysira.github.io/2024/01/13/minGasPoc/"/>
    <id>https://alleysira.github.io/2024/01/13/minGasPoc/</id>
    <published>2024-01-13T13:32:42.000Z</published>
    <updated>2024-01-13T15:12:38.043Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>尝试构造out of gas的攻击</p><span id="more"></span><h1 id="攻击概述"><a href="#攻击概述" class="headerlink" title="攻击概述"></a>攻击概述</h1><p>目的：使得jsevm run out of gas</p><p>方法：设置geth pyevm jsevm当前交易的gaslimt为0xccc，jsevm需要0x168a</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># geth 修改调用evm的gas不起作用，只能修改genesis.json中的gaslimit</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;gasLimit&quot;</span>: <span class="string">&quot;0xccc&quot;</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment"># pyevm runBytecode.py</span></span><br><span class="line">    call_txn = new_transaction(</span><br><span class="line">        chain.get_vm(),</span><br><span class="line">        SENDER,</span><br><span class="line">        simple_contract_address,</span><br><span class="line">        private_key=SENDER_PRIVATE_KEY,</span><br><span class="line">        gas=0xffff,</span><br><span class="line">        <span class="comment"># data=function_selector,</span></span><br><span class="line">        data=decode_hex(args.signature),</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line"><span class="comment"># runBytecode.js</span></span><br><span class="line">const results = await evm.runCall(&#123;</span><br><span class="line">gasLimit: BigInt(<span class="string">&#x27;0x&#x27;</span>+<span class="string">&#x27;ccc&#x27;</span>),</span><br><span class="line">data: hexToBytes(sig),</span><br><span class="line">to: contractAddress,</span><br><span class="line"><span class="built_in">caller</span>: new Address(hexToBytes(<span class="string">&quot;0x1c7cd2d37ffd63856a5bd56a9af1643f2bcf545f&quot;</span>))</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>给定输入<code>data=0xfe575a87000000000000000000000000bffd98ec9ba3dc965b8a97d876670bb367fa84c2</code>，执行函数<code>isBlacklisted()</code>，成功</p><p><img src="/2024/01/13/minGasPoc/image-20240113213936348.png" alt="image-20240113213936348"></p><p>但是目前的问题是geth和pyevm均是revert，交易没有真正执行</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># geth</span><br><span class="line">&#123;<span class="attr">&quot;pc&quot;</span>:<span class="number">23471</span>,<span class="attr">&quot;op&quot;</span>:<span class="number">253</span>,<span class="attr">&quot;gas&quot;</span>:<span class="string">&quot;0x2fe312&quot;</span>,<span class="attr">&quot;gasCost&quot;</span>:<span class="string">&quot;0x0&quot;</span>,<span class="attr">&quot;memSize&quot;</span>:<span class="number">192</span>,<span class="attr">&quot;stack&quot;</span>:[<span class="string">&quot;0xfe575a87&quot;</span>,<span class="string">&quot;0xcaf&quot;</span>,<span class="string">&quot;0xbffd98ec9ba3dc965b8a97d876670bb367fa84c2&quot;</span>,<span class="string">&quot;0x0&quot;</span>,<span class="string">&quot;0x3f94&quot;</span>,<span class="string">&quot;0x80&quot;</span>,<span class="string">&quot;0x80&quot;</span>,<span class="string">&quot;0x0&quot;</span>,<span class="string">&quot;0x7018&quot;</span>],<span class="attr">&quot;depth&quot;</span>:<span class="number">1</span>,<span class="attr">&quot;refund&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;opName&quot;</span>:<span class="string">&quot;REVERT&quot;</span>,<span class="attr">&quot;error&quot;</span>:<span class="string">&quot;execution reverted&quot;</span>&#125;</span><br><span class="line">&#123;<span class="attr">&quot;output&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="attr">&quot;gasUsed&quot;</span>:<span class="string">&quot;0xcc6&quot;</span>,<span class="attr">&quot;error&quot;</span>:<span class="string">&quot;execution reverted&quot;</span>&#125;</span><br><span class="line"># python</span><br><span class="line">&#123;<span class="attr">&quot;pc&quot;</span>: <span class="number">23471</span>, <span class="attr">&quot;op&quot;</span>: <span class="number">253</span>, <span class="attr">&quot;gas&quot;</span>: <span class="string">&quot;0x9f81&quot;</span>, <span class="attr">&quot;gasCost&quot;</span>: <span class="string">&quot;0x0&quot;</span>, <span class="attr">&quot;stack&quot;</span>: [<span class="string">&quot;0xfe575a87&quot;</span>, <span class="string">&quot;0xaf0c&quot;</span>, <span class="string">&quot;0xc284fa67b30b6776d8978a5b96dca39bec98fdbf&quot;</span>, <span class="string">&quot;0x0&quot;</span>, <span class="string">&quot;0x943f&quot;</span>, <span class="string">&quot;0x80&quot;</span>, <span class="string">&quot;0x8000000000000000000000000000000000000000000000000000000000000000&quot;</span>, <span class="string">&quot;0x0&quot;</span>, <span class="string">&quot;0x1870&quot;</span>, <span class="string">&quot;0x0&quot;</span>, <span class="string">&quot;0x0&quot;</span>], <span class="attr">&quot;depth&quot;</span>: <span class="number">0</span>, <span class="attr">&quot;opName&quot;</span>: <span class="string">&quot;REVERT&quot;</span>, <span class="attr">&quot;error&quot;</span>: <span class="string">&quot;None&quot;</span> &#125;</span><br><span class="line">&#123;<span class="attr">&quot;output&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="attr">&quot;gasUsed&quot;</span>: <span class="string">&quot;0xcc6&quot;</span>&#125;</span><br><span class="line"># jsevm</span><br><span class="line">&#123;<span class="attr">&quot;pc&quot;</span>:<span class="number">16225</span>,<span class="attr">&quot;gas&quot;</span>:<span class="string">&quot;0x107&quot;</span>,<span class="attr">&quot;gasCost&quot;</span>:<span class="string">&quot;0x0&quot;</span>,<span class="attr">&quot;memory&quot;</span>:<span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012800000000000000000000000000000000254879013500000000000019125315223615516322015091138151216118103111791032501321940000000000000000000000000000&quot;</span>,<span class="attr">&quot;memsize&quot;</span>:<span class="string">&quot;6&quot;</span>,<span class="attr">&quot;stack&quot;</span>:[<span class="string">&quot;0xfe575a87&quot;</span>,<span class="string">&quot;0xcaf&quot;</span>,<span class="string">&quot;0xbffd98ec9ba3dc965b8a97d876670bb367fa84c2&quot;</span>,<span class="string">&quot;0x0&quot;</span>,<span class="string">&quot;0x0&quot;</span>,<span class="string">&quot;0xfe575a87&quot;</span>,<span class="string">&quot;0xa4&quot;</span>,<span class="string">&quot;0x20&quot;</span>,<span class="string">&quot;0x80&quot;</span>,<span class="string">&quot;0x24&quot;</span>,<span class="string">&quot;0x80&quot;</span>,<span class="string">&quot;0x0&quot;</span>,<span class="string">&quot;0x107&quot;</span>],<span class="attr">&quot;depth&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;opName&quot;</span>:<span class="string">&quot;STATICCALL&quot;</span>&#125;</span><br><span class="line">&#123;<span class="attr">&quot;output&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="attr">&quot;gasUsed&quot;</span>:<span class="string">&quot;0xccc&quot;</span>,<span class="attr">&quot;error&quot;</span>:&#123;<span class="attr">&quot;error&quot;</span>:<span class="string">&quot;out of gas&quot;</span>,<span class="attr">&quot;errorType&quot;</span>:<span class="string">&quot;EvmError&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>问题似乎在于ethereumjs的staticcall的gas被计算了，而gas和pyevm执行staticcall的gas消耗被忽略了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// initializer is not initialized</span><br><span class="line">function isBlacklisted(address account) external view returns (bool) &#123;</span><br><span class="line"></span><br><span class="line">    return initializer.isBlacklisted(account);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在remix上不支持过长的合约，只能开启optimizer（200），然后调用isBlacklisted函数，注意到remix VM的gas消耗为5366</p><p><img src="/2024/01/13/minGasPoc/image-20240113220635216.png" alt="image-20240113220635216"></p><p>remix报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;error&quot;</span>: <span class="string">&quot;Failed to decode output: Error: hex data is odd-length (argument=&quot;</span>value<span class="string">&quot;, value=&quot;</span>0x0<span class="string">&quot;, code=INVALID_ARGUMENT, version=bytes/5.7.0)&quot;</span></span><br></pre></td></tr></table></figure><p>尝试了不同的地址依然存在问题</p><p>在remix中先执行setInitializer，依然执行错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function setInitializer(address init) public onlyOwner &#123;</span><br><span class="line"></span><br><span class="line">    require(!tradingEnabled);</span><br><span class="line"></span><br><span class="line">    require(init != address(this), &quot;Can&#x27;t be self.&quot;);</span><br><span class="line"></span><br><span class="line">    initializer = Initializer(init);</span><br><span class="line"></span><br><span class="line">    try initializer.getConfig() returns (address router, address constructorLP) &#123;</span><br><span class="line"></span><br><span class="line">        dexRouter = IRouter02(router); lpPair = constructorLP; lpPairs[lpPair] = true; </span><br><span class="line"></span><br><span class="line">        _approve(_owner, address(dexRouter), type(uint256).max);</span><br><span class="line"></span><br><span class="line">        _approve(address(this), address(dexRouter), type(uint256).max);</span><br><span class="line"></span><br><span class="line">    &#125; catch &#123; revert(); &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/01/13/minGasPoc/image-20240113222653503.png" alt="image-20240113222653503"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;尝试构造out of gas的攻击&lt;/p&gt;</summary>
    
    
    
    
    <category term="EVM" scheme="https://alleysira.github.io/tags/EVM/"/>
    
  </entry>
  
  <entry>
    <title>chainmaker</title>
    <link href="https://alleysira.github.io/2024/01/11/chainmaker/"/>
    <id>https://alleysira.github.io/2024/01/11/chainmaker/</id>
    <published>2024-01-11T06:03:35.000Z</published>
    <updated>2024-03-04T07:09:33.149Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>配置长安链</p><span id="more"></span><h1 id="长安链部署和配置"><a href="#长安链部署和配置" class="headerlink" title="长安链部署和配置"></a>长安链部署和配置</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装kubectl"><a href="#安装kubectl" class="headerlink" title="安装kubectl"></a>安装kubectl</h3><ul><li><a href="https://kubernetes.io/zh-cn/docs/reference/kubectl/">https://kubernetes.io/zh-cn/docs/reference/kubectl/</a></li><li>在根目录 <code>mkdir .kube</code>，将config文件cp到该目录下</li></ul><h3 id="本地安装长安链2-3-1"><a href="#本地安装长安链2-3-1" class="headerlink" title="本地安装长安链2.3.1"></a>本地安装长安链2.3.1</h3><ul><li><p>官方文档：<a href="https://docs.chainmaker.org.cn/v2.3.1/html/">https://docs.chainmaker.org.cn/v2.3.1/html/</a></p></li><li><p>安装go</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">wget https://golang.google.cn/dl/go1.18.10.linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">sudo rm -rf /usr/<span class="built_in">local</span>/go </span><br><span class="line">sudo tar -C /usr/<span class="built_in">local</span> -xzf go1.16.13.linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">vi /etc/profile</span><br><span class="line"><span class="comment"># 加入配置</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/go/bin</span><br><span class="line"><span class="comment"># 配置生效</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 换源</span></span><br><span class="line">go env GO11MODULE=on</span><br><span class="line">go env -w GOPROXY=https://goproxy.cn</span><br></pre></td></tr></table></figure></li><li><p>安装7.3版本以上的gcc</p></li><li><p>安装7zip </p><ul><li>```bash<br>sudo apt-get install p7zip-full p7zip-rar<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 安装docker，参考https://docs.docker.com/engine/install/ubuntu/#install-using-the-repository</span><br><span class="line">- 下载gitlab的pre仓库</span><br><span class="line">  - https://gitlab.distribute-compute.cn/chenzhu/pre</span><br><span class="line">- 安装完毕后测试智能合约是否能部署</span><br><span class="line"></span><br><span class="line">## 部署到云</span><br><span class="line"></span><br><span class="line">- 修改改k8sconfg/4.yml和Makefile里面的版本/命名空间</span><br><span class="line">- build docker </span><br><span class="line">  - `make docker-solo`</span><br><span class="line"></span><br><span class="line">- 提交docker，这部分需要</span><br><span class="line">  - `docker login -u xxx -p xxx xxx.myhuaweicloud.com`</span><br><span class="line"></span><br><span class="line">  - `make push`</span><br><span class="line"></span><br><span class="line">- 进入docker执行命令</span><br><span class="line">  - `kubectl exec docker-name -it /bin/bash -n mj`</span><br><span class="line"></span><br><span class="line">- 停止运行</span><br><span class="line">  - `make configFdown`</span><br><span class="line">- 在dockerfile中设置需要打包为docker的文件</span><br><span class="line"></span><br><span class="line"># SealEVM</span><br><span class="line"></span><br><span class="line">长安链EVM有两个开源仓库，不尽相同</span><br><span class="line"></span><br><span class="line">- github：https://github.com/SealSC/SealEVM</span><br><span class="line">- gitlab：https://git.chainmaker.org.cn/chainmaker/vm-evm</span><br><span class="line"></span><br><span class="line">gitlab的报错且没有文档</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line"># chainmaker.org/chainmaker/vm-evm/v2/evm-go/storage</span><br><span class="line">evm-go/storage/contractStorage.go:92:36: too many arguments in call to c.Ctx.CallContract</span><br><span class="line">        have (*common.Contract, *common.Contract, string, nil, map[string][]byte, number, common.TxType)</span><br><span class="line">        want (*common.Contract, string, []byte, map[string][]byte, uint64, common.TxType)</span><br><span class="line">evm-go/storage/contractStorage.go:206:13: undefined: &quot;chainmaker.org/chainmaker/utils/v2&quot;.NameToAddrInt</span><br><span class="line">evm-go/storage/contractStorage.go:351:36: too many arguments in call to c.Ctx.CallContract</span><br><span class="line">        have (*common.Contract, *common.Contract, string, []byte, map[string][]byte, uint64, common.TxType)</span><br><span class="line">        want (*common.Contract, string, []byte, map[string][]byte, uint64, common.TxType)</span><br><span class="line">evm-go/storage/contractStorage.go:359:36: too many arguments in call to c.Ctx.CallContract</span><br><span class="line">        have (*common.Contract, *common.Contract, string, []byte, map[string][]byte, uint64, common.TxType)</span><br><span class="line">        want (*common.Contract, string, []byte, map[string][]byte, uint64, common.TxType)</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>github的SealEVM能运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">go mod download </span><br><span class="line"><span class="built_in">cd</span> example</span><br><span class="line">./example</span><br><span class="line">go get: added chainmaker.org/chainmaker/common/v2</span><br></pre></td></tr></table></figure><ul><li><p>不支持PUSH0，因此虚拟机不支持shanghai分叉，支持使用solc 0.8.23 设定evm version为paris</p></li><li><p>gas计价混乱，只出现了0x3和SSTORE的两个值</p><ul><li>STOP计价为0x3</li><li><img src="/2024/01/11/chainmaker/image-20240204144319468.png" alt="image-20240204144319468"></li></ul></li></ul><h2 id="vm-evm"><a href="#vm-evm" class="headerlink" title="vm-evm"></a>vm-evm</h2><p>单测可以通过</p><p><img src="/2024/01/11/chainmaker/image-20240204143844766.png" alt="image-20240204143844766"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;配置长安链&lt;/p&gt;</summary>
    
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>sp23_find_spec_blind_spots_via_fuzz_testing</title>
    <link href="https://alleysira.github.io/2024/01/10/sp23-find-spec-blind-spots-via-fuzz-testing/"/>
    <id>https://alleysira.github.io/2024/01/10/sp23-find-spec-blind-spots-via-fuzz-testing/</id>
    <published>2024-01-10T09:22:21.000Z</published>
    <updated>2024-01-19T07:21:16.556Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Ji R, Xu M. Finding Specification Blind Spots via Fuzz Testing[C]//2023 IEEE Symposium on Security and Privacy (SP). IEEE Computer Society, 2023: 2708-2725.</p><span id="more"></span><p>形式化验证能够证明保持验证过的程序和声明的spocifications(SPEC)保持一致，但是如何保证SPEC是完备的 没有逻辑漏洞？本文使用Fuzzing-Assisted Specification Testing来解决这个问题。</p><p>核心思路是利用形式化验证过的程序的冗余性和多想想进行交叉检查。 </p><p>具体来讲，在同一个代码库中，SPEC（规范）、实现（CODE）和测试套件都是从同一组业务需求中派生出来的。因此，如果某个意图在CODE和测试用例中被捕捉到，但在SPEC中没有，则这表明SPEC存在盲点。</p><p>FAST以自动化的方式检查SPEC中的不完整性问题：它首先通过变异测试来定位SPEC的缺口gap，即通过检查CODE变体是否符合原始的SPEC来确定是否存在缺口。如果是这样，FAST进一步利用测试套件来推断缺口是由意图引起还是由错误引起的。根据代码库的大小，FAST可以选择以枚举方式还是进化方式生成CODE变体。FAST被应用于两个具有形式验证特性的开源代码库，并且分别帮助确认了它们SPEC中的13个和21个盲点。这凸显了SPEC不完整性在真实应用中的普遍存在。</p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>形式验证通过数学方法检查程序的正确性，为计算系统提供高度保证，即程序的行为完全受限于描述为一组期望属性（规范）的形式建模语言。形式验证在硬件和软件系统中已经被广泛采用。典型的应用场景包括可能导致重大损失和不可逆后果的情况（例如航空领域），或者传统的滚动式程序升级模型不可行的情况，如区块链上的智能合约。</p><p>形式化验证可以分解为两步</p><ul><li>1 设计目标系统的一系列规范 SPEC</li><li>2 证明实际的实现 CODE 和规范 SPEC是否符合，即$SPEC \sqsubseteq CODE$</li></ul><p>目前学术界在2方面进展迅速，但是1被关注较少。这就存在着严重的问题，即使一个程序经过完善的验证工具链进行了彻底的验证，该程序的正确性也仅限于其规范，程序中可能存在着盲点。由于目前形式化验证的成本较高、技术门槛较高，进行SPEC编写的人员一般不是写代码发的，作者想传达的思想是不能盲目的相信形式化验证后的代码，还需要去理解SPEC完备性的重要性</p><p> 硬件领域对SPEC完整性的研究比较多，现有的工作基于mutation testing，即将CODE或者SPEC进行变异，检查变异体是否依然符合旧的内容，因此，任何存活的变异体都会引发一个信号，表明规范可能是不完整的</p><p>因此去可以去研究：</p><ul><li>变异测试 mutation testing 是否能够应用于软件安全</li><li>如果不能，可以采用怎样的改进</li><li>优化后来解决成熟的代码库中是否普遍存在规范不完备的问题</li></ul><p>本文的主要工作是首先确认了采用变异测试能够高效地发现SPEC的漏洞，但是对于复杂的程序，基于变异的测试不够有效</p><h2 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h2><ul><li>当mutant通过了验证，如何证明SPEC之间的gap是故意而为还是错误<ul><li>解决思路：利用形式化验证程序中的冗余性和多样性，即代码 SPEC和测试套件都是从一组需求来的，但是以不同的思维方式进行编程：例如，使用不同的编程语言（甚至是编程范式）实现的，具有不同的演进路径，一般不同且独立的团队进行编写。因此，这三个不太可能出现相同的错误。</li><li>可以通过相互比较来发现错误</li></ul></li><li>如何构造一个更容易通过验证的mutant<ul><li>解决思路：fuzzer的遗传算法，计算每个mutant的fitness，只有高质量的mutant才可能被多次变异，fitness的标准就是验证后触发的错误（这也太trivial了）</li></ul></li></ul><p>FAST无法保证一定没有完备性问题，但可以用于说明程序中不存在明显的逻辑漏洞</p><h2 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h2><p>本文的贡献包括</p><ul><li>概念：我们指出形式验证程序中规范、代码和测试套件的“冗余性”和“多样性”，并利用这种冗余性（通过将测试套件作为“裁判”）来解决判断规范中缺陷是故意还是错误的问题，。</li><li>设计：采用基于遗传的进化，每个新的mutant会更难被杀死<ul><li>如何保证输入的多样性</li></ul></li><li>影响：分别发现了DPN和S2N中13个和21个盲点</li></ul><h1 id="Background-and-related-work"><a href="#Background-and-related-work" class="headerlink" title="Background and related work"></a>Background and related work</h1><p>介绍形式验证和规范不完整性问题以及变异测试和模糊测试</p><h2 id="形式化验证"><a href="#形式化验证" class="headerlink" title="形式化验证"></a>形式化验证</h2><p>已经被广泛应用在软件和硬件、密码学库(HACL*)、编译器、网络协议和智能合约(diem)中</p><p>步骤</p><ul><li>采用抽象逻辑语言设计SPEC</li><li>开发形式化工具来推理SPEC和目标代码实现之间的关系</li></ul><p>矛盾在于，一个理想的规范集需要足够完整，能够捕捉到所有利益相关者的意图，同时又需要足够抽象，以便在实施选择方面具有灵活性。例如，如果需求是对数组排序，SPEC需要足够完备能够理解排序的语义，然而需要足够抽象能够支持快排和归并排序的实现</p><p>然而，开发一个高质量的规范集是困难的。一个与代码相对应的规范集在实际价值上几乎没有意义，只会使代码库臃肿，导致代码更改的摩擦和更高的维护成本。另一方面，如果规范过于抽象，可能无法捕捉到一些基本的设计要求，在代码中可能存在未被发现的潜在漏洞。</p><p>目前的工作都是基于启发式手动调整的checklist</p><h2 id="自动化函数验证"><a href="#自动化函数验证" class="headerlink" title="自动化函数验证"></a>自动化函数验证</h2><p>本文主要聚焦于具有前置条件和后置条件的函数正确性验证，有时也被称为“按设计实现”的验证</p><p>在函数验证中，规范的目标通常是构成单个函数的代码，开发人员以SPEC谓词的形式为函数体提供前置条件和后置条件，这些谓词通常包括对函数参数和/或可以由函数中的代码引用的环境状态的条件。规范可能包含没有具体可执行语义的构造，例如对无界域的量化。虽然针对单个函数进行规定的,前置条件和后置条件不仅限于仅确立一个函数的正确性，它们对整个程序正确性的确立作出贡献，因为前置条件在调用方验证，从而可以在调用后假设后置条件。</p><p><img src="/2024/01/10/sp23-find-spec-blind-spots-via-fuzz-testing/image-20240111192543156.png" alt="image-20240111192543156"></p><p>例子中的ensures是一个后置条件，验证工具的任务是将代码和规范融合为可以交给后端求解器（通常是SMT求解器）处理的证明义务。</p><h2 id="规范SPEC的完备性"><a href="#规范SPEC的完备性" class="headerlink" title="规范SPEC的完备性"></a>规范SPEC的完备性</h2><p>图1中的代码符合SPEC，但是SPEC忽略了一个问题，如果add1函数的实现方式与图2a中所示，在原始循环之后还有一个额外的pop()操作。当前的规范只检查向量中每个剩余元素的值是否增加了一，忽略了对数据长度的校验。完整的规范如图2b所示，其中还有一个额外的ensures子句，进一步限制了add1函数修改输入向量的能力。这个缺失的ensures子句代表了原始规范的不完整性问题。</p><p><img src="/2024/01/10/sp23-find-spec-blind-spots-via-fuzz-testing/image-20240111193038531.png" alt="image-20240111193038531"></p><p>这里的问题出现在写SPEC实际上是另一种形式的编程，如何保证SPEC没有bug也很重要。这个问题被称为<em>gauging the completeness of SPEC</em>，在硬件领域受到了较多的关注，硬件领域主要采用的方法是mutation testing。</p><h2 id="Mutation-testing"><a href="#Mutation-testing" class="headerlink" title="Mutation testing"></a>Mutation testing</h2><p>mutation testing的idea来自于对软件测试的测试用例的怀疑主义，代码的安全性由测试保证，测试用例的安全性如何保证呢？这与FAST旨在解决的规范不完整性问题类似。</p><p>其实mutation based testing是从1970年代就开始被研究的一种方法</p><p>代码测试可以分为</p><ul><li>单元测试</li><li>集成测试</li><li>端到端测试</li></ul><p>用于测试不同测试组件的质量</p><p>同样可以用于测试没有具体语义的程序</p><p>硬件测试中，变异测试的目的是通过引入功能变换来评估给定的硬件SPEC的完整性。</p><h2 id="fuzzing中的遗传策略"><a href="#fuzzing中的遗传策略" class="headerlink" title="fuzzing中的遗传策略"></a>fuzzing中的遗传策略</h2><p>由于输入的状态空间较大，完全随机的输入生成实际作用不大。</p><p>在现代模糊测试研究中，处理状态探索问题的一种方式是模拟自然选择过程，结合随机变异和适者生存。具体而言，在每个变异轮次中，随机变异被用于增加探索尚未探索的路径的机会。适者生存的过程通过根据反馈（例如，在大多数模糊测试中的代码或路径覆盖）有效地对不同的种子进行排序，并给予排名较高的种子更好的机会来生成未来测试轮次的输入。</p><p>在模糊测试器的所有构建模块中（例如变异规则、种子调度、反馈机制），提供对种子质量的客观评估的度量标准对于模糊测试器的有效性至关重要。</p><p>AFL用了代码覆盖率，FAST提出了一种新的度量标准：利用求解器中的验证错误数量和多样性。</p><p>Language fuzzing好像和目前的虚拟机比较接近？语言模糊测试旨在发现编译器或解释器（例如虚拟机或JIT引擎）中的问题，这几篇可以再看一看</p><p><img src="/2024/01/10/sp23-find-spec-blind-spots-via-fuzz-testing/image-20240113193234749.png" alt="image-20240113193234749"></p><ul><li>Superion: Grammar-aware Greybox Fuzzing.</li><li>Soyeon Park, Wen Xu, Insu Yun, Daehee Jang, and Taesoo<br>Kim. Fuzzing Javascript Engines with Aspect-preserving<br>Mutation. In Proceedings of the 41st IEEE Symposium on<br>Security and Privacy (Oakland), San Francisco, CA, May<br>2020.</li><li>JQF: Coverage-guided Property-based Testing in Java.</li></ul><h1 id="The-Tale-SPEC-CPDE-and-Tests"><a href="#The-Tale-SPEC-CPDE-and-Tests" class="headerlink" title="The Tale SPEC CPDE and Tests"></a>The Tale SPEC CPDE and Tests</h1><p>生成多样的mutant不是挑战，评价生成的mutant的有效性是更重要的问题，本文中指通过了SPEC的mutant，在这里还需要判断这个mutant是否故意设计的gap</p><p>核心idea或者假设是：SPEC（来自于spec团队）、CODE（来自于开发者）、test suites（来自于QA质量保证团队）、三者不太可能犯同样的错，可以通过运行其中一个，和另外两个交叉对比检查正确性，实际上在测试用例中运行并检查SPEC就是一个例子</p><h1 id="变异"><a href="#变异" class="headerlink" title="变异"></a>变异</h1><ul><li><p>类型保留的变异：为了产生有效的CODE变异体，保证至少应该能够编译和执行，不具有参考价值</p></li><li><p>枚举变异：根据表1中讨论的有限的变异规则集合，对于在原始CODE中没有太多指令的小型代码，即使用算法1中描述的算法尝试所有可能的变异策略</p><ul><li>不支持一次修改多个运算符</li><li>改变循环结构的方法<ul><li>if else对换</li><li>continue break对换</li><li>三目运算符 对换</li></ul></li></ul></li></ul><p><img src="/2024/01/10/sp23-find-spec-blind-spots-via-fuzz-testing/image-20240113194902827.png" alt="image-20240113194902827"></p><p><img src="/2024/01/10/sp23-find-spec-blind-spots-via-fuzz-testing/image-20240113201033819.png" alt="image-20240113201033819"></p><h2 id="案例：Diem-支付网络"><a href="#案例：Diem-支付网络" class="headerlink" title="案例：Diem 支付网络"></a>案例：Diem 支付网络</h2><p>居然是区块链的例子，泪目了</p><p><img src="/2024/01/10/sp23-find-spec-blind-spots-via-fuzz-testing/image-20240113201711218.png" alt="image-20240113201711218"></p><ul><li>首先，静态分析AST，寻找所有可能的变异的地方</li><li><p>迭代地检查每个变异点，并按照表1中的通用变异规则生成CODE mutant。对于常量变异，CODE随机选择表1中列出的三个变异规则之一作为变异目标</p></li><li><p>对于每个生成的CODE突变，FAST将其传递给证明器，与原始的SPEC一起进行验证，并检查Move证明器的验证结果。Move证明器将报告验证状态以及验证错误的详细说明，即在CODE的哪一行违反了哪个SPEC属性</p></li></ul><p>结果：发现了404个可以进行变异的地方</p><h1 id="基于遗传策略的CODE变异"><a href="#基于遗传策略的CODE变异" class="headerlink" title="基于遗传策略的CODE变异"></a>基于遗传策略的CODE变异</h1><p>问题：当代码规模过大时，不适合将所有可能的突变点进行变异</p><p>遗传算法需要回答的两个问题：</p><ul><li>变异的对象<ul><li>solution：在进化开始之前，预先收集CODE中的潜在变异点。在这个信息收集步骤中，FAST从头到尾扫描给定的CODE，并将每个指令与表1中定义的可能的变异模式进行匹配</li></ul></li><li>哪个mutant更加适合作为下一轮的种子<ul><li>适度fitness评估：出现更少的错误，发现先前未知的验证错误均是好的mutant的表现</li><li>SPEC覆盖率是通过CODE变异体触发的验证错误来衡量的。对于每个未通过验证的CODE变异体，FAST期望从验证器那里得到一个报告来描述失败的原因。这个报告可以是一个简单的二进制通过/失败信号，也可以是一个包含 $SPEC \ X$ 在 $CODE$ 位置 $Y$ 由于原因 $Z$ 失败的记录的元组$(X, Y, Z)$列表。信息越详细，FAST对变异体的“适应度”测量就越好。</li><li>幸运的是，在实践中，大多数形式化验证工具都可以给出非常详细的验证错误解释，甚至包括可以具体执行以确定错误的反例。</li><li>CODE变异体都被分配了一个初始分数，该分数与两个因素成反比：1）剩余的验证错误数量和2）变异trace的长度。对于相同的验证错误集，FAST偏向于较小的变异体（即与原始CODE的编辑距离较小，类似于NeoDiff）</li></ul></li></ul><h2 id="fuzz的流程"><a href="#fuzz的流程" class="headerlink" title="fuzz的流程"></a>fuzz的流程</h2><p>seed pool保存着有意义来进行后续变异的种子code，种子都是根据分数排序的，每轮首先是种子选择算法，排序给出当前轮的种子并进行变异</p><ul><li>如果验证通过，分析是否为误报</li><li>如果验证失败，评估新code的适度，如果适合则保存该种子。同时，更新父种子的分数，并将父种子也加回到池子中<ul><li>如何保证种子的多样性？多给一些CODE，初始权重一样</li></ul></li></ul><p>值得一提的是，与可以从具有许多测试用例的种子池中启动的传统模糊测试不同，FAST的种子池在开始时只有一个种子，即没有任何变异的原始CODE。FAST给予这个创世种子足够高的分数，以便快速填充种子池中大量的单变异种子。但是在引导期之后，从FAST的角度来看，这个创世种子与其他种子没有区别。</p><p><img src="/2024/01/10/sp23-find-spec-blind-spots-via-fuzz-testing/image-20240113204315985.png" alt="image-20240113204315985"></p><h1 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h1><ul><li>测试套件的有效性</li><li>遗传算法的有效性：图6显示了在S2N上继续运行进化变异测试时，FAST发现的存活变异体数量的累积情况，大概在2^16秒时饱和</li></ul><p><img src="/2024/01/10/sp23-find-spec-blind-spots-via-fuzz-testing/image-20240113210923890.png" alt="image-20240113210923890" style="zoom:67%;"></p><h1 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h1><ul><li>变异SPEC：目前的方法是变异code而不是SPEC，理论上是可以反过来发现同样的gap<ul><li>然而，CODE和SPEC变异的对称性仅适用于发现SPEC中的差距，并不适用于判断差距是有意的还是错误的过程。在FAST中，可以通过对CODE变异体运行测试来对差距进行分类。但对于SPEC变异体来说，运行测试是徒劳的，因为CODE没有修改。这是FAST不采用SPEC变异方法的主要原因。</li><li>将对称性扩展到差距分类过程的解决方案是SPEC嵌入，即在适当的CODE位置嵌入SPEC并运行测试套件。</li></ul></li><li>基于coverage的SPEC完备性测试工具：<ul><li>目前流行用覆盖度（行覆盖度、指令覆盖度或分支覆盖度）来表示完整性，开源项目的谨慎维护者甚至可能要求任何新的CODE都必须附带测试用例，以保持代码库中的CODE覆盖率高。</li><li>目前没有用于测量SPEC的CODE覆盖度的工具，挑战在于似乎每个CODE片段都会参与到证明一些SPEC属性的过程中，很难解开复杂的逻辑公式。</li></ul></li><li>FAST的应用<ul><li>可应用的对象具备：验证系统是完全自动化的；FAST可以修改某种形式的CODE表示（LLVM IR）</li><li>FAST的普适性受到限制，因为形式验证尚未成为标准的工业实践，大多数软件中缺少SPEC</li></ul></li><li>可能错过一些gap的原因：<ul><li>变异演化方法本质上是不完整的。类似于为什么模糊测试无法找到软件中的所有错误一样，进化变异策略无法产生能够揭示SPEC中所有差距的CODE变异体——搜索空间太大无法枚举。</li><li>某些SPEC差距需要手动确认，特别是在第5种情况下，CODE变异体的验证失败——需要手动检查验证失败是由于不同步的证明提示（隐藏了SPEC差距）还是真正的SPEC违规引起的。</li></ul></li></ul><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>本文介绍了FAST工具，用于揭示形式SPEC中的不完整问题。FAST展示了如何通过交叉检查将形式验证程序（SPEC、CODE和测试套件）中的“冗余”和“多样性”协同起来，并通过枚举和进化变异测试提供了具体的设计和实现，用于检测SPEC中的盲点。本文将FAST应用于DPN和S2N，并分别确认了它们SPEC中的13个和21个盲点。这凸显了SPEC不完整在现实世界应用中的普遍存在。作者希望FAST的发现可以一定程度上呼吁社会，引起更多关于测量和确保形式验证代码库中SPEC质量的关注。</p><h2 id="可参考论文"><a href="#可参考论文" class="headerlink" title="可参考论文"></a>可参考论文</h2><p>mutation testing的</p><ul><li>Assessment of class mutation operators for c++ with the mucpp mutation system</li><li>Users guide to the pilot mutation system</li><li>W Eric Wong. Mutation Testing for the New Century, volume 24. Springer Science &amp; Business Media, 2001.</li><li>Timothy Alan Budd. Mutation Analysis of Program Test Data. Yale University, 1980.</li><li>Pedro Reales Mateo and Macario Polo Usaola. Reducing<br>mutation costs through uncovered mutants. Software Testing, Verification and Reliability, 25(5-7):464–489, 2015.</li><li>Baowen Xu, Xiaoyuan Xie, Liang Shi, and Changhai Nie.<br>Application of genetic algorithms in software testing. In<br>Advances in Machine Learning Applications in Software<br>Engineering, pages 287–317. IGI Global, 2007.</li></ul><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><ul><li>种子选择<ul><li>根据适度进行排序</li></ul></li><li>种子变异<ul><li>可以参考具体的对运算符进行的变异策略、改变循环结构</li><li>evmfuzz是每次变异一个位置后就执行，根据变异造成的效果改变变异器的权重；FAST是每次将所有能变异的地方进行变异，高阶变异是3个点同时变异</li></ul></li><li>种子评估：剩余的验证错误数量和变异trace的长度，倾向于发现新的验证错误、尽可能短</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Ji R, Xu M. Finding Specification Blind Spots via Fuzz Testing[C]//2023 IEEE Symposium on Security and Privacy (SP). IEEE Computer Society, 2023: 2708-2725.&lt;/p&gt;</summary>
    
    
    
    
    <category term="Mutation Testing" scheme="https://alleysira.github.io/tags/Mutation-Testing/"/>
    
  </entry>
  
  <entry>
    <title>Detecting Blockchain (E)VM Flaws</title>
    <link href="https://alleysira.github.io/2024/01/10/blocksec-evm-fuzz/"/>
    <id>https://alleysira.github.io/2024/01/10/blocksec-evm-fuzz/</id>
    <published>2024-01-10T07:50:22.000Z</published>
    <updated>2024-01-11T06:56:59.630Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>BlockSec CEO周亚金教授受邀参加香港Web3学者峰会，阐述了EVM虚拟机存在的潜在安全风险以及如何通过差分测试工具解决该类问题。</p><p>参考链接：<a href="https://mp.weixin.qq.com/s/9ujd7AMmWNHWE6Wujfqz2A">url</a></p><span id="more"></span><h1 id="Detecting-Blockchain-E-VM-Flaws"><a href="#Detecting-Blockchain-E-VM-Flaws" class="headerlink" title="Detecting Blockchain (E)VM Flaws"></a>Detecting Blockchain (E)VM Flaws</h1><p>打打广告</p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110161050085.png" alt="image-20240110161050085"></p><p>目前EVM兼容的链有200+</p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110161224346.png" alt="image-20240110161224346"></p><p>虚拟机是智能合约的foundation</p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110161402073.png" alt="image-20240110161402073"></p><p>virtual ROM中存储的是代码，account storge是持久化存储</p><p>evm如果对同一段代码执行结果不一样，就会导致分叉，有两个重要的事件</p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110161551985.png" alt="image-20240110161551985"></p><p>浅拷贝优化导致的错误</p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110161806004.png" alt="image-20240110161806004"></p><p>实现篡改return data</p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110161835490.png" alt="image-20240110161835490"></p><p>CVE2021 Geth及时修复了，但是其他fork geth的项目未能及时采用该patch </p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110162332986.png" alt="image-20240110162332986"></p><p>如何提前发现类似问题：提前开发系统，但是存在着一下问题</p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110162710450.png" alt="image-20240110162710450"></p><p>差分测试：不同种类的实现</p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110162923402.png" alt="image-20240110162923402"></p><p>输入相同，执行的合约相同，理论上输出应该一样</p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110162913739.png" alt="image-20240110162913739"></p><p>test case的prestate也应该相同</p><p>生成测试用例的方法</p><ul><li>用历史真实数据</li><li>基于覆盖率的fuzz（提到blocksec做了很多其他的维度）</li></ul><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110163219770.png" alt="image-20240110163219770"></p><p>基于种子交易mutate，生成不正常的交易</p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110163332043.png" alt="image-20240110163332043"></p><p>现有的evm存在定制，neo作为layer1，基于neo的链可能定制化</p><p>剔除假阳性的方法</p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110163448295.png" alt="image-20240110163448295"></p><p>blocksec目前支持的链的EVM</p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110163543389.png" alt="image-20240110163543389"></p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110155400899.png" alt="image-20240110155400899"></p><p><a href="https://nvd.nist.gov/vuln/detail/CVE-2020-26241">https://nvd.nist.gov/vuln/detail/CVE-2020-26241</a></p><p>目前zkevm的问题比较多</p><p>eos的问题：新的合约账户可能和已被销毁的合约账户连接起来</p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110155916090.png" alt="image-20240110155916090"></p><p>aurora预编译合约计算gas错误，远远小于实际的gas消耗，导致dos</p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110160130852.png" alt="image-20240110160130852"></p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110160609580.png" alt="image-20240110160609580"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;BlockSec CEO周亚金教授受邀参加香港Web3学者峰会，阐述了EVM虚拟机存在的潜在安全风险以及如何通过差分测试工具解决该类问题。&lt;/p&gt;
&lt;p&gt;参考链接：&lt;a href=&quot;https://mp.weixin.qq.com/s/9ujd7AMmWNHWE6Wujfqz2A&quot;&gt;url&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="EVM" scheme="https://alleysira.github.io/tags/EVM/"/>
    
  </entry>
  
  <entry>
    <title>TOSEM23</title>
    <link href="https://alleysira.github.io/2023/11/28/TOSEM23/"/>
    <id>https://alleysira.github.io/2023/11/28/TOSEM23/</id>
    <published>2023-11-28T11:38:58.000Z</published>
    <updated>2024-01-11T09:20:21.916Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Yixuan Zhang, Shangtong Cao, Haoyu Wang, Zhenpeng Chen, Xiapu Luo, Dongliang Mu, Yun Ma, Gang Huang, and Xuanzhe Liu. 2023. Characterizing and Detecting WebAssembly Runtime Bugs. ACM Trans. Softw. Eng. Methodol. Just Accepted (September 2023). <a href="https://doi.org/10.1145/3624743">https://doi.org/10.1145/3624743</a></p><span id="more"></span><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>首先收集了903个github上wasm bug相关的post，确认了311个真实的bug。基于数据，总结了31类wasm运行时的漏洞并且总结了共同的修复策略。设计了基于pattern的漏洞检测框架来自动检测Wasm中的bug。采用该漏洞检测框架测试了7个WASM运行时，发现了60个漏洞。</p><p>研究对象</p><ul><li>wasmtime</li><li>wasmer</li><li>WAMR</li></ul><p>贡献</p><ul><li>第一篇对Wasm运行时漏洞的系统研究，总结了漏洞的种类和对应的修复措施</li><li>开发了基于模式的漏洞检测框架，对真实世界的wasm运行时进行了检测，能够发现错误</li><li>脚本 数据集和漏洞检测工具已经开源（<a href="https://github.com/bnmcxlzd/TOSEM2023_Complementary_materials）">https://github.com/bnmcxlzd/TOSEM2023_Complementary_materials）</a></li></ul><h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><h2 id="wasm-binary"><a href="#wasm-binary" class="headerlink" title="wasm binary"></a>wasm binary</h2><p>wasm是一种底层的类似汇编的语言，设计目标是高效处理和紧凑表示。对应的二进制文件是.wasm。</p><p>Wasm标准定义了概念性的堆栈虚拟机，用于执行pop和push，并将结果留在堆栈上。</p><h2 id="wat-format"><a href="#wat-format" class="headerlink" title="wat format"></a>wat format</h2><p>.wat 是为开发者提供的漂亮的印刷文本格式，能够用于理解语义和wasm模块、进行测试、调试和优化等等。开发者可以使用wabt工具将wasm binary转换成文本格式</p><p>模块module是wasm代码的基本单元，表现为扁平树的形式；本地变量强类型</p><p><img src="/2023/11/28/TOSEM23/image-20231128201211895.png" alt="image-20231128201211895"></p><h2 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h2><p>Frontend compiler（AssemblyScript, Emscripten, Rustc/WASM-Bindgen）能够把高级语言编译为wasm bin，WASM被设计为高级编程语言的可移植编译目标，能够以接近本地执行的速度在多个平台上执行。wasm runtime是硬件和wasm bin之间的中间层</p><p><img src="/2023/11/28/TOSEM23/image-20231128201749638.png" alt="image-20231128201749638"></p><h2 id="wasm-runtime-architecture"><a href="#wasm-runtime-architecture" class="headerlink" title="wasm runtime architecture"></a>wasm runtime architecture</h2><p><img src="/2023/11/28/TOSEM23/image-20231128201825541.png" alt="image-20231128201825541"></p><p>后端编译器：支持提前编译Ahead-of-time compilation (AOT)和传统的即时编译Just-in-Time compilation</p><p>解释器：交互式执行</p><p>运行时环境：负责内存分配，栈的操作，报错</p><p>API：运行wasm运行时被嵌入到高级语言中作为库来使用</p><p>系统接口：支持类似操作系统的功能</p><h1 id="STUDY-DESIGN"><a href="#STUDY-DESIGN" class="headerlink" title="STUDY DESIGN"></a>STUDY DESIGN</h1><h2 id="研究问题"><a href="#研究问题" class="headerlink" title="研究问题"></a>研究问题</h2><p><img src="/2023/11/28/TOSEM23/image-20231129102622855.png" alt="image-20231129102622855"></p><p>漏洞分类的根本原因；是否存在普遍的修复策略；提出的分类方法对漏洞检测的有效性</p><h2 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h2><p>如何说明实验对象的代表性：</p><ul><li>LOC</li><li>star</li><li>支持的编译模式多</li><li>不同的编程语言实现</li></ul><p>数据来源</p><ul><li>github issue<ul><li>从github issue中提取有bug label的issue，最终304个wasmer的issues，167个wasmtime的issues和333个WAMR的issues（未label，全选）</li></ul></li><li>Stack Overlow<ul><li>Stack Overlow问题有标签，可根据标签爬取对应的post</li><li><img src="/2023/11/28/TOSEM23/image-20231129103818825.png" alt="image-20231129103818825"></li></ul></li></ul><h3 id="数据集的refine"><a href="#数据集的refine" class="headerlink" title="数据集的refine"></a>数据集的refine</h3><ul><li><p>筛去了没有确定性回答的issue和post</p></li><li><p>手工去除了install和build相关的错误，文档错误，用户误用等和wasm运行时无关的bug</p></li></ul><p>结果就是只剩下311个issue，SO全部没了（解释是可能github上wasm专家比较少）</p><p><img src="/2023/11/28/TOSEM23/image-20231129104347208.png" alt="image-20231129104347208"></p><h2 id="标记漏洞和修复策略"><a href="#标记漏洞和修复策略" class="headerlink" title="标记漏洞和修复策略"></a>标记漏洞和修复策略</h2><ul><li>pilot labelling 首先随机选了50%的post，论文前两位作者共同分析，进行分类</li><li>可靠性分析：根据之前的分类，两位作者独立标记剩下的40%的post验证之前对漏洞分类的正确性，采用Cohen’s kappa系数；对于出现的分歧与intercessor进行了讨论，新增了2类漏洞和3类修复措施；</li><li>对于剩下的10%，两位作者独立进行了分类，没有发现新的漏洞种类和修复措施，证明了分类的饱和 saturation</li></ul><h1 id="RQ1-TAXONOMY-OF-WASM-RUNTIME-BUGS"><a href="#RQ1-TAXONOMY-OF-WASM-RUNTIME-BUGS" class="headerlink" title="RQ1: TAXONOMY OF WASM RUNTIME BUGS"></a>RQ1: TAXONOMY OF WASM RUNTIME BUGS</h1><p>根据wasm的架构分析了漏洞种类</p><p><img src="/2023/11/28/TOSEM23/image-20231129110601087.png" alt="image-20231129110601087"></p><p>后端编译部分负责将bin编译为本地机器码，需要OS和CPU的支持，占总共bug的38.3%</p><h1 id="RQ3-PATTERN-BASED-BUG-DETECTOR-FOR-WASM-RUNTIMES"><a href="#RQ3-PATTERN-BASED-BUG-DETECTOR-FOR-WASM-RUNTIMES" class="headerlink" title="RQ3:PATTERN-BASED BUG DETECTOR FOR WASM RUNTIMES"></a>RQ3:PATTERN-BASED BUG DETECTOR FOR WASM RUNTIMES</h1><h2 id="Bug-detectors-for-Backend-Compilation"><a href="#Bug-detectors-for-Backend-Compilation" class="headerlink" title="Bug detectors for Backend Compilation"></a>Bug detectors for Backend Compilation</h2><p>No interest</p><h2 id="Bug-detectors-for-WASI-Robustness"><a href="#Bug-detectors-for-WASI-Robustness" class="headerlink" title="Bug detectors for WASI Robustness"></a>Bug detectors for WASI Robustness</h2><ul><li>文件操作错误：测试是否能重命名文件、是否能判断文件不存在、是否能移动文件、计数目录下的文件</li><li>import错误：不支持多个wasi的版本</li><li>输入输出流错误：用c++写程序编译为wasm bin再检查值和类型是否正确</li><li>OS错误：时间的API不一样，利用QuickJS进行测试</li></ul><h2 id="Bug-detectors-for-Runtime-environment"><a href="#Bug-detectors-for-Runtime-environment" class="headerlink" title="Bug detectors for Runtime environment"></a>Bug detectors for Runtime environment</h2><ul><li>module实例化错误：检查是否支持实例化 空 的wasm模块，短时间内大量实例化是否会内存泄漏</li><li><p>module导入错误：部分runtime省略了检查导入对象序号的步骤</p></li><li><p>Calling host functions：调用函数对象是否正确</p></li><li><p>memory issue：检查内存的增长是否是线性的</p></li><li>trap error：设计了带有不可达指令的module来测试运行时是否能正常跳出执行并且报告不可达代码的位置</li><li>入口错误：wasm运行时可能会不允许入口函数或拒绝没有入口函数的module</li><li>未处理异常</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Yixuan Zhang, Shangtong Cao, Haoyu Wang, Zhenpeng Chen, Xiapu Luo, Dongliang Mu, Yun Ma, Gang Huang, and Xuanzhe Liu. 2023. Characterizing and Detecting WebAssembly Runtime Bugs. ACM Trans. Softw. Eng. Methodol. Just Accepted (September 2023). &lt;a href=&quot;https://doi.org/10.1145/3624743&quot;&gt;https://doi.org/10.1145/3624743&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="Wasm" scheme="https://alleysira.github.io/tags/Wasm/"/>
    
  </entry>
  
  <entry>
    <title>OmniLedger</title>
    <link href="https://alleysira.github.io/2023/11/12/OmniLedger/"/>
    <id>https://alleysira.github.io/2023/11/12/OmniLedger/</id>
    <published>2023-11-12T05:09:50.000Z</published>
    <updated>2024-01-21T06:39:19.453Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Video"><a href="#Video" class="headerlink" title="Video"></a>Video</h1><p>视频链接：<a href="https://www.youtube.com/watch?v=vHVZ2gD8Ie4&amp;ab_channel=AllHackingCons">https://www.youtube.com/watch?v=vHVZ2gD8Ie4&amp;ab_channel=AllHackingCons</a></p><p>github：<a href="https://github.com/dedis/student_18_byzcoin">https://github.com/dedis/student_18_byzcoin</a></p><span id="more"></span><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p><img src="/2023/11/12/OmniLedger/image-20231112132024157.png" alt="image-20231112132024157"></p><p>进行分片时需要考虑的问题：</p><ul><li>验证者如何被分配到不同分片中去</li><li>如何实现跨分片的交易</li></ul><p><img src="/2023/11/12/OmniLedger/image-20231112132216448.png" alt="image-20231112132216448"></p><p>对于第一个问题，显然不能让验证者自己选择进去哪个分片，如果随机选择，需要保证分片大小足够大（失败概率为$10^{-6}$，分片大小在$10^3\to10^4$），符合leopard</p><p><img src="/2023/11/12/OmniLedger/image-20231112132409442.png" alt="image-20231112132409442"></p><p>在SimpleLedger的例子中，每轮有一个可信的random beacon，将验证者分到不同的分片中，且验证者能够验证哪些验证者跟自己在同一个分片</p><p><img src="/2023/11/12/OmniLedger/image-20231112132715120.png" alt="image-20231112132715120" style="zoom:150%;"></p><p>简单的设计，带来了很多问题</p><p><img src="/2023/11/12/OmniLedger/image-20231112133139221.png" alt="image-20231112133139221" style="zoom:150%;"></p><p>安全性方面：</p><ul><li>依赖第三方可信的random beacon</li><li>重配置阶段不支持处理交易</li><li>不支持跨片交易</li></ul><h2 id="OmniLedger"><a href="#OmniLedger" class="headerlink" title="OmniLedger"></a>OmniLedger</h2><p><img src="/2023/11/12/OmniLedger/image-20231112133339611.png" alt="image-20231112133339611" style="zoom:150%;"></p><p>主要有6部分工作，包括DRB 平稳的轮切换等，主要介绍三个</p><h3 id="DRB"><a href="#DRB" class="headerlink" title="DRB"></a>DRB</h3><p><img src="/2023/11/12/OmniLedger/image-20231112133730137.png" alt="image-20231112133730137" style="zoom:150%;"></p><h3 id="原子跨片交易"><a href="#原子跨片交易" class="headerlink" title="原子跨片交易"></a>原子跨片交易</h3><p>参考了数据库领域的工作，2阶段承诺</p><p><img src="/2023/11/12/OmniLedger/image-20231112134014422.png" alt="image-20231112134014422"></p><p>存在问题：2阶段承诺不是时间容忍的，敌手可以abort</p><p><img src="/2023/11/12/OmniLedger/image-20231112134516084.png" alt="image-20231112134516084"></p><p>将分片作为server，client将没有commit的交易输入锁定，等待对应输入分片的证明后解锁</p><h3 id="延迟和吞吐量的trade-off"><a href="#延迟和吞吐量的trade-off" class="headerlink" title="延迟和吞吐量的trade-off"></a>延迟和吞吐量的trade-off</h3><p>增大区块大小可以增加吞吐量，但是发送区块和验证区块的延迟会增加</p><p>Omniledger的思路是牺牲部分安全性来降低延迟</p><p>存在两层验证，一层处理数额较小的输入，安全性为90%，一层处理重要的交易</p><p><img src="/2023/11/12/OmniLedger/image-20231112135746820.png" alt="image-20231112135746820" style="zoom:67%;"></p><h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><p>Go语言编写，<a href="https://github.com/dedis/student_18_byzcoin">https://github.com/dedis/student_18_byzcoin</a></p><p>采用了dedis实验室的代码 <a href="https://github.com/dedis">https://github.com/dedis</a></p><p><img src="/2023/11/12/OmniLedger/image-20231112140022164.png" alt="image-20231112140022164" style="zoom:150%;"></p><p>首先测试scale-out，增加节点数量</p><p><img src="/2023/11/12/OmniLedger/image-20231112141351986.png" alt="image-20231112141351986" style="zoom:150%;"></p><p>1120是分片大小为70，16个分片，考虑敌手比例最多为25%，低于BFT的容错</p><p><img src="/2023/11/12/OmniLedger/image-20231112141855252.png" alt="image-20231112141855252" style="zoom:67%;"></p><p>对于延迟，分别测试了2层验证的耗时</p><p><img src="/2023/11/12/OmniLedger/image-20231112142156625.png" alt="image-20231112142156625" style="zoom:67%;"></p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p><img src="/2023/11/12/OmniLedger/image-20231112142320778.png" alt="image-20231112142320778" style="zoom:67%;"></p><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p>Q: 网络分区的影响</p><p>A: 如果发生网络分区，协议停止，不违反比特币的安全性</p><p>Q: 和Algorand的区别</p><p>A: Algorand没有sharding，可以选择将Algorand作为片内共识算法，Omniledger在Algorand之上，可以得到更好的敌手容忍比例</p><p>Q: 交易如何分配到分片内</p><p>A: Omniledger片内共识是参考比特币的，因此节点本地有UTXO数据库。如果存在跨片交易，依赖于原子承诺的设计，输入分片会commit或者abort</p><p>Q: 表格中安全性仅考虑到了25-30%，失败概率$10^{-6}$，如何实现容忍$10^{-10}$的错误概率</p><p>A: 更大的分片大小，trade-off</p><p>Q: 因为目前矿池集中的算力超过了25%，可能达到30% 40% 45%，作者认为可能会如何</p><p>A: 片内如果用比特币的共识能容忍50%的敌手</p><p>Q: 最坏情况下的性能，如所有交易都是跨片交易</p><p>A: 当所有交易都是跨片交易，不再是线性增长的。采用单个共识算法的效率会比sharding更好</p><p>Q: 敌手能否让所有交易都成为跨片交易？</p><p>A: 交易是由client发起的，不是由敌手选择的，因为交易有手续费，跨片交易的手续费比普通交易更高，如果跨3个片交易费可能是片内交易的三倍</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Video&quot;&gt;&lt;a href=&quot;#Video&quot; class=&quot;headerlink&quot; title=&quot;Video&quot;&gt;&lt;/a&gt;Video&lt;/h1&gt;&lt;p&gt;视频链接：&lt;a href=&quot;https://www.youtube.com/watch?v=vHVZ2gD8Ie4&amp;amp;ab_channel=AllHackingCons&quot;&gt;https://www.youtube.com/watch?v=vHVZ2gD8Ie4&amp;amp;ab_channel=AllHackingCons&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;github：&lt;a href=&quot;https://github.com/dedis/student_18_byzcoin&quot;&gt;https://github.com/dedis/student_18_byzcoin&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="Sharding" scheme="https://alleysira.github.io/tags/Sharding/"/>
    
  </entry>
  
  <entry>
    <title>leopard-bft</title>
    <link href="https://alleysira.github.io/2023/10/31/leopard-bft/"/>
    <id>https://alleysira.github.io/2023/10/31/leopard-bft/</id>
    <published>2023-10-31T06:47:05.000Z</published>
    <updated>2023-11-11T14:22:18.328Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Hu K, Guo K, Tang Q, et al. Leopard: Towards High Throughput-Preserving BFT for Large-scale Systems[C]//2022 IEEE 42nd International Conference on Distributed Computing Systems (ICDCS). IEEE, 2022: 157-167.</p><span id="more"></span><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>安装go，将<code>awesomeProject DKG</code> cp到<code>GOROOT</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alleysira@LAPTOP-M4HO8L6S:~/leopard-bft$ sudo cp -r go/src/awesomeProject /usr/local/go/src</span><br><span class="line">alleysira@LAPTOP-M4HO8L6S:~/leopard-bft$ sudo cp -r go/src/DKG /usr/local/go/src</span><br></pre></td></tr></table></figure><p>经典编不过去</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alleysira@LAPTOP-M4HO8L6S:~/leopard-bft/go/src/awesomeProject$ go build main.go</span><br><span class="line"><span class="meta">#</span><span class="bash"> DKG</span></span><br><span class="line">/usr/local/go/src/DKG/bls.go:6:10: fatal error: bls/bls.h: No such file or directory</span><br><span class="line">    6 | #include &lt;bls/bls.h&gt;</span><br><span class="line">      |          ^~~~~~~~~~~</span><br><span class="line">compilation terminated.</span><br></pre></td></tr></table></figure><h3 id="bn"><a href="#bn" class="headerlink" title="bn"></a>bn</h3><p>论文中bls采用了 <a href="https://github.com/dfinity-side-projects/bn，安装">https://github.com/dfinity-side-projects/bn，安装</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">alleysira@LAPTOP-M4HO8L6S:~/bn-master$ make</span><br><span class="line">make -C mcl UPDATE_ASM=1 lib/libmcl.so CFLAGS_USER=-std=c++11 MCL_MAX_BIT_SIZE=384</span><br><span class="line">make[1]: Entering directory &#x27;/home/alleysira/bn-master/mcl&#x27;</span><br><span class="line">g++ -o src/gen src/gen.cpp -g3 -Wall -Wextra -Wformat=2 -Wcast-qual -Wcast-align -Wwrite-strings -Wfloat-equal -Wpointer-arith -m64 -I include -I test -I ../xbyak -I ../cybozulib/include -std=c++11 -fomit-frame-pointer -DNDEBUG -Ofast -march=native -fPIC -DMCL_MAX_BIT_SIZE=384 -DMCL_USE_LLVM=1 -O0</span><br><span class="line">src/gen -old -f src/func.list &gt; src/base64.ll</span><br><span class="line">opt -O3 -o - src/base64.ll -march=x86-64 | llc -O3 -o src/asm/x86-64.s -march=x86-64 -relocation-model=pic  -pre-RA-sched=list-ilp -max-sched-reorder=128</span><br><span class="line">opt: src/base64.ll:16:26: error: expected comma after getelementptr&#x27;s type</span><br><span class="line"><span class="meta">%</span><span class="bash">r5 = getelementptr i64* %r2, i64 %r4</span></span><br><span class="line">                         ^</span><br><span class="line">g++ -c src/asm/x86-64.s -o obj/x86-64.o -g3 -Wall -Wextra -Wformat=2 -Wcast-qual -Wcast-align -Wwrite-strings -Wfloat-equal -Wpointer-arith -m64 -I include -I test -I ../xbyak -I ../cybozulib/include -std=c++11 -fomit-frame-pointer -DNDEBUG -Ofast -march=native -fPIC -DMCL_MAX_BIT_SIZE=384 -DMCL_USE_LLVM=1</span><br><span class="line">src/gen -old -f src/func.list -s bmi2 &gt; src/base64.bmi2.ll</span><br><span class="line">opt -O3 -o - src/base64.bmi2.ll -march=x86-64 | llc -O3 -o src/asm/x86-64.bmi2.s -march=x86-64 -relocation-model=pic  -pre-RA-sched=list-ilp -max-sched-reorder=128 -mattr=bmi2</span><br><span class="line">opt: src/base64.bmi2.ll:16:26: error: expected comma after getelementptr&#x27;s type</span><br><span class="line"><span class="meta">%</span><span class="bash">r5 = getelementptr i64* %r2, i64 %r4</span></span><br><span class="line">                         ^</span><br></pre></td></tr></table></figure><p><code>make clean</code>之后<code>sudo make</code>依然出错，目测是llvm的版本的问题</p><p>github 上相关的issue</p><ul><li><p><a href="https://github.com/dfinity-side-projects/bn/issues/10">https://github.com/dfinity-side-projects/bn/issues/10</a></p></li><li><p><a href="https://github.com/dfinity-side-projects/bn/issues/3">https://github.com/dfinity-side-projects/bn/issues/3</a></p></li></ul><p>opt是llvm的优化器，问题原因是采用的llvm是10.0版本，.ll文件的语法不相同，但是能编译出libbls的两个库和一个libmcl</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">g++ -o src/gen src/gen.cpp -g3 -Wall -Wextra -Wformat=2 -Wcast-qual -Wcast-align -Wwrite-strings -Wfloat-equal -Wpointer-arith -m64 -I include -I test -I ../xbyak -I ../cybozulib/include -std=c++11 -fomit-frame-pointer -DNDEBUG -Ofast -march=native -fPIC -DMCL_MAX_BIT_SIZE=384 -DMCL_USE_LLVM=1 -O0</span><br><span class="line">src/gen -old -f src/func.list &gt; src/base64.ll</span><br><span class="line">opt -O3 -o - src/base64.ll -march=x86-64 | llc -O3 -o src/asm/x86-64.s -march=x86-64 -relocation-model=pic  -pre-RA-sched=list-ilp -max-sched-reorder=128</span><br><span class="line">opt: src/base64.ll:16:26: error: expected comma after getelementptr&#x27;s type</span><br><span class="line"><span class="meta">%</span><span class="bash">r5 = getelementptr i64* %r2, i64 %r4</span></span><br><span class="line">                         ^</span><br><span class="line">g++ -c src/asm/x86-64.s -o obj/x86-64.o -g3 -Wall -Wextra -Wformat=2 -Wcast-qual -Wcast-align -Wwrite-strings -Wfloat-equal -Wpointer-arith -m64 -I include -I test -I ../xbyak -I ../cybozulib/include -std=c++11 -fomit-frame-pointer -DNDEBUG -Ofast -march=native -fPIC -DMCL_MAX_BIT_SIZE=384 -DMCL_USE_LLVM=1</span><br><span class="line">src/gen -old -f src/func.list -s bmi2 &gt; src/base64.bmi2.ll</span><br><span class="line">opt -O3 -o - src/base64.bmi2.ll -march=x86-64 | llc -O3 -o src/asm/x86-64.bmi2.s -march=x86-64 -relocation-model=pic  -pre-RA-sched=list-ilp -max-sched-reorder=128 -mattr=bmi2</span><br><span class="line">opt: src/base64.bmi2.ll:16:26: error: expected comma after getelementptr&#x27;s type</span><br><span class="line"><span class="meta">%</span><span class="bash">r5 = getelementptr i64* %r2, i64 %r4</span></span><br></pre></td></tr></table></figure><p>应该是缺一个mcl库，因为报错编不出来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/tmp/go-build/cgo-gcc-prolog:1354: undefined reference to `mclBn_precomputedMillerLoop&#x27;</span><br><span class="line">/usr/bin/ld: $WORK/b002/_x004.o: in function `_cgo_7ee38b8fbf18_Cfunc_mclBn_precomputedMillerLoop2&#x27;:</span><br><span class="line">/tmp/go-build/cgo-gcc-prolog:1370: undefined reference to `mclBn_precomputedMillerLoop2&#x27;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure><p>尝试把16.04的库直接拿过来用，不行，有一些函数的接口变了，卒</p><p>尝试修改mcl的Makefile文件，跳过对.ll的报错，失败</p><p><img src="/2023/10/31/leopard-bft/image-20231031180355543.png" alt="image-20231031180355543"></p><p>一个逆天bug，/*cgo xxx*/后面不能有空行，必须直接跟着import “C”</p><p>将存放4个库文件的<code>/usr/local/lib</code>加入到LD路径中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=/lib:/usr/lib:/usr/local/lib</span><br></pre></td></tr></table></figure><p>屈服了，下载3.9版本的llvm用cmake build</p><p>如何build的教程 <a href="https://releases.llvm.org/3.9.0/docs/CMake.html">https://releases.llvm.org/3.9.0/docs/CMake.html</a></p><p><img src="/2023/10/31/leopard-bft/image-20231031221526742.png" alt="image-20231031221526742"></p><p><code>make bn</code>没有报错</p><p>库都正确编译了，但是依然有问题，是fp.cpp文件的6个函数存在undefined reference（不应该啊）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">alleysira@LAPTOP-M4HO8L6S:~/leopard-bft/go/src/awesomeProject$ go build main.go</span><br><span class="line"><span class="meta">#</span><span class="bash"> DKG</span></span><br><span class="line">/usr/bin/ld: /usr/local/lib/libbls384.so: undefined reference to `mcl::fp::copyUnitToByteAsLE(unsigned char*, unsigned long const*, unsigned long)&#x27;</span><br><span class="line">/usr/bin/ld: /usr/local/lib/libbls384.so: undefined reference to `mcl::fp::copyAndMask(unsigned long*, void const*, unsigned long, mcl::fp::Op const&amp;, bool)&#x27;</span><br><span class="line">/usr/bin/ld: /usr/local/lib/libbls384.so: undefined reference to `mcl::fp::arrayToStr(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;&amp;, unsigned long const*, unsigned long, int)&#x27;</span><br><span class="line">/usr/bin/ld: /usr/local/lib/libbls384.so: undefined reference to `mcl::fp::hash[abi:cxx11](unsigned long, void const*, unsigned long)&#x27;</span><br><span class="line">/usr/bin/ld: /usr/local/lib/libbls384.so: undefined reference to `mcl::fp::streamToArray(bool*, unsigned long*, unsigned long, std::istream&amp;, int)&#x27;</span><br><span class="line">/usr/bin/ld: /usr/local/lib/libbls384.so: undefined reference to `mcl::fp::Op::init(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;, unsigned long, mcl::fp::Mode, unsigned long)&#x27;</span><br><span class="line">collect2: error: ld returned 1 exit status </span><br></pre></td></tr></table></figure><p>猜测是bn库的版本不对（并不是）</p><p>是因为忘记删除之前<code>\usr\lib\</code>下尝试的新版的mcl编出来的libbslxx.so</p><p>以下是最终能通过build的bls.go</p><p><img src="/2023/10/31/leopard-bft/image-20231031231943209.png" alt="image-20231031231943209"></p><p>把<code>simulateUnderNode\network</code>文件夹cp到<code>GOROOT</code>下即可运行</p><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>4个terminal对应4个节点</p><p><img src="/2023/10/31/leopard-bft/image-20231031233119579.png" alt="image-20231031233119579"></p><p><img src="/2023/10/31/leopard-bft/image-20231031233148849.png" alt="image-20231031233148849"></p><p><img src="/2023/10/31/leopard-bft/image-20231031233209582.png" alt="image-20231031233209582"></p><p><img src="/2023/10/31/leopard-bft/image-20231031233217854.png" alt="image-20231031233217854"></p><p><img src="/2023/10/31/leopard-bft/image-20231031233204879.png" alt="image-20231031233204879"></p><p><img src="/2023/10/31/leopard-bft/image-20231031233312013.png" alt="image-20231031233312013"></p><h1 id="报告笔记"><a href="#报告笔记" class="headerlink" title="报告笔记"></a>报告笔记</h1><p>胡可欣老师详细介绍了工作</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Hotstuff是diem链底层的共识</p><p>半同步网络模型下，已经被证明支持的恶意敌手上界是1/3</p><p>传统的BFT类共识，当节点规模扩大，吞吐量急剧下降</p><ul><li>PBFT &gt;100</li></ul><p><img src="/2023/10/31/leopard-bft/image-20231102141032382.png" alt="image-20231102141032382"></p><p>提升可扩展性的方法</p><ul><li>横向扩展 scale out：共识节点分组，各组对交易并行，分片属于横向方案<ul><li>安全性要求组的大小为600 1000，和想要得到大规模节点的需求之间存在矛盾关系</li></ul></li><li>纵向扩展scale up：给每个节点增加物理资源，存在瓶颈</li></ul><p>发现瓶颈存在于领导者</p><ul><li>错误概率的问题<ul><li>组合</li><li>项目指标安全性要求是单片$10^{-18}$</li></ul></li><li>网络模型<ul><li>半同步 影响活性，一致性与网络模型无关</li><li>Dumbo系列共识是异步</li></ul></li></ul><p>Hotstuff降低了通信复杂度，存在轮数增加的问题；实验结果显示Hotstuff确实提高了性能和规模 </p><h2 id="协议设计"><a href="#协议设计" class="headerlink" title="协议设计"></a>协议设计</h2><ul><li><p>数据传输与共识解耦：先分摊交易，由领导者决定哪些交易当前轮打包</p><ul><li>怎么保证 交易分散没有交集 每个节点都拥有全集，发送时可能 mod 4</li><li>发 Hash(datablock) ，通过调整尺寸来保证复杂度不是n^2</li><li>复杂度是摊销的结果，实际没有降低复杂度</li></ul></li><li><p>纠删码</p><ul><li>法定人数2f+1，一定能收到f+1个好的纠删码片段</li><li>如何判断收到纠删码的完整性：带线性长度的证明</li><li>设计没有考虑proposal可能是交易，实际场景可能存在双花问题</li></ul></li></ul><h2 id="协议实现"><a href="#协议实现" class="headerlink" title="协议实现"></a>协议实现</h2><ul><li><p>实现</p><ul><li>信道 reliable and auth：不是工业界的实现</li><li>execution engine<ul><li>bls需要额外进行DKG</li><li>rate-limiter : 限制数据块分散交易的频率，利用到了半同步</li><li>双通道 go channel（共识优先级高于数据）</li></ul></li></ul></li><li><p>实验</p><ul><li>增加节点数量：600个节点，吞吐量仍然在10w</li><li>增加节点资源：斜率更高</li><li>杭州：一个机器 一个核，1个核能否带多个节点（docker）</li><li>软件所资源目前能使用的资源200个CPU</li><li>具体系统实现用的签名：<ul><li>猎豹采用的是bls门限签名</li><li>Schnorr（复旦大学李强老师）</li><li>ecdsa（pipelined Hotstuff）</li></ul></li><li>规模运行到600时，一笔交易确认已经非常困难了，由于databa</li></ul></li><li><p>安全性</p><ul><li>目前$n=600,Pr_{error}&lt;10^{-6},n=1000,Pr_{error}&lt;10^{-9}$，指标要求的是$10^{-18}$</li></ul></li><li><p>后续工作</p><ul><li>尽快将分片共识的框架搭起来，缺少经验可以学习一下刘老师团队的工作</li><li>明确能否在1个核上运行2个节点</li><li>实现安全性可以考虑gearbox，目前leopard BFT代码里是有一条底层链的实现的</li><li>leopard BFT有后续引用工作：Hu Z, Guan S, Xu W, et al. A Data Flow Framework with High Throughput and Low Latency for Permissioned Blockchains[C]//2023 IEEE 43rd International Conference on Distributed Computing Systems (ICDCS). IEEE, 2023: 1-12.</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Hu K, Guo K, Tang Q, et al. Leopard: Towards High Throughput-Preserving BFT for Large-scale Systems[C]//2022 IEEE 42nd International Conference on Distributed Computing Systems (ICDCS). IEEE, 2022: 157-167.&lt;/p&gt;</summary>
    
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="Consensus" scheme="https://alleysira.github.io/tags/Consensus/"/>
    
    <category term="Sharding" scheme="https://alleysira.github.io/tags/Sharding/"/>
    
  </entry>
  
  <entry>
    <title>Wasm-runtime-bugs-survey</title>
    <link href="https://alleysira.github.io/2023/10/25/Wasm-runtime-bugs-survey/"/>
    <id>https://alleysira.github.io/2023/10/25/Wasm-runtime-bugs-survey/</id>
    <published>2023-10-25T10:54:28.000Z</published>
    <updated>2023-11-28T12:37:30.395Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Wang Y, Zhou Z, Ren Z, et al. A Comprehensive Study of WebAssembly Runtime Bugs[C]//2023 IEEE International Conference on Software Analysis, Evolution and Reengineering (SANER). IEEE, 2023: 355-366.</p><span id="more"></span><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>考虑对漏洞进行分类</p><p>研究对象为4个Wasm</p><ul><li>浏览器采用的Wasm<ul><li><a href="https://v8.dev/">V8</a>：谷歌的开源JS和WAsm引擎，采用c++实现，被用在Chrome和Node.js中 </li><li><a href="https://spidermonkey.dev/">SpiderMonkey</a>：Mozilla的JS和Wasm引擎，采用C++实现，被用在Firefox</li></ul></li><li>独立的Wssm<ul><li><a href="https://wasmer.io/">Wasmer</a>：Rust实现，代码仓库 <a href="https://github.com/wasmerio/wasmer">https://github.com/wasmerio/wasmer</a></li><li><a href="https://github.com/bytecodealliance/wasmtime">Wasmtime</a>：Rust实现</li></ul></li></ul><p>回答6个问题</p><ul><li><p>Wasm运行时漏洞的根本原因的分布：进行了漏洞分类并分析了分布</p></li><li><p>Wasm运行时漏洞的症状：帮助理解漏洞可能导致的结果，辅助如何设计oracle，分为6类</p></li><li><p>根本原因和症状之间的联系</p></li><li>Wasm运行时漏洞的修复时间</li><li>不同运行时漏洞的共同点</li></ul><p>数据集和测试脚本已经<a href="https://github.com/Wang11Yue/WebAssembly_Runtime_Bugs">开源</a> </p><h1 id="Wasm-runtimes"><a href="#Wasm-runtimes" class="headerlink" title="Wasm runtimes"></a>Wasm runtimes</h1><p>wasm运行时负责将二进制wasm指令翻译为本地CPU的机器码，三种方法</p><ul><li>解释执行 解释器</li><li>提前编译为本地执行文件 编译器</li><li>及时编译 编译器 浏览器一般用，因为用户体验较好</li></ul><p><img src="/2023/10/25/Wasm-runtime-bugs-survey/image-20231026101820583.png" alt="image-20231026101820583"></p><h1 id="Methodology"><a href="#Methodology" class="headerlink" title="Methodology"></a>Methodology</h1><ul><li>收集漏洞：首先从closed和fixed中搜集所有已修复漏洞，得到BugSet1<ul><li><a href="https://bugs.chromium.org/p/v8/issues/list?q=&amp;can=1">https://bugs.chromium.org/p/v8/issues/list?q=&amp;can=1</a></li><li><a href="https://bugzilla.mozilla.org/query.cgi?format=advanced">https://bugzilla.mozilla.org/query.cgi?format=advanced</a></li><li><a href="https://github.com/wasmerio/wasmer">https://github.com/wasmerio/wasmer</a></li><li><a href="https://github.com/bytecodealliance/wasmtime">https://github.com/bytecodealliance/wasmtime</a></li></ul></li><li>收集漏洞修复的commit：漏洞提交到修复之前的commit（为了方便，筛掉了采用多个commit修复的情况），筛掉与代码无关的commit得到BugSet2（包含一个commit修复多个漏洞）和BugSet3<ul><li><img src="/2023/10/25/Wasm-runtime-bugs-survey/image-20231026103848029.png" alt="image-20231026103848029"></li></ul></li><li><p>漏洞分类和标记：3位熟悉Wasm的人员对BugSet2中的漏洞手工进行标记，标记出root cause和symptom</p></li><li><p>根本原因：16类</p><ul><li><img src="/2023/10/25/Wasm-runtime-bugs-survey/image-20231026111915194.png" alt="image-20231026111915194"></li></ul></li><li>症状：6类<ul><li><img src="/2023/10/25/Wasm-runtime-bugs-survey/image-20231026111927262.png" alt="image-20231026111927262"></li></ul></li></ul><h1 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h1><ul><li><p>根本原因</p><ul><li>不正确的算法实现是bug出现最多的地方 25.45%</li><li>内存问题占17.7%</li></ul></li><li><p>症状</p><ul><li>最常见的是crash，占比56.86%</li><li>不正确的功能占比22.15%</li></ul></li><li><p>根本原因和症状之间的联系：</p><ul><li>不正确的算法实现、内存、异常处理错误可能导致所有的症状（数量上53.52%）</li><li>79.01%的漏洞导致的结果是崩溃、不正确的功能，但是原因可能各异</li><li><img src="/2023/10/25/Wasm-runtime-bugs-survey/image-20231026113425878.png" alt="image-20231026113425878"></li></ul></li><li><p>修复漏洞花费的时间</p><ul><li>修复时间快于GCC和LLVM</li><li><img src="/2023/10/25/Wasm-runtime-bugs-survey/image-20231026113453636.png" alt="image-20231026113453636"></li></ul></li><li><p>修复涉及到的代码和文件 </p><ul><li><img src="/2023/10/25/Wasm-runtime-bugs-survey/image-20231026113811061.png" alt="image-20231026113811061"></li><li>超过50%的漏洞一个文件就修复了</li><li><img src="/2023/10/25/Wasm-runtime-bugs-survey/image-20231026113504452.png" alt="image-20231026113504452"></li><li>外部API不兼容原因导致的修复文件最多，Bad performance症状涉及到的文件最多，平均4.45</li><li><p><img src="/2023/10/25/Wasm-runtime-bugs-survey/image-20231026114237105.png" alt="image-20231026114237105"></p></li><li><p>修复代码行数的中位数从12-70变化</p></li></ul></li><li><p>不同Wasm运行时之间的共同点：采用斯皮尔曼相关系数进行分析</p><ul><li>取值范围在-1到1之间，-1表示完全负的单调关系，1表示完全正的单调关系，0表示没有单调关系,[0.8-1.0]表示相关性强</li><li><img src="/2023/10/25/Wasm-runtime-bugs-survey/image-20231026114536167.png" alt="image-20231026114536167"></li><li>症状类似，原因相关性不强</li></ul></li></ul><h1 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h1><ul><li>设计漏洞检测工具检测 <ul><li>最常出现的根本原因</li><li>常出现的两个症状</li></ul></li><li>现有的 算法实现 漏洞修复机制需要改进 <ul><li>crash的oracle定义相对简单，可以模糊测试；带有报错，可以辅助和调试</li><li>incorrect functionality难定义，可能采用差分测试</li></ul></li></ul><h1 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h1><ul><li>软件漏洞综述</li><li>Wasm运行时比较多，没有涉及到漏洞检测的</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Wang Y, Zhou Z, Ren Z, et al. A Comprehensive Study of WebAssembly Runtime Bugs[C]//2023 IEEE International Conference on Software Analysis, Evolution and Reengineering (SANER). IEEE, 2023: 355-366.&lt;/p&gt;</summary>
    
    
    
    
    <category term="VM" scheme="https://alleysira.github.io/tags/VM/"/>
    
  </entry>
  
  <entry>
    <title>VM-matters</title>
    <link href="https://alleysira.github.io/2023/10/23/VM-matters/"/>
    <id>https://alleysira.github.io/2023/10/23/VM-matters/</id>
    <published>2023-10-23T08:23:24.000Z</published>
    <updated>2023-10-29T14:43:19.217Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Zheng S, Wang H, Wu L, et al. VM matters: a comparison of WASM VMS and EVMS in the performance of blockchain smart contracts[J]. arXiv preprint arXiv:2012.01032, 2020.</p><span id="more"></span><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Wasm已经被以太坊采用，即eWASM，以期望取代EVM</p><p>以太坊的性能瓶颈</p><ul><li>共识协议</li><li>交易签名</li><li>执行引擎（EVM）</li></ul><p>然而EVM对真实世界的合约来说工具不够完善，开发者开始研究Wasm。Wasm被集成到了所有主流浏览器中。Wasm程序执行效率接近于本地执行，比浏览器Js的实现快2倍</p><p>Ethereum 2.0 roadmap中已经包含了eWASM，潜在的优势</p><ul><li>交易处理更快，提升吞吐量</li><li>支持更多智能合约语言</li><li>目前Geth和Openethereum在实验支持WASM，但是社区活跃似乎在18年，从2022年起代码仓库不再更新<ul><li><a href="https://github.com/ewasm/design">https://github.com/ewasm/design</a></li></ul></li></ul><p>目前没有明确的证据表明WASM能够提高区块链执行的实际效率</p><p>主要工作</p><ul><li><p>本文分析了智能合约执行引擎对区块链执行效率的影响，主要研究两类</p><ul><li><p>EVM engines：Geth和Openethereum</p></li><li><p>WASM engines：11个，3个是区块链定制的（Eos Geth 和 Openethereum）</p></li></ul></li><li><p>分析了字节码内引擎对比和字节码间的引擎对比，即EVM和WASM先自己和自己比，再跨平台比较</p></li><li>设计了一系列的benchmark</li></ul><p>得出了一系列<strong>结论</strong></p><ul><li>基于EVM的链对Wasm的支持<strong>不尽人意</strong><ul><li>Wasm的实现不稳定，客户端的编码规则不一致；支持的编程语言少</li></ul></li><li>对EVM来说，Geth和表现比Openethereum好</li><li>智能合约在Wasm上运行效率差异显著，最大3个数量级</li><li>本地支持的<strong>数据类型</strong>对Wasm合约执行影响显著，如Wasm的数据类型为32/64bit，当执行256的EVM字节码时，带来额外开销</li><li>尽管Standalone WASM的效率比EVM高，但是eWASM VM比EVM慢（所有256bit数据和大多数64bit数据），可能是gas测量和EEI上下文切换带来的开销</li></ul><p>为了研究，会开源benchmark和所有实验结果（因为匿名提交删掉了，github没搜到，但是有很多其他的开源的benchmark）</p><h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><h2 id="Smart-Contract"><a href="#Smart-Contract" class="headerlink" title="Smart Contract"></a>Smart Contract</h2><p>EVM合约字节码的执行是自循环，当程序结束或者出现error或者遇到STOP RETURN语句时终止</p><p>gas用于支付 <em>计算 存储 带宽</em> 的成本</p><h2 id="EVM-WASM-eWASM-字节码"><a href="#EVM-WASM-eWASM-字节码" class="headerlink" title="EVM/WASM/eWASM 字节码"></a>EVM/WASM/eWASM 字节码</h2><ul><li>EVM<ul><li>EVM仅支持256比特的数据，小于该长度的计算都必须转换成256比特的形式EVM才能处理</li><li>EVM不支持浮点数</li></ul></li><li>Wasm：2017年由浏览器厂商提出，在隔离的沙箱中运行<ul><li>可分为解码、验证和执行三个阶段</li><li>数据类型：32bit和64bit的浮点数、整数</li></ul></li><li>eWasm：Wasm的子集<ul><li>通过Wasm执行引擎定义的Ethereum Environment Interface (EEI)和以太坊交互</li><li>限制了浮点数（为了保证和以太坊的一致性）</li><li>定义了 EVM 交叉编译器，实现对EVM字节码的后向兼容性</li></ul></li></ul><p><img src="/2023/10/23/VM-matters/image-20231023192003800.png" alt="image-20231023192003800"></p><h1 id="Study-Design"><a href="#Study-Design" class="headerlink" title="Study Design"></a>Study Design</h1><p>研究四个问题</p><ul><li>目前区块链客户端对Wasm的支持情况</li><li>EVM比较</li><li>Wasm比较</li><li>EVM和Wasm比较</li></ul><p><img src="/2023/10/23/VM-matters/image-20231023192331005.png" alt="image-20231023192331005"></p><p>实验方法</p><ul><li><p>采用0.5.4的solc编译solidity生成EVM字节码</p></li><li><p>利用 <a href="https://github.com/second-state/SOLL">SOLL</a>（最新的release是2年前的）编译soldity生成eWasm的字节码</p></li><li><p>然而eWasm的字节码不能在一般的Wasm上面运行，利用其他引擎支持的语言 Rust 编写等价合约来编译成Wasm字节码</p></li></ul><p>对选择的Wasm的介绍</p><ul><li>Geth WASM - <a href="https://github.com/ewasm/hera">Hera</a>：C++实现，需要EVMC的支持,EVMC是EVM和客户端交互的接口，支持对应的Wasm后端包括<a href="https://github.com/webassembly/wabt">wabt</a> <a href="https://github.com/webassembly/binaryen">Binaryen</a> 和 <a href="https://github.com/WAVM/WAVM">WAVM</a></li><li>Openethereum WASM - <a href="https://github.com/paritytech/wasmi">wasmi</a>：Rust实现，虽然项目凉了，但是Wasm现在依然非常活跃</li><li>EOS VM：虚拟机运行是确定性的，采用软件实现浮点数。采用看门狗 timer来限制执行时间</li><li>其余还有Life SSVM wagon wbt wasm3 WAMR wasmtime</li></ul><p>benchmark</p><p>13个不同种类的测试标准</p><p><img src="/2023/10/23/VM-matters/image-20231023195252543.png" alt="image-20231023195252543"></p><ul><li><p>操作码层面的测试：Simple Operation测试了单一运算的效率</p></li><li><p>以太坊层面的测试：Arithmetic Block Status和Hashing测试</p></li></ul><h1 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h1><ul><li>EVM对比：Openethereum和geth对比<img src="/2023/10/23/VM-matters/image-20231024172501663.png" alt="image-20231024172501663"></li><li>WASM对比 <img src="/2023/10/23/VM-matters/image-20231024172615876.png" alt="image-20231024172615876"></li><li>eWasm和EVM字节码对比 <img src="/2023/10/23/VM-matters/image-20231024172751695.png" alt="image-20231024172751695"></li><li>Wasm带来的额外开销占比 <img src="/2023/10/23/VM-matters/image-20231024173251526.png" alt="image-20231024173251526"></li></ul><h1 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a>Limitation</h1><ul><li><p>benchmark的局限性</p><ul><li>目前只支持单一的操作、算术运算和哈希，不支持对KV存储的操作，因为Wasm目前不支持长期存储。</li><li>没有交易 和其他合约交互的测试</li></ul></li><li><p>目前的思路是设计benchmark来近似测量操作码执行的效率，更精确的方法应该是直接测量记录操作码的运行时间</p></li><li>Wasm VM仍然在频繁更新，本论文的结果可能不能反映目前的VM的实际性能</li></ul><h2 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h2><p>第一篇对Wasm和EVM执行效率进行对比的论文，目前有一些对Wasm的研究和区块链系统性能测量的研究</p><ul><li>Wasm字节码分析<ul><li>有工作<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Marius Musch, Christian Wressnegger, Martin Johns, and Konrad Rieck. 2019.New Kid on the Web: A Study on the Prevalence of WebAssembly in the Wild. In International Conference on Detection of Intrusions and Malware, and VulnerabilityAssessment. Springer, 23–42.">[1]</span></a></sup>分析了Alexa上使用WAsm的合约，发现仅1/600的合约使用Wasm</li><li>有工作发现<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Jan Rüth, Torsten Zimmermann, KonradWolsing, and Oliver Hohlfeld. 2018. Digginginto browser-based crypto mining. In Proceedings of the Internet MeasurementConference 2018. 70–76.">[2]</span></a></sup>Wasm被用于PoW，可能导致cryptojacking</li><li>工作<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Weikang Bian, Wei Meng, and Mingxue Zhang. 2020. MineThrottle: Defendinga gainst WASM In-Browser Cryptojacking. In Proceedings of The Web Conference3 112–3118.">[3]</span></a></sup> 提出了防御cryptojacking的方法</li></ul></li><li>区块链性能测量<ul><li>BlockBench <sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Tien Tuan Anh Dinh, Ji Wang, Gang Chen, Rui Liu, Beng Chin Ooi, and Kian-Lee Tan. 2017. Blockbench: A framework for analyzing private blockchains. InProceedings of the 2017 ACM International Conference on Management of Data.1085–1100.">[4]</span></a></sup>测量区块链私链的性能，分析了Ethereum, Parity and Hyperledger，发现区块链系统的瓶颈在于共识协议</li><li>工作<sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Sara Rouhani and Ralph Deters. 2017. Performance analysis of ethereum transactionsin private blockchain. In 2017 8th IEEE International Conference on Software Engineering and Service Science (ICSESS). IEEE, 70–74.">[5]</span></a></sup>分析了Geth和Parity上交易的效率，发现Parity更快</li></ul></li></ul><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Marius Musch, Christian Wressnegger, Martin Johns, and Konrad Rieck. 2019.New Kid on the Web: A Study on the Prevalence of WebAssembly in the Wild. In International Conference on Detection of Intrusions and Malware, and VulnerabilityAssessment. Springer, 23–42.<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Jan Rüth, Torsten Zimmermann, KonradWolsing, and Oliver Hohlfeld. 2018. Digginginto browser-based crypto mining. In Proceedings of the Internet MeasurementConference 2018. 70–76.<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Weikang Bian, Wei Meng, and Mingxue Zhang. 2020. MineThrottle: Defendinga gainst WASM In-Browser Cryptojacking. In Proceedings of The Web Conference3 112–3118.<a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Tien Tuan Anh Dinh, Ji Wang, Gang Chen, Rui Liu, Beng Chin Ooi, and Kian-Lee Tan. 2017. Blockbench: A framework for analyzing private blockchains. InProceedings of the 2017 ACM International Conference on Management of Data.1085–1100.<a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Sara Rouhani and Ralph Deters. 2017. Performance analysis of ethereum transactionsin private blockchain. In 2017 8th IEEE International Conference on Software Engineering and Service Science (ICSESS). IEEE, 70–74.<a href="#fnref:5" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;Zheng S, Wang H, Wu L, et al. VM matters: a comparison of WASM VMS and EVMS in the performance of blockchain smart contracts[J]. arXiv preprint arXiv:2012.01032, 2020.&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/categories/Blockchain/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="VM" scheme="https://alleysira.github.io/tags/VM/"/>
    
  </entry>
  
  <entry>
    <title>smart-contract-audit</title>
    <link href="https://alleysira.github.io/2023/10/19/smart-contract-audit/"/>
    <id>https://alleysira.github.io/2023/10/19/smart-contract-audit/</id>
    <published>2023-10-19T07:14:55.000Z</published>
    <updated>2023-10-23T12:43:50.567Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>收集、分析智能合约审计报告</p><span id="more"></span><h1 id="审计报告"><a href="#审计报告" class="headerlink" title="审计报告"></a>审计报告</h1><h2 id="调研结果"><a href="#调研结果" class="headerlink" title="调研结果"></a>调研结果</h2><p>收集了来自42家公司的2382份pdf格式的审计报告，主要针对的是智能合约</p><p>总结了审计报告的主要内容并以MetaTransaction的审计报告为例介绍了各个模块</p><h2 id="审计报告主要内容"><a href="#审计报告主要内容" class="headerlink" title="审计报告主要内容"></a>审计报告主要内容</h2><p>以审计公司 <a href="https://abdk.consulting/">ABDK.consulting</a> 对 <a href="[0x | Powerful APIs to build financial apps on crypto rails](https://0x.org/">0x</a>) 项目的 MetaTransaction审计报告为例，介绍审计报告一般包含的主要内容</p><h3 id="审计方法"><a href="#审计方法" class="headerlink" title="审计方法"></a>审计方法</h3><p>介绍审计过程中采用的方法或审计的流程</p><p>该审计报告主要进行了四个方面的分析</p><ul><li>常规代码检查：检查代码风格是否清楚、一致，具体检查缩进、变量命名、缺失注释等问题</li><li>实体使用分析：分析代码中的实体（例如变量、函数、类等）的使用情况和模式。了解代码中的实体是如何被引用、使用和修改的，以及它们在不同上下文中的行为和依赖关系</li><li>访问控制分析：对于能够被外部访问的实体，检查访问控制是否恰当</li><li>代码逻辑分析：分析特定函数的正确性和效率，检查代码的行为是否符合预期、算法是否正确</li></ul><p><img src="/2023/10/19/smart-contract-audit/image-20231008154504134.png" alt="image-20231008154504134" style="zoom:67%;"></p><h3 id="审计对象"><a href="#审计对象" class="headerlink" title="审计对象"></a>审计对象</h3><p>一般会给出被审计项目的基本介绍、代码、项目结构等信息</p><p>源代码：<a href="https://github.com/0xProject/protocol/compare/development...feat/MetaTransactionV2">Comparing development…feat/MetaTransactionV2 · 0xProject/protocol (github.com)</a> 以及 <a href="https://github.com/0xProject/protocol/pull/665/commits/6e926af41cd93ebd8686163f5ac34759b4ff1446">feat: Multiplex + MetaTransaction integration and MetaTransaction Multi-Fee Support [RFQ-795] [LIT-870] by patrick-dowell · Pull Request #665 · 0xProject/protocol (github.com)</a></p><p>审计对象的项目结构</p><p><img src="/2023/10/19/smart-contract-audit/image-20231008152113943.png" alt="image-20231008152113943"></p><h3 id="审计结果"><a href="#审计结果" class="headerlink" title="审计结果"></a>审计结果</h3><p>主要包括发现的漏洞类型、数量以及漏洞的修复情况</p><p>根据危害等级，一般将漏洞等级分为：</p><ul><li>Critical：严重</li><li>Major：高危</li><li>Moderate：中危</li><li>Minor：低危</li></ul><p>本报告发现了1个严重漏洞、1个高危漏洞、1个中危漏洞、17个低危漏洞，其中5个已经修复，仍有15个低危漏洞尚未被修复</p><p><img src="/2023/10/19/smart-contract-audit/image-20231008152655355.png" alt="image-20231008152655355" style="zoom:67%;"></p><h3 id="漏洞详细信息"><a href="#漏洞详细信息" class="headerlink" title="漏洞详细信息"></a>漏洞详细信息</h3><p>审计报告一般会对发现的漏洞进行描述，包括漏洞的分类、漏洞的危害、漏洞在合约中的位置、如何触发漏洞、以及如何修复漏洞</p><p>以发现的严重漏洞CVF-1为例，审计报告中介绍了该漏洞的具体信息</p><ul><li>漏洞分类为 缺陷</li><li>两个modifier <code>refundsAttachedEth</code> 和<code>doesNotReduceEthBalance</code>可能产生冲突</li><li>漏洞位置：该漏洞出现在<code>MetaTransactionsFeatureV2.sol</code>合约中</li><li>建议的修复措施：将<code>refundsAttachedEth</code>和<code>doesNotReduceEthBalance</code>合并作为交易退款的标识符</li><li>0x项目的解决方法：删除<code>refundsAttachedEth()</code>，将<code>executeMetatransaction</code>设置为<code>notpayable</code></li></ul><p><img src="/2023/10/19/smart-contract-audit/image-20231008153109744.png" alt="image-20231008153109744"></p><h2 id="审计报告来源"><a href="#审计报告来源" class="headerlink" title="审计报告来源"></a>审计报告来源</h2><p>共计42家审计公司公开发布的审计报告，具体名单如下</p><div class="table-container"><table><thead><tr><th style="text-align:center">审计公司</th><th style="text-align:center">链接</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://www.abdk.consulting/">ABDK Consulting</a></td><td style="text-align:center"><a href="https://github.com/abdk-consulting/audits">Link</a></td></tr><tr><td style="text-align:center"><a href="https://www.arbitraryexecution.com/blog/">Arbitrary Execution</a></td><td style="text-align:center"><a href="https://github.com/arbitraryexecution/publications">Link</a></td></tr><tr><td style="text-align:center"><a href="https://arcadiamgroup.com/">Arcadia Group</a></td><td style="text-align:center"><a href="https://www.arcadia.agency/auditReports">Link</a></td></tr><tr><td style="text-align:center"><a href="https://www.blockchainlabs.nz/home">BlockchainLabs</a></td><td style="text-align:center"><a href="https://github.com/BlockchainLabsNZ/audits">Link</a></td></tr><tr><td style="text-align:center"><a href="https://blocksecteam.com">BlockSec</a></td><td style="text-align:center"><a href="https://github.com/blocksecteam/audit-reports">Link</a></td></tr><tr><td style="text-align:center"><a href="https://chainsafe.io/">Chain Safe</a></td><td style="text-align:center"><a href="https://github.com/ChainSafe/audits">Link</a></td></tr><tr><td style="text-align:center"><a href="https://chainsulting.de/">Chainsulting</a></td><td style="text-align:center"><a href="https://github.com/chainsulting/Smart-Contract-Security-Audits">Link</a></td></tr><tr><td style="text-align:center"><a href="https://cystack.net/">Cystack</a></td><td style="text-align:center"><a href="https://github.com/cystack/security-audit-reports">Link</a></td></tr><tr><td style="text-align:center"><a href="https://credshields.com/index.html">CredShields</a></td><td style="text-align:center"><a href="https://github.com/Credshields/Audit-Reports">Link</a></td></tr><tr><td style="text-align:center"><a href="https://www.coinspect.com/">Coinspect</a></td><td style="text-align:center"><a href="https://github.com/coinspect/publications">Link</a></td></tr><tr><td style="text-align:center"><a href="https://www.cyfrin.io/">Cyfrin</a></td><td style="text-align:center"><a href="https://github.com/ChainAccelOrg/cyfrin-audit-reports">Link</a></td></tr><tr><td style="text-align:center"><a href="https://decurity.io/">Decurity</a></td><td style="text-align:center"><a href="https://github.com/Decurity/audits">Link</a></td></tr><tr><td style="text-align:center"><a href="https://www.dedaub.com/">Dedaub</a></td><td style="text-align:center"><a href="https://github.com/Dedaub/audits">Link</a></td></tr><tr><td style="text-align:center"><a href="https://distributedlab.com/">Distributed Lab</a></td><td style="text-align:center"><a href="https://github.com/dl-solidity-library/audits">Link</a></td></tr><tr><td style="text-align:center"><a href="https://github.com/g0-group">G0 Group</a></td><td style="text-align:center"><a href="https://github.com/g0-group/Audits">Link</a></td></tr><tr><td style="text-align:center"><a href="https://guardianaudits.com/">GuardianAudits</a></td><td style="text-align:center"><a href="https://github.com/GuardianAudits/Audits">Link</a></td></tr><tr><td style="text-align:center"><a href="https://lab.guardianaudits.com/">Guardian Solidity Lab</a></td><td style="text-align:center"><a href="https://github.com/GuardianAudits/SolidityLabAudits/tree/main">Link</a></td></tr><tr><td style="text-align:center"><a href="https://hexens.io/">Hexens</a></td><td style="text-align:center"><a href="https://github.com/Hexens/Smart-Contract-Review-Public-Reports">Link</a></td></tr><tr><td style="text-align:center"><a href="https://www.immunebytes.com/">Immunebytes</a></td><td style="text-align:center"><a href="https://github.com/ImmuneBytes/Smart-Contract-Audit-Reports/">Link</a></td></tr><tr><td style="text-align:center"><a href="https://informal.systems/">InformalSystems</a></td><td style="text-align:center"><a href="https://github.com/informalsystems/audits">Link</a></td></tr><tr><td style="text-align:center"><a href="https://www.kalos.xyz/">Kalos</a></td><td style="text-align:center"><a href="https://github.com/kalos-xyz/Publications">Link</a></td></tr><tr><td style="text-align:center"><a href="https://mixbytes.io/">MixBytes</a></td><td style="text-align:center"><a href="https://github.com/mixbytes/audits_public">Link</a></td></tr><tr><td style="text-align:center"><a href="https://www.numencyber.com/">Numen</a></td><td style="text-align:center"><a href="https://github.com/numencyber/Public_Report">Link</a></td></tr><tr><td style="text-align:center"><a href="https://www.oaksecurity.io/">Oak Security</a></td><td style="text-align:center"><a href="https://github.com/oak-security/audit-reports">Link</a></td></tr><tr><td style="text-align:center"><a href="https://oxor.io">Oxorio</a></td><td style="text-align:center"><a href="https://github.com/oxor-io/public_audits">Link</a></td></tr><tr><td style="text-align:center"><a href="https://github.com/peppersec">PepperSec</a></td><td style="text-align:center"><a href="https://github.com/peppersec/public-audit-reports">Link</a></td></tr><tr><td style="text-align:center"><a href="https://pessimistic.io/">Pessemistic</a></td><td style="text-align:center"><a href="https://github.com/pessimistic-io/audits">Link</a></td></tr><tr><td style="text-align:center"><a href="https://redteam.pl/">REDTEAM.PL</a></td><td style="text-align:center"><a href="https://github.com/redteampl/public_reports">Link</a></td></tr><tr><td style="text-align:center"><a href="https://runtimeverification.com/">Runtime Verification</a></td><td style="text-align:center"><a href="https://github.com/runtimeverification/publications#smart-contracts-security-audit-and-formal-verification">Link</a></td></tr><tr><td style="text-align:center"><a href="https://www.sec3.dev/">Sec3</a></td><td style="text-align:center"><a href="https://github.com/sec3-service/reports">Link</a></td></tr><tr><td style="text-align:center"><a href="https://audit.shellboxes.com/">ShellBoxes</a></td><td style="text-align:center"><a href="https://github.com/shellboxes/public-audit-reports">Link</a></td></tr><tr><td style="text-align:center"><a href="https://www.sherlock.xyz/">Sherlock</a></td><td style="text-align:center"><a href="https://github.com/sherlock-protocol/sherlock-reports">Link</a></td></tr><tr><td style="text-align:center"><a href="https://sigmaprime.io/">Sigma Prime</a></td><td style="text-align:center"><a href="https://github.com/sigp/public-audits">Link</a></td></tr><tr><td style="text-align:center"><a href="https://smcauditors.com/index.html">SMC Auditors</a></td><td style="text-align:center"><a href="https://github.com/smcauditors/smart-contract-audits">Link</a></td></tr><tr><td style="text-align:center"><a href="https://solidified.io/">Solidified</a></td><td style="text-align:center"><a href="https://github.com/solidified-platform/audits">Link</a></td></tr><tr><td style="text-align:center"><a href="https://spearbit.com/">Spearbit</a></td><td style="text-align:center"><a href="https://github.com/spearbit/portfolio">Link</a></td></tr><tr><td style="text-align:center"><a href="https://statemind.io/">Statemind</a></td><td style="text-align:center"><a href="https://github.com/statemindio/public-audits">Link</a></td></tr><tr><td style="text-align:center"><a href="https://www.truscova.com/index.php">Truscova</a></td><td style="text-align:center"><a href="https://github.com/Truscova/Reports">Link</a></td></tr><tr><td style="text-align:center"><a href="https://www.verichains.io/">Verichains</a></td><td style="text-align:center"><a href="https://github.com/verichains/public-audit-reports">Link</a></td></tr><tr><td style="text-align:center"><a href="https://yacademy.dev/">yAcademy</a></td><td style="text-align:center"><a href="https://github.com/yacademy/audits">Link</a></td></tr><tr><td style="text-align:center"><a href="https://yaudit.dev/">yAudit</a></td><td style="text-align:center"><a href="https://github.com/yAudit/reports">Link</a></td></tr><tr><td style="text-align:center"><a href="https://www.zellic.io/">Zellic</a></td><td style="text-align:center"><a href="https://github.com/Zellic/publications">Link</a></td></tr><tr><td style="text-align:center"><a href="https://www.zokyo.io/">Zokyo</a></td><td style="text-align:center"><a href="https://github.com/zokyo-sec/audit-reports">Link</a></td></tr></tbody></table></div><h1 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h1><ul><li><p>Etherscan目前认证了60家智能合约审计公司</p><ul><li><a href="https://etherscan.io/directory/Smart_Contracts/Smart_Contracts_Audit_And_Security">https://etherscan.io/directory/Smart_Contracts/Smart_Contracts_Audit_And_Security</a></li></ul></li><li><p>中山大学郑子彬老师的团队花费了44个人月，分析了1322份开源的审计报告</p><ul><li><a href="https://arxiv.org/abs/2305.08456">https://arxiv.org/abs/2305.08456</a></li><li>开源工具DappScan <ul><li><a href="https://github.com/InPlusLab/DAppSCAN">https://github.com/InPlusLab/DAppSCAN</a></li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;收集、分析智能合约审计报告&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/categories/Blockchain/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="SmartContract" scheme="https://alleysira.github.io/tags/SmartContract/"/>
    
  </entry>
  
  <entry>
    <title>EVM_security</title>
    <link href="https://alleysira.github.io/2023/10/12/EVM-security/"/>
    <id>https://alleysira.github.io/2023/10/12/EVM-security/</id>
    <published>2023-10-12T13:46:08.000Z</published>
    <updated>2023-11-29T13:16:50.051Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>调研区块链虚拟机安全</p><span id="more"></span><h1 id="EVM的不同实现"><a href="#EVM的不同实现" class="headerlink" title="EVM的不同实现"></a>EVM的不同实现</h1><ul><li>EVM官方实现：<a href="https://ethereum.org/en/developers/docs/evm/">Ethereum Virtual Machine (EVM) | ethereum.org</a><ul><li><a href="https://github.com/ethereum/py-evm">Py-EVM</a> - <em>Python</em></li><li><a href="https://github.com/ethereum/evmone">evmone</a> - <em>C++</em></li><li><a href="https://github.com/ethereumjs/ethereumjs-vm">ethereumjs-vm</a> - <em>JavaScript</em></li><li><a href="https://github.com/microsoft/eevm">eEVM</a> - <em>C++</em>，微软开发</li><li><a href="https://github.com/bluealloy/revm\-">https://github.com/bluealloy/revm\-</a> <em>Rust</em></li></ul></li><li><a href="https://github.com/rust-blockchain/evm">SputnikVM</a>：- <em>rust</em></li><li><a href="https://github.com/ethereum/pyethereum">pyethereum</a>：- <em>py</em>，2023.3已被弃用</li></ul><h1 id="其他VM"><a href="#其他VM" class="headerlink" title="其他VM"></a>其他VM</h1><ul><li><a href="https://github.com/neo-project/neo-vm">NEO VM</a>：采用C#实现，Neo链目前的市值排行66，NEO支持多种常用的编程语言，如C#、Java和Python等编写智能合约</li><li><a href="https://github.com/solana-labs/solana">Solana Virtual Machine</a>：Solana链（市值第7）上的虚拟机，rust实现.<ul><li>智能合约语言可以是Rust, C, and C++，翻译成BPF字节码执行；支持交易并行</li><li><a href="https://github.com/neonlabsorg/neon-evm">Neon</a>用于solana和EVM对齐</li></ul></li><li><a href="https://github.com/input-output-hk/cardano-node">Cardano</a>：token ADA，目前市值排行8，采用Haskell语言实现，以<a href="https://github.com/runtimeverification/evm-semantics">KEVM</a>,EVM的形式化验证版本为基础<ul><li>其中Milkomeda C1是Cardano对应的EVM侧链</li></ul></li><li><a href="https://gitlab.com/tezos/tezos">Tezos</a>：目前的市值排行52，项目采用的语言是OCaml，合约采用的编程语言是Archetype, LIGO, 和SmartPy，翻译为底层语言<a href="https://opentezos.com/michelson/">Michelson</a>后在VM上执行<ul><li>虚拟机的设计未详细介绍，参考资料<a href="https://forklog.com/sp/dev-on-tezos/en/tezos-introduction/#:~:text=Tezos&#39;s VM works with byte,with fast access to data">What Smart Contracts are and How They Work</a></li><li>github镜像：<a href="https://github.com/tezos/tezos-mirror">tezos/tezos-mirror: Github test mirror of the Octez software</a></li></ul></li></ul><h2 id="WASM"><a href="#WASM" class="headerlink" title="WASM"></a>WASM</h2><ul><li><a href="https://github.com/EOSIO/eos-vm">EOSIO, EOS-VM</a>：第一个DpoS的链，C++实现，目前的市值排行57，采用WebAssembly（WASM）作为底层引擎，通过即时编译技术将智能合约字节码转换为本地机器码；同样支持多种编程语言，包括C++、Rust、Python等编写智能合约</li><li><a href="https://github.com/near/nearcore">Near</a>：采用Rust实现，Wasm作为执行引擎，市值排行43</li><li>国内的迅雷公司的<a href="https://github.com/xunleichain/tc-wasm/tree/master">迅雷链</a>：采用Wasm作为VM，目前提供<a href="https://blockchain.xunlei.com/">数字藏品</a></li><li><a href="https://tron.network/">Tron</a>：市值10声称要支持WASM，但是根据<a href="https://tron.network/static/doc/white_paper_v_2_0.pdf">官方白皮书</a>的介绍，目前采用的实现是以太坊的fork</li><li><a href="https://github.com/ewasm/hera">Hera</a>：Geth采用的Wasm，需要EVMC的支持</li><li><a href="https://github.com/vshymanskyy/awesome-wasm-tools">awesome-wasm-tools</a>：Wasm静态分析、动态分析和相关论文的仓库</li></ul><p>学习资料</p><ul><li>fuzzinglab<ul><li>开源工具集 <a href="https://fuzzinglabs.com/blockchain-security-fuzzing/">FuzzingLabs</a></li><li>medium Fuzz testing in webassembly vms <a href="https://medium.com/wasmer/fuzz-testing-in-webassembly-vms-3a301f982e5a">https://medium.com/wasmer/fuzz-testing-in-webassembly-vms-3a301f982e5a</a></li><li>学习教程 <a href="https://fuzzinglabs.com/journey-fuzzing-webassembly-wasm-vm/">https://fuzzinglabs.com/journey-fuzzing-webassembly-wasm-vm/</a></li></ul></li><li>中科大CSS实验室 <a href="https://csslab-ustc.github.io/index.html">https://csslab-ustc.github.io/index.html</a><ul><li>在py虚拟机 wasm虚拟机方面有很多工作</li></ul></li></ul><h2 id="MOVE-VM"><a href="#MOVE-VM" class="headerlink" title="MOVE VM"></a>MOVE VM</h2><ul><li>github的awesome库：<a href="https://github.com/MystenLabs/awesome-move#papers">https://github.com/MystenLabs/awesome-move#papers</a></li><li><a href="https://github.com/diem/diem">MoveVM</a>：Facebook旗下的区块链项目Diem（ Libra ）采用的虚拟机，rust实现</li><li><a href="https://github.com/MystenLabs/sui">Sui</a>：Mysten Labs于2022年3月发起的layer1 PoS公链，目前市值排行91，同样采用Move作为运行时</li></ul><h1 id="以太坊客户端"><a href="#以太坊客户端" class="headerlink" title="以太坊客户端"></a>以太坊客户端</h1><p>根据以太坊主网的<a href="https://www.ethernodes.org/">统计数据</a>显示，geth是使用最广泛的客户端</p><p><img src="/2023/10/12/EVM-security/image-20231012160435832.png" alt="image-20231012160435832"></p><ul><li><a href="https://github.com/ethereum/go-ethereum">Geth</a>：占比50.0%，采用go语言实现，最常用的客户端<ul><li>支持Mainnet, Sepolia, Goerli</li></ul></li><li><a href="https://github.com/NethermindEth/nethermind">Nethermind</a>：占比29.3%，采用C#实现<ul><li>支持Mainnet, Sepolia, Goerli, and more</li></ul></li><li><a href="https://github.com/ledgerwatch/erigon">Erigon</a>：占比11.12%，采用go语言实现，作为Openethereum的后继者<ul><li>Mainnet, Sepolia, Goerli, and more</li></ul></li><li><a href="https://github.com/hyperledger/besu">besu</a>：占比9%，Java实现，Hyperledger 项目的一部分，是一个企业级以太坊客户端<ul><li>Mainnet, Sepolia, Goerli, and more</li></ul></li><li><a href="https://github.com/paradigmxyz/reth">reth</a>：占比0.5%，Rust实现<ul><li>Mainnet, Sepolia, Goerli, and more</li></ul></li><li><p><a href="https://github.com/openethereum/openethereum">Openethereum</a>：采用Rust实现，曾经仅次于geth， August 4, 2021已被弃用</p></li><li><p><a href="https://github.com/etclabscore/core-geth">Coregeth</a>：Go实现，Geth的下游发行版</p></li></ul><h1 id="EVM兼容的区块链"><a href="#EVM兼容的区块链" class="headerlink" title="EVM兼容的区块链"></a>EVM兼容的区块链</h1><p>所有兼容EVM的区块链可见 <a href="https://www.coincarp.com/zh/chainlist/">EVM公链列表CoinCarp</a></p><ul><li><a href="https://www.bnbchain.world/en">Binance Smart Chain</a>：token BNB，市值排行第4，由币安交易所推出<ul><li>客户端<a href="https://github.com/bnb-chain/bsc">bsc</a>基于geth fork开发，EVM类似于geth</li></ul></li><li><a href="https://fantom.foundation/">Fantom</a>：token FTM，市值排行63<ul><li>客户端opera采用go实现，利用了EVM的实现<a href="https://github.com/Fantom-foundation/go-opera">go-opera</a></li></ul></li><li><a href="https://polygon.technology/">Polygon</a>：token MATIC，市值排行13<ul><li>虚拟机是zkEVM，声称与EVM等价 <a href="https://polygon.technology/polygon-zkevm">Polygon zkEVM | Scaling for the Ethereum Virtual Machine</a></li><li><a href="https://github.com/maticnetwork/bor">Bor</a>，EVM实现是geth的fork</li></ul></li><li><a href="https://www.avax.network/">Avalanche</a>：token AVAX，市值排行22</li></ul><h1 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h1><ul><li><p><a href="https://github.com/ethereum/tests">EVMtest</a> 以太坊项目官方对客户端会进行单元测试，</p></li><li><p><a href="https://github.com/ooibc88/blockbench">Blockbench</a> 区块链测试用例 </p></li><li><p><a href="https://github.com/ziyadedher/evm-bench">EVM性能对比和压力测试</a> </p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>可能的研究方向<ul><li>虚拟机：目前学术论文的研究对象主要是EVM的官方实现（geth/aleth/js-evm/openethereum）和EVM兼容的链（FISCO-BCOS-evm），逐渐开始有向其他公有链项目采用的VM进行延伸（Neo）的工作。后续工作可以考虑对其他EVM兼容的区块链上的EVM实现（如SputnikVM）进行差分模糊测试和对其他非EVM的知名公有链的虚拟机（EOS-VM/Solana/Cardano）安全性进行研究</li><li>客户端：现有的对以太坊客户端的测试主要以Geth为主。但是从以太坊官方的统计数据来看，除了Geth之外，Nethermind、Eriqon、besu同样占有较大的比例，对以上客户端内的EVM实现进行差分模糊测试也是具有一定研究意义的</li></ul></li><li>目前探索的方向：学习EVMfuzzer和NeoDiff，扩展到EVM compatible的链上</li></ul><h1 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h1><ul><li>6年前其他人总结的EVM相关的资料：<a href="https://github.com/pirapira/awesome-ethereum-virtual-machine">pirapira/awesome-ethereum-virtual-machine: Ethereum Virtual Machine Awesome List (github.com)</a></li><li><a href="https://github.com/kareniel/awesome-evm-security">https://github.com/kareniel/awesome-evm-security</a></li><li>WASM对应的VM：<a href="https://github.com/appcypher/awesome-wasm-runtimes">appcypher/awesome-wasm-runtimes: A list of webassemby runtimes (github.com)</a></li><li>Move语言相关资料：<a href="https://github.com/MystenLabs/awesome-move#move-powered-blockchains">MystenLabs/awesome-move: Code and content from the Move community. (github.com)</a></li><li>CCS23放出的Accepted Poster <a href="https://www.sigsac.org/ccs/CCS2023/program.html">https://www.sigsac.org/ccs/CCS2023/program.html</a><ul><li>Poster:A Privacy-Preserving Smart Contract Vulnerability Detection Framework for Permissioned Blockchain<br>Wensheng Tian (Nanhu Laboratory - CN)<br>Lei Zhang (Nanhu Laboratory - CN)<br>Shuangxi Chen (Jiaxing Vocational and Technical College - CN)<br>Hu Wang (Zhejiang Big Data Development Administration - CN)<br>Xiao Luo (Zhejiang University - CN)</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;调研区块链虚拟机安全&lt;/p&gt;</summary>
    
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>BlockScope</title>
    <link href="https://alleysira.github.io/2023/09/26/BlockScope/"/>
    <id>https://alleysira.github.io/2023/09/26/BlockScope/</id>
    <published>2023-09-26T10:17:51.000Z</published>
    <updated>2024-01-21T08:07:47.730Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="BlockScope-Detecting-and-Investigating-Propagated-Vulnerabilities-in-Forked-Blockchain-Projects"><a href="#BlockScope-Detecting-and-Investigating-Propagated-Vulnerabilities-in-Forked-Blockchain-Projects" class="headerlink" title="BlockScope: Detecting and Investigating Propagated Vulnerabilities in Forked Blockchain Projects"></a>BlockScope: Detecting and Investigating Propagated Vulnerabilities in Forked Blockchain Projects</h1><p>Yi X, Fang Y, Wu D, et al. BlockScope: Detecting and Investigating Propagated Vulnerabilities in Forked Blockchain Projects[C].Network and Distributed System Security (NDSS) Symposium 2023 27 February - 3 March 2023, San Diego, CA, USA.</p><span id="more"></span><p>NDSS23的<a href="https://www.ndss-symposium.org/ndss-paper/blockscope-detecting-and-investigating-propagated-vulnerabilities-in-forked-blockchain-projects/">工作</a></p><p>许多区块链重用或者fork了比特币/以太坊等经典区块链的代码，不难理解，当fork或频繁fetch时可能将原来链上存在的漏洞传播到当前链上。本文设计了BlockScope，能够在输入现有的BC/Ethereum安全补丁后，检测出多个cloned漏洞</p><p>BlockScope采用基于相似度的代码匹配机制，设计了一种新的计算代码相似度的方法来覆盖所有syntax-wide变量的克隆</p><p>BlockScope能够自动抽取补丁的上下文，找到潜在的相关代码进行对比</p><p>和现有工作ReDebug相比，能在精度接近的情况下实现1.8倍的recall（确定更多可能执行的路径或者函数调用）</p><p>分别在13/16个forked区块链上发现了101个漏洞</p><ul><li>40个被接受或修复</li><li>66被知情，等待中</li><li>4个被拒绝</li></ul><p>总结出了3类从源到分叉的链的漏洞传播规律</p><p>仅开源了具体的漏洞报告 <a href="https://github.com/VPRLab/BlkVulnReport">VPRLab/BlkVulnReport: A Summary of Vulnerabilities Found in the BlockScope NDSS’23 Paper (github.com)</a>，没有源代码</p><h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>因为开源，所以可以fork或重用eth和Bitcoin的代码</p><p>漏洞传播可能的途径</p><ul><li>最初分叉</li><li>update commits</li></ul><p>创新点</p><ul><li>相似度检查而不是精确的hash对比，相似度计算方法改进，更好处理增删和重排序<ul><li>更接近Soundness：大幅降低假阴率，略微提高假阳率</li></ul></li><li>抽取并利用补丁代码的语境定位可能相关的代码段<ul><li>提高执行效率和精度</li></ul></li></ul><p>数据集采用了38个补丁</p><ul><li>32个是比特币的代码仓库中来的（CVE只有4个</li><li>6个Ethereum的CVE</li></ul><p>分别测试了11+6个fork链的C/Go的代码，准确率和recall率为91.8%</p><p>发现漏洞后试图总结传播规律</p><ul><li>最初fork时传播</li><li>fetch时传播</li><li>被非显式的commit感染</li></ul><p>大多数分叉链修补的时间延迟约为200天 </p><p>提供的具体漏洞CVE和PR：<a href="https://github.com/VPRLab/BlkVulnReport">VPRLab/BlkVulnReport: A Summary of Vulnerabilities Found in the BlockScope NDSS’23 Paper (github.com)</a></p><p>wu老师的主页总结了学术界和工业界安全相关会议的ddl <a href="https://daoyuan14.github.io/">Daoyuan Wu’s HomePage (daoyuan14.github.io)</a></p><h1 id="design-choices-and-system-overview"><a href="#design-choices-and-system-overview" class="headerlink" title="design choices and system overview"></a>design choices and system overview</h1><ul><li>基于补丁的代码检测</li><li>不针对特定编程语言，不采用类似程序分析的抽象</li><li>创新点<ul><li>利用补丁代码上下文，仅定位相关的代码（不用分析全程序，精度更高）</li><li>采用基于代码相似度的代码匹配机制，支持3类代码克隆</li></ul></li></ul><h1 id="问题与思考"><a href="#问题与思考" class="headerlink" title="问题与思考"></a>问题与思考</h1><ul><li>什么是similariry based code match</li><li>recall：分析结果中确定可达分支的能力</li><li>extract之前需要normalizing and tokenizing</li></ul><p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;BlockScope-Detecting-and-Investigating-Propagated-Vulnerabilities-in-Forked-Blockchain-Projects&quot;&gt;&lt;a href=&quot;#BlockScope-Detecting-and-Investigating-Propagated-Vulnerabilities-in-Forked-Blockchain-Projects&quot; class=&quot;headerlink&quot; title=&quot;BlockScope: Detecting and Investigating Propagated Vulnerabilities in Forked Blockchain Projects&quot;&gt;&lt;/a&gt;BlockScope: Detecting and Investigating Propagated Vulnerabilities in Forked Blockchain Projects&lt;/h1&gt;&lt;p&gt;Yi X, Fang Y, Wu D, et al. BlockScope: Detecting and Investigating Propagated Vulnerabilities in Forked Blockchain Projects[C].Network and Distributed System Security (NDSS) Symposium 2023 27 February - 3 March 2023, San Diego, CA, USA.&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/categories/Blockchain/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="SmartContract" scheme="https://alleysira.github.io/tags/SmartContract/"/>
    
  </entry>
  
  <entry>
    <title>NeoDiff</title>
    <link href="https://alleysira.github.io/2023/09/25/NeoDiff/"/>
    <id>https://alleysira.github.io/2023/09/25/NeoDiff/</id>
    <published>2023-09-25T07:55:11.000Z</published>
    <updated>2023-11-28T11:40:35.726Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Uncovering-Smart-Contract-VM-Bugs-Via-Differential-Fuzzing"><a href="#Uncovering-Smart-Contract-VM-Bugs-Via-Differential-Fuzzing" class="headerlink" title="Uncovering Smart Contract VM Bugs Via Differential Fuzzing"></a>Uncovering Smart Contract VM Bugs Via Differential Fuzzing</h1><p>Maier D, Fäßler F, Seifert J P. Uncovering Smart Contract VM Bugs Via Differential Fuzzing[C]//Reversing and Offensive-oriented Trends Symposium. 2021: 11-22.</p><span id="more"></span><p>基于覆盖和状态对智能合约虚拟机的行为进行模糊测试，提出了NeoDiff——第一个反馈导向的智能合约虚拟机的模糊测试框架</p><ul><li><p>除了对EVM进行模糊测试，NeoDiff发现了若干Neo区块链上的重要漏洞</p></li><li><p>通过高层的语义变异器，发现了Python编写的Neo智能合约和传统CPython编写的合约的不一致</p></li><li>发现了C#的Neo虚拟机中的内存损坏问题</li></ul><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>智能合约虚拟机类似于传统安全研究范畴内的操作系统，执行合约的虚拟机定义了如何进行交互的接口，没有文件系统、套接字和线程，而是直接访问区块链，因此出现了新的安全问题</p><p>智能合约虚拟机需要保证执行结果的一致性</p><p>2500行代码实现了NeoDiff</p><p>反馈部分不仅考虑了覆盖率，还考虑了虚拟机传回的状态传播</p><p>尽管对以太坊的两个虚拟机的测试仅返回了假阳的结果（可能是因为严格的手工测试），额外发现了很多其他生态系统中的漏洞，如Neo</p><p>Neo是一个被研究较少的区块链，2021年日均交易量达1.5亿美元。项目地址：<a href="https://neo.org/">Neo 智能经济</a></p><p><a href="https://www.investopedia.com/tech/china-neo-cryptocurrency/">NEO (NEO) Definition (investopedia.com)</a></p><p><img src="/2023/09/25/NeoDiff/image-20230925160606443.png" alt="image-20230925160606443"></p><p>在Neo上NeoDiff发现了VM的不一致性、主链上的内存损坏，因为Neo提供了利用python等传统编程语言写智能合约的选项，因此可以利用python的语义进行模糊测试</p><p>和传统模糊测试不同的是，差分模糊测试想要实现的是输出或状态的不一致，NeoDiff支持对不同编程语言实现的系统进行模糊测试（neo-python VM 客户端和Neo VM C# 共识节点)，</p><p>发现了CPython and neo-boa Python和智能合约上的语义差别</p><p>贡献如下：</p><ul><li><p>开发并开源了NeoDiff，对智能合约虚拟机定制的模糊测试工具</p><ul><li><a href="https://github.com/fgsect/NeoDiff">fgsect/NeoDiff: Differential fuzzing for Smart Contract VMs (github.com)</a></li></ul></li><li><p>实现了NeoDiff的后端，来模糊测试openethereum against the geth Ethereum VM和<br>Neo VM against neo-python.</p></li><li>测试了CPython和Python实现的合约的语义，发现了语义的差距和对应的安全后果</li><li>讨论了如何利用智能合约虚拟机中的不一致性进行攻击（如攻击区块链网络上的应用</li><li>NeoDiff帮助发现并修复了Neo智能合约生态系统中的重要bug</li></ul><h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><p>2020年FC有一篇讨论NEo的BFT方案的论文，Neo采用PoS，参与共识的节点数量较少；目前支持8种编程语言编写合约（Python, Go, JavaScript, Java and C#  /C C++ to be done)；Neo的编译器调用对应语言的官方编译器，将IR转换成AVM 码，即虚拟机的字节码。</p><p>参与共识的节点运行C#编写的Neo VM构成区块链网络的核心部分，为了调用区块链，用户需要使用客户端程序，提供了SDK供开发者在NEO区块链上编写应用程序和合约交互；SDK需要能够理解所有交易并本地执行合约</p><ul><li><p>资产：Neo区块链原生的资产是代币Neo和部署、执行合约需要的GAS；NeoGas随时间生成并根据拥有的Neo成比例地分配给钱包；每个节点本地 都能执行字节码形式的合约，消耗的gas和opcode以及syscall相关联。共识算法是基于PBFT的DelegatedBFT</p></li><li><p>虚拟机：负责执行上传的合约，每个参与者都必须有VM来执行合约，和传统的VM不同，Neo VM不提供硬件和文件系统访问，直接和区块链的数据交互。本地执行合约允许客户端从合约存储中直接读取数据，而不用通过缓慢的API进行查或相信中心化的节点</p></li><li><p>C#虚拟机：执行引擎是核心部分，包括函数和调用栈。执行合约时创建一个对应的上下文。上下文中包括代码和两个栈每个合约在隔离的上下文中执行，合约可以使用两个栈</p><ul><li>altstack：临时数据存储</li><li>执行栈：存储结果</li><li>每次调用生成新的调用栈</li><li><p>架构如图<img src="/2023/09/25/NeoDiff/image-20230925171307210.png" alt="image-20230925171307210"></p></li><li><p>持久存储：大多数数据（例如区块链的交易和合约的永久K-V存储）均可以通过syscall操作码访问；区块链本身仅存储交易，包括了调用合约的交易；为了得到当前存储的状态，所有交易都必须被重放（重新执行），存储可能存了认证消息或代币的余额。可以给予另一个合约访问存储的对象的权利</p><ul><li>实现中的漏洞或不恰当的授权可能导致存储相关的问题，如delagatecall<ul><li>Johannes Krupp and Christian Rossow. 2018. teether: Gnawing at Ethereum to<br>Automatically Exploit Smart Contracts. Proceedings of the 27th USENIX Security<br>Symposium (2018), 1317–1333.</li></ul></li></ul></li></ul></li></ul><h1 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work"></a>Related work</h1><p>在智能合约概念出现之前，差分模糊测试被用于测试编译器和代码库</p><ul><li>CSmith：自动生成C程序，寻找不同编译器和优化层级带来的程序行为的差异 2011</li><li>Diffuzz：通过差分模糊测试进行侧信道分析</li><li>NEZHA：对二进制代码库进行差分模糊测试，除了代码覆盖率之外，采用了多种反馈</li><li>HyDiff：和NEZHA类似，关注覆盖率的同时，额外利用了静态分析和符号执行，采用了一系列的启发式推理改善对变异输出的</li><li>EVMFuzzer：生成合约并提供给以太坊虚拟机发现不一致性，在solidity层面对合约进行变异</li></ul><p>提到了EVMFuzzer，世界线收束</p><h1 id="NEODIFF"><a href="#NEODIFF" class="headerlink" title="NEODIFF"></a>NEODIFF</h1><p>对同一个虚拟机的多个可选实现进行差分模糊测试</p><p><img src="/2023/09/25/NeoDiff/image-20230925185409445.png" alt="image-20230925185409445"></p><h2 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h2><p>反馈导向，可以采用不同量级的反馈机制来对不同编程语言实现的VM进行测试</p><p>和EVMFuzz相比，NeoDiff更底层，生成有效的操作码序列而不是修改AST再转化为合约，会枚举所有可能的操作码序列，然而solidity编译器可能不会生成无意义的操作码（假设VM之前很少接受这种高级语言不会生成的序列的测试）</p><ul><li>Diff generator：采用基于反馈的变异器生成VM执行的字节码<ul><li>拼接、添加高覆盖率的片段、随机翻转字节，能够生成高级编程语言无法生成的操作码序列</li></ul></li><li>mutator：可以针对特定目标定制不同变异器；默认NeoDiff循环采用下列的变异器，直到达到最小的合约长度；由于可能生成全新的合约，不容易陷入局部最优解；会将成功执行的字节码序列保留下来；方便定义其他特定链的变异器<ul><li>随机1字节</li><li>全拼接：添加<del>部分</del>第二个随机合约的代码，倾向于能够覆盖新分支的测试用例</li><li>部分拼接：添加部分第二个随机合约的代码，倾向于能够覆盖新分支的测试用例<ul><li><img src="/2023/09/25/NeoDiff/image-20230925193912440.png" alt="image-20230925193912440"></li></ul></li><li>字节插入：一个字节插入到当前合约的随机位置</li><li>特殊操作：特殊的字节码，比如ETH的PUSHBYTES</li></ul></li><li>Diff Analyzer：需要修改EVM的实现来生成trace，trace的内容包括执行的操作码的列表，对应的类型hash $\tau$和状态hash $\sigma$，分析器通过比较$\sigma$来发现不同，通过$\tau$判断是否到达了新的状态<ul><li>假设当中间的$\sigma$不同时，认为出现了分叉</li><li>出现不一致时，导致问题产生的操作码和对应的$\tau$存储在结果中</li><li>分叉之前正确的操作码和对应的$\tau$会前向传播到minimizer</li><li>minimizer试图寻找到能导致特定$\tau$的最短字节序列并且存储到$\tau$ map中去<ul><li>$\tau$ map随着模糊测试的进行不断增长，后续可以用于变异的反馈</li></ul></li><li><img src="/2023/09/25/NeoDiff/image-20230925200033512.png" alt="image-20230925200033512"></li></ul></li></ul><h2 id="state-hash"><a href="#state-hash" class="headerlink" title="state-hash"></a>state-hash</h2><p>为了标识不同的执行，利用了状态哈希$\sigma$，取当前执行中的状态的子集，由研究者定义对于diff重要的信息，将该信息包括在哈希中</p><ul><li>对于基于栈的虚拟机而言，包括对栈的概率性采样；</li><li>如果有寄存器应该包括寄存器的值</li><li>如果有额外的内存，需要考虑内存</li></ul><p>执行速度和精度之前需要进行trade-off，可能的话对每个操作码都更新$\sigma$，利用它来检测不一致性</p><h2 id="Type-Hash"><a href="#Type-Hash" class="headerlink" title="Type-Hash"></a>Type-Hash</h2><p>思路：利用type-hash来作为一种轻量级的覆盖率的表示</p><p>也包含了状态信息，但是没有和之前的状态连接起来，仅标识当前操作码的状态</p><p>由于Neo VM支持多种类型（整数、字节数组等），以太坊仅支持256比特的整数作为类型，设立了虚类型方便执行</p><p>NeoDiff支持在传统的代码覆盖率下进行测试，如果采用了类型哈希，可以用来对差异进行排序和分类</p><p>类型哈希 $\tau $ 利用栈顶的2个类型，前缀为当前的操作码，执行加法命令，栈顶元素是整型1和字节数组2，对应的类型哈希 𝜏 为ADD_12</p><p>问题：类型哈希变化一定意味着覆盖率的变化吗？实验结果：86%的情况下，发现新的类型哈希 𝜏 同样标识到达了新的代码覆盖率。结果表明类型哈希能够表示所有的覆盖率变化，NeoDiff同样支持采用实际的覆盖率作为类型哈希</p><p><img src="/2023/09/25/NeoDiff/image-20231006192746686.png" alt="image-20231006192746686"></p><h2 id="Minimization"><a href="#Minimization" class="headerlink" title="Minimization"></a>Minimization</h2><p>利用测试用例再次执行VM，对于每个字节检查是否包含了之前的 𝜏 ，一旦发现了所有的类型哈希，认为当前长度是最短的</p><p>根据操作码导致的类型哈希来进行分类</p><h1 id="Eval"><a href="#Eval" class="headerlink" title="Eval"></a>Eval</h1><p>工具已经开源，后续有空测试一下</p><p><a href="https://github.com/fgsect/NeoDiff">fgsect/NeoDiff: Differential fuzzing for Smart Contract VMs (github.com)</a></p><ul><li>C# VM and neo-python VM<ul><li>测试了4个变异策略<ul><li>random：字节全随机</li><li>mut1p：将特定值压入栈，利用覆盖率反馈的概率较低</li><li>mut20p：基于反馈的变异，概率是20倍</li><li>coverage：默认变异策略，初始是随机的</li><li><img src="/2023/09/25/NeoDiff/image-20230928082042644.png" alt="image-20230928082042644"></li><li>然而当运行深度增加，随机策略丧失了多样性</li></ul></li></ul></li><li>geth vs. openethereum<ul><li>发现了6个不同，均是配置信息，未能在现有的区块链上复现</li><li><img src="/2023/09/25/NeoDiff/image-20230928084441953.png" alt="image-20230928084441953"></li></ul></li><li>cpy vs. Neo py：额外设计了py的语义变异器，不基于状态，能够产生有效的python脚本能够作为Neo智能合约运行<ul><li><img src="/2023/09/25/NeoDiff/image-20231006200937631.png" alt="image-20231006200937631"></li></ul></li></ul><h1 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h1><h2 id="合约虚拟机差异的安全影响"><a href="#合约虚拟机差异的安全影响" class="headerlink" title="合约虚拟机差异的安全影响"></a>合约虚拟机差异的安全影响</h2><ul><li>链上差异：可能导致算力分叉，大多数算力采用的实现将成为主流，可能导致链分叉</li><li>区块链应用差异：钱包和Dapp本地执行结果和主网不一致，导致出现本地分叉</li><li>合约语义差异：python写的合约和solidity写的合约行为不一致，恶意的开发者可能设计后门</li></ul><h2 id="对Neo-VM差异的PoC"><a href="#对Neo-VM差异的PoC" class="headerlink" title="对Neo VM差异的PoC"></a>对Neo VM差异的PoC</h2><p>给了比较详细的PoC和脚本</p><h2 id="Ethereum-VM-Differences"><a href="#Ethereum-VM-Differences" class="headerlink" title="Ethereum VM Differences"></a>Ethereum VM Differences</h2><p><img src="/2023/09/25/NeoDiff/image-20231006202931015.png" alt="image-20231006202931015"></p><p>表明进行差分模糊测试时应该在空白的链上，采用相同的初始设置</p><p>或者手动删除这些假阳性</p><h2 id="语言语义的差异"><a href="#语言语义的差异" class="headerlink" title="语言语义的差异"></a>语言语义的差异</h2><ul><li>语义差异：<ul><li>编译时报错：neo-boa不支持range()和float</li></ul></li><li>字符串连接：<ul><li>+：neo-python编译成VMOP.ADD，整数加法<ul><li>‘xxx’+’!!!’=’xxx!!!’, not ‘yyy’</li></ul></li></ul></li><li>字符串乘法<ul><li>’x’<em>21 和 ’x’</em>20</li></ul></li><li>潜在的漏洞：Neo VM会进行类型转换，之前的安全机制如给key加前缀可能不再安全<ul><li><img src="/2023/09/25/NeoDiff/image-20231006204246703.png" alt="image-20231006204246703"></li></ul></li></ul><h2 id="Neo-VM的差异和漏洞"><a href="#Neo-VM的差异和漏洞" class="headerlink" title="Neo VM的差异和漏洞"></a>Neo VM的差异和漏洞</h2><ul><li>类型转换</li><li>执行引擎的差异</li><li>数学操作的不一致</li><li>VM崩溃</li></ul><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>仓库地址：<a href="https://github.com/fgsect/NeoDiff">https://github.com/fgsect/NeoDiff</a></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git submodule init</span><br><span class="line">git submodule update <span class="comment">## take some time</span></span><br></pre></td></tr></table></figure><p>openethereum经典下不下来，但是git checkout似乎没问题，先看看能不能编译出来</p><h3 id="安装go"><a href="#安装go" class="headerlink" title="安装go"></a>安装go</h3><p>安装go，选择1.16.15，<a href="https://golang.google.cn/dl/">https://golang.google.cn/dl/</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -C /usr/local -xzf go1.16.15.linux-amd64.tar.gz</span><br><span class="line">build go ehtereum</span><br></pre></td></tr></table></figure><p>报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alleysira@LAPTOP-M4HO8L6S:~/NeoDiff$ make -C ./go-ethereum all</span><br><span class="line">make: Entering directory &#x27;/home/alleysira/NeoDiff/go-ethereum&#x27;</span><br><span class="line">env GO111MODULE=on go run build/ci.go install</span><br><span class="line">go: github.com/Azure/azure-pipeline-go@v0.2.2: Get &quot;https://proxy.golang.org/github.com/%21azure/azure-pipeline-go/@v/v0.2.2.mod&quot;: dial tcp 172.217.163.49:443: i/o timeout</span><br><span class="line">make: *** [Makefile:21: all] Error 1</span><br><span class="line">make: Leaving directory &#x27;/home/alleysira/NeoDiff/go-ethereum&#x27;</span><br></pre></td></tr></table></figure><p>挂代理用 <code>source ../proxy</code>,<code>curl www.google.com</code>检查，作用不大，卒</p><p>换国内的代理解决</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go env -w GO111MODULE=on</span><br><span class="line">go env -w  GOPROXY=https://goproxy.cn,direct </span><br></pre></td></tr></table></figure><h3 id="build-openethereum"><a href="#build-openethereum" class="headerlink" title="build openethereum"></a>build openethereum</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --proto &#x27;=https&#x27; --tlsv1.2 -sSf https://sh.rustup.rs | sh</span><br></pre></td></tr></table></figure><p>换ustc的源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ./openethereum/bin/evmbin</span><br><span class="line">cargo build --release</span><br></pre></td></tr></table></figure><p>卡在441/442</p><p><img src="/2023/09/25/NeoDiff/image-20231016212223747.png" alt="image-20231016212223747"></p><h3 id="安装虚拟环境"><a href="#安装虚拟环境" class="headerlink" title="安装虚拟环境"></a>安装虚拟环境</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;Installing reqs for us, creating virtualenv&quot;</span><br><span class="line">virtualenv -p &quot;$(command -v python3)&quot; &quot;$(pwd)/.env&quot;</span><br><span class="line">. .env/bin/activate</span><br><span class="line">pip3 install -r requirements.txt</span><br></pre></td></tr></table></figure><p>轻松愉快</p><h3 id="安装Neo-python的环境"><a href="#安装Neo-python的环境" class="headerlink" title="安装Neo python的环境"></a>安装Neo python的环境</h3><p>本来是轻松加愉快，缺一个leveldb，补上就行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd neo-python</span><br><span class="line">pip install -r requirements.txt</span><br><span class="line">sudo apt-get install libleveldb-dev</span><br></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>在虚拟环境<code>.env</code>中运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">. .env/bin/activate</span><br><span class="line">./utils/EVMrun.sh 1</span><br><span class="line">./utils/EVMscale.sh [proc_count]</span><br></pre></td></tr></table></figure><p><img src="/2023/09/25/NeoDiff/image-20231016215516748.png" alt="image-20231016215516748"></p><p>运行100轮，测试geth和openEthereum查看结果</p><p><img src="/2023/09/25/NeoDiff/image-20231018180131426.png" alt="image-20231018180131426"></p><p>平均运行一轮消耗时间为76/25=3</p><p><img src="/2023/09/25/NeoDiff/image-20231018195339302.png" alt="image-20231018195339302"></p><p>运行了22小时，379轮</p><p><img src="/2023/09/25/NeoDiff/image-20231019162646551.png" alt="image-20231019162646551"></p><p>在utils目录下运行analyse_data.py得到对应的csv文件</p><h1 id="问题和思考"><a href="#问题和思考" class="headerlink" title="问题和思考"></a>问题和思考</h1><ul><li>变异策略生成的合约操作码能够执行的比例占多少</li><li>为什么说Ethereum VM没有类型</li><li>和EVMfuzzer相比，对于不一致性的对比更加细致（不再仅思考输出的不一致性，还考虑了中间过程）</li><li>状态哈希需要研究者手动定义对于diff来说哪些信息重要</li><li>minimization认为最短的序列不一定是最短；代码可能有跳转</li><li>python语义的对比：为什么是和python2 和 3对比，而不是直接比较</li></ul><p>本文定义的变异策略显示coverage已经足够好了</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Uncovering-Smart-Contract-VM-Bugs-Via-Differential-Fuzzing&quot;&gt;&lt;a href=&quot;#Uncovering-Smart-Contract-VM-Bugs-Via-Differential-Fuzzing&quot; class=&quot;headerlink&quot; title=&quot;Uncovering Smart Contract VM Bugs Via Differential Fuzzing&quot;&gt;&lt;/a&gt;Uncovering Smart Contract VM Bugs Via Differential Fuzzing&lt;/h1&gt;&lt;p&gt;Maier D, Fäßler F, Seifert J P. Uncovering Smart Contract VM Bugs Via Differential Fuzzing[C]//Reversing and Offensive-oriented Trends Symposium. 2021: 11-22.&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/categories/Blockchain/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="SmartContract" scheme="https://alleysira.github.io/tags/SmartContract/"/>
    
  </entry>
  
  <entry>
    <title>EVMFuzzer</title>
    <link href="https://alleysira.github.io/2023/09/19/EVMFuzzer/"/>
    <id>https://alleysira.github.io/2023/09/19/EVMFuzzer/</id>
    <published>2023-09-19T08:09:27.000Z</published>
    <updated>2024-02-29T12:13:30.846Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="EVMFuzzer-Detect-EVM-Vulnerabilities-via-Fuzz-Testing"><a href="#EVMFuzzer-Detect-EVM-Vulnerabilities-via-Fuzz-Testing" class="headerlink" title="EVMFuzzer: Detect EVM Vulnerabilities via Fuzz Testing"></a>EVMFuzzer: Detect EVM Vulnerabilities via Fuzz Testing</h1><p>Fu Y, Ren M, Ma F, et al. Evmfuzzer: detect evm vulnerabilities via fuzz testing[C]//Proceedings of the 2019 27th ACM joint meeting on european software engineering conference and symposium on the foundations of software engineering. 2019: 1110-1114.</p><span id="more"></span><p><a href="https://www.youtube.com/watch?v=9Lejgf2GSOk&amp;ab_channel=EVMFuzzer">EVMFuzzer: Detect EVM Vulnerabilities via Fuzz Testing - YouTube</a></p><p>对以太坊合约进行测试的挑战在于测试输入数据的格式以及预言机的存在，EVMFuzzer是第一个采用差分模糊测试技巧检查以太坊漏洞的工具。本文的核心思想是不断生成种子合约并输入给目标EVM和其他测试标准EVM，通过发现尽可能多的执行结果的不一致性，最终发现带有输出交叉引用的漏洞</p><p>给定目标EVM和对应的API，EVMFuzzer通过预定义的mutators生成新的种子合约，采用动态优先级调度算法来指导种子合约选择过程，最大化不一致性。最终EVMFuzzer将其他测试标准EVM作为交叉应用的预言机来避免手动检查</p><p>实验结果：将36295个真实世界的合约作为种子，生成了253153个合约，其中66.3的合约表现出了不同的性能。在4个EVM上发现了若干先前未知的漏洞，其中5个已经作为CVE记录在NVD了</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Oyente和MAIAN采用符号执行来发现智能合约的漏洞，如果EVM本身存在漏洞，会导致严重的后果</p><p>选择了10个通过了Oyente安全检查的合约在EVM上执行，发现了其中7个的gas消耗不一样</p><p>合约层面的验证无法保证以太坊交易执行的正确性，需要保证EVM执行的正确性</p><p>对EVM的测试面临着以下的挑战</p><ul><li>如何定义一般场景测试标准<ul><li>EVM有超过10种不同编程语言的实现</li></ul></li><li>如何生成能够引发bug的测试样例<ul><li>目前没有对EVM进行系统测试的工具</li></ul></li></ul><p>贡献</p><ul><li>给出一种对EVM进行差分模糊测试的评价标准，定义了8个变异器（种子合约生成），设计了动态优先级调度算法</li><li>实现了EVMFuzz，能够自动进行差分模糊测试</li><li>测试了目前广泛使用的EVM，发现了5个CVE</li></ul><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>例子</p><p><img src="/2023/09/19/EVMFuzzer/image-20230920151552188.png" alt="image-20230920151552188"></p><p>这个合约能够通过若干合约测试和验证工具，在不同EVM实现中结果不同，甚至可能会导致dos</p><p>分别在js-evm,py-evm,aleth上进行测试</p><p>aleth会打印执行路径然后一直占有CPU资源，指导系统kill所有进程然后宕机</p><p>aleth不会给出用户有好的反馈或者及时止损或者减少恶意占用的资源，最终导致dos</p><p>这个例子表示一些包含边界条件的合约可能触发EVM实现的边界条件，但是这种合约比较难以构造，因此可以采用差分模糊测试</p><h2 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work"></a>Related work</h2><ul><li>Fuzzing：采用边界数据作为输入来保证程序没有bug<ul><li>主流工具AFL类的，采用多种策略加速fuzzing</li></ul></li><li>Differential Testing：针对预期功能相同的不同实现进行测试，发现不同<ul><li>DLFuzz对深度学习框架进行差分模糊测试</li></ul></li><li>智能合约验证：Oyente从字节码构造控制流图再进行符号执行；Zeus是一个sound的分析器，将智能合约翻译到LLVM中</li></ul><p>EVMFuzzer面向的目标是EVM，其他工作主要关注智能合约</p><h2 id="Approach-Overview"><a href="#Approach-Overview" class="headerlink" title="Approach Overview"></a>Approach Overview</h2><p>Differential fuzz testing is to continuously provide invalid, unexpected or random data as inputs to several programs with the same functions.</p><p>如果发现运行结果不同，可能发现了bug</p><p>种子合约生成模块基于 静态分析</p><p>统一合约执行基于 循环模糊测试</p><p><img src="/2023/09/19/EVMFuzzer/image-20230920154124925.png" alt="image-20230920154124925"></p><h2 id="EVMFuzzer-design"><a href="#EVMFuzzer-design" class="headerlink" title="EVMFuzzer design"></a>EVMFuzzer design</h2><p>主要包含 种子合约生成模块和EVM执行模块，种子合约生成模块会不断生成高质量的种子，力图扩大不同EVM执行结果之间的区别。EVM执行模块会为目标EVM和其他测试标准EVM创建统一的执行环境</p><p><img src="/2023/09/19/EVMFuzzer/image-20230919164625085.png" alt="image-20230919164625085"></p><h3 id="种子合约生成"><a href="#种子合约生成" class="headerlink" title="种子合约生成"></a>种子合约生成</h3><p>输入合约，输出关键性质改变后的合约</p><ul><li>构造种子合约的重要位置标识的CAST抽象语法树，辅助后续的变异和分析</li><li>将seed合约放入池中</li><li>EVMFuzz对合约进行评估，排列为带有优先队列，对优先级进行动态调整</li><li>选择排在第一的合约，利用8个（arxiv）预定义的变异器和组合策略来指导变异并获得EVM的输入</li></ul><p>测试用例生成器</p><p>seed合约存储在seed pool中，EVMFuzzer根据动态优先级对候选合约进行排序，首位的合约会被选中进行变异，采用8个预定的编译器和组合策略进行变异</p><ul><li>种子变异：从3个细粒度（word char statement）设计了8个编译器，维护基于度量差异的优先级队列；如果度量差异增加，对应的变异器的权重按降序排列加入到队列中，否则不会更新队列</li><li>种子优先级和选择：为了保证多样性，其他优先级低的合约同样需要有一定的概率被选中，因此采用动态优先级调度算法维护一个候选队列，每个合约有初始的权限，随着等待时间增加</li></ul><h3 id="指标的公式"><a href="#指标的公式" class="headerlink" title="指标的公式"></a>指标的公式</h3><p>EVM作为基于交易的状态机，状态的改变基于操作码和输入的参数以及gas限制</p><ul><li>操作码序列：表示了程序的执行过程，能用于检查执行的正确性 $opSeqLen(i,C)$，i表示平台，执行合约C</li><li>消耗的gas：一个交易或一条消息中消耗的gas总量，直接和交易的执行费相关联，$gsdUsed(i,C)$</li></ul><p>根据两个指标，定义了差异信息的评估指标dif f，值越大表示产生不一致执行结果的概率越大 $output(i,C)$表示执行输出，对于函数调用是返回值；对于交易是balance</p><p>两个指标反应了实现和执行的差距，执行输出反应了EVM运行的正确性和一致性</p><h3 id="CAST的构造"><a href="#CAST的构造" class="headerlink" title="CAST的构造"></a>CAST的构造</h3><p>模糊测试之前，首先执行静态分析，生成CAST</p><p>智能合约的CAST是对Solidity源代码的抽象语法结构的结构化树形表示，树上的每个节点表示源码中出现的结构，CAST定义并分解了所有语句中的性质，分解成CAST方便进行变异，能够根据关键属性直接进行搜索、替代、删除或者插入操作符</p><p>CAST将种子合约的关键位置表示出来（和ehter交易相关的子树），主要包含6个语句符号 new, call , delegatecall , callcode, send and transfer</p><p>变异器主要作用于这些关键位置来测试EVM的核心功能，阴影部分就是重要的位置</p><p><img src="/2023/09/19/EVMFuzzer/image-20230920164427662.png" alt="image-20230920164427662"></p><h3 id="种子合约优先级"><a href="#种子合约优先级" class="headerlink" title="种子合约优先级"></a>种子合约优先级</h3><p>候选合约的重要性不同，使得合约之间指标差异增加的合约应当作为下一轮变异迭代的标准</p><p>同时，为了保证多样性，其他合约应该有一定概率被选中。因此采用动态优先级分配算法来维护一个候选队列，每个合约有初始的优先级，随着等待时间增加，值会增加</p><p><img src="/2023/09/19/EVMFuzzer/image-20230920170033059.png" alt="image-20230920170033059"></p><p>看看伪代码，指标差异优先级初始值为0-10，优先级等于=差异加上时间优先级，根据优先级进行降序排序</p><p>选中优先级最高的作为下一轮变异的合约，输出，对剩余合约的time_pri 加1</p><h3 id="种子合约的变异"><a href="#种子合约的变异" class="headerlink" title="种子合约的变异"></a>种子合约的变异</h3><p>为了生成高质量的种子合约，能够在不同的EVM中触发更多的不一致性</p><p>根据伪代码，首先生成CAST，根据上次迭代的差异信息更新每个变异器（做排序）</p><p><img src="/2023/09/19/EVMFuzzer/image-20230920171115727.png" alt="image-20230920171115727"></p><p>选择组合策略（输入）来变异候选种子合约，最后利用 <a href="https://www.npmjs.com/package/soltar">soltar - npm (npmjs.com)</a> 从CAST中重建代码，输出变异后的代码</p><ul><li>典型的变异器：需要保证被修改合约的语义正确性保证能够正确生成代码，根据合约的逻辑设计了8个变异器<ul><li><img src="/2023/09/19/EVMFuzzer/image-20230920182840510.png" alt="image-20230920182840510"><ul><li>对于方法内的本地变量，修改变量的类型</li><li>对于函数修改对应的属性<ul><li>实际代码实现是修改可见性，可能导致类似的问题：一个函数同时为public和private，已修正</li></ul></li><li>修改算术运算符<ul><li>实际的代码实现没有对当前运算符是否有效（运算符可能出现在注释里面）</li></ul></li><li>修改条件判断语句内的运算符</li><li>修改循环内的边界条件</li><li>对函数内的语句增加assert或者删去assert</li><li>删除函数的return</li><li>对于方法的控制流增加break或者continue</li></ul></li></ul></li><li>变异器选择：同样给这些变异器优先级，根据返回的dif进行调整权重，如果变异后差异变大，将变异器的id加入到队列中，降序排列<ul><li>除了权重更新外，还定义了组合策略，来增加随机性和多样性<ul><li>组合索引为奇数的变异器</li><li>组合索引为偶数的变异器</li><li>组合第一个和最后一个变异器</li><li>不带权重随机选一个变异器</li><li>每轮在上面的策略中随机选一个</li></ul></li></ul></li></ul><h3 id="统一的EVM执行"><a href="#统一的EVM执行" class="headerlink" title="统一的EVM执行"></a>统一的EVM执行</h3><p>为多个EVM提供统一的运行时环境，收到种子合约后编译为字节码，参数根据被调用函数的参数类型生成</p><ul><li><p>solc −bin −runtime xx.sol</p></li><li><p>对于每个数据类型，预先定义了一些常见的或者极端值，生成时随机选取</p></li></ul><p>之后调用每个EVM的执行接口自动在所有EVM上执行，将输出结果标准化后，根据测试指标计算差异信息，比较执行输出结果。</p><p>根据种子提高指标差异的程度，决定是否将种子放入seed pool中（保存了高质量的合约），该模块会记录潜在的异常，为了后续进行手工的问题根源分析</p><h3 id="种子合约选择"><a href="#种子合约选择" class="headerlink" title="种子合约选择"></a>种子合约选择</h3><p>dif的意义是为了评估生成的种子合约的质量，定义如下</p><p><img src="/2023/09/19/EVMFuzzer/image-20230920194726395.png" alt="image-20230920194726395"></p><p>看看伪代码</p><p>diff最大值为10，值进行标准化，时间优先级置0，更新flag</p><p><img src="/2023/09/19/EVMFuzzer/image-20230920200434697.png" alt="image-20230920200434697"></p><h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><p>回答的问题</p><ul><li>EVM之间是否存在不一致性<ul><li>gas消耗的不一致性<ul><li><img src="/2023/09/19/EVMFuzzer/image-20230920202213767.png" alt="image-20230920202213767"></li><li>原因：以太坊黄皮书未定义某些特定opcode的gas消耗，如MSOTRE,SLOAD等；采用的退款机制不同</li><li>将gas消耗的平均值作为基准，js-evm 好</li><li><img src="/2023/09/19/EVMFuzzer/image-20230920202945965.png" alt="image-20230920202945965"></li></ul></li><li>opcode的不一致性：仅1,275合约能同时在4个EVM上运行并返回相同结果，字节码长度不同<ul><li>原因可能是EVM进行了优化</li><li><img src="/2023/09/19/EVMFuzzer/image-20230920203426230.png" alt="image-20230920203426230"></li><li>结果可以看到aleth和geth保持一致，js-evm更小（某种程度上减轻了EVM的开销，但是这种开销减少的代价可能是丧失了鲁棒性）</li><li><img src="/2023/09/19/EVMFuzzer/image-20230920204613634.png" alt="image-20230920204613634"></li></ul></li></ul></li><li>EVMFuzz是否能高效地生成高质量的种子合约<ul><li>狠狠跑了3天，生成了25 3153份不同的合约，66.2%的合约成功出发了不一致性（因为包含了gas不一致，水分比较大）Ind.1是除此之外都crash，Ind.2是除此之外都不crash</li><li><img src="/2023/09/19/EVMFuzzer/image-20230920204015260.png" alt="image-20230920204015260"></li><li>为了说明变异器的质量，找了个复杂的合约进行了测试，记录每轮的weight变化</li><li>单独使用一种变异器的速度，evencomb最快但没跳出局部最优解，总体上comball效果最好，完全随机效果最差<ul><li><img src="/2023/09/19/EVMFuzzer/image-20230920204702036.png" alt="image-20230920204702036"></li></ul></li><li>详细分析CombAll来研究不同变异器的权重和作用，0.125作为基准</li><li><img src="/2023/09/19/EVMFuzzer/image-20230920204957741.png" alt="image-20230920204957741"></li><li><img src="/2023/09/19/EVMFuzzer/image-20230920205443157.png" alt="image-20230920205443157"></li></ul></li><li>是否能通过EVMFuzz发现EVM的漏洞<ul><li>需要手工分析，发现了5个CVE（现有的CVE中与EVM相关的有6个，智能合约的500个，总数为112913）</li><li><img src="/2023/09/19/EVMFuzzer/image-20230920205747171.png" alt="image-20230920205747171"></li></ul></li></ul><p>合约部署在以太坊上，分析了合约的行数，函数，相关的操作码和特定的操作码，其中超过6500份合约有超过500行代码，90个超过2000行，表明目标合约比较复杂</p><h2 id="Using-EVMFuzzer"><a href="#Using-EVMFuzzer" class="headerlink" title="Using EVMFuzzer"></a>Using EVMFuzzer</h2><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><img src="/2023/09/19/EVMFuzzer/image-20230919172850242.png" alt="image-20230919172850242"></p><p>后端集成了4个广泛使用的EVM作为基准</p><ul><li>ethereumjs-vm v2.4.0</li><li>py-evm v0.2.0-alpha.31</li><li>aleth v1.5.0-alpha.6</li><li>geth v1.8.13</li></ul><p>合约compiler solc 0.4.24版本</p><h3 id="运行的例子"><a href="#运行的例子" class="headerlink" title="运行的例子"></a>运行的例子</h3><p>用户提供EVM的源码/可执行文件和API，论文中的target EVM是加强版的js-EVM（之前她的B会的工作）</p><p>报告从3个维度来评价这个EVM</p><ul><li>代码实现完整性</li><li>gas计算的准确性</li><li>执行路径规划的合理性</li></ul><p><img src="/2023/09/19/EVMFuzzer/image-20230919174027003.png" alt="image-20230919174027003"></p><h2 id="Preliminary-Evaluation"><a href="#Preliminary-Evaluation" class="headerlink" title="Preliminary Evaluation"></a>Preliminary Evaluation</h2><p>初始的seed合约是36295个，实验在笔记本上跑的</p><p>根据2类内部测试指标（消耗的gas和操作码序列），发现了大量的不一致</p><p>33,424/36,295合约的操作码序列是正确的，用于进行gas的对比（排除了不同操作码带来的gas差异）</p><p>每个平台约50%的gas消耗都和其他平台不一样，aleth甚至达到90%</p><p><img src="/2023/09/19/EVMFuzzer/image-20230919190818271.png" alt="image-20230919190818271"></p><p>1275个合约成功在4个EVM上执行，返回了相同的输出但是序列的长度不同</p><p><img src="/2023/09/19/EVMFuzzer/image-20230919191002754.png" alt="image-20230919191002754"></p><p>aleth和geth的相同，作为baseline，js-evm的长度始终短于baseline，py-evm的长度高于baseline</p><p>可以推断出：EVM的执行和实现存在不一致，可以利用<code>gasUsed</code>和操作码序列指示器的度量差异来引导合约的生成，从而导致潜在的执行输出的不一致</p><p>发现的漏洞：发现了不一致后需要手工进行分析，探索根源，查看了EVM的实现，发现了5个CVE</p><p><img src="/2023/09/19/EVMFuzzer/image-20230919191848784.png" alt="image-20230919191848784"></p><p>其中一个针对geth的CVE，稳定触发 执行时段错误，原因在于异常处理程序没有处理所有边界情况</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>提出了第一个对EVM实现的差分模糊测试的工具，给出了两个度量标准（gas和opcode sequence），在生成的253,153个合约的执行中，超过一半的合约表现出了差异</p><p>未来工作：设计更通用的mutator，对更多EVM的安全性进行评估</p><ul><li>设计更多的变异器：目前仅在AST层面修改关键部分，后续可以在源码层次层架函数调用，合约继承等</li><li>更高效的优先级处理：目前是用堆实现的优先队列，插入删除的复杂度是$\Theta(logn)$，排序的复杂度是$\Theta(nlogn)$，可以有其他的思路，比如搞成系数</li><li>支持更多EVM的实现</li><li>更精确的选择标准：gas和opcode之间可以加系数，gas可能没有那么重要</li></ul><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>尝试配一下</p><p>安装solc-select，配置环境变量，source一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pip3 install solc-select</span><br><span class="line">sudo nano ~/.bashrc</span><br><span class="line">//add this line</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;/home/alleysira/.local/bin:<span class="variable">$PATH</span>&quot;</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line">solc-select install 0.4.24</span><br><span class="line">solc-select use 0.4.24</span><br></pre></td></tr></table></figure><p>配置wsl代理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/resolv.conf</span><br><span class="line">export ALL_PROXY=&quot;http://172.20.80.1:7890&quot;</span><br></pre></td></tr></table></figure><p>安装ethereum</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install software-properties-common</span><br><span class="line">sudo add-apt-repository -y ppa:ethereum/ethereum</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install ethereum #network issue</span><br></pre></td></tr></table></figure><p>补充安装numpy</p><p>pip3 install eth_utils</p><p>每日一乐</p><p><img src="/2023/09/19/EVMFuzzer/image-20230921200746505.png" alt="image-20230921200746505"></p><p>修改一下node的路径jsevm就可以运行了，修改为/usr/bin/node</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p><code>python -m virtualenv env</code> 在当前目录下创建一个名为 “env” 的虚拟环境</p><p><img src="/2023/09/19/EVMFuzzer/image-20231016192446379.png" alt="image-20231016192446379"></p><p>执行 <code>source env/bin/activate</code></p><p><img src="/2023/09/19/EVMFuzzer/image-20231016192501740.png" alt="image-20231016192501740"></p><p>在虚拟环境env中调用EVMFuzzer</p><p><img src="/2023/09/19/EVMFuzzer/image-20231016192632283.png" alt="image-20231016192632283"></p><p>选择当前执行10轮</p><p><img src="/2023/09/19/EVMFuzzer/image-20230921203024645.png" alt="image-20230921203024645"></p><p><img src="/2023/09/19/EVMFuzzer/image-20230921201837081.png" alt="image-20230921201837081"></p><p>会给出当前轮选择的变异策略，以及采用的变异器</p><p>10轮测试耗时约250s，生成了20个种子合约</p><p><img src="/2023/09/19/EVMFuzzer/image-20230921202131725.png" alt="image-20230921202131725"></p><p>第79轮产生了不一致</p><p><img src="/2023/09/19/EVMFuzzer/image-20231018171322281.png" alt="image-20231018171322281"></p><p><img src="/2023/09/19/EVMFuzzer/image-20231018171336978.png" alt="image-20231018171336978"></p><p><img src="/2023/09/19/EVMFuzzer/image-20231018171526617.png" alt="image-20231018171526617"></p><p>实验结束后<code>deactivate</code>虚拟环境</p><p>测试100轮，时间为2494s，时间为线性</p><p><img src="/2023/09/19/EVMFuzzer/image-20231018175507578.png" alt="image-20231018175507578"></p><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><ul><li><p>SB Curated: A Curated Dataset of Vulnerable Solidity Smart Contracts</p><ul><li><a href="https://github.com/smartbugs/smartbugs-curated">https://github.com/smartbugs/smartbugs-curated</a></li><li>根据 <a href="https://dasp.co/"><strong>DASP</strong> 2018</a>（遗憾的是已经不再维护）前top 10的漏洞类型进行划分，包括143个.sol文件</li><li>包括重入漏洞 访问控制 算术漏洞 call Dos 随机性 front running 时间戳 短地址 unknown</li><li>Smartbugs 项目的Samples文件夹下有10个样例合约</li></ul></li><li><p>Smartbugs测试时采用的数据集，包括47,587个合约，47398个.sol文件</p><ul><li>69个带注释的合约</li><li>47,518个以太坊上下载的合约</li></ul></li><li><p>SolidiFI Benchmark，7类1700个合约</p><ul><li><a href="https://github.com/DependableSystemsLab/SolidiFI-benchmark">https://github.com/DependableSystemsLab/SolidiFI-benchmark</a></li></ul></li><li><p>爬Etherscan</p><ul><li><a href="https://docs.etherscan.io/api-endpoints/contracts">https://docs.etherscan.io/api-endpoints/contracts</a></li></ul></li></ul><h2 id="学习代码"><a href="#学习代码" class="headerlink" title="学习代码"></a>学习代码</h2><h3 id="Run-py"><a href="#Run-py" class="headerlink" title="Run.py"></a>Run.py</h3><p>每次运行清除TestOut文件夹</p><p>支持分析的合约函数的参数类型仅支持<code>bool uint int address</code>，不支持数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inputData = generate_input.make(dataList) </span><br></pre></td></tr></table></figure><p>将smartbugs的samples文件夹下的所有.sol文件作为输入，执行后发现很多合约的参数类型不满足条件，因此无法生成对应参数，无法运行合约</p><p>尝试扩展到支持string，把array简化为同类型的一个变量</p><p><img src="/2023/09/19/EVMFuzzer/image-20231101171439238.png" alt="image-20231101171439238"></p><p>对于array，尝试手动构造一个</p><p>生成函数签名是用solc编译合约的方法实现的，能够输出函数签名</p><p><img src="/2023/09/19/EVMFuzzer/image-20231020141102264.png" alt="image-20231020141102264"></p><p><code>generate_input.py</code>的<code>make()</code>负责根据参数列表生成参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make</span>(<span class="params">dataList</span>):</span></span><br><span class="line">    ret = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> _, val <span class="keyword">in</span> <span class="built_in">enumerate</span>(dataList) : </span><br><span class="line">        <span class="keyword">if</span> (val.find(<span class="string">&quot;uint&quot;</span>) != -<span class="number">1</span>) <span class="keyword">or</span> (val.find(<span class="string">&quot;int&quot;</span>) != -<span class="number">1</span>) :</span><br><span class="line">            ls1 = <span class="built_in">list</span>(np.random.randint(<span class="number">0</span>, <span class="number">100</span>, size=<span class="number">1</span>))</span><br><span class="line">            ls2 = [<span class="built_in">hex</span>(i)[<span class="number">2</span>:] <span class="keyword">for</span> i <span class="keyword">in</span> ls1]</span><br><span class="line">            uint_str = <span class="string">&#x27;&#x27;</span>.join(ls2)</span><br><span class="line">            full_str = uint_str.zfill(<span class="number">64</span>) <span class="comment"># 不足用0补</span></span><br><span class="line">            ret += full_str</span><br><span class="line">        <span class="keyword">elif</span> val.find(<span class="string">&quot;bool&quot;</span>) != -<span class="number">1</span>:</span><br><span class="line">            ls1 = <span class="built_in">list</span>(np.random.randint(<span class="number">0</span>, <span class="number">2</span>, size=<span class="number">1</span>))</span><br><span class="line">            ls2 = [<span class="built_in">hex</span>(i)[<span class="number">2</span>:] <span class="keyword">for</span> i <span class="keyword">in</span> ls1]</span><br><span class="line">            bool_str = <span class="string">&#x27;&#x27;</span>.join(ls2)</span><br><span class="line">            full_str = bool_str.zfill(<span class="number">64</span>)</span><br><span class="line">            ret += full_str</span><br><span class="line">        <span class="keyword">elif</span> val.find(<span class="string">&quot;address&quot;</span>) != -<span class="number">1</span>:</span><br><span class="line">            ls1 = <span class="built_in">list</span>(np.random.randint(<span class="number">0</span>, <span class="number">16</span>, size=<span class="number">40</span>))</span><br><span class="line">            ls2 = [<span class="built_in">hex</span>(i)[<span class="number">2</span>:] <span class="keyword">for</span> i <span class="keyword">in</span> ls1]</span><br><span class="line">            addr_str = <span class="string">&#x27;&#x27;</span>.join(ls2)</span><br><span class="line">            full_str = addr_str.zfill(<span class="number">64</span>)</span><br><span class="line">            ret += full_str</span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><ul><li>生成uint和int类型的参数时，没有考虑具体的参数长度，如uint256和int64是不同的数据范围，简化为<ul><li>生成0-100的数</li><li>转16进制</li><li>zfill补为64长</li><li>可以考虑具体读uint256 64 128 再生成对应长度的参数</li></ul></li><li>生成address和bool完全可以简化为直接生成16进制字符串</li></ul><p>Input data=函数签名+生成的参数，有效位数太小，修改可能精度可以提高触发率</p><p>4类变异策略</p><h3 id="update-weight"><a href="#update-weight" class="headerlink" title="update_weight()"></a>update_weight()</h3><p><code>update_weight()</code>函数根据上一轮每个变异器造成的差异生成权重，排序后根据传入的变异策略决定当前轮的变异器列表choice</p><p><code>mutators_weight.py</code>根据输入的策略对种子合约进行变异</p><p><img src="/2023/09/19/EVMFuzzer/image-20231019184748514.png" alt="image-20231019184748514"></p><p>发现缩进的代码的问题，但实际执行没有出现报错？（已解决）</p><p>解决jsevm调用后，发现确实存在问题，见cnt=0</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weight, choice = update_weight(dirPATH, <span class="string">&quot;mutator_diff&quot;</span>, select) <span class="comment"># combined strategy</span></span><br></pre></td></tr></table></figure><p>Run.py中cnt仅出现3次</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(diff_list)):</span><br><span class="line">        cnt += <span class="built_in">int</span>(diff_list[i])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(diff_list)):</span><br><span class="line">        weight[i+<span class="number">1</span>] = <span class="built_in">float</span>(<span class="built_in">int</span>(diff_list[i]) / cnt)</span><br></pre></td></tr></table></figure><p>修改代码逻辑，为cnt=0时，权重定义为1/8</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">weight = &#123;&#125;  <span class="comment"># an empty dict</span></span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(diff_list)):</span><br><span class="line">    cnt += <span class="built_in">int</span>(diff_list[i])</span><br><span class="line"><span class="keyword">if</span> cnt!=<span class="number">0</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(diff_list)):</span><br><span class="line">        weight[i+<span class="number">1</span>] = <span class="built_in">float</span>(<span class="built_in">int</span>(diff_list[i]) / cnt)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(diff_list)):</span><br><span class="line">        weight[i+<span class="number">1</span>] = <span class="number">1</span> / <span class="number">8</span></span><br></pre></td></tr></table></figure><h3 id="mutators-weight-py"><a href="#mutators-weight-py" class="headerlink" title="mutators_weight.py"></a>mutators_weight.py</h3><p>逻辑实现错误，当合约中函数已经有可见性修饰时，工具的实现是在修饰符后再加一个修饰符，显然会导致编译错误，没有任何意义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># have other modifiers</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    modifier = line[start_pos + <span class="number">2</span>:end_pos]</span><br><span class="line">    <span class="keyword">if</span> modifier.find(property_[num - <span class="number">1</span>]) == -<span class="number">1</span>:</span><br><span class="line">        str_list = <span class="built_in">list</span>(line)</span><br><span class="line">        str_list.insert(start_pos + <span class="number">2</span>, property_[num - <span class="number">1</span>] + <span class="string">&quot; &quot;</span>)</span><br><span class="line">        content = <span class="string">&quot;&quot;</span>.join(str_list)</span><br><span class="line">f2.write(content)</span><br><span class="line">it += <span class="number">1</span></span><br><span class="line"><span class="comment"># revised version</span></span><br><span class="line"> <span class="keyword">else</span>:</span><br><span class="line">    modifier = line[start_pos + <span class="number">2</span>:end_pos]</span><br><span class="line">    <span class="comment"># print(&quot;modifier&quot;,modifier)</span></span><br><span class="line">    <span class="keyword">if</span> modifier.find(property_[num - <span class="number">1</span>]) == -<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(property_)):</span><br><span class="line">            <span class="keyword">if</span> modifier.find(property_[(num - <span class="number">1</span>+i)%<span class="built_in">len</span>(property_)])!=-<span class="number">1</span>:</span><br><span class="line">                mod_start = modifier.find(property_[(num - <span class="number">1</span>+i)%<span class="built_in">len</span>(property_)]) + start_pos + <span class="number">2</span></span><br><span class="line">                mod_end = mod_start + <span class="built_in">len</span>(property_[(num - <span class="number">1</span>+i)%<span class="built_in">len</span>(property_)])</span><br><span class="line">                <span class="comment"># print(mod_start,mod_end)</span></span><br><span class="line">                str_list = <span class="built_in">list</span>(line)</span><br><span class="line">                <span class="comment"># print(&quot;&quot;.join(str_list))</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># print(&quot;del part&quot;,str_list[mod_start:mod_end])</span></span><br><span class="line">                <span class="keyword">del</span> str_list[mod_start:mod_end]</span><br><span class="line">                </span><br><span class="line">                str_list.insert(mod_start, property_[num - <span class="number">1</span>])</span><br><span class="line">                <span class="comment"># print(&quot;&quot;.join(str_list))</span></span><br><span class="line">                content = <span class="string">&quot;&quot;</span>.join(str_list)</span><br><span class="line">                <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h3 id="TestOut-dir"><a href="#TestOut-dir" class="headerlink" title="/TestOut dir"></a>/TestOut dir</h3><p>TestOut/contract1 中</p><ul><li><p>/bincode是solc —bin-runtime编译出的，形式为 bincode_funName_index，index是当前轮数</p></li><li><p>/seed是变异后的种子合约</p></li><li>/output文件夹记录了所有虚拟机执行后的输出，包括pc，op，gas，gasprice和栈</li><li><p>mutator_diff记录当前轮变异器是否产生了diff，8行</p></li><li><p>newdiff记录当前轮总的diff</p></li><li><p>diffHis记录了变异器的权重变化的历史</p></li><li>Mycontract.signatures 是函数签名（哈希值，函数名，参数类型）</li><li>result.json记录了具体是jsevm cppevm pyevm在opcode和gas出现的不一致以及对应不一致的输出，相关的交易数据</li></ul><p>以下是与4个虚拟机交互的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">retcode = subprocess.call(<span class="string">&quot;/usr/bin/node &quot;</span> + PROJECT_DIR + <span class="string">&quot;/benchmarkEVMs/jsEVM/js_runcode.js --code &quot;</span> + bincode + <span class="string">&quot; --sig &quot;</span> + sigName + <span class="string">&quot; &gt; &quot;</span> + outputPATH + <span class="string">&quot;jsout.json&quot;</span>,shell=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">retcode = subprocess.call(<span class="string">&quot;python3 &quot;</span> + PROJECT_DIR + <span class="string">&quot;/benchmarkEVMs/py-evm/test_tx.py --data &quot;</span> + bincode + <span class="string">&quot; --sig &quot;</span> + sigName + <span class="string">&quot; &gt; &quot;</span> + outputPATH + <span class="string">&quot;pyout.json&quot;</span>,shell=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">retcode = subprocess.call(<span class="string">&quot;./benchmarkEVMs/evm --debug --json --code &quot;</span> + bincode + <span class="string">&quot; --input &quot;</span> + sigName[<span class="number">2</span>:] + <span class="string">&quot; run &gt; &quot;</span> + outputPATH + <span class="string">&quot;gethout.json&quot;</span>, shell=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># aleth 比较复杂</span></span><br><span class="line">retcode = subprocess.call(<span class="string">&quot;./benchmarkEVMs/aleth-vm trace --code &quot;</span> + bincode + <span class="string">&quot; --mnemonics --input &quot;</span> + sigName + <span class="string">&quot; &gt; &quot;</span> + outputPATH + <span class="string">&quot;aletraceout&quot;</span>,shell=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">retcode = subprocess.call(<span class="string">&quot;python3 &quot;</span> + PROJECT_DIR + <span class="string">&quot;/utils/cpp_convert_json_1.py &quot;</span> + outputPATH + <span class="string">&quot;aletraceout &quot;</span> + <span class="string">&quot; &gt; &quot;</span> + outputPATH + <span class="string">&quot;alethout.json&quot;</span>,shell=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># aleth output</span></span><br><span class="line">retcode = subprocess.call(<span class="string">&quot;./benchmarkEVMs/aleth-vm stats --code &quot;</span> + bincode + <span class="string">&quot; --mnemonics --input &quot;</span> + sigName + <span class="string">&quot; &gt; &quot;</span> + outputPATH + <span class="string">&quot;aleresultout&quot;</span>,shell=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">retcode = subprocess.call(<span class="string">&quot;python3 &quot;</span> + PROJECT_DIR + <span class="string">&quot;/utils/cpp_convert_json_2.py &quot;</span> + outputPATH + <span class="string">&quot;aleresultout &quot;</span> + <span class="string">&quot; &gt;&gt; &quot;</span> + outputPATH + <span class="string">&quot;alethout.json&quot;</span>,shell=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/node js_runcode.js --code 0xyyyy --sig 0xyyyy &gt; jsout.json</span><br><span class="line">python3 test_tx.py --data 0xyyyy --sig 0xyyyy &gt; pyout.json</span><br><span class="line">./evm --debug --json --code 0xyyyy --input yyyy run &gt; gethout.json</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> pyevm call</span></span><br><span class="line">python3 /home/alleysira/EVMFuzzer/benchmarkEVMs/py-evm/test_tx.py --data 608060405260043610610062576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680634ddd108a1461006757806387f71cef14610092578063890eba68146100dd578063aa237e211461010c575b600080fd5b34801561007357600080fd5b5061007c610145565b6040518082815260200191505060405180910390f35b34801561009e57600080fd5b506100c7600480360381019080803590602001909291908035906020019092919050505061014b565b6040518082815260200191505060405180910390f35b3480156100e957600080fd5b506100f261024f565b604051808215151515815260200191505060405180910390f35b34801561011857600080fd5b5061014360048036038101908080351515906020019092919080359060200190929190505050610261565b005b60015481565b6000806000806000806000806000806000808c8e111561017d578c8e019950899850888a1415151561017957fe5b889a505b8c8e101561019b578c8e0397506000881015151561019757fe5b879a505b8c8e14156101c557600096505b600a8710156101c1578c8e019d508660010196506101a8565b8d9a505b8c8e1015156101e7578c8e029550601494508486141515156101e357fe5b859a505b8c8e111515610214578c8e8115156101fb57fe5b049350600184039250600a8311151561021057fe5b829a505b8c8e14151561023b578c8e1115610230578c91508d9050610237565b8d91508c90505b819a505b8a9b50505050505050505050505092915050565b6000809054906101000a900460ff1681565b816000806101000a81548160ff0219169083151502179055508060018190555050505600a165627a7a7230582036c5562a74060217554d53de9758f565aa5aae303e48c5027a8fb554aba828dc0029 --sig 0x87f71cef00000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000043</span><br></pre></td></tr></table></figure><h3 id="utils-cmp-js"><a href="#utils-cmp-js" class="headerlink" title="/utils/cmp.js"></a>/utils/cmp.js</h3><p>cmp.js负责实现比较json文件中实验结果的逻辑，result.json记录了不同虚拟机执行相同交易后对比的结果</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//result.json</span></span><br><span class="line">&#123;<span class="attr">&quot;error&quot;</span>:<span class="string">&quot;js&amp;py_output+gas&quot;</span>,<span class="attr">&quot;js_output&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="attr">&quot;py_output&quot;</span>:<span class="string">&quot;0000000000000000000000000000000000000000000000000000000000000022&quot;</span>,<span class="attr">&quot;js_gasUsed&quot;</span>:<span class="string">&quot;0x2e&quot;</span>,<span class="attr">&quot;py_gasUsed&quot;</span>:<span class="string">&quot;0x2d9&quot;</span>,<span class="attr">&quot;txdata&quot;</span>:<span class="string">&quot;0x87f71cef0000000000000000000000000000000000000000000000000000000000000022000000000000000000000000000000000000000000000000000000000000003e&quot;</span>&#125; </span><br></pre></td></tr></table></figure><p>从输出来看，只比较了三个cpp/aleth jsevm 和pyevm的输出</p><p>计算newdiff，newdiff文件的数字是totalDiff，totalDiff=opcodediff+gasusedDiff</p><p>opcodediff是三个虚拟机行数差的绝对值</p><p>gasusedDiff是三个.json文件最后一行的gasused字段差的绝对值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">opcodeDiff=<span class="built_in">Math</span>.abs(js_file_data.length-cpp_file_data.length)+</span><br><span class="line">    <span class="built_in">Math</span>.abs(js_file_data.length-py_file_data.length)+</span><br><span class="line">    <span class="built_in">Math</span>.abs(py_file_data.length-cpp_file_data.length)</span><br></pre></td></tr></table></figure><p>代码里没有实现geth和cpp py js虚拟机对比的代码</p><p>实现geth和js对比的函数<code>js_geth_cmp</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gethout.json</span></span><br><span class="line">&#123;<span class="attr">&quot;pc&quot;</span>:<span class="number">2</span>,<span class="attr">&quot;op&quot;</span>:<span class="number">96</span>,<span class="attr">&quot;gas&quot;</span>:<span class="string">&quot;0x2540be3fd&quot;</span>,<span class="attr">&quot;gasCost&quot;</span>:<span class="string">&quot;0x0&quot;</span>,<span class="attr">&quot;memory&quot;</span>:<span class="string">&quot;0x&quot;</span>,<span class="attr">&quot;memSize&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;stack&quot;</span>:[<span class="string">&quot;0x80&quot;</span>],<span class="attr">&quot;depth&quot;</span>:<span class="number">1</span>,<span class="attr">&quot;refund&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;opName&quot;</span>:<span class="string">&quot;PUSH1&quot;</span>,<span class="attr">&quot;error&quot;</span>:<span class="string">&quot;&quot;</span>&#125;</span><br><span class="line"><span class="comment">//jsout.json</span></span><br><span class="line">&#123;<span class="attr">&quot;pc&quot;</span>:<span class="number">4</span>,<span class="attr">&quot;op&quot;</span>:<span class="number">82</span>,<span class="attr">&quot;gas&quot;</span>:<span class="string">&quot;0xfffffff9&quot;</span>,<span class="attr">&quot;gasCost&quot;</span>:<span class="string">&quot;0x3&quot;</span>,<span class="attr">&quot;stack&quot;</span>:[<span class="string">&quot;0x80&quot;</span>,<span class="string">&quot;0x40&quot;</span>],<span class="attr">&quot;depth&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;opName&quot;</span>:<span class="string">&quot;MSTORE&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>逻辑混乱，前面用的是gasused（即所有gas\timesgasCost，后面仅比较gasCost）</p><h2 id="代码问题总结"><a href="#代码问题总结" class="headerlink" title="代码问题总结"></a>代码问题总结</h2><h3 id="jsevm错误调用，已解决"><a href="#jsevm错误调用，已解决" class="headerlink" title="jsevm错误调用，已解决"></a>jsevm错误调用，已解决</h3><p>实验结果中newdiff文件发现有50000个不同，回溯数据，发现result.json有490条不同，不同的原因是js-evm仅能执行12条指令，其他3个虚拟机都能执行111个合约</p><p><img src="/2023/09/19/EVMFuzzer/image-20231026172846459.png" alt="image-20231026172846459"></p><p>jsout.json的行数远远小于其他两个虚拟机的输出长度</p><p>代码写的有问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">retcode = subprocess.call(<span class="string">&quot;/usr/bin/node &quot;</span> + PROJECT_DIR + <span class="string">&quot;/benchmarkEVMs/jsEVM/js_runcode.js --code &quot;</span> + bincode + <span class="string">&quot; --sig &quot;</span> + sigName + <span class="string">&quot; &gt; &quot;</span> + outputPATH + <span class="string">&quot;jsout.json&quot;</span>, shell=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># shell中直接调用jsevm</span></span><br><span class="line">node benchmarkEVMs/jsEVM/js_runcode.js --code 608060405260043610610062576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680634ddd108a1461006757806387f71cef14610092578063890eba68146100dd578063aa237e211461010c575b600080fd5b34801561007357600080fd5b5061007c610145565b6040518082815260200191505060405180910390f35b34801561009e57600080fd5b506100c7600480360381019080803590602001909291908035906020019092919050505061014b565b6040518082815260200191505060405180910390f35b3480156100e957600080fd5b506100f261024f565b604051808215151515815260200191505060405180910390f35b34801561011857600080fd5b5061014360048036038101908080351515906020019092919080359060200190929190505050610261565b005b60015481565b6000806000806000806000806000806000808c8e111561017d578c8e019950899850888a1415151561017957fe5b889a505b8c8e101561019b578c8e0397506000881015151561019757fe5b879a505b8c8e14156101c557600096505b600a8710156101c1578c8e019d508660010196506101a8565b8d9a505b8c8e1015156101e7578c8e029550601494508486141515156101e357fe5b859a505b8c8e111515610214578c8e8115156101fb57fe5b049350600184039250600a8311151561021057fe5b829a505b8c8e14151561023b578c8e1115610230578c91508d9050610237565b8d91508c90505b819a505b8a9b50505050505050505050505092915050565b6000809054906101000a900460ff1681565b816000806101000a81548160ff0219169083151502179055508060018190555050505600a165627a7a7230582036c5562a74060217554d53de9758f565aa5aae303e48c5027a8fb554aba828dc0029 --sig <span class="number">0x890eba680000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000003e</span></span><br></pre></td></tr></table></figure><p>虚拟机没有正确解析sig参数，验证github，源码确实存在这个问题</p><p><img src="/2023/09/19/EVMFuzzer/image-20231026200824290.png" alt="image-20231026200824290"></p><p>修改后继续进行测试</p><h3 id="cnt-0导致错误，已解决"><a href="#cnt-0导致错误，已解决" class="headerlink" title="cnt=0导致错误，已解决"></a>cnt=0导致错误，已解决</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;Run.py&quot;, line 736, in &lt;module&gt;</span><br><span class="line">    main()</span><br><span class="line">  File &quot;Run.py&quot;, line 353, in main</span><br><span class="line">    weight, choice = update_weight(dirPATH, &quot;mutator_diff&quot;, select) # combined strategy</span><br><span class="line">  File &quot;Run.py&quot;, line 120, in update_weight</span><br><span class="line">    weight[i+1] = float(int(diff_list[i]) / cnt)</span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure><p>原因是weight更新部分漏写了部分逻辑</p><h3 id="geth和aleth输出对应错误，已解决"><a href="#geth和aleth输出对应错误，已解决" class="headerlink" title="geth和aleth输出对应错误，已解决"></a>geth和aleth输出对应错误，已解决</h3><p>代码实现前后逻辑不一致</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">retcode = subprocess.call(<span class="string">&quot;./benchmarkEVMs/evm --debug --json --code &quot;</span> + bincode + <span class="string">&quot; --input &quot;</span> + sigName[<span class="number">2</span>:] + <span class="string">&quot; run &gt; &quot;</span> + outputPATH + <span class="string">&quot;gethout.json&quot;</span>,shell=<span class="literal">True</span>)</span><br><span class="line">retcode = subprocess.call( <span class="string">&quot;python3 &quot;</span> + PROJECT_DIR + <span class="string">&quot;/utils/cpp_convert_json_1.py &quot;</span> + outputPATH + <span class="string">&quot;aletraceout &quot;</span> + <span class="string">&quot; &gt; &quot;</span> + outputPATH + <span class="string">&quot;alethout.json&quot;</span>,shell=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><img src="/2023/09/19/EVMFuzzer/image-20231026220208745.png" alt="image-20231026220208745"></p><p>修改为一致的顺序</p><h3 id="未实现geth和cpp-py-js虚拟机对比的代码"><a href="#未实现geth和cpp-py-js虚拟机对比的代码" class="headerlink" title="未实现geth和cpp py js虚拟机对比的代码"></a>未实现geth和cpp py js虚拟机对比的代码</h3><p>仅对比EVM和其他四个虚拟机的结果，aleth py js 3个虚拟机互相对比，没有geth和aleth py js虚拟机之间对比的代码</p><p>原因可能是论文中提到geth和aleth的实验结果一致</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (my_output != js_output) and (my_output != py_output) and (my_output != geth_output) and (my_output != aleth_output):</span><br><span class="line">   X1 += 1</span><br></pre></td></tr></table></figure><p>逻辑是and，是因为仅4个虚拟机输出相同与targetEVM不同才有意义，因此需要加上4个虚拟机相同的逻辑</p><p>出现不支持的操作码 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> js-evm geth</span></span><br><span class="line">101 &#123;&quot;gasCost&quot;:&#123;&quot;__old&quot;:&quot;0x0&quot;,&quot;__new&quot;:&quot;0xc&quot;&#125;,&quot;opName&quot;:&#123;&quot;__old&quot;:&quot;INVALID&quot;,&quot;__new&quot;:&quot;Missing opcode 0xfe&quot;&#125;&#125;  opName: INVALID js: INVALID geth: Missing opcode 0xfe</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> result.json</span></span><br><span class="line">&#123;&quot;error&quot;:&quot;js&amp;py_output+gas&quot;,&quot;js_output&quot;:&quot;&quot;,&quot;py_output&quot;:&quot;0000000000000000000000000000000000000000000000000000000000000028&quot;,&quot;js_gasUsed&quot;:&quot;0xffffffff&quot;,&quot;py_gasUsed&quot;:&quot;0x2d1&quot;,&quot;txdata&quot;:&quot;0x87f71cef00000000000000000000000000000000000000000000000000000000000000470000000000000000000000000000000000000000000000000000000000000028&quot;&#125; </span><br><span class="line"></span><br><span class="line">&#123;&quot;error&quot;:&quot;cpp&amp;py_output+gas&quot;,&quot;cpp_output&quot;:&quot;&quot;,&quot;py_output&quot;:&quot;0000000000000000000000000000000000000000000000000000000000000028&quot;,&quot;cpp_gasUsed&quot;:&quot;0x7fffffffffffffff&quot;,&quot;py_gasUsed&quot;:&quot;0x2d1&quot;,&quot;txdata&quot;:&quot;0x87f71cef00000000000000000000000000000000000000000000000000000000000000470000000000000000000000000000000000000000000000000000000000000028&quot;&#125; </span><br><span class="line"></span><br><span class="line">&#123;&quot;error&quot;:&quot;js&amp;py_output+gas&quot;,&quot;js_output&quot;:&quot;&quot;,&quot;py_output&quot;:&quot;0000000000000000000000000000000000000000000000000000000000000000&quot;,&quot;js_gasUsed&quot;:&quot;0x9d&quot;,&quot;py_gasUsed&quot;:&quot;0x1d3&quot;,&quot;txdata&quot;:&quot;0xaa237e2100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012&quot;&#125; </span><br><span class="line"></span><br><span class="line">&#123;&quot;error&quot;:&quot;cpp&amp;py_output+gas&quot;,&quot;cpp_output&quot;:&quot;&quot;,&quot;py_output&quot;:&quot;0000000000000000000000000000000000000000000000000000000000000000&quot;,&quot;cpp_gasUsed&quot;:&quot;0x7fffffffffffffff&quot;,&quot;py_gasUsed&quot;:&quot;0x1d3&quot;,&quot;txdata&quot;:&quot;0xaa237e2100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012&quot;&#125; </span><br></pre></td></tr></table></figure><p>在cmp.js中增加了geth和其他三个evm对比的代码</p><p>Run.py主函数中将test_evm和其他4个虚拟机进行对比，当且仅当gas和opcode与4个虚拟机都不同时，认为虚拟机的实现是存在问题的（体会思想，因为被参考的4个虚拟机也存在不同）</p><h3 id="虚拟机output不同，已排除"><a href="#虚拟机output不同，已排除" class="headerlink" title="虚拟机output不同，已排除"></a>虚拟机output不同，已排除</h3><p>发现问题一般是pyout和其他虚拟机不同</p><ul><li>pyout末尾为0028</li><li>输出为空时，输出全0</li></ul><p><img src="/2023/09/19/EVMFuzzer/image-20231030192218403.png" alt="image-20231030192218403"></p><p>怀疑可能是pyevm和其他evm版本差距过大，查看pyevm的版本，实验环境中的版本是0.8.0-b1，Evmfuzz当时的pyevm是0.2.0a31，但实际上执行的pyevm不是0.7.0-a4，已解决</p><p><img src="/2023/09/19/EVMFuzzer/image-20231030193108290.png" alt="image-20231030193108290"></p><p><img src="/2023/09/19/EVMFuzzer/image-20231030233846704.png" alt="image-20231030233846704"></p><p>py虚拟机存在的问题</p><p><img src="/2023/09/19/EVMFuzzer/image-20231102235320918.png" alt="image-20231102235320918"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eth.exceptions.InvalidJumpDestination: Invalid Jump Destination</span><br></pre></td></tr></table></figure><p>pyevm官方文档的解释</p><p><img src="/2023/09/19/EVMFuzzer/image-20231107165715063.png" alt="image-20231107165715063"></p><h3 id="aleth-always-success，已解决"><a href="#aleth-always-success，已解决" class="headerlink" title="aleth always success，已解决"></a>aleth always success，已解决</h3><p>aleth虚拟机的返回值应该没有正确解析，无论怎么样的输入aleth都能正确输出</p><p>4个输出，仅考虑最后一个输出是否有效，不合理，修改代码实现</p><p><img src="/2023/09/19/EVMFuzzer/image-20231102222744372.png" alt="image-20231102222744372"></p><h3 id="argument-type，已解决"><a href="#argument-type，已解决" class="headerlink" title="argument type，已解决"></a>argument type，已解决</h3><p>原因是未传入code参数或传入空字符串，默认值为true</p><p><img src="/2023/09/19/EVMFuzzer/image-20231102215912217.png" alt="image-20231102215912217"></p><p><img src="/2023/09/19/EVMFuzzer/image-20231102212643892.png" alt="image-20231102212643892"></p><p>code参数怎么会是bool值，输出一下还真是boolean</p><p>argv.code未读到参数时默认的值为true，增加这样一个模块</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (argv.code!=<span class="literal">true</span>)&#123;</span><br><span class="line">    code=argv.code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新jsevm后，yargs模块提供了默认值的设计</p><h3 id="json为空"><a href="#json为空" class="headerlink" title="json为空"></a>json为空</h3><p>当gethout.json为空时，不符合json数据格式报错，不影响程序的正确执行</p><p><img src="/2023/09/19/EVMFuzzer/image-20231102212659481.png" alt="image-20231102212659481"></p><p>现有解决方案是若空则执行0x00 </p><h3 id="特殊类型参数无法生成，已解决"><a href="#特殊类型参数无法生成，已解决" class="headerlink" title="特殊类型参数无法生成，已解决"></a>特殊类型参数无法生成，已解决</h3><p>未能生成含参数为自定义的结构体Bet类型的函数签名，尝试采用solc直接编译，但是也没有对应的solc</p><p><img src="/2023/09/19/EVMFuzzer/image-20231102230039548.png" alt="image-20231102230039548"></p><p>生成的.signature中确实没有该函数的函数签名</p><p><img src="/2023/09/19/EVMFuzzer/image-20231102230128925.png" alt="image-20231102230128925"></p><p>以函数betPrize为例，该函数第一个参数是结构体类型，solc0.4.24无法编译出该合约的函数签名</p><p><img src="/2023/09/19/EVMFuzzer/image-20231108171659739.png" alt="image-20231108171659739"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(env) alleysira@LAPTOP-M4HO8L6S:~/EVMFuzzer/candidateContract/smartbugs$ solc SmartBillions.sol --hashes | grep -n bet</span><br><span class="line"></span><br><span class="line">(env) alleysira@LAPTOP-M4HO8L6S:~/EVMFuzzer/candidateContract/smartbugs$solc SmartBillions.sol --abi | grep -n bet</span><br></pre></td></tr></table></figure><p>尝试abi之后均没有编译出该函数的函数签名</p><p><img src="/2023/09/19/EVMFuzzer/image-20231108171941124.png" alt="image-20231108171941124"></p><p>换solc的版本解决</p><h3 id="geth不支持push0，已解决"><a href="#geth不支持push0，已解决" class="headerlink" title="geth不支持push0，已解决"></a>geth不支持push0，已解决</h3><p>尝试了在执行时设置—prestate genesis.json， failed</p><p>目前还是调回了paris</p><p>解决方法：调整prestate参数的位置到run的前面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retcode = subprocess.call(<span class="string">&quot;./benchmarkEVMs/evm --debug --gas 0xffffffff --noreturndata --json --code &quot;</span> + bincode + <span class="string">&quot; --input &quot;</span> + sigName[<span class="number">2</span>:] + <span class="string">&quot; --prestate ./benchmarkEVMs/genesis.json run &gt; &quot;</span> + PROJECT_DIR + <span class="string">&quot;/manCheck/gethout.json&quot;</span>,shell=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="exp1"><a href="#exp1" class="headerlink" title="exp1"></a>exp1</h3><ul><li>实验数据：smartbugs-curated的access_control arithmetic bad_randomness denial_of_service前四类的48个合约</li><li>运行10轮</li><li>solc版本为0.4.24</li></ul><h4 id="合约接口无法识别"><a href="#合约接口无法识别" class="headerlink" title="合约接口无法识别"></a>合约接口无法识别</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/home/alleysira/EVMFuzzer/TestOut/contract4/seed/PreProcess_BECToken_2.sol:46:3: Error: Expected &#x27;&#123;&#x27; but got &#x27;function&#x27;</span><br><span class="line">  function transfer(address to, uint256 value) public returns (bool);</span><br><span class="line">  ^------^</span><br><span class="line">1 PreProcess_BECToken_2.sol</span><br></pre></td></tr></table></figure><p>solidity源代码中的合约接口被编译器错误理解为函数实现，原因是Solidity 版本 0.4.24 以及之前的版本确实不支持显式的合约接口（contract interface）声明。在这些旧版本中，需要使用抽象合约（abstract contract）来实现类似接口的功能。</p><p>尝试用0.5.x的编译器，查看是否能够支持合约接口（是否有意义）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/home/alleysira/EVMFuzzer/TestOut/contract4/seed/PreProcess_BECToken_2.sol:56:1: Error: Function, variable, struct or modifier declaration expected.</span><br><span class="line">continue;</span><br><span class="line">^------^</span><br><span class="line">1 PreProcess_BECToken_2.sol</span><br></pre></td></tr></table></figure><h4 id="mutator导致多个可见性"><a href="#mutator导致多个可见性" class="headerlink" title="mutator导致多个可见性"></a>mutator导致多个可见性</h4><p>关于函数可见性变异的代码可能有问题，已修正</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/home/alleysira/EVMFuzzer/TestOut/contract4/seed/PreProcess_BECToken_7.sol:46:57: Error: Visibility already specified as &quot;internal&quot;.</span><br><span class="line">  function transfer(address to, uint256 value) internal public returns (bool);</span><br><span class="line"></span><br><span class="line">/home/alleysira/EVMFuzzer/TestOut/contract17/seed/PreProcess_phishable_9.sol:17:55: Error: Visibility already specified as &quot;external&quot;.</span><br><span class="line">  function withdrawAll(address _recipient) external public &#123;</span><br><span class="line">                                                      ^----^</span><br><span class="line">1 PreProcess_phishable_9.sol</span><br></pre></td></tr></table></figure><p>类似的问题，已修正</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/home/alleysira/EVMFuzzer/TestOut/contract4/seed/PreProcess_BECToken_1.sol:90:62: Error: Visibility already specified as &quot;private&quot;.</span><br><span class="line">  function allowance(address owner, address spender) private public constant returns (uint256);</span><br><span class="line">                                                             ^----^</span><br><span class="line">/home/alleysira/EVMFuzzer/TestOut/contract4/seed/PreProcess_BECToken_1.sol:149:64: Error: Visibility already specified as &quot;private&quot;.</span><br><span class="line">  function allowance(address _owner, address _spender) private public constant returns (uint256 remaining) &#123;</span><br><span class="line">                                                               ^----^</span><br><span class="line">1 PreProcess_BECToken_1.sol</span><br><span class="line"></span><br><span class="line">/home/alleysira/EVMFuzzer/TestOut/contract19/seed/PreProcess_token_3.sol:26:47: Error: Visibility already specified as &quot;private&quot;.</span><br><span class="line">   function balanceOf(address _owner) private public constant returns (uint balance) &#123;</span><br><span class="line">                                              ^----^</span><br><span class="line">1 PreProcess_token_3.sol</span><br></pre></td></tr></table></figure><p>添加break和continue不太准确，查看源代码，没发现这个问题，未能复现</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/home/alleysira/EVMFuzzer/TestOut/contract22/seed/PreProcess_smart_billions_4.sol:155:1: Error: Function, variable, struct or modifier declaration expected.</span><br><span class="line">break;</span><br></pre></td></tr></table></figure><h4 id="mutator对注释后的代码进行变异"><a href="#mutator对注释后的代码进行变异" class="headerlink" title="mutator对注释后的代码进行变异"></a>mutator对注释后的代码进行变异</h4><p>出现问题的原因可能是 变异器没有考虑注释行，变异的位置在被注释的部分，实际上合约的逻辑没有发生变化，无效变异</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/home/alleysira/EVMFuzzer/TestOut/contract24/seed/PreProcess_integer_overflow_1_3.sol:12:13: Error: Expected primary expression.</span><br><span class="line">         ++ &lt;yes&gt; &lt;report&gt; ARITHMETIC</span><br><span class="line">            ^</span><br><span class="line">1 PreProcess_integer_overflow_1_3.sol</span><br></pre></td></tr></table></figure><p>举例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// before mutation</span><br><span class="line">contract Overflow &#123;</span><br><span class="line">     uint private sellerBalance=0;</span><br><span class="line"></span><br><span class="line">     function add(uint value) returns (bool)&#123;</span><br><span class="line">         // &lt;yes&gt; &lt;report&gt; ARITHMETIC</span><br><span class="line">         sellerBalance += value; // possible overflow</span><br><span class="line"></span><br><span class="line">         // possible auditor assert</span><br><span class="line">         // assert(sellerBalance &gt;= value);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">//after mutation, it seems that &gt; is replaced with &gt;=, but in the commented line</span><br><span class="line"> contract Overflow &#123;</span><br><span class="line">     uint private sellerBalance=0;</span><br><span class="line"></span><br><span class="line">     function add(uint value) returns (bool)&#123;</span><br><span class="line">         // &gt;=yes&gt;= &gt;=report&gt;= ARITHMETIC</span><br><span class="line">         sellerBalance += value; // possible overflow</span><br><span class="line"></span><br><span class="line">         // possible auditor assert</span><br><span class="line">         // assert(sellerBalance &gt; value);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>变异时把注释用的//变异为了**，因此导致的错误</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/home/alleysira/EVMFuzzer/TestOut/contract41/seed/PreProcess_open_address_lottery_9.sol:<span class="number">67</span>:<span class="number">9</span>: Error: Expected primary expression.</span><br><span class="line">        ** calculate the number of current address - <span class="number">1</span> <span class="keyword">in</span> <span class="number">8</span> chance</span><br><span class="line">        ^^</span><br><span class="line"><span class="number">1</span> PreProcess_open_address_lottery_9.sol</span><br><span class="line">    </span><br><span class="line">    function luckyNumberOfAddress(address addr) constant returns(uint n)&#123;</span><br><span class="line">        // calculate the number of current address - <span class="number">1</span> <span class="keyword">in</span> <span class="number">8</span> chance</span><br><span class="line">        n = uint(keccak256(uint(addr), secretSeed)[<span class="number">0</span>]) % <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 运行了5个小时，输入49个合约，生成了1500个种子合约</span></span><br><span class="line">                         Detection Report</span><br><span class="line"></span><br><span class="line">After 18512.80s running, EVMFuzzer successfully generated 1500 seeds.</span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> In 0.0% (0/1500) of the tests, the output results are different from the standard execution.</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> In 1.13% (17/1500) of the tests, the gas consuming are more than the average value.</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> In 62.13% (932/1500) of the tests, the gas consuming are less than the average value.</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> In 36.73% (551/1500) of the tests, the gas consuming are equal to the average value.</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> In 4.73% (71/1500) of the tests, the execution sequence are more than the average value.</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> In 47.8% (717/1500) of the tests, the execution sequence are less than the average value.</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> In 47.47% (712/1500) of the tests, the execution sequence are equal to the average value.</span></span><br><span class="line"></span><br><span class="line">Final Conslusion:</span><br><span class="line">1. The code implementation of test EVM is relatively complete, can be used for Ethereum.</span><br><span class="line">2. The deviation of gas calculation is large, there exists dynamic optimization during the calculation process, and the optimization effect is good.</span><br><span class="line">3. The execution path planning is correct, there exists dynamic optimization during the executing procedure, and the optimization effect is good.</span><br></pre></td></tr></table></figure><h3 id="exp2"><a href="#exp2" class="headerlink" title="exp2"></a>exp2</h3><ul><li>实验数据：smartbugs-curated的剩余的6类，共100个合约，其中包含若干个unchecked的合约</li></ul><h4 id="pyevm和TestEVM独有的问题"><a href="#pyevm和TestEVM独有的问题" class="headerlink" title="pyevm和TestEVM独有的问题"></a>pyevm和TestEVM独有的问题</h4><p>可能是因为脚本是python实现的</p><ul><li>gas不足</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/home/alleysira/EVMFuzzer/TestOut/contract33/seed/PreProcess_0x561eac93c92360949ab1f1403323e6db345cbf31_5.sol:28:24:</span><br><span class="line"></span><br><span class="line">eth.exceptions.OutOfGas: Out of gas: Needed 5000 - Remaining 2141 - Reason: SSTORE: 0x8888888888888888888888888888888888888888[29102676481673041902632991033461445430619272659676223336789171408008386403024] -&gt; 0 (0)</span><br></pre></td></tr></table></figure><ul><li>未发现16进制数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/home/alleysira/EVMFuzzer/myEVM/runTx.py&quot;, line 159, in &lt;module&gt;</span><br><span class="line">    main()</span><br><span class="line">  File &quot;/home/alleysira/EVMFuzzer/myEVM/runTx.py&quot;, line 130, in main</span><br><span class="line">    genesis_state(base_state, simple_contract_address, args.data))</span><br><span class="line">  File &quot;/home/alleysira/EVMFuzzer/myEVM/runTx.py&quot;, line 93, in genesis_state</span><br><span class="line">    &#x27;code&#x27;: decode_hex(bytecode),  # contract bytecode</span><br><span class="line">  File &quot;/home/alleysira/EVMFuzzer/env/lib/python3.8/site-packages/eth_utils/hexadecimal.py&quot;, line 20, in decode_hex</span><br><span class="line">    return binascii.unhexlify(ascii_hex)</span><br><span class="line">binascii.Error: Non-hexadecimal digit found</span><br></pre></td></tr></table></figure><ul><li>eth.exceptions.InvalidJumpDestination: Invalid Jump Destination</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/home/alleysira/EVMFuzzer/benchmarkEVMs/py-evm/test_tx.py&quot;, line 165, in &lt;module&gt;</span><br><span class="line">    main()</span><br><span class="line">  File &quot;/home/alleysira/EVMFuzzer/benchmarkEVMs/py-evm/test_tx.py&quot;, line 158, in main</span><br><span class="line">    result_bytes = chain.get_transaction_result(call_txn, chain.get_canonical_head())</span><br><span class="line">  File &quot;/home/alleysira/EVMFuzzer/benchmarkEVMs/py-evm/eth/chains/base.py&quot;, line 575, in get_transaction_result</span><br><span class="line">    computation.raise_if_error()</span><br><span class="line">  File &quot;/home/alleysira/EVMFuzzer/benchmarkEVMs/py-evm/eth/vm/computation.py&quot;, line 173, in raise_if_error</span><br><span class="line">    raise self._error</span><br><span class="line">  File &quot;/home/alleysira/EVMFuzzer/benchmarkEVMs/py-evm/eth/vm/computation.py&quot;, line 587, in apply_computation</span><br><span class="line">    opcode_fn(computation=computation)</span><br><span class="line">  File &quot;/home/alleysira/EVMFuzzer/benchmarkEVMs/py-evm/eth/vm/opcode.py&quot;, line 49, in wrapped_logic_fn</span><br><span class="line">    return logic_fn(computation)</span><br><span class="line">  File &quot;/home/alleysira/EVMFuzzer/benchmarkEVMs/py-evm/eth/vm/logic/flow.py&quot;, line 24, in jump</span><br><span class="line">    raise InvalidJumpDestination(&quot;Invalid Jump Destination&quot;)</span><br><span class="line">eth.exceptions.InvalidJumpDestination: Invalid Jump Destination</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/home/alleysira/EVMFuzzer/myEVM/runTx.py&quot;, line 159, in &lt;module&gt;</span><br><span class="line">    main()</span><br><span class="line">  File &quot;/home/alleysira/EVMFuzzer/myEVM/runTx.py&quot;, line 155, in main</span><br><span class="line">    result_bytes = chain.get_transaction_result(call_txn, chain.get_canonical_head())</span><br><span class="line">  File &quot;/home/alleysira/EVMFuzzer/myEVM/eth/chains/base.py&quot;, line 575, in get_transaction_result</span><br><span class="line">    computation.raise_if_error()</span><br><span class="line">  File &quot;/home/alleysira/EVMFuzzer/myEVM/eth/vm/computation.py&quot;, line 173, in raise_if_error</span><br><span class="line">    raise self._error</span><br><span class="line">  File &quot;/home/alleysira/EVMFuzzer/myEVM/eth/vm/computation.py&quot;, line 587, in apply_computation</span><br><span class="line">    opcode_fn(computation=computation)</span><br><span class="line">  File &quot;/home/alleysira/EVMFuzzer/myEVM/eth/vm/opcode.py&quot;, line 49, in wrapped_logic_fn</span><br><span class="line">    return logic_fn(computation)</span><br><span class="line">  File &quot;/home/alleysira/EVMFuzzer/myEVM/eth/vm/logic/flow.py&quot;, line 24, in jump</span><br><span class="line">    raise InvalidJumpDestination(&quot;Invalid Jump Destination&quot;)</span><br><span class="line">eth.exceptions.InvalidJumpDestination: Invalid Jump Destination</span><br></pre></td></tr></table></figure><h2 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h2><h3 id="solc"><a href="#solc" class="headerlink" title="solc"></a>solc</h3><p>更新pip，更新solc，安装0.8.23和0.8.22版本的solc</p><p>solc 0.8.22编出的合约存在的问题：</p><p>evm本身存在version</p><p>solc编译时可以设定编译对象evm版本：<a href="https://docs.soliditylang.org/en/latest/using-the-compiler.html#setting-the-evm-version-to-target">https://docs.soliditylang.org/en/latest/using-the-compiler.html#setting-the-evm-version-to-target</a></p><p>详细的EVM version <a href="https://docs.blockscout.com/for-developers/evm-version-information">https://docs.blockscout.com/for-developers/evm-version-information</a></p><h3 id="geth"><a href="#geth" class="headerlink" title="geth"></a>geth</h3><p>build 更新go版本，参考<a href="https://www.cnblogs.com/pebblecome/p/14815365.html">https://www.cnblogs.com/pebblecome/p/14815365.html</a></p><p>ppa安装最新的geth1.13.4</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository -y ppa:ethereum/ethereum</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install ethereum</span><br><span class="line">sudo apt-get upgrade geth</span><br></pre></td></tr></table></figure><p>geth官方提供的非常有用的资料 <a href="https://geth.ethereum.org/docs/developers/evm-tracing">https://geth.ethereum.org/docs/developers/evm-tracing</a></p><p>更新后的geth evm</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(env) alleysira@LAPTOP-M4HO8L6S:~/EVMFuzzer/benchmarkEVMs$ evm --version</span><br><span class="line">evm version 1.13.4-stable-3f907d6a</span><br><span class="line">(env) alleysira@LAPTOP-M4HO8L6S:~/EVMFuzzer/benchmarkEVMs$ ./evm --version</span><br><span class="line">evm version 1.9.0-unstable-95b2ec71</span><br></pre></td></tr></table></figure><p>发现的geth的输出发生了变化，通过跑myContract来看一下</p><p><img src="/2023/09/19/EVMFuzzer/image-20231114203433001.png" alt="image-20231114203433001"></p><p>由于<code>fmt.Fprintln(os.Stderr, &quot;#### LOGS ####&quot;)</code>输出在标准错误，因此命令行会出现这个</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;pc&quot;:0,&quot;op&quot;:96,&quot;gas&quot;:&quot;0x2540be400&quot;,&quot;gasCost&quot;:&quot;0x3&quot;,&quot;memSize&quot;:0,&quot;stack&quot;:[],&quot;depth&quot;:1,&quot;refund&quot;:0,&quot;opName&quot;:&quot;PUSH1&quot;&#125;</span><br><span class="line">&#123;&quot;pc&quot;:2,&quot;op&quot;:96,&quot;gas&quot;:&quot;0x2540be3fd&quot;,&quot;gasCost&quot;:&quot;0x3&quot;,&quot;memSize&quot;:0,&quot;stack&quot;:[&quot;0xff&quot;],&quot;depth&quot;:1,&quot;refund&quot;:0,&quot;opName&quot;:&quot;PUSH1&quot;&#125;</span><br><span class="line">&#123;&quot;pc&quot;:4,&quot;op&quot;:0,&quot;gas&quot;:&quot;0x2540be3fa&quot;,&quot;gasCost&quot;:&quot;0x0&quot;,&quot;memSize&quot;:0,&quot;stack&quot;:[&quot;0xff&quot;,&quot;0xff&quot;],&quot;depth&quot;:1,&quot;refund&quot;:0,&quot;opName&quot;:&quot;STOP&quot;&#125;</span><br><span class="line">&#123;&quot;output&quot;:&quot;&quot;,&quot;gasUsed&quot;:&quot;0x6&quot;&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">### LOGS ####</span></span></span><br></pre></td></tr></table></figure><h3 id="jsevm"><a href="#jsevm" class="headerlink" title="jsevm"></a>jsevm</h3><p>旧的js版本 2.4.0，node版本为v10.19.0</p><p>官方文档：useful <a href="https://github.com/ethereumjs/ethereumjs-monorepo/tree/master/packages/evm">https://github.com/ethereumjs/ethereumjs-monorepo/tree/master/packages/evm</a></p><p>not that new <a href="https://ethereumjs.readthedocs.io/en/latest/">https://ethereumjs.readthedocs.io/en/latest/</a></p><p>npm doc： <a href="https://www.npmjs.com/package/@ethereumjs/evm">https://www.npmjs.com/package/@ethereumjs/evm</a></p><p>修改后，使用的node的版本为20.9.0</p><p>如何运行合约，可以参考：<a href="https://github.com/ethereumjs/ethereumjs-monorepo/blob/f9525af55b4c2068a003e8035184913c0adcd980/packages/evm/test/runCall.spec.ts#L608">https://github.com/ethereumjs/ethereumjs-monorepo/blob/f9525af55b4c2068a003e8035184913c0adcd980/packages/evm/test/runCall.spec.ts#L608</a></p><p>收集jsevm results的参数</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  logs: [],</span><br><span class="line">  returnValue: Uint8Array(<span class="number">0</span>) [],</span><br><span class="line">  selfdestruct: Set(<span class="number">0</span>) &#123;&#125;,</span><br><span class="line">  createdAddresses: Set(<span class="number">0</span>) &#123;&#125;,</span><br><span class="line">  runState: &#123;</span><br><span class="line">    programCounter: <span class="number">103</span>,</span><br><span class="line">    opCode: <span class="number">253</span>,</span><br><span class="line">    memory: Memory &#123; _store: [Uint8Array] &#125;,</span><br><span class="line">    memoryWordCount: <span class="number">3</span>n,</span><br><span class="line">    highestMemCost: <span class="number">9</span>n,</span><br><span class="line">    stack: Stack &#123; _len: <span class="number">1</span>, _store: [Array], _maxHeight: <span class="number">1024</span> &#125;,</span><br><span class="line">    returnStack: Stack &#123; _len: <span class="number">0</span>, _store: [], _maxHeight: <span class="number">1023</span> &#125;,</span><br><span class="line">    code: Uint8Array(<span class="number">672</span>) [</span><br><span class="line">       <span class="number">96</span>, <span class="number">128</span>,  <span class="number">96</span>,  <span class="number">64</span>,  <span class="number">82</span>,  <span class="number">96</span>,   <span class="number">4</span>,  <span class="number">54</span>,  <span class="number">16</span>,  <span class="number">97</span>,   <span class="number">0</span>,  <span class="number">98</span>,</span><br><span class="line">       <span class="number">87</span>,  <span class="number">96</span>,   <span class="number">0</span>,  <span class="number">53</span>, <span class="number">124</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>, <span class="number">144</span>,   <span class="number">4</span>,</span><br><span class="line">       <span class="number">99</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>,  <span class="number">22</span>, <span class="number">128</span>,  <span class="number">99</span>,  <span class="number">77</span>, <span class="number">221</span>,  <span class="number">16</span>, <span class="number">138</span>,</span><br><span class="line">       <span class="number">20</span>,  <span class="number">97</span>,   <span class="number">0</span>, <span class="number">103</span>,  <span class="number">87</span>, <span class="number">128</span>,  <span class="number">99</span>, <span class="number">135</span>, <span class="number">247</span>,  <span class="number">28</span>, <span class="number">239</span>,  <span class="number">20</span>,</span><br><span class="line">       <span class="number">97</span>,   <span class="number">0</span>, <span class="number">146</span>,  <span class="number">87</span>, <span class="number">128</span>,  <span class="number">99</span>, <span class="number">137</span>,  <span class="number">14</span>, <span class="number">186</span>, <span class="number">104</span>,  <span class="number">20</span>,  <span class="number">97</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">201</span>,  <span class="number">87</span>, <span class="number">128</span>,  <span class="number">99</span>, <span class="number">170</span>,  <span class="number">35</span>, <span class="number">126</span>,  <span class="number">33</span>,  <span class="number">20</span>,  <span class="number">97</span>,   <span class="number">0</span>,</span><br><span class="line">      <span class="number">248</span>,  <span class="number">87</span>,  <span class="number">91</span>,  <span class="number">96</span>,</span><br><span class="line">      ... <span class="number">572</span> more items</span><br><span class="line">    ],</span><br><span class="line">    validJumps: Uint8Array(<span class="number">672</span>) [</span><br><span class="line">      <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">      <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">      <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">      <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">      <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">      <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">      <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">      <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">      <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">      ... <span class="number">572</span> more items</span><br><span class="line">    ],</span><br><span class="line">    cachedPushes: &#123;</span><br><span class="line">      &#x27;1&#x27;: <span class="number">128</span>n,</span><br><span class="line">      &#x27;3&#x27;: <span class="number">64</span>n,</span><br><span class="line">      &#x27;6&#x27;: <span class="number">4</span>n,</span><br><span class="line">      &#x27;10&#x27;: <span class="number">98</span>n,</span><br><span class="line">      &#x27;14&#x27;: <span class="number">0</span>n,</span><br><span class="line">      &#x27;17&#x27;: <span class="number">26959946667150639794667015087019630673637144422540572481103610249216</span>n,</span><br><span class="line">      &#x27;49&#x27;: <span class="number">4294967295</span>n,</span><br><span class="line">      &#x27;56&#x27;: <span class="number">1306333322</span>n,</span><br><span class="line">      &#x27;62&#x27;: <span class="number">103</span>n,</span><br><span class="line">      &#x27;67&#x27;: <span class="number">2281118959</span>n,</span><br><span class="line">      &#x27;73&#x27;: <span class="number">146</span>n,</span><br><span class="line">      &#x27;78&#x27;: <span class="number">2299443816</span>n,</span><br><span class="line">      &#x27;84&#x27;: <span class="number">201</span>n,</span><br><span class="line">      &#x27;89&#x27;: <span class="number">2854452769</span>n,</span><br><span class="line">      &#x27;95&#x27;: <span class="number">248</span>n,</span><br><span class="line">      &#x27;100&#x27;: <span class="number">0</span>n,</span><br><span class="line">      &#x27;108&#x27;: <span class="number">115</span>n,</span><br><span class="line">      &#x27;112&#x27;: <span class="number">0</span>n,</span><br><span class="line">      &#x27;118&#x27;: <span class="number">124</span>n,</span><br><span class="line">      &#x27;121&#x27;: <span class="number">305</span>n,</span><br><span class="line">      &#x27;126&#x27;: <span class="number">64</span>n,</span><br><span class="line">      &#x27;133&#x27;: <span class="number">32</span>n,</span><br><span class="line">      &#x27;139&#x27;: <span class="number">64</span>n,</span><br><span class="line">      &#x27;151&#x27;: <span class="number">158</span>n,</span><br><span class="line">      &#x27;155&#x27;: <span class="number">0</span>n,</span><br><span class="line">      &#x27;161&#x27;: <span class="number">199</span>n,</span><br><span class="line">      &#x27;164&#x27;: <span class="number">4</span>n,</span><br><span class="line">      &#x27;176&#x27;: <span class="number">32</span>n,</span><br><span class="line">      &#x27;186&#x27;: <span class="number">32</span>n,</span><br><span class="line">      &#x27;196&#x27;: <span class="number">311</span>n,</span><br><span class="line">      &#x27;206&#x27;: <span class="number">213</span>n,</span><br><span class="line">      &#x27;210&#x27;: <span class="number">0</span>n,</span><br><span class="line">      &#x27;216&#x27;: <span class="number">222</span>n,</span><br><span class="line">      &#x27;219&#x27;: <span class="number">574</span>n,</span><br><span class="line">      &#x27;224&#x27;: <span class="number">64</span>n,</span><br><span class="line">      &#x27;235&#x27;: <span class="number">32</span>n,</span><br><span class="line">      &#x27;241&#x27;: <span class="number">64</span>n,</span><br><span class="line">      &#x27;253&#x27;: <span class="number">260</span>n,</span><br><span class="line">      &#x27;257&#x27;: <span class="number">0</span>n,</span><br><span class="line">      &#x27;263&#x27;: <span class="number">303</span>n,</span><br><span class="line">      &#x27;266&#x27;: <span class="number">4</span>n,</span><br><span class="line">      &#x27;280&#x27;: <span class="number">32</span>n,</span><br><span class="line">      &#x27;290&#x27;: <span class="number">32</span>n,</span><br><span class="line">      &#x27;300&#x27;: <span class="number">592</span>n,</span><br><span class="line">      &#x27;307&#x27;: <span class="number">1</span>n,</span><br><span class="line">      &#x27;313&#x27;: <span class="number">0</span>n,</span><br><span class="line">      &#x27;316&#x27;: <span class="number">0</span>n,</span><br><span class="line">      &#x27;319&#x27;: <span class="number">0</span>n,</span><br><span class="line">      &#x27;322&#x27;: <span class="number">0</span>n,</span><br><span class="line">      &#x27;325&#x27;: <span class="number">0</span>n,</span><br><span class="line">      &#x27;328&#x27;: <span class="number">0</span>n,</span><br><span class="line">      &#x27;334&#x27;: <span class="number">360</span>n,</span><br><span class="line">      &#x27;352&#x27;: <span class="number">356</span>n,</span><br><span class="line">      &#x27;366&#x27;: <span class="number">390</span>n,</span><br><span class="line">      &#x27;375&#x27;: <span class="number">0</span>n,</span><br><span class="line">      &#x27;382&#x27;: <span class="number">386</span>n,</span><br><span class="line">      &#x27;396&#x27;: <span class="number">441</span>n,</span><br><span class="line">      &#x27;400&#x27;: <span class="number">0</span>n,</span><br><span class="line">      &#x27;405&#x27;: <span class="number">109</span>n,</span><br><span class="line">      &#x27;410&#x27;: <span class="number">437</span>n,</span><br><span class="line">      &#x27;419&#x27;: <span class="number">423</span>n,</span><br><span class="line">      &#x27;429&#x27;: <span class="number">1</span>n,</span><br><span class="line">      &#x27;434&#x27;: <span class="number">403</span>n,</span><br><span class="line">      &#x27;448&#x27;: <span class="number">484</span>n,</span><br><span class="line">      &#x27;457&#x27;: <span class="number">461</span>n,</span><br><span class="line">      &#x27;466&#x27;: <span class="number">20</span>n,</span><br><span class="line">      &#x27;476&#x27;: <span class="number">480</span>n,</span><br><span class="line">      &#x27;491&#x27;: <span class="number">520</span>n,</span><br><span class="line">      &#x27;500&#x27;: <span class="number">1</span>n,</span><br><span class="line">      &#x27;506&#x27;: <span class="number">10</span>n,</span><br><span class="line">      &#x27;512&#x27;: <span class="number">516</span>n,</span><br><span class="line">      &#x27;527&#x27;: <span class="number">559</span>n,</span><br><span class="line">      &#x27;535&#x27;: <span class="number">548</span>n,</span><br><span class="line">      &#x27;545&#x27;: <span class="number">555</span>n,</span><br><span class="line">      &#x27;576&#x27;: <span class="number">0</span>n,</span><br><span class="line">      &#x27;582&#x27;: <span class="number">256</span>n,</span><br><span class="line">      &#x27;588&#x27;: <span class="number">255</span>n,</span><br><span class="line">      &#x27;595&#x27;: <span class="number">0</span>n,</span><br><span class="line">      &#x27;598&#x27;: <span class="number">256</span>n,</span><br><span class="line">      &#x27;605&#x27;: <span class="number">255</span>n,</span><br><span class="line">      &#x27;620&#x27;: <span class="number">1</span>n,</span><br><span class="line">      &#x27;631&#x27;: <span class="number">108278179835992</span>n,</span><br><span class="line">      &#x27;649&#x27;: <span class="number">22782674781861623699170174827345051082396830843149090857</span>n</span><br><span class="line">    &#125;,</span><br><span class="line">    stateManager: DefaultStateManager &#123;</span><br><span class="line">      DEBUG: <span class="literal">false</span>,</span><br><span class="line">      _debug: [Function],</span><br><span class="line">      _proofTrie: [Trie],</span><br><span class="line">      common: [Common],</span><br><span class="line">      _checkpointCount: <span class="number">0</span>,</span><br><span class="line">      _trie: [Trie],</span><br><span class="line">      _storageTries: &#123;&#125;,</span><br><span class="line">      originalStorageCache: [OriginalStorageCache],</span><br><span class="line">      _prefixCodeHashes: <span class="literal">true</span>,</span><br><span class="line">      _prefixStorageTrieKeys: <span class="literal">false</span>,</span><br><span class="line">      _accountCacheSettings: [Object],</span><br><span class="line">      _accountCache: [AccountCache],</span><br><span class="line">      _storageCacheSettings: [Object],</span><br><span class="line">      _storageCache: [StorageCache],</span><br><span class="line">      _codeCacheSettings: [Object],</span><br><span class="line">      _codeCache: [CodeCache]</span><br><span class="line">    &#125;,</span><br><span class="line">    blockchain: Blockchain &#123;</span><br><span class="line">      _isInitialized: <span class="literal">true</span>,</span><br><span class="line">      common: [Common],</span><br><span class="line">      _hardforkByHeadBlockNumber: <span class="literal">false</span>,</span><br><span class="line">      _validateConsensus: <span class="literal">true</span>,</span><br><span class="line">      _validateBlocks: <span class="literal">true</span>,</span><br><span class="line">      _customGenesisState: undefined,</span><br><span class="line">      db: [MapDB],</span><br><span class="line">      dbManager: [DBManager],</span><br><span class="line">      consensus: [EthashConsensus],</span><br><span class="line">      _heads: &#123;&#125;,</span><br><span class="line">      _lock: [Lock],</span><br><span class="line">      _genesisBlock: [Block],</span><br><span class="line">      _headHeaderHash: [Uint8Array],</span><br><span class="line">      _headBlockHash: [Uint8Array]</span><br><span class="line">    &#125;,</span><br><span class="line">    env: &#123;</span><br><span class="line">      address: [Address],</span><br><span class="line">      caller: [Address],</span><br><span class="line">      callData: &lt;Buffer <span class="number">38</span> <span class="number">34</span> <span class="number">36</span> <span class="number">32</span> <span class="number">31</span> <span class="number">35</span> <span class="number">31</span> <span class="number">63</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">36</span> <span class="number">61</span> <span class="number">65</span> <span class="number">62</span> <span class="number">64</span> <span class="number">30</span> <span class="number">32</span> <span class="number">65</span> <span class="number">62</span> <span class="number">32</span> <span class="number">62</span> <span class="number">63</span> <span class="number">34</span> <span class="number">61</span> <span class="number">65</span> <span class="number">61</span> <span class="number">34</span> <span class="number">34</span> ... <span class="number">22</span> more bytes&gt;,</span><br><span class="line">      callValue: <span class="number">0</span>n,</span><br><span class="line">      code: [Uint8Array],</span><br><span class="line">      isStatic: <span class="literal">false</span>,</span><br><span class="line">      depth: <span class="number">0</span>,</span><br><span class="line">      gasPrice: <span class="number">0</span>n,</span><br><span class="line">      origin: [Address],</span><br><span class="line">      block: [Object],</span><br><span class="line">      contract: [Account],</span><br><span class="line">      codeAddress: [Address],</span><br><span class="line">      gasRefund: <span class="number">0</span>n,</span><br><span class="line">      containerCode: undefined,</span><br><span class="line">      blobVersionedHashes: [],</span><br><span class="line">      createdAddresses: undefined</span><br><span class="line">    &#125;,</span><br><span class="line">    shouldDoJumpAnalysis: <span class="literal">false</span>,</span><br><span class="line">    interpreter: Interpreter &#123;</span><br><span class="line">      opDebuggers: [Object],</span><br><span class="line">      _evm: [EVM],</span><br><span class="line">      _stateManager: [DefaultStateManager],</span><br><span class="line">      common: [Common],</span><br><span class="line">      _runState: [Object],</span><br><span class="line">      journal: [Journal],</span><br><span class="line">      _env: [Object],</span><br><span class="line">      _result: [Object],</span><br><span class="line">      profilerOpts: undefined,</span><br><span class="line">      performanceLogger: [EVMPerformanceLogger]</span><br><span class="line">    &#125;,</span><br><span class="line">    gasRefund: <span class="number">0</span>n,</span><br><span class="line">    gasLeft: <span class="number">4294967138</span>n,</span><br><span class="line">    returnBytes: Uint8Array(<span class="number">0</span>) [],</span><br><span class="line">    logs: [],</span><br><span class="line">    returnValue: Uint8Array(<span class="number">0</span>) [],</span><br><span class="line">    selfdestruct: Set(<span class="number">0</span>) &#123;&#125;,</span><br><span class="line">    createdAddresses: undefined,</span><br><span class="line">    address: Address &#123; bytes: [Uint8Array] &#125;,</span><br><span class="line">    caller: Address &#123; bytes: [Uint8Array] &#125;,</span><br><span class="line">    callData: &lt;Buffer <span class="number">38</span> <span class="number">34</span> <span class="number">36</span> <span class="number">32</span> <span class="number">31</span> <span class="number">35</span> <span class="number">31</span> <span class="number">63</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">36</span> <span class="number">61</span> <span class="number">65</span> <span class="number">62</span> <span class="number">64</span> <span class="number">30</span> <span class="number">32</span> <span class="number">65</span> <span class="number">62</span> <span class="number">32</span> <span class="number">62</span> <span class="number">63</span> <span class="number">34</span> <span class="number">61</span> <span class="number">65</span> <span class="number">61</span> <span class="number">34</span> <span class="number">34</span> ... <span class="number">22</span> more bytes&gt;,</span><br><span class="line">    callValue: <span class="number">0</span>n,</span><br><span class="line">    isStatic: <span class="literal">false</span>,</span><br><span class="line">    depth: <span class="number">0</span>,</span><br><span class="line">    gasPrice: <span class="number">0</span>n,</span><br><span class="line">    origin: Address &#123; bytes: [Uint8Array] &#125;,</span><br><span class="line">    block: &#123; header: [Object] &#125;,</span><br><span class="line">    contract: Account &#123;</span><br><span class="line">      nonce: <span class="number">0</span>n,</span><br><span class="line">      balance: <span class="number">0</span>n,</span><br><span class="line">      storageRoot: [Uint8Array],</span><br><span class="line">      codeHash: [Uint8Array]</span><br><span class="line">    &#125;,</span><br><span class="line">    codeAddress: Address &#123; bytes: [Uint8Array] &#125;,</span><br><span class="line">    containerCode: undefined,</span><br><span class="line">    blobVersionedHashes: []</span><br><span class="line">  &#125;,</span><br><span class="line">  exceptionError: EvmError &#123; error: &#x27;revert&#x27;, errorType: &#x27;EvmError&#x27; &#125;,</span><br><span class="line">  gas: <span class="number">4294967138</span>n,</span><br><span class="line">  executionGasUsed: <span class="number">157</span>n,</span><br><span class="line">  gasRefund: <span class="number">0</span>n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="py-evm"><a href="#py-evm" class="headerlink" title="py-evm"></a>py-evm</h3><p>直接更新后由于接口改变，无法直接使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/home/alleysira/EVMFuzzer/benchmarkEVMs/py-evm/test_tx.py&quot;, line 18, in &lt;module&gt;</span><br><span class="line">    from eth.vm.forks.shanghai import ShanghaiVM</span><br><span class="line">ModuleNotFoundError: No module named &#x27;eth.vm.forks.shanghai&#x27;</span><br><span class="line"></span><br><span class="line">[&#x27;/home/alleysira/EVMFuzzer/benchmarkEVMs/py-evm&#x27;, &#x27;/usr/lib/python38.zip&#x27;, &#x27;/usr/lib/python3.8&#x27;, &#x27;/usr/lib/python3.8/lib-dynload&#x27;, &#x27;/home/alleysira/EVMFuzzer/env/lib/python3.8/site-packages&#x27;]</span><br><span class="line">sys_path</span><br></pre></td></tr></table></figure><p>太智障了，本地的pyevm文件夹优先级更高</p><h4 id="trace-py-evm的过程信息"><a href="#trace-py-evm的过程信息" class="headerlink" title="trace py-evm的过程信息"></a>trace py-evm的过程信息</h4><p>和old版本对比，调用的函数是execute_transaction，输出json在这之后</p><p>新版本采用的函数是apply_transaction</p><p>trace之后，是在这里：class FrontierTransactionExecutor(BaseTransactionExecutor)</p><p><img src="/2023/09/19/EVMFuzzer/image-20231121225605895.png" alt="image-20231121225605895"></p><p>computation = self.build_computation(message, valid_transaction)</p><p>实现在class FrontierTransactionExecutor(BaseTransactionExecutor):的 def build_computation(self, message, transaction):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">      computation = self.vm_state.get_computation(  message,transaction_context).apply_message()</span><br><span class="line">apply_message()</span><br><span class="line"></span><br><span class="line">computation = self.apply_computation(</span><br><span class="line">    self.state,</span><br><span class="line">    self.msg,</span><br><span class="line">    self.transaction_context,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply_computation</span> <span class="title">in</span> </span></span><br></pre></td></tr></table></figure><p><img src="/2023/09/19/EVMFuzzer/image-20231121231928188.png" alt="image-20231121231928188"></p><p>apply_computation实现了对执行过程的记录</p><p>为了记录输出，需要在/home/alleysira/EVMFuzzer/env/lib/python3.8/site-packages/eth/vm/computation.py 中的def <strong>exit</strong>函数中实现对结果的记录</p><p>对比新老版本，发现新的实现中当EVM error出现时，会erase当前的返回值（可能解释了更新之后jsevm均是revert）</p><p><img src="/2023/09/19/EVMFuzzer/image-20231122143445037.png" alt="image-20231122143445037"></p><h3 id="aleth"><a href="#aleth" class="headerlink" title="aleth"></a>aleth</h3><p>当前版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(env) alleysira@LAPTOP-M4HO8L6S:~/EVMFuzzer/benchmarkEVMs$ ./aleth-vm --version</span><br><span class="line">aleth-vm 1.7.0-alpha.0-23+commit.32f9c88f</span><br><span class="line">Build: linux/relwithdebinfo</span><br></pre></td></tr></table></figure><p>更新工作完成后的虚拟机采用了shanghai分叉，具体版本</p><ul><li>geth 1.13.4-stable-3f907d6a<ul><li>Neodiff：1.9.21-unstable</li></ul></li><li>pyevm：0.8.0b1<ul><li>EVMFuzz：0.2.0-alpha.31</li></ul></li><li>jsevm：4.1.3，旧版本是 2.4.0</li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="push0"><a href="#push0" class="headerlink" title="push0"></a>push0</h4><p>geth的evm不支持push0，可能是未采用shanghai fork，目前已通过对solc增加—evm-version paris解决，后续采用prestate —genesis.json解决</p><h4 id="storge"><a href="#storge" class="headerlink" title="storge"></a>storge</h4><p>jsevm执行涉及到storge的操作码（如 SLOAD）会遇到问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Error: getContractStorage() called on non-existing account</span><br><span class="line">    at DefaultStateManager.getContractStorage (/home/alleysira/node_modules/@ethereumjs/statemanager/dist/cjs/stateManager.js:291:19)</span><br><span class="line">/home/alleysira/EVMFuzzer/benchmarkEVMs/jsEVM/usage.js:86</span><br><span class="line">            &#x27;output&#x27;:results.returnValue.toString(16),</span><br></pre></td></tr></table></figure><p>目前通过对newdiff文件判断解决</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    thisline = newdiffFile.readline().strip()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> thisline==<span class="string">&quot;NaN&quot;</span>:</span><br><span class="line">        newdiff = <span class="number">0</span> </span><br><span class="line">    <span class="keyword">else</span>:    </span><br><span class="line">        <span class="built_in">print</span>(thisline,thisline==<span class="string">&quot;NaN&quot;</span>)</span><br><span class="line">        newdiff = <span class="built_in">int</span>(thisline.strip())</span><br><span class="line">        newdiffFile.close()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error: <span class="string">&quot;/home/alleysira/EVMFuzzer/TestOut/contract3/seed/PreProcess_Rocket_Crash.sol&quot;</span> is not found.</span><br><span class="line">1 PreProcess_Rocket_Crash.sol</span><br></pre></td></tr></table></figure><p><a href="https://github.com/ethereumjs/ethereumjs-monorepo/issues/2654">https://github.com/ethereumjs/ethereumjs-monorepo/issues/2654</a></p><p>阅读github相关issue，通过采用runCall代替runCode解决</p><p>The main change is to use <code>runCall</code> instead of <code>runCode</code> which as is documented in the method notes, isn’t intended to be called directly from the <code>evm</code> class. <code>runCall</code> is the preferred way to execute raw bytecode in the <code>evm</code> with minimal fuss.</p><h1 id="EVM-history"><a href="#EVM-history" class="headerlink" title="EVM history"></a>EVM history</h1><p>以太坊官方的EVM变更历史：<a href="https://ethereum.org/en/history/">https://ethereum.org/en/history/</a></p><p>目前正在进行<a href="https://coindataflow.com/en/ethereum-cancun-hard-fork-countdown分叉">https://coindataflow.com/en/ethereum-cancun-hard-fork-countdown分叉</a></p><p>目前的代码里使用的都是shanghai分叉之后的EVM，但是相关的配置文件没有找到，仅istanbul之前的版本有详细的gas相关的设置</p><p><img src="/2023/09/19/EVMFuzzer/image-20231123223503259.png" alt="image-20231123223503259"></p><p>上海分叉仅提供了对应的EIP</p><p><img src="/2023/09/19/EVMFuzzer/image-20231123223532622.png" alt="image-20231123223532622"></p><p>查看对应EIP进行的约定</p><p><img src="/2023/09/19/EVMFuzzer/image-20231123230240051.png" alt="image-20231123230240051" style="zoom:90%;"></p><p><img src="/2023/09/19/EVMFuzzer/image-20231123224321349.png" alt="image-20231123224321349"></p><p><img src="/2023/09/19/EVMFuzzer/image-20231123224725125.png" alt="image-20231123224725125" style="zoom:75%;"></p><p><img src="/2023/09/19/EVMFuzzer/image-20231123224750211.png" alt="image-20231123224750211" style="zoom:90%;"></p><p>定义默认值：/home/alleysira/node_modules/@ethereumjs/evm/src/types.ts</p><h1 id="possible-vul"><a href="#possible-vul" class="headerlink" title="possible vul"></a>possible vul</h1><h2 id="FATAL-ERROR-v8-ToLocalChecked-Empty-MaybeLocal"><a href="#FATAL-ERROR-v8-ToLocalChecked-Empty-MaybeLocal" class="headerlink" title="FATAL ERROR: v8::ToLocalChecked Empty MaybeLocal"></a>FATAL ERROR: v8::ToLocalChecked Empty MaybeLocal</h2><ul><li><p>环境</p></li><li><p>solc 0.4.24 </p></li><li><p>contract = PreProcess_dos_number.sol</p></li><li><p>func = insertNnumbers</p></li><li><p>sig = 0x529f6f2d00000000000000000000000000000000000000000000000000000000643bf62f000000000000000000000000000000000000000000000000000000001a2a62cd</p></li><li><p>表现：OOM错误</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FATAL ERROR: v8::ToLocalChecked Empty MaybeLocal</span><br><span class="line"> 1: 0xc99970 node::Abort() [/home/alleysira/node/node-v20.9.0-linux-x64/bin/node]</span><br><span class="line"> 2: 0xb6feda node::OOMErrorHandler(char const*, v8::OOMDetails const&amp;) [/home/alleysira/node/node-v20.9.0-linux-x64/bin/node]</span><br><span class="line"> 3: 0xebfb60 v8::api_internal::ToLocalEmpty() [/home/alleysira/node/node-v20.9.0-linux-x64/bin/node]</span><br><span class="line"> 4: 0xca0d9c  [/home/alleysira/node/node-v20.9.0-linux-x64/bin/node]</span><br><span class="line"> 5: 0xf26ecf v8::internal::FunctionCallbackArguments::Call(v8::internal::CallHandlerInfo) [/home/alleysira/node/node-v20.9.0-linux-x64/bin/node]</span><br><span class="line"> 6: 0xf2773d  [/home/alleysira/node/node-v20.9.0-linux-x64/bin/node]</span><br><span class="line"> 7: 0xf27c05 v8::internal::Builtin_HandleApiCall(int, unsigned long*, v8::internal::Isolate*) [/home/alleysira/node/node-v20.9.0-linux-x64/bin/node]</span><br><span class="line"> 8: 0x1931df6  [/home/alleysira/node/node-v20.9.0-linux-x64/bin/node]</span><br><span class="line">Aborted</span><br><span class="line">Killed</span><br></pre></td></tr></table></figure><p><img src="/2023/09/19/EVMFuzzer/image-20231203120926246.png" alt="image-20231203120926246"></p><p>具体原因是jsout.json和gethout.json太大了（5g），导致执行cmp.js时内存不足，已经排除虚拟机的问题</p><p>修改geth和jsevm的初始geth为0xffff</p><h2 id="jsevm-crash"><a href="#jsevm-crash" class="headerlink" title="jsevm crash"></a>jsevm crash</h2><p>环境：旧版的jsevm</p><p>表现：jsevm占满CPU资源，不释放，写了一个113G的大文件</p><p><img src="/2023/09/19/EVMFuzzer/image-20231109223105417.png" alt="image-20231109223105417"></p><p>收集错误信息尝试复现</p><p>合约0x663e4229142a27f00bafb5d087e1e730648314c3.sol共计2000行，包含18个具体的合约。造成错误时对应的函数是<code>tokensOfOwner</code>，code参数来自于文件<code>bincode_tokendsOfOwner_3/PandaMinting.bin-runtime</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Select contract:  PreProcess_0x663e4229142a27f00bafb5d087e1e730648314c3.sol</span><br><span class="line">Select function:  tokensOfOwner</span><br><span class="line">Input data:  0x8462151c0000000000000000000000006aebd02eb2bc4aea449f7555fb46a404e164e575</span><br><span class="line"></span><br><span class="line">/home/alleysira/EVMFuzzer/TestOut/contract88/seed/PreProcess_0x663e4229142a27f00bafb5d087e1e730648314c3_3.sol:78:5: Error: Function, variable, struct or modifier declaration expected.</span><br><span class="line">    ++ function tokensOfOwner(address _owner) external view</span><br><span class="line">    ^^</span><br><span class="line">1 PreProcess_0x663e4229142a27f00bafb5d087e1e730648314c3_3.sol</span><br><span class="line"></span><br><span class="line">Select contract:  PreProcess_0x663e4229142a27f00bafb5d087e1e730648314c3.sol</span><br><span class="line">Select function:  tokensOfOwner</span><br><span class="line">Input data:  0x8462151c0000000000000000000000006aebd02eb2bc4aea449f7555fb46a404e164e575</span><br><span class="line"></span><br><span class="line">PandaMinting.bin-runtime</span><br><span class="line"></span><br><span class="line">bincode </span><br><span class="line"></span><br><span class="line">608060405260043610610301576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806301ffc9a7146103065780630519ce791461036a57806306fd...</span><br></pre></td></tr></table></figure><p>导致wsl产生了Bus error</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">^CBus error</span><br><span class="line">alleysira@LAPTOP-M4HO8L6S:~/EVMFuzzer$ top -c</span><br><span class="line">Segmentation fault</span><br></pre></td></tr></table></figure><p><img src="/2023/09/19/EVMFuzzer/image-20231109224034073.png" alt="image-20231109224034073"></p><p>将wsl备份后，尝试进行复现，未能成功复现。结合windows的报错来看，可能是硬件内存故障</p><p><img src="/2023/09/19/EVMFuzzer/image-20231109223921434.png" alt="image-20231109223921434"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">                                            Detection Report</span><br><span class="line"></span><br><span class="line">After 14328.35s running, EVMFuzzer successfully generated 1135 seeds.</span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> In 0.0% (0/1135) of the tests, the output results are different from the standard execution.</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> In 0.0% (0/1135) of the tests, the gas consuming are more than the average value.</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> In 77.89% (884/1135) of the tests, the gas consuming are less than the average value.</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> In 22.11% (251/1135) of the tests, the gas consuming are equal to the average value.</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> In 33.83% (384/1135) of the tests, the execution sequence are more than the average value.</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> In 53.83% (611/1135) of the tests, the execution sequence are less than the average value.</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> In 12.33% (140/1135) of the tests, the execution sequence are equal to the average value.</span></span><br><span class="line"></span><br><span class="line">Final Conslusion:</span><br><span class="line">1. The code implementation of test EVM is relatively complete, can be used for Ethereum.</span><br><span class="line">2. The deviation of gas calculation is large, there exists dynamic optimization during the calculation process, and the optimization effect is good.</span><br><span class="line">3. The deviation of executing sequence is large, there exists dynamic optimization during the executing procedure, and the optimization effect is good.</span><br></pre></td></tr></table></figure><p>更新到最新版本后，依然没有复现成功</p><h1 id="manual-check"><a href="#manual-check" class="headerlink" title="manual check"></a>manual check</h1><h2 id="1129-manual-check"><a href="#1129-manual-check" class="headerlink" title="1129 manual check"></a>1129 manual check</h2><h3 id="contract15"><a href="#contract15" class="headerlink" title="contract15"></a>contract15</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;error&quot;</span>:<span class="string">&quot;js&amp;py_output+gas&quot;</span>,<span class="attr">&quot;js_output&quot;</span>:<span class="string">&quot;4e487b710000000000000000000000000000000000000000000000000000000000000012&quot;</span>,<span class="attr">&quot;py_output&quot;</span>:<span class="string">&quot;4e487b710000000000000000000000000000000000000000000000000000000000000001&quot;</span>,<span class="attr">&quot;js_gasUsed&quot;</span>:<span class="string">&quot;0xe75&quot;</span>,<span class="attr">&quot;py_gasUsed&quot;</span>:<span class="string">&quot;0x364&quot;</span>,<span class="attr">&quot;txdata&quot;</span>:<span class="string">&quot;87f71cef00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;</span>&#125; </span><br><span class="line">&#123;<span class="attr">&quot;error&quot;</span>:<span class="string">&quot;geth&amp;js_output+gas&quot;</span>,<span class="attr">&quot;geth_output&quot;</span>:<span class="string">&quot;4e487b710000000000000000000000000000000000000000000000000000000000000001&quot;</span>,<span class="attr">&quot;js_output&quot;</span>:<span class="string">&quot;4e487b710000000000000000000000000000000000000000000000000000000000000012&quot;</span>,<span class="attr">&quot;geth_gasUsed&quot;</span>:<span class="string">&quot;0x364&quot;</span>,<span class="attr">&quot;js_gasUsed&quot;</span>:<span class="string">&quot;0xe75&quot;</span>,<span class="attr">&quot;txdata&quot;</span>:<span class="string">&quot;87f71cef00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;</span>&#125; </span><br></pre></td></tr></table></figure><p>手动运行</p><p>code=MyContract.bin-runtime,sig=txdata</p><p>测试jsevm</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node benchmarkEVMs/jsEVM/runcode.js --code  --sig &gt; manCheck/jsout.json</span><br></pre></td></tr></table></figure><p>evm</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">benchmarkEVMs/evm --debug --json --code --input run &gt; manCheck/gethout.json</span><br></pre></td></tr></table></figure><p>pyevm </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 benchmarkEVMs/py-evm/main.py --data  --sig  &gt; manCheck/pyout.json</span><br></pre></td></tr></table></figure><p>实验验证发现三个虚拟机的输出是一致的，只不过如果pyevm是revert的话，会把revert当时的消息返回到stdout，而不是记录在json中，此时发现的不一致性应该是和上一轮的结果对比得到的</p><p><img src="/2023/09/19/EVMFuzzer/image-20231130194007013.png" alt="image-20231130194007013"></p><p>实际上问题在于记录txdata的模块有误，导致实际运行的参数和记录的不一致</p><h3 id="contract8"><a href="#contract8" class="headerlink" title="contract8"></a>contract8</h3><p>init 函数的调用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">code = 608060405234801561001057600080fd5b506004361061002b5760003560e01c8063a5843f0814610030575b600080fd5b61004a600480360381019061004591906100b4565b61004c565b005b80600080848152602001908152602001600020600082825461006e9190610123565b925050819055505050565b600080fd5b6000819050919050565b6100918161007e565b811461009c57600080fd5b50565b6000813590506100ae81610088565b92915050565b600080604083850312156100cb576100ca610079565b5b60006100d98582860161009f565b92505060206100ea8582860161009f565b9150509250929050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600061012e8261007e565b91506101398361007e565b9250828203905081811115610151576101506100f4565b5b9291505056fea26469706673582212205f70c63820cc0b692b6fcbc38408e72d7ec11e42ee43e008dfad6dade831de7164736f6c63430008160033</span><br><span class="line">sig = 0xa5843f0800000000000000000000000000000000000000000000000000000000f0c4de6400000000000000000000000000000000000000000000000000000000ac348fbf</span><br></pre></td></tr></table></figure><p>检查后发现同样是geth和pyevm revert，但是jsevm输出为空，复现成功，发现实际上是调用参数的问题，已排除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">geth&amp;pyevm revert with the same result</span><br><span class="line">4e487b710000000000000000000000000000000000000000000000000000000000000011</span><br><span class="line">jsout &quot;&quot;</span><br></pre></td></tr></table></figure><h3 id="contract45"><a href="#contract45" class="headerlink" title="contract45"></a>contract45</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">code = 608060405234801561001057600080fd5b50600436106100365760003560e01c806306661abd1461003b578063a444f5e914610059575b600080fd5b610043610075565b60405161005091906100af565b60405180910390f35b610073600480360381019061006e91906100fb565b61007b565b005b60005481565b8060008082825461008c9190610157565b9250508190555050565b6000819050919050565b6100a981610096565b82525050565b60006020820190506100c460008301846100a0565b92915050565b600080fd5b6100d881610096565b81146100e357600080fd5b50565b6000813590506100f5816100cf565b92915050565b600060208284031215610111576101106100ca565b5b600061011f848285016100e6565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600061016282610096565b915061016d83610096565b925082820390508181111561018557610184610128565b5b9291505056fea264697066735822122060a4627f3d1d3a1c54591b731ad267cadbd87d7cfd362c0e979629f8e9d658bd64736f6c63430008160033</span><br><span class="line">sig = 0xa444f5e9000000000000000000000000000000000000000000000000000000006357ee11</span><br></pre></td></tr></table></figure><p>复现成功，但实际上是调用参数的问题，已排除</p><h2 id="1203-1205-1206-manual-check"><a href="#1203-1205-1206-manual-check" class="headerlink" title="1203+1205+1206 manual check"></a>1203+1205+1206 manual check</h2><ul><li>1203 跑了curated所有的合约，solc 0.4.24</li></ul><p><img src="/2023/09/19/EVMFuzzer/image-20231203162214645.png" alt="image-20231203162214645"></p><p>从实验结果来看，最新的geth和py的实现较为完善，只有5个合约触发了不一致的输出，手工对不一致性进行分析</p><ul><li>1206 修复了jsevm caller的问题后，再进行一次相同规模的测试</li></ul><p>After 5063.21s running, EVMFuzzer successfully generated 2720 seeds.</p><p><img src="/2023/09/19/EVMFuzzer/image-20231206155011637.png" alt="image-20231206155011637"></p><h3 id="contract28-已排除"><a href="#contract28-已排除" class="headerlink" title="contract28 已排除"></a>contract28 已排除</h3><ul><li>合约：PreProcess_0x89c1b3807d4c67df034fffb62f3509561218d30b.sol </li><li>合约源码要求的编译器是0.4.9</li></ul><p>三个虚拟机均正常return，geth和py output与gas相同，jsevm不同</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;error&quot;</span>:<span class="string">&quot;js&amp;py_output+gas&quot;</span>,<span class="attr">&quot;js_output&quot;</span>:<span class="string">&quot;0000000000000000000000000000000000000000000000000000000000000001&quot;</span>,<span class="attr">&quot;py_output&quot;</span>:<span class="string">&quot;0400000000000000000000000000000000000000000000000000000000000000&quot;</span>,<span class="attr">&quot;js_gasUsed&quot;</span>:<span class="string">&quot;0xce36&quot;</span>,<span class="attr">&quot;py_gasUsed&quot;</span>:<span class="string">&quot;0x259b&quot;</span>,<span class="attr">&quot;txdata&quot;</span>:<span class="string">&quot;0x4c125e7900000000000000000000000000000000000000000000000000000000691cc6c9&quot;</span>&#125; </span><br><span class="line">&#123;<span class="attr">&quot;error&quot;</span>:<span class="string">&quot;geth&amp;js_output+gas&quot;</span>,<span class="attr">&quot;geth_output&quot;</span>:<span class="string">&quot;0400000000000000000000000000000000000000000000000000000000000000&quot;</span>,<span class="attr">&quot;js_output&quot;</span>:<span class="string">&quot;0000000000000000000000000000000000000000000000000000000000000001&quot;</span>,<span class="attr">&quot;geth_gasUsed&quot;</span>:<span class="string">&quot;0x259b&quot;</span>,<span class="attr">&quot;js_gasUsed&quot;</span>:<span class="string">&quot;0xce36&quot;</span>,<span class="attr">&quot;txdata&quot;</span>:<span class="string">&quot;0x4c125e7900000000000000000000000000000000000000000000000000000000691cc6c9&quot;</span>&#125; </span><br></pre></td></tr></table></figure><p>调用cancel函数导致的错误</p><p>geth的log出现了输出</p><p><img src="/2023/09/19/EVMFuzzer/image-20231203164124414.png" alt="image-20231203164124414"></p><p>看函数源码，geth和py都返回了FAIL_FLAG的值，但是jsevm返回的是SUCCESS_FLAG，进入了不同的分支，传入一个不存在的requests[requestId].requester时，jsevm中能够绕过requests[requestId].requester == msg.sender</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function cancel(uint64 requestId) public returns (int) &#123;</span><br><span class="line">        if (externalCallFlag) &#123;</span><br><span class="line">            throw;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (killswitch) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        uint fee = requests[requestId].fee;</span><br><span class="line">        if (requests[requestId].requester == msg.sender &amp;&amp; fee &gt;= CANCELLATION_FEE) &#123;</span><br><span class="line">            // If the request was sent by this user and has money left on it,</span><br><span class="line">            // then cancel it.</span><br><span class="line">            requests[requestId].fee = CANCELLED_FEE_FLAG;</span><br><span class="line">            externalCallFlag = true;</span><br><span class="line">            if (!msg.sender.call.value(fee - CANCELLATION_FEE)()) &#123;</span><br><span class="line">                throw;</span><br><span class="line">            &#125;</span><br><span class="line">            externalCallFlag = false;</span><br><span class="line">            Cancel(requestId, msg.sender, requests[requestId].requester, requests[requestId].fee, 1);</span><br><span class="line">            return SUCCESS_FLAG; //1, jsevm output</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Cancel(requestId, msg.sender, requests[requestId].requester, fee, -1);</span><br><span class="line">            return FAIL_FLAG; //geth and pyevm output</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在remix上复现同样得到了和geth pyevm相同的结果</p><p><img src="/2023/09/19/EVMFuzzer/image-20231205175003496.png" alt="image-20231205175003496"></p><p>修改msg.sender的地址后发现是误报</p><p><img src="/2023/09/19/EVMFuzzer/image-20231205175024037.png" alt="image-20231205175024037"></p><h3 id="contract29-已排除"><a href="#contract29-已排除" class="headerlink" title="contract29 已排除"></a>contract29 已排除</h3><ul><li><p>合约：0x9d06cbafa865037a01d322d3f4222fa3e04e5488.sol delta.sol</p></li><li><p>表现：geth和py reverted，消耗的gas相同，但是jsevm return了值，gas消耗也不同</p></li><li>函数：<ul><li>243f6e0c: change_active(uint256)</li><li>bec60bd2: change_token_price(uint256)</li><li>2e1a7d4d: withdraw(uint256)</li><li>均出现了一样的问题</li></ul></li></ul><p>先看change_active函数的运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">modifier onlyOwner() &#123;</span><br><span class="line">if (msg.sender != owner) &#123;</span><br><span class="line">       throw;</span><br><span class="line">   &#125;</span><br><span class="line">   _;</span><br><span class="line">&#125;    </span><br><span class="line"> //Change active</span><br><span class="line"> function change_active(uint256 _active) onlyOwner returns (bool result) &#123;</span><br><span class="line">   active = _active;</span><br><span class="line">   return true;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>正确的执行结果应该是revert，验证发现jsevm居然返回0000001(true)，jsevm是如何判断当前用户是owner的？修改返回值为false，返回值变成了全0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function withdraw(uint256 _amount) onlyOwner returns (bool result) &#123;</span><br><span class="line">    uint256 balance;</span><br><span class="line">    balance = this.balance;</span><br><span class="line">    if(_amount &gt; 0) balance = _amount;</span><br><span class="line">    // &lt;yes&gt; &lt;report&gt; UNCHECKED_LL_CALLS</span><br><span class="line">    owner.send(balance);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>withdraw函数中，返回值为true，又绕过了only owner修饰符，出现了越权访问</p><p>以及msg.sender=全0地址</p><p>jsevm中的默认的 msg.sender = 0000000000000000000000000000000000000000000000000000000000000000，显然不能和</p><p>执行 msg.sender==owner 成立，发现evm中执行没有静态状态变量的值，全是0</p><p>修改msg.sender的地址为与pyevm一致的地址0x1c7cd2d37ffd63856a5bd56a9af1643f2bcf545f后，该问题已解决</p><h3 id="contract33-已部分排除"><a href="#contract33-已部分排除" class="headerlink" title="contract33 已部分排除"></a>contract33 已部分排除</h3><ul><li>合约：PreProcess_list_dos_1.sol after_M5_lendGovernmentMoney_PreProcess_list_dos_1.sol</li><li>表现：py输出为空，报错invalid ; geth和jsevm输出全0但是正常返回</li><li>txdata：0xd95a2d42000000000000000000000000228cc1a8fda4b263de06a4596e20a8ad284df8e6</li><li>函数：lendGovernmentMoney(address)</li></ul><p>pyevm报错 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eth.exceptions.InvalidInstruction: Invalid opcode 0xfe @ 1264</span><br></pre></td></tr></table></figure><p>结合geth和jsevm的result.json，pyevm未能执行CALLER</p><ul><li>js的过程</li></ul><p><img src="/2023/09/19/EVMFuzzer/image-20231203191506616.png" alt="image-20231203191506616"></p><ul><li>py的过程</li></ul><p><img src="/2023/09/19/EVMFuzzer/image-20231203192319230.png" alt="image-20231203192319230"></p><p>正确的实验结果应该是报错，在remix vm上复现成功，geth和js均正确，pyevm返回为空</p><p>复现发现<code>pyevm</code>报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eth.exceptions.InvalidInstruction: Invalid opcode 0xfe @ 1264</span><br></pre></td></tr></table></figure><p>测试函数<code>lendGovernmentMoney(address)</code></p><p>为什么会有两个output，以及geth和jsevm均进入了第二个分支</p><p>原因：</p><ul><li>传入的<code>msg.value</code>不一样？pyevm默认的<code>msg.data = 0</code><ul><li><img src="/2023/09/19/EVMFuzzer/image-20231206172616178.png" alt="image-20231206172616178"></li></ul></li><li>pyevm 进入了 if (lastTimeOfNewCredit + TWELVE_HOURS &lt; block.timestamp)这个分支</li></ul><p>错误原因：pyevm能够读到timestamp，而geth和jsevm没有timestamp的值</p><p>进入同一个分支后，geth和jsevm burn all the gas，pyevm返回了两次？无法解释</p><h3 id="contract102-重复"><a href="#contract102-重复" class="headerlink" title="contract102 重复"></a>contract102 重复</h3><ul><li>合约：实际上就是contract33，函数签名都一样</li></ul><h3 id="contract122-已排除"><a href="#contract122-已排除" class="headerlink" title="contract122 已排除"></a>contract122 已排除</h3><p>问题大户，修改了caller之后已经不再出现该问题</p><ul><li><p>合约：contract FiftyFlip PreProcess_0xe09b1ab8111c2729a76f16de96bc86a7af837928_1.sol </p></li><li><p>表现：</p><ul><li>jsevm输出为空，geth和py输出有值，geth pyevm revert</li></ul></li><li><p>txdata：</p><ul><li>0x2d4f40c600000000000000000000000047a8320bfb820ef9098a1de8cf34d70f597c5e94</li><li>0xd702087f000000000000000000000000c3cfbdf2c080bb895e5b54108d6baf22319bbbb1</li><li>0xd493b9ac000000000000000000000000fb322ec50d729c4442d24fbf0cd53918c97bbbdf000000000000000000000000ccf49b92e14951c322d65d034faf3e3401f75bba000000000000000000000000000000000000000000000000000000006f926c24</li><li>0x89c5077f00000000000000000000000063c8e71019ee71b33287ec4a4a106b255e8a653f00000000000000000000000000000000000000000000000000000000e5ffe3f6</li></ul></li><li><p>函数：</p><ul><li><p>2d4f40c6: setBotAddress(address)</p><ul><li><p>geth和pyevm均revert且输出了相同的值，js没有输出，最后一个操作码是stop；</p></li><li><p>```shell</p><h1 id="pyevm-error"><a href="#pyevm-error" class="headerlink" title="pyevm error"></a>pyevm error</h1><p>eth.exceptions.Revert: b”\x08\xc3y\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00 \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00’You are not the owner of this contract!\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- d702087f: setSecretSigner(address)</span><br><span class="line"></span><br><span class="line">  - 和上一个一样，geth和pyevm均revert且输出了相同的值，js没有输出，最后一个操作码是stop</span><br><span class="line"></span><br><span class="line">  - ```shell</span><br><span class="line">    # pyevm error</span><br><span class="line">    eth.exceptions.Revert: b&quot;\x08\xc3y\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00 \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&#x27;You are not the owner of this contract!\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&quot;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>d493b9ac: transferAnyERC20Token(address,address,uint256)</p><ul><li>和上面两个类似，geth和pyevm均revert且输出了相同的值，但是此时jsevm revert，没输出</li></ul></li><li><p>89c5077f: withdrawDevFee(address,uint256)</p><ul><li><p>三者均revert，geth/py输出相同，jsevm的输出非常接近但是不一样</p><ul><li>jsevm： 08c379a00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003a596f752061726520747279696e6720746f207769746864726177206d6f726520616d6f756e74207468616e20646576656c6f706572206665652e000000000000</li><li>geth/py: 08c379a000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000027596f7520617265206e6f7420746865206f776e6572206f66207468697320636f6e74726163742100000000000000000000000000000000000000000000000000</li></ul></li><li><p>```shell<br>eth.exceptions.Revert: b”\x08\xc3y\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00 \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00’You are not the owner of this contract!\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 1212 manual check</span><br><span class="line"></span><br><span class="line">爬取了etherscan最新的4000个验证后的合约，合约基本均为0.8.x版本。将每个合约中的所有函数经过5轮变异</span><br><span class="line"></span><br><span class="line">仅发现了3类gas不一致，没有output不一致的情况</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">../expResult/1211/contract2802/result.json addeed</span><br><span class="line">../expResult/1211/contract1070/result.json addeed</span><br><span class="line">../expResult/1211/contract484/result.json addeed</span><br><span class="line">&#123;&#x27;js&amp;py_gas&#x27;: 0.5, &#x27;geth&amp;js_gas&#x27;: 0.4782608695652174, &#x27;geth&amp;py_gas&#x27;: 0.021739130434782608&#125;</span><br><span class="line">Total Error type:  3</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><p><img src="/2023/09/19/EVMFuzzer/image-20231211155836992.png" alt="image-20231211155836992" style="zoom: 50%;"></p><p><img src="/2023/09/19/EVMFuzzer/image-20231211155926329.png" alt="image-20231211155926329" style="zoom: 50%;"></p><p>逐个分析3个合约不一致性的来源</p><h3 id="contract-484"><a href="#contract-484" class="headerlink" title="contract 484"></a>contract 484</h3><ul><li><p>合约：PreProcess_0x17971fe4dd6f31c39d8608a5062b18ade246a87a_3.sol <a href="https://docs.bannochmoor.com/">https://docs.bannochmoor.com/</a></p></li><li><p>contractname：Bannochmoor</p></li><li><p>input: </p><ul><li>isBlacklisted(address) 0xfe575a87000000000000000000000000bffd98ec9ba3dc965b8a97d876670bb367fa84c2</li><li>setBlacklistEnabled(address,bool) 0xeec2744e00000000000000000000000050be92661fb0da16356a6e31f2208dc41663aa4d0000000000000000000000000000000000000000000000000000000000000000</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(env) alleysira@LAPTOP-M4HO8L6S:~/EVMFuzzer$ solc --bin-runtime manCheck/contract/PreProcess_0x17971fe4dd6f31c39d8608a5062b18ade246a87a.sol -o manCheck/contract/ --overwrite</span><br></pre></td></tr></table></figure><h4 id="isBlacklisted-address"><a href="#isBlacklisted-address" class="headerlink" title="isBlacklisted(address)"></a>isBlacklisted(address)</h4><p>执行函数isBlacklisted(address)，发现geth和pyevm的 gas消耗是0xcc6，jsout是0x168a</p><p>对比gethout.json和jsout.json，geth执行<code>staticcall</code>本来应该消耗 0x2f2485的gas，但是实际上没消耗</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//geth</span></span><br><span class="line">&#123;<span class="attr">&quot;pc&quot;</span>:<span class="number">16225</span>,<span class="attr">&quot;op&quot;</span>:<span class="number">250</span>,<span class="attr">&quot;gas&quot;</span>:<span class="string">&quot;0x2fe413&quot;</span>,<span class="attr">&quot;gasCost&quot;</span>:<span class="string">&quot;0x2f2485&quot;</span>,<span class="attr">&quot;memSize&quot;</span>:<span class="number">192</span>,<span class="attr">&quot;stack&quot;</span>:[<span class="string">&quot;0xfe575a87&quot;</span>,<span class="string">&quot;0xcaf&quot;</span>,<span class="string">&quot;0xbffd98ec9ba3dc965b8a97d876670bb367fa84c2&quot;</span>,<span class="string">&quot;0x0&quot;</span>,<span class="string">&quot;0x0&quot;</span>,<span class="string">&quot;0xfe575a87&quot;</span>,<span class="string">&quot;0xa4&quot;</span>,<span class="string">&quot;0x20&quot;</span>,<span class="string">&quot;0x80&quot;</span>,<span class="string">&quot;0x24&quot;</span>,<span class="string">&quot;0x80&quot;</span>,<span class="string">&quot;0x0&quot;</span>,<span class="string">&quot;0x2fe413&quot;</span>],<span class="attr">&quot;depth&quot;</span>:<span class="number">1</span>,<span class="attr">&quot;refund&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;opName&quot;</span>:<span class="string">&quot;STATICCALL&quot;</span>&#125;</span><br><span class="line"><span class="comment">//jsout</span></span><br><span class="line">&#123;<span class="attr">&quot;pc&quot;</span>:<span class="number">16225</span>,<span class="attr">&quot;gas&quot;</span>:<span class="string">&quot;0xf43a&quot;</span>,<span class="attr">&quot;gasCost&quot;</span>:<span class="string">&quot;0x0&quot;</span>,<span class="attr">&quot;memory&quot;</span>:<span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012800000000000000000000000000000000254879013500000000000019125315223615516322015091138151216118103111791032501321940000000000000000000000000000&quot;</span>,<span class="attr">&quot;memsize&quot;</span>:<span class="string">&quot;6&quot;</span>,<span class="attr">&quot;stack&quot;</span>:[<span class="string">&quot;0xfe575a87&quot;</span>,<span class="string">&quot;0xcaf&quot;</span>,<span class="string">&quot;0xbffd98ec9ba3dc965b8a97d876670bb367fa84c2&quot;</span>,<span class="string">&quot;0x0&quot;</span>,<span class="string">&quot;0x0&quot;</span>,<span class="string">&quot;0xfe575a87&quot;</span>,<span class="string">&quot;0xa4&quot;</span>,<span class="string">&quot;0x20&quot;</span>,<span class="string">&quot;0x80&quot;</span>,<span class="string">&quot;0x24&quot;</span>,<span class="string">&quot;0x80&quot;</span>,<span class="string">&quot;0x0&quot;</span>,<span class="string">&quot;0xf43a&quot;</span>],<span class="attr">&quot;depth&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;opName&quot;</span>:<span class="string">&quot;STATICCALL&quot;</span>&#125;</span><br><span class="line"><span class="comment">//py</span></span><br><span class="line">&#123;<span class="attr">&quot;pc&quot;</span>: <span class="number">16225</span>, <span class="attr">&quot;op&quot;</span>: <span class="number">250</span>, <span class="attr">&quot;gas&quot;</span>: <span class="string">&quot;0xa082&quot;</span>, <span class="attr">&quot;gasCost&quot;</span>: <span class="string">&quot;0x0&quot;</span>, <span class="attr">&quot;stack&quot;</span>: [<span class="string">&quot;0xfe575a87&quot;</span>, <span class="string">&quot;0xaf0c&quot;</span>, <span class="string">&quot;0xc284fa67b30b6776d8978a5b96dca39bec98fdbf&quot;</span>, <span class="string">&quot;0x0&quot;</span>, <span class="string">&quot;0x0&quot;</span>, <span class="string">&quot;0x875a57fe&quot;</span>, <span class="string">&quot;0xa4&quot;</span>, <span class="string">&quot;0x20&quot;</span>, <span class="string">&quot;0x8000000000000000000000000000000000000000000000000000000000000000&quot;</span>, <span class="string">&quot;0x24&quot;</span>, <span class="string">&quot;0x8000000000000000000000000000000000000000000000000000000000000000&quot;</span>, <span class="string">&quot;0x0&quot;</span>, <span class="string">&quot;0xa082&quot;</span>], <span class="attr">&quot;depth&quot;</span>: <span class="number">0</span>, <span class="attr">&quot;opName&quot;</span>: <span class="string">&quot;STATICCALL&quot;</span>, <span class="attr">&quot;error&quot;</span>: <span class="string">&quot;None&quot;</span> &#125;</span><br></pre></td></tr></table></figure><p>其中，pyevm依然出现了之前的2次返回的情况，执行<code>staticcall</code>后返回了</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;pc&quot;</span>: <span class="number">0</span>, <span class="attr">&quot;op&quot;</span>: <span class="number">0</span>, <span class="attr">&quot;gas&quot;</span>: <span class="string">&quot;0x9d9e&quot;</span>, <span class="attr">&quot;gasCost&quot;</span>: <span class="string">&quot;0x0&quot;</span>, <span class="attr">&quot;stack&quot;</span>: [], <span class="attr">&quot;depth&quot;</span>: <span class="number">1</span>, <span class="attr">&quot;opName&quot;</span>: <span class="string">&quot;STOP&quot;</span>, <span class="attr">&quot;error&quot;</span>: <span class="string">&quot;None&quot;</span> &#125;</span><br><span class="line">&#123;<span class="attr">&quot;output&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="attr">&quot;gasUsed&quot;</span>: <span class="string">&quot;0x0&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>看函数，未初始化的全局变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Initializer initializer;</span><br><span class="line"></span><br><span class="line">function isBlacklisted(address account) external view returns (bool) &#123;</span><br><span class="line"></span><br><span class="line">    return initializer.isBlacklisted(account);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在remix上部署报错</p><ul><li><p>Warning: Contract code size is 31376 bytes and exceeds 24576 bytes (a limit introduced in Spurious Dragon). This contract may not be deployable on Mainnet. Consider enabling the optimizer (with a low “runs” value!), turning off revert strings, or using libraries.   —&gt; contracts/test.sol:207:1:    | 207 | contract Bannochmoor is IERC20 {    | ^ (Relevant source part starts here and spans across multiple lines). </p></li><li><p>Contract creation initialization returns data with length of more than 24576 bytes. The deployment will likely fail if the current network has activated the eip 170. More info: <a href="https://eips.ethereum.org/EIPS/eip-170">eip-170</a></p></li></ul><p>通过开启优化器解决源代码文件过大的问题</p><p><img src="/2023/09/19/EVMFuzzer/image-20231211212219307.png" alt="image-20231211212219307"></p><p>对于staticcall的gas消耗的计算：<a href="https://github.com/wolflo/evm-opcodes/blob/main/gas.md#aa-4-staticcall">https://github.com/wolflo/evm-opcodes/blob/main/gas.md#aa-4-staticcall</a></p><p>分析一下具体执行了哪些操作码和对应的个数：整挺好，发现geth多了一个<code>STOP</code></p><p>发现不同操作码的gas消耗确实不太一样，NeoDiff没有记录这些操作码</p><p>MSTORE</p><ul><li>geth C+9+6+3=30</li><li>js and py: 3+3+3+3=12</li></ul><p>非常奇怪，从输出来看js和py是一样的，但实际执行结果是geth和py一致，js不同</p><h4 id="setBlacklistEnabled-address-bool"><a href="#setBlacklistEnabled-address-bool" class="headerlink" title="setBlacklistEnabled(address,bool)"></a>setBlacklistEnabled(address,bool)</h4><p>看一下第二个函数，执行bincode_setBlacklistEnabled_3/Bannochmoor.bin-runtime时出现了jsevm gas不一致，py geth 0x15c6, jsevm 0x1f8a</p><p>原来是onlyOwner被变异了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">modifier onlyOwner() &#123; </span><br><span class="line">         require(_owner &lt;= msg.sender, &quot;Caller =/= owner.&quot;); _; </span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">modifier onlyOwner() &#123; </span><br><span class="line">         require(_owner == msg.sender, &quot;Caller =/= owner.&quot;); _; </span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><p>导致了gas不一致的结果，但是保证jsevm和pyevm的sender一样也有不一致性</p><h3 id="contract-1070-已排除"><a href="#contract-1070-已排除" class="headerlink" title="contract 1070 已排除"></a>contract 1070 已排除</h3><ul><li><p>合约：PreProcess_0xdabb3d9d0d2c36a4131b301444672111fcbf5ceb_3.sol</p></li><li><p>input: </p><ul><li><p>5d37a8dd: assureCanTransfer(address,address,address,uint256)</p><p>0x5d37a8dd000000000000000000000000383fc804d250a74fa346deb30b0396d97e226ed6000000000000000000000000d98e3a0fbdd3ef5eadca9ad24a09abfa93c9235100000000000000000000000009988669ba6b8a9aa2aee66e71c94faf26562b5200000000000000000000000000000000000000000000000000000000a85d2903</p></li></ul></li><li><p>表现：py different with geth and js</p></li></ul><p>和未变异的合约相比，将<code>！=</code>变为了<code>&gt;</code>，因此是调用方式造成的不一致性，卒</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    function assureCanTransfer( address msgSender, address from, address to, uint256) external &#123;</span><br><span class="line">    // msg.sender !=  </span><br><span class="line">        if (msg.sender &gt; 0xbddc20ed7978B7d59eF190962F441cD18C14e19f) return;</span><br><span class="line">        bytes32 cachedBanned = banned;</span><br><span class="line">        if (</span><br><span class="line">            keccak256(abi.encodePacked(msgSender)) &gt;= cachedBanned &amp;&amp;</span><br><span class="line">            keccak256(abi.encodePacked(from)) &lt;= cachedBanned &amp;&amp;</span><br><span class="line">            keccak256(abi.encodePacked(to)) &lt;= cachedBanned</span><br><span class="line">        ) revert Banned();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="contract-2802-已排除"><a href="#contract-2802-已排除" class="headerlink" title="contract 2802 已排除"></a>contract 2802 已排除</h3><p>提供了最多的gas不一致</p><ul><li><p>合约：PreProcess_0xd85cc69b92fbd5551870e7def7baeba764008395.sol</p></li><li><p>input: </p><ul><li>getClaimableDividendOf(address) 0x8ecc37fb0000000000000000000000004ccaf589fc374ccad1f79b5b339322f9cf19c65f</li><li>getDividendsClaimedOf(address)  0x5cc33f74000000000000000000000000521c755ce0c5f49e708d327789892ba0ff2416e1</li><li>getDividendsClaimedOf(address)  0x5cc33f740000000000000000000000003bde5776e515c56d4a083e2e1ec32bd7f60805c6</li></ul></li><li>表现：js different with geth and py</li></ul><p>DividendDistributor.bin-runtime和IDividendDistributor.signature都有5cc33f74，但是后者.bin-runtime为空</p><p>对于函数getClaimableDividendOf(address) ，无法复现，猜测是已经通过设置相同的地址解决了</p><h2 id="0116-manual-check"><a href="#0116-manual-check" class="headerlink" title="0116 manual check"></a>0116 manual check</h2><p>手动检查在ThinkPad上发现的2个gas不一致的问题</p><h3 id="0x9e1b5a3878cc0b3f88707bf198495baa424b8ec4-sol"><a href="#0x9e1b5a3878cc0b3f88707bf198495baa424b8ec4-sol" class="headerlink" title="0x9e1b5a3878cc0b3f88707bf198495baa424b8ec4.sol"></a>0x9e1b5a3878cc0b3f88707bf198495baa424b8ec4.sol</h3><ul><li>sig：0xc261d41c000000000000000000000000000000000000000000000000000000007a6798e50000000000000000000000000000000000000000000000000000000053c161930000000000000000000000003deb54778e24c7dd7e4505214453c560f94267fa000000000000000000000000fb7b01eb6d20e5d66e9d8e5840002c862a11033b0000000000000000000000003aeffd7528ae566836f911731acfb494fc7131a30000000000000000000000007e847c09d9796d8b5d00063e9a1e3f7e46d6871f</li><li>func</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;error&quot;</span>:<span class="string">&quot;js&amp;py_gas&quot;</span>,<span class="attr">&quot;js_output&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="attr">&quot;py_output&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="attr">&quot;js_gasUsed&quot;</span>:<span class="string">&quot;0x2494&quot;</span>,<span class="attr">&quot;py_gasUsed&quot;</span>:<span class="string">&quot;0x1ad0&quot;</span>,<span class="attr">&quot;txdata&quot;</span>:<span class="string">&quot;0x14cc25e80000000000000000000000008f8f2cef2198a1d94faf69ca5419313331287ce30000000000000000000000000000000000000000000000000000000042ed4ee7&quot;</span>&#125; </span><br><span class="line">&#123;<span class="attr">&quot;error&quot;</span>:<span class="string">&quot;geth&amp;js_gas&quot;</span>,<span class="attr">&quot;geth_output&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="attr">&quot;js_output&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="attr">&quot;geth_gasUsed&quot;</span>:<span class="string">&quot;0x1ad0&quot;</span>,<span class="attr">&quot;js_gasUsed&quot;</span>:<span class="string">&quot;0x2494&quot;</span>,<span class="attr">&quot;txdata&quot;</span>:<span class="string">&quot;0x14cc25e80000000000000000000000008f8f2cef2198a1d94faf69ca5419313331287ce30000000000000000000000000000000000000000000000000000000042ed4ee7&quot;</span>&#125; </span><br></pre></td></tr></table></figure><h3 id="contract595-0x7008d42622a8b4ef73e946833ea90e608de9e96b-sol-未排除"><a href="#contract595-0x7008d42622a8b4ef73e946833ea90e608de9e96b-sol-未排除" class="headerlink" title="contract595 0x7008d42622a8b4ef73e946833ea90e608de9e96b.sol 未排除"></a>contract595 0x7008d42622a8b4ef73e946833ea90e608de9e96b.sol 未排除</h3><p>result.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;error&quot;</span>:<span class="string">&quot;js&amp;py_gas&quot;</span>,<span class="attr">&quot;js_output&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="attr">&quot;py_output&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="attr">&quot;js_gasUsed&quot;</span>:<span class="string">&quot;0x4a3a&quot;</span>,<span class="attr">&quot;py_gasUsed&quot;</span>:<span class="string">&quot;0x4076&quot;</span>,<span class="attr">&quot;txdata&quot;</span>:<span class="string">&quot;0x22ea223100000000000000000000000042a39d51fc07bb9c181a0b62df834575cb3b1aa40000000000000000000000000000000000000000000000000000000054c1f8e0&quot;</span>,<span class="attr">&quot;js_error&quot;</span>:&#123;<span class="attr">&quot;error&quot;</span>:<span class="string">&quot;revert&quot;</span>,<span class="attr">&quot;errorType&quot;</span>:<span class="string">&quot;EvmError&quot;</span>&#125;&#125; </span><br><span class="line">&#123;<span class="attr">&quot;error&quot;</span>:<span class="string">&quot;geth&amp;js_gas&quot;</span>,<span class="attr">&quot;geth_output&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="attr">&quot;js_output&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="attr">&quot;geth_gasUsed&quot;</span>:<span class="string">&quot;0x4076&quot;</span>,<span class="attr">&quot;js_gasUsed&quot;</span>:<span class="string">&quot;0x4a3a&quot;</span>,<span class="attr">&quot;txdata&quot;</span>:<span class="string">&quot;0x22ea223100000000000000000000000042a39d51fc07bb9c181a0b62df834575cb3b1aa40000000000000000000000000000000000000000000000000000000054c1f8e0&quot;</span>,<span class="attr">&quot;js_error&quot;</span>:&#123;<span class="attr">&quot;error&quot;</span>:<span class="string">&quot;revert&quot;</span>,<span class="attr">&quot;errorType&quot;</span>:<span class="string">&quot;EvmError&quot;</span>&#125;,<span class="attr">&quot;geth_error&quot;</span>:<span class="string">&quot;execution reverted&quot;</span>&#125; </span><br><span class="line">&#123;<span class="attr">&quot;error&quot;</span>:<span class="string">&quot;js&amp;py_gas&quot;</span>,<span class="attr">&quot;js_output&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="attr">&quot;py_output&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="attr">&quot;js_gasUsed&quot;</span>:<span class="string">&quot;0xffff&quot;</span>,<span class="attr">&quot;py_gasUsed&quot;</span>:<span class="string">&quot;0x6d09&quot;</span>,<span class="attr">&quot;txdata&quot;</span>:<span class="string">&quot;0xc261d41c000000000000000000000000000000000000000000000000000000007a6798e50000000000000000000000000000000000000000000000000000000053c161930000000000000000000000003deb54778e24c7dd7e4505214453c560f94267fa000000000000000000000000fb7b01eb6d20e5d66e9d8e5840002c862a11033b0000000000000000000000003aeffd7528ae566836f911731acfb494fc7131a30000000000000000000000007e847c09d9796d8b5d00063e9a1e3f7e46d6871f&quot;</span>,<span class="attr">&quot;js_error&quot;</span>:&#123;<span class="attr">&quot;error&quot;</span>:<span class="string">&quot;out of gas&quot;</span>,<span class="attr">&quot;errorType&quot;</span>:<span class="string">&quot;EvmError&quot;</span>&#125;&#125; </span><br><span class="line">&#123;<span class="attr">&quot;error&quot;</span>:<span class="string">&quot;geth&amp;js_gas&quot;</span>,<span class="attr">&quot;geth_output&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="attr">&quot;js_output&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="attr">&quot;geth_gasUsed&quot;</span>:<span class="string">&quot;0x21564&quot;</span>,<span class="attr">&quot;js_gasUsed&quot;</span>:<span class="string">&quot;0xffff&quot;</span>,<span class="attr">&quot;txdata&quot;</span>:<span class="string">&quot;0xc261d41c000000000000000000000000000000000000000000000000000000007a6798e50000000000000000000000000000000000000000000000000000000053c161930000000000000000000000003deb54778e24c7dd7e4505214453c560f94267fa000000000000000000000000fb7b01eb6d20e5d66e9d8e5840002c862a11033b0000000000000000000000003aeffd7528ae566836f911731acfb494fc7131a30000000000000000000000007e847c09d9796d8b5d00063e9a1e3f7e46d6871f&quot;</span>,<span class="attr">&quot;js_error&quot;</span>:&#123;<span class="attr">&quot;error&quot;</span>:<span class="string">&quot;out of gas&quot;</span>,<span class="attr">&quot;errorType&quot;</span>:<span class="string">&quot;EvmError&quot;</span>&#125;&#125; </span><br><span class="line">&#123;<span class="attr">&quot;error&quot;</span>:<span class="string">&quot;geth&amp;py_gas&quot;</span>,<span class="attr">&quot;geth_output&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="attr">&quot;py_output&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="attr">&quot;geth_gasUsed&quot;</span>:<span class="string">&quot;0x21564&quot;</span>,<span class="attr">&quot;py_gasUsed&quot;</span>:<span class="string">&quot;0x6d09&quot;</span>,<span class="attr">&quot;txdata&quot;</span>:<span class="string">&quot;0xc261d41c000000000000000000000000000000000000000000000000000000007a6798e50000000000000000000000000000000000000000000000000000000053c161930000000000000000000000003deb54778e24c7dd7e4505214453c560f94267fa000000000000000000000000fb7b01eb6d20e5d66e9d8e5840002c862a11033b0000000000000000000000003aeffd7528ae566836f911731acfb494fc7131a30000000000000000000000007e847c09d9796d8b5d00063e9a1e3f7e46d6871f&quot;</span>&#125; </span><br></pre></td></tr></table></figure><ul><li><p>函数1</p><ul><li>22ea2231: purchaseTokens(address,uint256)</li><li>D223ICO.bin-runtime </li><li>data: 0x22ea223100000000000000000000000042a39d51fc07bb9c181a0b62df834575cb3b1aa40000000000000000000000000000000000000000000000000000000054c1f8e0</li><li>发现前3个bin都没问题，出问题的是poc/contract595/bincode/bincode_purchaseTokens_3/D223ICO.bin-runtime </li><li>使用diff查看不同的地方，经典是msg.sender导致了后续不一样，已向开发者提交issue</li><li><img src="/2023/09/19/EVMFuzzer/image-20240117111625156.png" alt="image-20240117111625156"></li></ul></li><li><p>函数2 已排除</p><ul><li><p>c261d41c: set(uint256,uint256,address,address,address,address)</p></li><li><p>D223ICO.bin-runtime</p></li><li><p>python3 poc.py —code poc/contract595/bincode/bincode_set_1/D223ICO.bin-runtime —sig 0xc261d41c000000000000000000000000000000000000000000000000000000007a6798e50000000000000000000000000000000000000000000000000000000053c161930000000000000000000000003deb54778e24c7dd7e4505214453c560f94267fa000000000000000000000000fb7b01eb6d20e5d66e9d8e5840002c862a11033b0000000000000000000000003aeffd7528ae566836f911731acfb494fc7131a30000000000000000000000007e847c09d9796d8b5d00063e9a1e3f7e46d6871f</p></li><li><p>表现：geth和jsevm gas一致0x21564，pyevm不一样0x6d09</p></li><li><p>```solidity</p><pre><code>function set(uint256 _price_USD, uint256 _price_rate_ETH, address _ICO_token, address _USDT, address _USDC, address _DAI) public&#123;    require(msg.sender == owner);    price_rate_USD     = _price_USD;    USDT_contract      = _USDT;    USDC_contract      = _USDC;    DAI_contract       = _DAI;    ICO_token          = _ICO_token;    price_rate_ETH     = _price_rate_ETH;&#125;</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 依然是msg.sender的问题？不是，已排除是初始gas不同导致的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 0118-4k</span><br><span class="line"></span><br><span class="line">```json</span><br><span class="line">2024-01-18 11:48:26 TestOut/contract779/result.json addeed</span><br><span class="line">2024-01-18 11:48:26 TestOut/contract2545/result.json addeed</span><br><span class="line">2024-01-18 11:48:26 TestOut/contract2479/result.json addeed</span><br><span class="line">2024-01-18 11:48:26 TestOut/contract4371/result.json addeed</span><br><span class="line">2024-01-18 11:48:26 TestOut/contract573/result.json addeed</span><br><span class="line">2024-01-18 11:48:26 TestOut/contract191/result.json addeed</span><br><span class="line">2024-01-18 11:48:26 TestOut/contract3441/result.json addeed</span><br><span class="line">2024-01-18 11:48:26 TestOut/contract3475/result.json addeed</span><br><span class="line">2024-01-18 11:48:26 TestOut/contract2463/result.json addeed</span><br><span class="line">2024-01-18 11:48:26 The valid ressult.json with different output are contracts: [779]</span><br><span class="line">2024-01-18 11:48:26 &#123;&#x27;js&amp;py_output+gas&#x27;: 0.047619047619047616, &#x27;geth&amp;js_output+gas&#x27;: 0.047619047619047616, &#x27;geth&amp;py_output&#x27;: 0.047619047619047616, &#x27;js&amp;py_gas&#x27;: 0.41904761904761906, &#x27;geth&amp;js_gas&#x27;: 0.41904761904761906, &#x27;geth&amp;py_gas&#x27;: 0.01904761904761905&#125; </span><br><span class="line">2024-01-18 11:48:26 Total Error type:  6</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>先看779 </p><h3 id="contract779"><a href="#contract779" class="headerlink" title="contract779"></a>contract779</h3><p>合约：PreProcess_0xb6fb6cf20ae6933c6b7b437b40536207a657df1d.sol</p><p>输入：0xb9bc47ab00000000000000000000000014b1d72a2013c61897e4b86fa40367e0f0a96d31</p><p>函数：b9bc47ab: createNest(address)</p><p>命令：python3 poc.py —code ./poc/contract779/bincode/bincode_createNest_0/nestCreator.bin-runtime —sig 0xb9bc47ab00000000000000000000000014b1d72a2013c61897e4b86fa40367e0f0a96d31</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">contract nestCreator &#123;</span><br><span class="line">    function createNest(address token) external returns(address nest)&#123;</span><br><span class="line">        nest = address(new Nest(token));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract Nest &#123;</span><br><span class="line">    //Contract cannot do anything so no removal of tokens can happen</span><br><span class="line">    address public Token;</span><br><span class="line">    constructor(address _Token) &#123;</span><br><span class="line">        Token = _Token;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么简单的合约为什么会出错呢，三个虚拟机的输出都不一样，直观理解如果想要得到相同输出需要构造一致的初始环境，猜测是msg.sender的区别导致了，后面需要学习一下如何解释new address这个操作</p><h1 id="docker-alleysira-evmfuzz-vx-x-x"><a href="#docker-alleysira-evmfuzz-vx-x-x" class="headerlink" title="docker alleysira/evmfuzz:vx.x.x"></a>docker alleysira/evmfuzz:vx.x.x</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker build -t alleysira/evmfuzz:1.0.1 .</span><br><span class="line">docker run -it images /bin/bash</span><br><span class="line">docker <span class="built_in">exec</span> -it id /bin/bash</span><br><span class="line">docker push alleysira/evmfuzz:1.0.1</span><br><span class="line">docker pull alleysira/evmfuzz</span><br></pre></td></tr></table></figure><h1 id="wasm-fuzzer"><a href="#wasm-fuzzer" class="headerlink" title="wasm-fuzzer"></a>wasm-fuzzer</h1><h2 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h2><p>已经在长安链开源社区开源 <a href="https://git.chainmaker.org.cn/chainmaker/wasm-fuzzer">https://git.chainmaker.org.cn/chainmaker/wasm-fuzzer</a></p><p>首先按照readme build一下，缺头文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/home/alleysira/wasm-fuzzer/wasmfuzzer/wasmfuzzer_test_main.cpp:10:10: fatal error: gtest/gtest.h: No such file or directory</span><br><span class="line">   10 | #include &lt;gtest/gtest.h&gt;</span><br><span class="line">      |          ^~~~~~~</span><br><span class="line">compilation terminated.</span><br></pre></td></tr></table></figure><p>在shell中安装即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libgtest-dev</span><br></pre></td></tr></table></figure><h2 id="运行-1"><a href="#运行-1" class="headerlink" title="运行"></a>运行</h2><p>在项目根目录运行即可</p><p><img src="/2023/09/19/EVMFuzzer/image-20240216164932669.png" alt="image-20240216164932669"></p><p><img src="/2023/09/19/EVMFuzzer/image-20240216180025164.png" alt="image-20240216180025164"></p><p><img src="/2023/09/19/EVMFuzzer/image-20240218231727717.png" alt="image-20240218231727717"></p><p><img src="/2023/09/19/EVMFuzzer/image-20240217102709538.png" alt="image-20240217102709538"></p><p>在zgc电脑上没跑出结果</p><p><img src="/2023/09/19/EVMFuzzer/image-20240223093007529.png" alt="image-20240223093007529"></p><h1 id="opcodes"><a href="#opcodes" class="headerlink" title="opcodes"></a>opcodes</h1><p>以太坊官方对操作码介绍：<a href="https://ethereum.org/en/developers/docs/evm/opcodes/">https://ethereum.org/en/developers/docs/evm/opcodes/</a></p><p>操作码和对应的gas：<a href="https://www.evm.codes/?fork=shanghai">https://www.evm.codes/?fork=shanghai</a></p><p>查阅字节码：<a href="https://github.com/wolflo/evm-opcodes">https://github.com/wolflo/evm-opcodes</a></p><p>2Hours crash course：<a href="https://www.youtube.com/watch?v=8p7RKYJ9AF0&amp;ab_channel=UttamSingh">https://www.youtube.com/watch?v=8p7RKYJ9AF0&amp;ab_channel=UttamSingh</a></p><h2 id="Yellow-paper"><a href="#Yellow-paper" class="headerlink" title="Yellow paper"></a>Yellow paper</h2><p>学习以太坊官方对EVM的介绍：<a href="https://ethereum.org/en/developers/tutorials/yellow-paper-evm/">https://ethereum.org/en/developers/tutorials/yellow-paper-evm/</a></p><h3 id="EVM-Basic"><a href="#EVM-Basic" class="headerlink" title="EVM Basic"></a>EVM Basic</h3><p>EVM栈的深度为1024，每个单元大小为256比特，方便哈希运算和椭圆曲线运算</p><p>memory是32字节长，初始为全0，执行<code>mstore(0, 0x60A7)</code>之后，内存的0-29都是<code>0</code>，30是<code>0x60</code>,31是<code>0xa7</code></p><p>EVM的四类内存：stack memory storge calldata</p><p>标准的冯诺依曼架构将code和data存储在同一个内存中，EVM为了安全性期间没有采用这样的设计，将代码存储在storge中</p><h3 id="Fees-OVERVIEW"><a href="#Fees-OVERVIEW" class="headerlink" title="Fees OVERVIEW"></a>Fees OVERVIEW</h3><ul><li>操作码：存在对应的计算公式</li><li>运行消耗：创建合约、调用合约</li><li>扩展内存：gas消耗和内存的平方成正比</li></ul><p>以上仅是定义的gas价格，没有考虑市场中对validator的消费</p><h3 id="Execution-environment"><a href="#Execution-environment" class="headerlink" title="Execution environment"></a>Execution environment</h3><p><img src="/2023/09/19/EVMFuzzer/image-20231203153419624.png" alt="image-20231203153419624"></p><h3 id="EVM-Execution-Overview"><a href="#EVM-Execution-Overview" class="headerlink" title="EVM Execution Overview"></a>EVM Execution Overview</h3><p>退出时的操作码：RETURN REVERT STOP SELFSTRUCT </p><p><img src="/2023/09/19/EVMFuzzer/image-20231203154214956.png" alt="image-20231203154214956"></p><p>第二条，如果执行的操作码是REVERT，新的状态和旧的相同，损失部分gas</p><p>正常的halting</p><ul><li>如果操作码不是halt，返回空集</li><li>如果遇到STOP或SELFDESTRUCT，返回0字节</li><li>如果遇到return和revert，从内存中返回操作码指定的字节，栈顶是第一个字节，第二个值是长度</li></ul><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><h2 id="论文阅读"><a href="#论文阅读" class="headerlink" title="论文阅读"></a>论文阅读</h2><ul><li>发现了不一致性后，如何解释一致性可能产生的影响——攻击者可以操作合约输出不一致的结果<ul><li>如何寻找bug的来源——手工分析</li></ul></li><li>能不能测试其他的安全组件？consensus implementation</li><li>采用的中间表示形式是AST，换成3AC或者SSA是否具有可行性？<ul><li>后续的opcode不同和gas是否可能是由CAST转换为solidity的过程引入的</li><li>设计变异器时利用了控制流，直观理解是更合适</li><li>solc本身支持输出ast形式</li><li><img src="/2023/09/19/EVMFuzzer/image-20231020143445389.png" alt="image-20231020143445389"></li><li><img src="/2023/09/19/EVMFuzzer/image-20230920183950597.png" alt="image-20230920183950597"></li></ul></li><li>time_pri仅加1，合理性在于初始值为0-10</li><li>dif的定义应该有问题，需要把abs拆开</li><li>编译器的版本为0.4.24，如果对新的版本的合约进行差分测试，需要进行哪些更改</li><li><p>考虑操作码一致性时，为什么不考虑结果不同的，也可以说明一定问题？</p><ul><li>只有结果一致的，才能说明benchmark是有效的，因为被参考的4个虚拟机之间就有非常多差异</li></ul></li><li><p><del>给出该论文的后续工作，已解决</del></p><ul><li><a href="https://scholar.google.com/scholar?start=0&amp;hl=en&amp;as_sdt=2005&amp;sciodt=0,5&amp;cites=7702365947421966340&amp;scipsc=">Fu: Evmfuzzer: detect evm vulnerabilities via fuzz testing - Google Scholar</a></li></ul></li></ul><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><ul><li>如何确定发现的不一致性可能导致的危害<ul><li>可能导致网络分叉，算力占多数的节点采用的客户端会成为网络的主链</li><li>上层应用对区块链的状态的认识可能不正确</li><li>恶意的开发者可能利用合约执行差异的漏洞来隐藏后门</li></ul></li></ul><p>和王老师交流内容</p><ul><li><p>目前工作：</p><ul><li>阅读代码实现，修正功能实现上的错误，如错误调用jsevm、aleth always true</li><li>增加了对geth pyevm jsevm aleth之间进行对比的代码</li><li>种子合约大约给了200个，1500+，简单的分析</li></ul></li><li><p>理想的一个工具，距离一篇论文</p><ul><li>测试对象：targetEVM 测试的虚拟机的版本、编译器的版本</li><li>针对现有的EVM compatible的链的虚拟机来做测试</li><li>如何找漏洞：输出output不同的地方，如何解释输入会导致不同</li><li>定义安全参数：opcode/gas diff</li></ul></li></ul><h1 id="请教"><a href="#请教" class="headerlink" title="请教"></a>请教</h1><ul><li>1214 杰峰</li><li>0107 贺宁宇<ul><li>介绍基本情况，复现了evmfuzzer，差分模糊测试，standalone 没有前置状态，seed是种子</li><li>变异 拿收集的合约solc编译成字节码再跑，变异的话是在ast上变异完反到solidity上去再编译到字节码，Etherscan4000个，每个函数执行5次，发现的问题都是gas相关的。<ul><li>实验的意义，是否可能发现漏洞</li><li>直接生成字节码的比较适合参考的工作<ul><li>wasm直接生成opcode</li><li>不能直接基于字节码</li></ul></li><li>实验对象 EVM兼容1.0 2.0代表性的区块链</li><li>构造攻击：可能导致分叉，双花和拒绝服务</li><li>不需要权限的合约，mutation的base，种类，合约的 ERC20/720/DEFI，合约的占比，全部都爬下来sample，全节点</li><li>mutation based testing</li><li>+状态：先做standalone，优先级</li></ul></li><li>反馈是操作码序列和gas</li><li>基于源码的工作太弱了，学术界认可度不高</li></ul></li></ul><h1 id="CVE"><a href="#CVE" class="headerlink" title="CVE"></a>CVE</h1><p>回头看一下论文的CVE，实际上都没有得到开发者的确认，质量堪忧</p><ul><li><p><a href="https://github.com/ethereum/py-evm/issues/1448">https://github.com/ethereum/py-evm/issues/1448</a></p></li><li><p><a href="https://github.com/ethereumjs/ethereumjs-monorepo/issues/386">https://github.com/ethereumjs/ethereumjs-monorepo/issues/386</a></p></li><li><a href="https://github.com/ethereum/go-ethereum/issues/18069">https://github.com/ethereum/go-ethereum/issues/18069</a> <a href="https://github.com/ethereumjs/ethereumjs-monorepo/issues/395">https://github.com/ethereumjs/ethereumjs-monorepo/issues/395</a><ul><li><img src="/2023/09/19/EVMFuzzer/image-20231204145531439.png" alt="image-20231204145531439"></li></ul></li></ul><p>在CNVD发现同一个issue拿了两个CNVD编号</p><p><a href="https://www.cnvd.org.cn/flaw/show/CNVD-2020-34744">https://www.cnvd.org.cn/flaw/show/CNVD-2020-34744</a></p><p><a href="https://www.cnvd.org.cn/flaw/show/CNVD-2018-24156，带CVE">https://www.cnvd.org.cn/flaw/show/CNVD-2018-24156，带CVE</a></p><p>blocksec挖的两个cve</p><p><a href="https://nvd.nist.gov/vuln/detail/CVE-2020-26241">https://nvd.nist.gov/vuln/detail/CVE-2020-26241</a></p><h1 id="TO-DO"><a href="#TO-DO" class="headerlink" title="TO DO"></a>TO DO</h1><ul><li>[ ] 工具实现<ul><li>[ ] 重构模块<ul><li>[x] 保留pyevm jsevm geth，去掉aleth和own vm</li><li>[ ] 测试网中部署/运行合约，实现geth和jsevm完整的带链上状态和交易的实验<ul><li>[ ] 难度比较大，思考为了测试操作码的话是否有必要</li></ul></li><li>[ ] 合约的函数参数生成<ul><li>[ ] 遗留数组未解决</li></ul></li></ul></li></ul></li><li>[ ] 收集数据集<ul><li>[x] .sol数据集<ul><li>[x] 目前爬了4000个etherscan中的合约</li></ul></li><li>[ ] bin runtime数据集：也爬etherscan</li><li>[ ] 总结github issue的pattern</li></ul></li><li>[ ] 基于操作码进行变异<ul><li>[ ] 学习NeoDiff的设计</li><li>[ ] 总结对合约进行fuzz的工具</li></ul></li><li>[ ] 不一致性复现<ul><li>[x] 发现了jsevm不revert的例子，等待与开发者确认</li><li>[x] 手动检查1203simplify</li><li>[x] 询问王老师如何判断合约不一致性可能导致的问题，手工分析</li><li>[x] check Government<ul><li>[x] 向开发者提issue</li></ul></li><li>[ ] 分析4000个合约运行后revert的原因，如何避免<ul><li>[x] 咨询杰峰同志，去读gas meter</li></ul></li><li>[ ] static call操作码消耗值的计算</li><li>[x] jsevm和py geth 消耗的gas不一样的问题<ul><li>[x] 已发送issue</li></ul></li></ul></li><li>[ ] 功能修复<ul><li>[x] result.json中的txdata永远是函数签名+全0：cmp.js中的yargs模块误用</li><li>[x] geth不支持solc —evm-version shanghai，使用prestate参数解决</li><li>[x] 解决了caller默认为全0导致与状态变量判断相等的问题</li><li>[x] 解决了solc 0.8.x 版本会编译出Error signatures和 Evnet signatures的问题</li><li>[x] solc可能无法编译出过大合约的问题，考虑默认开启optimizer？<ul><li>[x] 解决大合约循环的问题，编译错误即continue</li></ul></li><li>[ ] 如何修复msg.sender不一致导致的问题？<ul><li>[ ] 目前三个脚本的msg.sender不一样,py 0000000000000000000000003fd0886fd8dc3c8cd9999a0d17a1fe074d01e0a6, js 0000000000000000000000001c7cd2d37ffd63856a5bd56a9af1643f2bcf545f, geth 000000000000000000000000000000000000000000000000000073656e646572，满足py &gt; js &gt; geth，三个虚拟机中存储owner全为0</li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;EVMFuzzer-Detect-EVM-Vulnerabilities-via-Fuzz-Testing&quot;&gt;&lt;a href=&quot;#EVMFuzzer-Detect-EVM-Vulnerabilities-via-Fuzz-Testing&quot; class=&quot;headerlink&quot; title=&quot;EVMFuzzer: Detect EVM Vulnerabilities via Fuzz Testing&quot;&gt;&lt;/a&gt;EVMFuzzer: Detect EVM Vulnerabilities via Fuzz Testing&lt;/h1&gt;&lt;p&gt;Fu Y, Ren M, Ma F, et al. Evmfuzzer: detect evm vulnerabilities via fuzz testing[C]//Proceedings of the 2019 27th ACM joint meeting on european software engineering conference and symposium on the foundations of software engineering. 2019: 1110-1114.&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/categories/Blockchain/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="SmartContract" scheme="https://alleysira.github.io/tags/SmartContract/"/>
    
  </entry>
  
  <entry>
    <title>trusted_computing</title>
    <link href="https://alleysira.github.io/2023/09/17/trusted-computing/"/>
    <id>https://alleysira.github.io/2023/09/17/trusted-computing/</id>
    <published>2023-09-17T11:04:12.000Z</published>
    <updated>2023-12-28T11:49:20.433Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>写写作业，记记笔记（maybe</p><span id="more"></span><h1 id="Reflections-on-Trusting-Trust——KEN-THOMPSON"><a href="#Reflections-on-Trusting-Trust——KEN-THOMPSON" class="headerlink" title="Reflections on Trusting Trust——KEN THOMPSON"></a>Reflections on Trusting Trust——KEN THOMPSON</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><p>吹水部分提到了Dennis Ritchie（C语言之父），他俩有一次写了个20行 <em>逐字符</em> 相同的汇编程序（磕到了）</p><p>程序员这个职业是Ken写在个人收入申报表上的职业，因此他介绍了他写过的最好玩的一个程序</p><ul><li>Stage1：写出最短的编译运行后能够生成自己源码的程序</li><li>Stage2：learning program的思路是教会编译器如何处理给定的字符</li><li>Stage3：当编译器匹配到某个pattern时，编译出bug</li></ul><p>以上步骤组合起来，修改编译器编译出bin、安装为库后，再恢复为正常的编译器，由于程序是可复制的，后续所有采用该库编译的代码都会有bug而无迹可寻</p><p>作者给出了很有哲理的结论：You can’t trust code that you did not totally create yourself. 不要信任非自己亲手写的代码（反思自己平常用的github上star不多的代码和gpt生成的代码）</p><p>最后呼吁了媒体严肃对黑客这一群体的认识，媒体对他们的报告是“神童”，一种偏褒义的评价。然而实际上侵入计算机系统的后果最轻是故意破坏公物，最坏是非法侵入和盗窃等罪名，还是很严肃的。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>真的无迹可寻吗？如果反编译可执行文件，发现执行逻辑和源码不同，就会意识到程序有bug，寻找bug的源头可能会去检查编译器的版本，发现编译器没问题可能就会去查看依赖库（当然比较难找了）</p><h1 id="Recognizing-Safety-and-Liveness——Bowen-Alpern"><a href="#Recognizing-Safety-and-Liveness——Bowen-Alpern" class="headerlink" title="Recognizing Safety and Liveness——Bowen Alpern"></a>Recognizing Safety and Liveness——Bowen Alpern</h1><h2 id="主要内容-1"><a href="#主要内容-1" class="headerlink" title="主要内容"></a>主要内容</h2><p>安全性和活性的通俗理解：</p><ul><li>安全性：坏事儿不会发生，证明满足性质是不变性论证</li><li>活性：好事儿最终会发生（类比区块链的活性，诚实用户的交易在一定时间后一定会出现在诚实节点的账本中），证明满足性质是良基论证</li></ul><p>本篇论文的主要工作包括：</p><ul><li>通过测试来判断一个Büchi有限状态自动机描述的性质是否满足活性和安全性<ul><li>证明了对于确定性Büchi有限状态自动机的性质，可以用不变性论证来证明；</li><li>活性可以通过良基论证来证明</li></ul></li><li>给出了活性和安全性的形式化定义</li><li>给出了将性质分解为活性和安全性的方法，其中活性和安全性的合取就是原始属性</li></ul><p>Büchi有限状态自动机接受两类输入</p><ul><li><p>所有第一个状态满足谓词 $\neg Pre$的无限序列</p></li><li><p>满足$Pre\  \neg Done \ Done\wedge Post$的无限序列</p><p><img src="/2023/09/17/trusted-computing/image-20231228155506277.png" alt="image-20231228155506277"></p></li></ul><p>如果对每个状态存在能到接收状态的路径，称Büchi有限状态自动机是可缩减的</p><p>对于安全性的定义的理解是对于性质$P$，如果在无限序列$\sigma$中坏事发生了，一定在有限前缀后，能够符合$P$；如果$\sigma$不符合$P$，说明存在$\sigma$的某个前缀包括坏事，对于该前缀的任何扩展，都不会满足$P$。</p><script type="math/tex; mode=display">\text { Safety: }\left(\forall \sigma: \sigma \in S^\omega: \sigma \models P \Leftrightarrow\left(\forall i: 0 \leq i:\left(\exists \beta: \beta \in S^\omega: \sigma[. . i] \beta=P\right)\right)\right)</script><p>对于活性的定义，需要观察到的是，没有任何部分执行是不可挽回的，因为如果某个部分执行是不可挽回的，那么它就是一个坏事。作者认为这是活性的定义特征。如果属性$P$满足以下条件，则$P$是一个活性属性</p><script type="math/tex; mode=display">\text { Liveness: }\left(\forall \alpha: \alpha \in S^*:\left(\exists \beta: \beta \in S^\omega: \alpha \beta \vDash P\right)\right)</script><h2 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h2><p>这篇论文采用有限状态自动机来形式化地描述和验证性质，我很好奇是否存在其他的模型能够被用来形式化这些性质，以及在具体的应用场景中，比如区块链上，是否可以通过设计一个静态分析或形式化验证的工具，定义一些性质来检测区块链共识的漏洞。</p><h1 id="Fairness-Through-Awareness——Cynthia-Dwork"><a href="#Fairness-Through-Awareness——Cynthia-Dwork" class="headerlink" title="Fairness Through Awareness——Cynthia Dwork"></a>Fairness Through Awareness——Cynthia Dwork</h1><h2 id="主要内容-2"><a href="#主要内容-2" class="headerlink" title="主要内容"></a>主要内容</h2><p>本文研究的是分类中的公平性，主要贡献在于是提出了一个公平分类的框架</p><ul><li>用于确定个体在当前分类任务中相似程度的（假设性的）任务特定度量</li><li>在公平约束条件下最大化效用的算法，即对待相似的个体应类似对待</li></ul><p>本文还讨论了公平性与隐私的关系，公平性何时暗示隐私，以及在差分隐私背景下开发的工具如何应用于公平性问题。提供了一个公平分类的规范方法和一个实现公平性的框架。</p><h2 id="思考-2"><a href="#思考-2" class="headerlink" title="思考"></a>思考</h2><p>本文主要的idea是实现相似的人在分类中被类似地对待，讨论部分提出的在广告领域中的公平性是否会隐藏广告商的信息的问题非常有趣，从相反的视角来考虑提升公平性可能带来对隐私的破坏。（隐隐看来本文的工作非常契合西方对”政治正确”的偏好）</p><h1 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h1><p>BLP模型中的安全等级可以更改</p><ul><li>谁可以更改：安全服务的使用者</li><li>什么时候可以更改：$\text{收益}\leq\text{成本}$ 时不会更改</li><li>如何判断是否应该改？本质是上一个问题，需要量化当前的收益，cybersecurity inssurance</li></ul><p>存在Covert Channel</p><p>完整性指信息的真实性 可靠性</p><p>可用性：信息匹配服务</p><h2 id="安全策略的执行和验证"><a href="#安全策略的执行和验证" class="headerlink" title="安全策略的执行和验证"></a>安全策略的执行和验证</h2><p>可扩展系统的的安全性</p><ul><li>插件</li><li>应用</li><li>服务器跑脚本</li></ul><p>可用方法</p><ul><li>类型检查</li><li>静态验证</li><li>代码重构（目前国产软件的层次）</li><li>运行时强制执行（重点介绍）</li></ul><p>前两个方法需要代码审计者的程序设计水平更高</p><p>利用执行监视器强制实施安全策略，只能获得程序原子操作一次执行的结果，例子</p><ul><li>文件系统访问控制</li><li>防火墙</li><li>堆栈检查</li><li>动态边界检查</li><li>恶意软件检测器</li><li>Chrome SP</li></ul><p>审计监视策略的缺点：滞后性，只有发生事件之后才能观察到</p><h2 id="引用监视器"><a href="#引用监视器" class="headerlink" title="引用监视器"></a>引用监视器</h2><p>机制完整性：假设输入符号对应实际执行，真实的状态转换对应于自动机的转换函数，建模可以覆盖100%的程序</p><p>解决策略</p><ul><li>隔离：目标程序无法写自动机的内部表示</li><li>complete mediation：一个变量在研究中完全传递或完全解释了两个其他变量之间的关系</li></ul><p>如何证明程序S满足策略集合P：</p><p>当S违反任意策略时终止，否则继续运行</p><p>需要保证实施方案符合隔离、complete mediations</p><p>重写器：输入机器语言程序，输出嵌入了安全策略的程序</p><h2 id="trusted-machine-learning"><a href="#trusted-machine-learning" class="headerlink" title="trusted machine learning"></a>trusted machine learning</h2><p>目前的LLM可分为预训练模型（基模型）+特定任务模型</p><p>大模型的参数增长速度远远大于摩尔定律算力的增长，无法采用静态分析类似的思想进行大模型的安全性分析，后续的工作都是抽查的思想</p><p>训练数据本身存在误差</p><p>如果训练数据没有误差是否会正确</p><p>消除幻觉</p><p>一致性</p><p>对齐：和人类社会的规则、价值观保持一致</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;写写作业，记记笔记（maybe&lt;/p&gt;</summary>
    
    
    
    
    <category term="Coursework" scheme="https://alleysira.github.io/tags/Coursework/"/>
    
    <category term="Trsted Computing" scheme="https://alleysira.github.io/tags/Trsted-Computing/"/>
    
  </entry>
  
</feed>
