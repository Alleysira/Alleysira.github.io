<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Alleysira&#39;s blog</title>
  
  
  <link href="https://alleysira.github.io/atom.xml" rel="self"/>
  
  <link href="https://alleysira.github.io/"/>
  <updated>2023-10-12T13:47:37.220Z</updated>
  <id>https://alleysira.github.io/</id>
  
  <author>
    <name>Alleysira</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>EVM_security</title>
    <link href="https://alleysira.github.io/2023/10/12/EVM-security/"/>
    <id>https://alleysira.github.io/2023/10/12/EVM-security/</id>
    <published>2023-10-12T13:46:08.000Z</published>
    <updated>2023-10-12T13:47:37.220Z</updated>
    
    <content type="html"><![CDATA[<p>调研区块链虚拟机安全</p><span id="more"></span><h1 id="EVM的不同实现"><a href="#EVM的不同实现" class="headerlink" title="EVM的不同实现"></a>EVM的不同实现</h1><ul><li>EVM官方实现：<a href="https://ethereum.org/en/developers/docs/evm/">Ethereum Virtual Machine (EVM) | ethereum.org</a><ul><li><a href="https://github.com/ethereum/py-evm">Py-EVM</a> - <em>Python</em></li><li><a href="https://github.com/ethereum/evmone">evmone</a> - <em>C++</em></li><li><a href="https://github.com/ethereumjs/ethereumjs-vm">ethereumjs-vm</a> - <em>JavaScript</em></li><li><a href="https://github.com/microsoft/eevm">eEVM</a> - <em>C++</em>，微软开发</li></ul></li><li><a href="(https://github.com/rust-blockchain/evm">SputnikVM</a>)：- <em>rust</em></li><li><a href="https://github.com/ethereum/pyethereum">pyethereum</a>：- <em>py</em>，2023.3已被弃用</li></ul><h1 id="其他VM"><a href="#其他VM" class="headerlink" title="其他VM"></a>其他VM</h1><ul><li><a href="https://github.com/neo-project/neo-vm">NEO VM</a>：采用C#实现，Neo链目前的市值排行66，NEO支持多种常用的编程语言，如C#、Java和Python等编写智能合约</li><li><a href="https://github.com/EOSIO/eos-vm">EOSIO, EOS-VM</a>：C++实现，目前的市值排行57，采用WebAssembly（WASM）作为底层引擎，通过即时编译技术将智能合约字节码转换为本地机器码；同样支持多种编程语言，包括C++、Rust、Python等编写智能合约</li><li><a href="https://github.com/solana-labs/solana">Solana Virtual Machine</a>：Solana链（市值第7）上的虚拟机，rust实现.<ul><li>智能合约语言可以是Rust, C, and C++，翻译成BPF字节码执行；支持交易并行</li><li><a href="https://github.com/neonlabsorg/neon-evm">Neon</a>用于solana和EVM对齐</li></ul></li><li><a href="https://github.com/diem/diem">MoveVM</a>：Facebook旗下的区块链项目Diem（ Libra ）采用的虚拟机，rust实现</li><li><a href="https://github.com/input-output-hk/cardano-node">Cardano</a>：token ADA，目前市值排行8，采用Haskell语言实现，以<a href="https://github.com/runtimeverification/evm-semantics">KEVM</a>,EVM的形式化验证版本为基础<ul><li>其中Milkomeda C1是Cardano对应的EVM侧链</li></ul></li><li><a href="https://gitlab.com/tezos/tezos">Tezos</a>：目前的市值排行52，项目采用的语言是OCaml，合约采用的编程语言是Archetype, LIGO, 和SmartPy，翻译为底层语言<a href="https://opentezos.com/michelson/">Michelson</a>后在VM上执行<ul><li>虚拟机的设计未详细介绍，参考资料<a href="https://forklog.com/sp/dev-on-tezos/en/tezos-introduction/#:~:text=Tezos&#39;s VM works with byte,with fast access to data">What Smart Contracts are and How They Work</a></li><li>github镜像：<a href="https://github.com/tezos/tezos-mirror">tezos/tezos-mirror: Github test mirror of the Octez software. Please do not submit pull-requests here!</a></li></ul></li></ul><h1 id="以太坊客户端"><a href="#以太坊客户端" class="headerlink" title="以太坊客户端"></a>以太坊客户端</h1><p>根据以太坊主网的<a href="https://www.ethernodes.org/">统计数据</a>显示，geth是使用最广泛的客户端</p><p><img src="/2023/10/12/EVM-security/image-20231012160435832.png" alt="image-20231012160435832"></p><ul><li><a href="https://github.com/ethereum/go-ethereum">Geth</a>：占比50.0%，采用go语言实现，最常用的客户端<ul><li>支持Mainnet, Sepolia, Goerli</li></ul></li><li><a href="https://github.com/NethermindEth/nethermind">Nethermind</a>：占比29.3%，采用c#实现<ul><li>支持Mainnet, Sepolia, Goerli, and more</li></ul></li><li><a href="https://github.com/ledgerwatch/erigon">Erigon</a>：占比11.12%，采用go语言实现<ul><li>Mainnet, Sepolia, Goerli, and more</li></ul></li><li><a href="https://github.com/hyperledger/besu">besu</a>：占比9%，Java实现，Hyperledger 项目的一部分，是一个企业级以太坊客户端<ul><li>Mainnet, Sepolia, Goerli, and more</li></ul></li><li><a href="https://github.com/paradigmxyz/reth">reth</a>：占比0.5%，Rust实现<ul><li>Mainnet, Sepolia, Goerli, and more</li></ul></li><li><a href="https://github.com/openethereum/openethereum">Openethereum</a>：采用Rust实现，曾经仅次于geth， Nov 7, 2020 已被弃用</li></ul><p>以太坊项目对以上客户端会进行单元测试，测试代码的仓库 <a href="https://github.com/ethereum/tests">ethereum/tests: Common tests for all Ethereum implementations (github.com)</a></p><h1 id="EVM兼容的区块链"><a href="#EVM兼容的区块链" class="headerlink" title="EVM兼容的区块链"></a>EVM兼容的区块链</h1><p>所有兼容EVM的区块链可见 <a href="https://www.coincarp.com/zh/chainlist/">EVM公链列表CoinCarp</a></p><ul><li><a href="https://www.bnbchain.world/en">Binance Smart Chain</a>：token BNB，市值排行第4，由币安交易所推出<ul><li>客户端<a href="https://github.com/bnb-chain/bsc">bsc</a>基于geth fork开发，EVM类似于geth</li></ul></li><li><a href="https://fantom.foundation/">Fantom</a>：token FTM，市值排行63<ul><li>客户端opera采用go实现，利用了EVM的实现<a href="https://github.com/Fantom-foundation/go-opera">go-opera</a></li></ul></li><li><a href="https://polygon.technology/">Polygon</a>：token MATIC，市值排行13<ul><li>虚拟机是zkEVM，声称与EVM等价 <a href="https://polygon.technology/polygon-zkevm">Polygon zkEVM | Scaling for the Ethereum Virtual Machine</a></li></ul></li><li><a href="https://www.avax.network/">Avalanche</a>：token AVAX，市值排行22</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>可能的研究方向<ul><li>虚拟机：目前学术论文的研究对象主要是EVM的官方实现（geth/aleth/js-evm/openethereum）和EVM兼容的链（FISCO-BCOS-evm），逐渐开始有向其他公有链项目采用的VM进行延伸（Neo）的工作。后续工作可以考虑对其他EVM实现（如SputnikVM）进行差分模糊测试和对其他知名公有链的虚拟机（EOS-VM/Solana/Cardano）</li><li>客户端：现有的对以太坊客户端的测试主要以Geth为主。但是从以太坊官方的统计数据来看，除了Geth之外，Nethermind、Eriqon、besu同样占有较大的比例，对以上客户端内的EVM实现进行差分模糊测试也是具有一定研究意义的</li></ul></li></ul><h1 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h1><ul><li>6年前其他人总结的EVM相关的资料：<a href="https://github.com/pirapira/awesome-ethereum-virtual-machine">pirapira/awesome-ethereum-virtual-machine: Ethereum Virtual Machine Awesome List (github.com)</a></li><li>wasm对应的VM：<a href="https://github.com/appcypher/awesome-wasm-runtimes">appcypher/awesome-wasm-runtimes: A list of webassemby runtimes (github.com)</a></li><li>Move语言相关资料：<a href="https://github.com/MystenLabs/awesome-move#move-powered-blockchains">MystenLabs/awesome-move: Code and content from the Move community. (github.com)</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;调研区块链虚拟机安全&lt;/p&gt;</summary>
    
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>BlockScope</title>
    <link href="https://alleysira.github.io/2023/09/26/BlockScope/"/>
    <id>https://alleysira.github.io/2023/09/26/BlockScope/</id>
    <published>2023-09-26T10:17:51.000Z</published>
    <updated>2023-10-10T12:17:17.401Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BlockScope-Detecting-and-Investigating-Propagated-Vulnerabilities-in-Forked-Blockchain-Projects"><a href="#BlockScope-Detecting-and-Investigating-Propagated-Vulnerabilities-in-Forked-Blockchain-Projects" class="headerlink" title="BlockScope: Detecting and Investigating Propagated Vulnerabilities in Forked Blockchain Projects"></a>BlockScope: Detecting and Investigating Propagated Vulnerabilities in Forked Blockchain Projects</h1><p>Yi X, Fang Y, Wu D, et al. BlockScope: Detecting and Investigating Propagated Vulnerabilities in Forked Blockchain Projects[C].Network and Distributed System Security (NDSS) Symposium 2023<br>27 February - 3 March 2023, San Diego, CA, USA.</p><span id="more"></span><p>NDSS23的<a href="https://www.ndss-symposium.org/ndss-paper/blockscope-detecting-and-investigating-propagated-vulnerabilities-in-forked-blockchain-projects/">工作</a></p><p>许多区块链重用或者fork了比特币/以太坊等经典区块链的代码，不难理解，当fork或频繁fetch时可能将原来链上存在的漏洞传播到当前链上。本文设计了BlockScope，能够在输入现有的BC/Ethereum安全补丁后，检测出多个cloned漏洞</p><p>BlockScope采用基于相似度的代码匹配机制，设计了一种新的计算代码相似度的方法来覆盖所有syntax-wide变量的克隆</p><p>BlockScope能够自动抽取补丁的上下文，找到潜在的相关代码进行对比</p><p>和现有工作ReDebug相比，能在精度接近的情况下实现1.8倍的recall（确定更多可能执行的路径或者函数调用）</p><p>分别在13/16个forked区块链上发现了101个漏洞</p><ul><li>40个被接受或修复</li><li>66被知情，等待中</li><li>4个被拒绝</li></ul><p>总结出了3类从源到分叉的链的漏洞传播规律</p><p>仅开源了具体的漏洞报告 <a href="https://github.com/VPRLab/BlkVulnReport">VPRLab/BlkVulnReport: A Summary of Vulnerabilities Found in the BlockScope NDSS’23 Paper (github.com)</a>，没有源代码</p><h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>因为开源，所以可以fork或重用eth和Bitcoin的代码</p><p>漏洞传播可能的途径</p><ul><li>最初分叉</li><li>update commits</li></ul><p>创新点</p><ul><li>相似度检查而不是精确的hash对比，相似度计算方法改进，更好处理增删和重排序<ul><li>更接近Soundness：大幅降低假阴率，略微提高假阳率</li></ul></li><li>抽取并利用补丁代码的语境定位可能相关的代码段<ul><li>提高执行效率和精度</li></ul></li></ul><p>数据集采用了38个补丁</p><ul><li>32个是比特币的代码仓库中来的（CVE只有4个</li><li>6个Ethereum的CVE</li></ul><p>分别测试了11+6个fork链的C/Go的代码，准确率和recall率为91.8%</p><p>发现漏洞后试图总结传播规律</p><ul><li>最初fork时传播</li><li>fetch时传播</li><li>被非显式的commit感染</li></ul><p>大多数分叉链修补的时间延迟约为200天 </p><p>提供的具体漏洞CVE和PR：<a href="https://github.com/VPRLab/BlkVulnReport">VPRLab/BlkVulnReport: A Summary of Vulnerabilities Found in the BlockScope NDSS’23 Paper (github.com)</a></p><p>wu老师的主页总结了学术界和工业界安全相关会议的ddl <a href="https://daoyuan14.github.io/">Daoyuan Wu’s HomePage (daoyuan14.github.io)</a></p><h1 id="design-choices-and-system-overview"><a href="#design-choices-and-system-overview" class="headerlink" title="design choices and system overview"></a>design choices and system overview</h1><ul><li>基于补丁的代码检测</li><li>不针对特定编程语言，不采用类似程序分析的抽象</li><li>创新点<ul><li>利用补丁代码上下文，仅定位相关的代码（不用分析全程序，精度更高）</li><li>采用基于代码相似度的代码匹配机制，支持3类代码克隆</li></ul></li></ul><h1 id="问题与思考"><a href="#问题与思考" class="headerlink" title="问题与思考"></a>问题与思考</h1><ul><li>什么是similariry based code match</li><li>recall：分析结果中确定可达分支的能力</li><li>extract之前需要normalizing and tokenizing</li></ul><p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;BlockScope-Detecting-and-Investigating-Propagated-Vulnerabilities-in-Forked-Blockchain-Projects&quot;&gt;&lt;a href=&quot;#BlockScope-Detecting-and-Investigating-Propagated-Vulnerabilities-in-Forked-Blockchain-Projects&quot; class=&quot;headerlink&quot; title=&quot;BlockScope: Detecting and Investigating Propagated Vulnerabilities in Forked Blockchain Projects&quot;&gt;&lt;/a&gt;BlockScope: Detecting and Investigating Propagated Vulnerabilities in Forked Blockchain Projects&lt;/h1&gt;&lt;p&gt;Yi X, Fang Y, Wu D, et al. BlockScope: Detecting and Investigating Propagated Vulnerabilities in Forked Blockchain Projects[C].Network and Distributed System Security (NDSS) Symposium 2023&lt;br&gt;27 February - 3 March 2023, San Diego, CA, USA.&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/categories/Blockchain/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="SmartContract" scheme="https://alleysira.github.io/tags/SmartContract/"/>
    
  </entry>
  
  <entry>
    <title>NeoDiff</title>
    <link href="https://alleysira.github.io/2023/09/25/NeoDiff/"/>
    <id>https://alleysira.github.io/2023/09/25/NeoDiff/</id>
    <published>2023-09-25T07:55:11.000Z</published>
    <updated>2023-10-10T12:16:49.288Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Uncovering-Smart-Contract-VM-Bugs-Via-Differential-Fuzzing"><a href="#Uncovering-Smart-Contract-VM-Bugs-Via-Differential-Fuzzing" class="headerlink" title="Uncovering Smart Contract VM Bugs Via Differential Fuzzing"></a>Uncovering Smart Contract VM Bugs Via Differential Fuzzing</h1><p>Maier D, Fäßler F, Seifert J P. Uncovering Smart Contract VM Bugs Via Differential Fuzzing[C]//Reversing and Offensive-oriented Trends Symposium. 2021: 11-22.</p><span id="more"></span><p>基于覆盖和状态对智能合约虚拟机的行为进行模糊测试，提出了NeoDiff——第一个反馈导向的智能合约虚拟机的模糊测试框架</p><ul><li><p>除了对EVM进行模糊测试，NeoDiff发现了若干Neo区块链上的重要漏洞</p></li><li><p>通过高层的语义变异器，发现了Python编写的Neo智能合约和传统CPython编写的合约的不一致</p></li><li>发现了C#的Neo虚拟机中的内存损坏问题</li></ul><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>智能合约虚拟机类似于传统安全研究范畴内的操作系统，执行合约的虚拟机定义了如何进行交互的接口，没有文件系统、套接字和线程，而是直接访问区块链，因此出现了新的安全问题</p><p>智能合约虚拟机需要保证执行结果的一致性</p><p>2500行代码实现了NeoDiff</p><p>反馈部分不仅考虑了覆盖率，还考虑了虚拟机传回的状态传播</p><p>尽管对以太坊的两个虚拟机的测试仅返回了假阳的结果（可能是因为严格的手工测试），额外发现了很多其他生态系统中的漏洞，如Neo</p><p>Neo是一个被研究较少的区块链，2021年日均交易量达1.5亿美元。项目地址：<a href="https://neo.org/">Neo 智能经济</a></p><p><a href="https://www.investopedia.com/tech/china-neo-cryptocurrency/">NEO (NEO) Definition (investopedia.com)</a></p><p><img src="/2023/09/25/NeoDiff/image-20230925160606443.png" alt="image-20230925160606443"></p><p>在Neo上NeoDiff发现了VM的不一致性、主链上的内存损坏，因为Neo提高了利用python等传统编程语言写智能合约的选项，因此可以利用python的语义进行模糊测试</p><p>和传统模糊测试不同的是，差分模糊测试想要实现的是输出或状态的不一致，NeoDiff支持对不同编程语言实现的系统进行模糊测试（neo-python VM 客户端和Neo VM C# 共识节点)，</p><p>发现了CPython and neo-boa Python和智能合约上的语义差别</p><p>贡献如下：</p><ul><li><p>开发并开源了NeoDiff，对智能合约虚拟机定制的模糊测试工具</p><ul><li><a href="https://github.com/fgsect/NeoDiff">fgsect/NeoDiff: Differential fuzzing for Smart Contract VMs (github.com)</a></li></ul></li><li><p>实现了NeoDiff的后端，来模糊测试openethereum against the geth Ethereum VM和<br>Neo VM against neo-python.</p></li><li>测试了CPython和Python实现的合约的语义，发现了语义的差距和对应的安全后果</li><li>讨论了如何利用智能合约虚拟机中的不一致性进行攻击（如攻击区块链网络上的应用</li><li>NeoDiff帮助发现并修复了Neo智能合约生态系统中的重要bug</li></ul><h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><p>2020年FC有一篇讨论NEo的BFT方案的论文，Neo采用PoS，参与共识的节点数量较少；目前支持8种编程语言编写可约（Python, Go, JavaScript, Java and C#  /C C++ to be done)；Neo的编译器调用对应语言的官方编译器，将IR转换成AVM 码，即虚拟机的字节码。</p><p>参与共识的节点运行C#编写的Neo VM构成区块链网络的核心部分，为了调用区块链，用户需要使用客户端程序，提供了SDK供开发者在NEO区块链上编写应用程序和合约交互；SDK需要能够理解所有交易并本地执行合约</p><ul><li><p>资产：Neo区块链原生的资产是代币Neo和部署、执行合约需要的GAS；NeoGas随时间生成并根据拥有的Neo成比例地分配给钱包；每个节点本地 都能执行字节码形式的合约，消耗的gas和opcode以及syscall相关联。共识算法是基于PBFT的DelegatedBFT</p></li><li><p>虚拟机：负责执行上传的合约，每个参与者都必须有VM来执行合约，和传统的VM不同，Neo VM不提供硬件和文件系统访问，直接和区块链的数据交互。本地执行合约允许客户端从合约存储中直接读取数据，而不用通过缓慢的API进行查或相信中心化的节点</p></li><li><p>C#虚拟机：执行引擎是核心部分，包括函数和调用栈。执行合约时创建一个对应的上下文。上下文中包括代码和两个栈每个合约在隔离的上下文中执行，合约可以使用两个栈</p><ul><li>altstack：临时数据存储</li><li>执行栈：存储结果</li><li>每次调用生成新的调用栈</li><li><p>架构如图<img src="/2023/09/25/NeoDiff/image-20230925171307210.png" alt="image-20230925171307210"></p></li><li><p>持久存储：大多数数据（例如区块链的交易和合约的永久KV存储）均可以通过syscall操作码访问；区块链本身仅存储交易，包括了调用合约的交易；为了得到当前存储的状态，所有交易都必须被重放（重新执行），存储可能存了认证消息或代币的余额。可以给予另一个合约访问存储的对象的权利</p><ul><li>实现中的漏洞或不恰当的授权可能导致存储相关的问题，如delagatecall<ul><li>Johannes Krupp and Christian Rossow. 2018. teether: Gnawing at Ethereum to<br>Automatically Exploit Smart Contracts. Proceedings of the 27th USENIX Security<br>Symposium (2018), 1317–1333.</li></ul></li></ul></li></ul></li></ul><h1 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work"></a>Related work</h1><p>在智能合约概念出现之前，差分模糊测试被用于测试编译器和代码库</p><ul><li>CSmith：自动生成C程序，寻找不同编译器和优化层级带来的程序行为的差异 2011</li><li>Diffuzz：通过差分模糊测试进行侧信道分析</li><li>NEZHA：对二进制代码库进行差分模糊测试，除了代码覆盖率之外，采用了多种反馈</li><li>HyDiff：和NEZHA类似，关注覆盖率的同时，额外利用了静态分析和符号执行，采用了一系列的启发式推理改善对变异输出的</li><li>EVMFuzzer：生成合约并提供给以太坊虚拟机发现不一致性，在solidity层面对合约进行变异</li></ul><p>提到了EVMFuzzer，世界线收束</p><h1 id="NEODIFF"><a href="#NEODIFF" class="headerlink" title="NEODIFF"></a>NEODIFF</h1><p>对同一个虚拟机的多个可选实现进行差分模糊测试</p><p><img src="/2023/09/25/NeoDiff/image-20230925185409445.png" alt="image-20230925185409445"></p><h2 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h2><p>反馈导向，可以采用不同量级的反馈机制来对不同编程语言实现的VM进行测试</p><p>和EVMFuzz相比，NeoDiff更底层，生成有效的操作码序列而不是修改AST再转化为合约，会枚举所有可能的操作码序列，然而solidity编译器可能不会生成无意义的操作码（假设VM之前很少接受这种高级语言不会生成的序列的测试）</p><ul><li>Diff generator：采用基于反馈的变异器生成VM执行的字节码<ul><li>拼接、添加高覆盖率的片段、随机翻转字节，能够生成高级编程语言无法生成的操作码序列</li></ul></li><li>mutator：可以针对特定目标定制不同变异器；默认NeoDiff循环采用下列的变异器，直到达到最小的合约长度；由于可能生成全新的合约，不容易陷入局部最优解；会将成功执行的字节码序列保留下来；方便定义其他特定链的变异器<ul><li>随机1字节</li><li>全拼接：添加<del>部分</del>第二个随机合约的代码，倾向于能够覆盖新分支的测试用例</li><li>部分拼接：添加部分第二个随机合约的代码，倾向于能够覆盖新分支的测试用例<ul><li><img src="/2023/09/25/NeoDiff/image-20230925193912440.png" alt="image-20230925193912440"></li></ul></li><li>字节插入：一个字节插入到当前合约的随机位置</li><li>特殊操作：特殊的字节码，比如ETH的PUSHBYTES</li></ul></li><li>Diff Analyzer：需要修改EVM的实现来生成trace，trace的内容包括执行的操作码的列表，对应的类型hash $\tau$和状态hash $\sigma$，分析器通过比较$\sigma$来发现不同，通过$\tau$判断是否到达了新的状态<ul><li>假设当中间的$\sigma$不同时，认为出现了分叉</li><li>出现不一致时，导致问题产生的操作码和对应的$\tau$存储在结果中</li><li>分叉之前正确的操作码和对应的$\tau$会前向传播到minimizer</li><li>minimizer试图寻找到能导致特定$\tau$的最短字节序列并且存储到$\tau$ map中去<ul><li>$\tau$ map随着模糊测试的进行不断增长，后续可以用于变异的反馈</li></ul></li><li><img src="/2023/09/25/NeoDiff/image-20230925200033512.png" alt="image-20230925200033512"></li></ul></li></ul><h2 id="state-hash"><a href="#state-hash" class="headerlink" title="state-hash"></a>state-hash</h2><p>为了标识不同的执行，利用了状态哈希$\sigma$，取当前执行中的状态的子集，由研究者定义对于diff重要的信息，将该信息包括在哈希中</p><ul><li>对于基于栈的虚拟机而言，包括对栈的概率性采样；</li><li>如果有寄存器应该包括寄存器的值</li><li>如果有额外的内存，需要考虑内存</li></ul><p>执行速度和精度之前需要进行trade-off，可能的话对每个操作码都更新$\sigma$，利用它来检测不一致性</p><h2 id="Type-Hash"><a href="#Type-Hash" class="headerlink" title="Type-Hash"></a>Type-Hash</h2><p>思路：利用type-hash来作为一种轻量级的覆盖率的表示</p><p>也包含了状态信息，但是没有和之前的状态连接起来，仅标识当前操作码的状态</p><p>由于Neo VM支持多种类型（整数、字节数组等），以太坊仅支持256比特的整数作为类型，设立了虚类型方便执行</p><p>NeoDiff支持在传统的代码覆盖率下进行测试，如果采用了类型哈希，可以用来对差异进行排序和分类</p><p>类型哈希 $\tau $ 利用栈顶的2个类型，前缀为当前的操作码，执行加法命令，栈顶元素是整型1和字节数组2，对应的类型哈希 𝜏 为ADD_12</p><p>问题：类型哈希变化一定意味着覆盖率的变化吗？实验结果：86%的情况下，发现新的类型哈希 𝜏 同样标识到达了新的代码覆盖率。结果表明类型哈希能够表示所有的覆盖率变化，NeoDiff同样支持采用实际的覆盖率作为类型哈希</p><p><img src="/2023/09/25/NeoDiff/image-20231006192746686.png" alt="image-20231006192746686"></p><h2 id="Minimization"><a href="#Minimization" class="headerlink" title="Minimization"></a>Minimization</h2><p>利用测试用例再次执行VM，对于每个字节检查是否包含了之前的 𝜏 ，一旦发现了所有的类型哈希，认为当前长度是最短的</p><p>根据操作码导致的类型哈希来进行分类</p><h1 id="Eval"><a href="#Eval" class="headerlink" title="Eval"></a>Eval</h1><p>工具已经开源，后续有空测试一下</p><p><a href="https://github.com/fgsect/NeoDiff">fgsect/NeoDiff: Differential fuzzing for Smart Contract VMs (github.com)</a></p><ul><li>C# VM and neo-python VM<ul><li>测试了4个变异策略<ul><li>random：字节全随机</li><li>mut1p：将特定值压入栈，利用覆盖率反馈的概率较低</li><li>mut20p：基于反馈的变异，概率是20倍</li><li>coverage：默认变异策略，初始是随机的</li><li><img src="/2023/09/25/NeoDiff/image-20230928082042644.png" alt="image-20230928082042644"></li><li>然而当运行深度增加，随机策略丧失了多样性</li></ul></li></ul></li><li>geth vs. openethereum<ul><li>发现了6个不同，均是配置信息，未能在现有的区块链上复现</li><li><img src="/2023/09/25/NeoDiff/image-20230928084441953.png" alt="image-20230928084441953"></li></ul></li><li>cpy vs. Neo py：额外设计了py的语义变异器，不基于状态，能够产生有效的python脚本能够作为Neo智能合约运行<ul><li><img src="/2023/09/25/NeoDiff/image-20231006200937631.png" alt="image-20231006200937631"></li></ul></li></ul><h1 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h1><h2 id="合约虚拟机差异的安全影响"><a href="#合约虚拟机差异的安全影响" class="headerlink" title="合约虚拟机差异的安全影响"></a>合约虚拟机差异的安全影响</h2><ul><li>链上差异：可能导致算力分叉，大多数算力采用的实现将成为主流，可能导致链分叉</li><li>区块链应用差异：钱包和Dapp本地执行结果和主网不一致，导致出现本地分叉</li><li>合约语义差异：python写的合约和solidity写的合约行为不一致，恶意的开发者可能设计后门</li></ul><h2 id="对Neo-VM差异的PoC"><a href="#对Neo-VM差异的PoC" class="headerlink" title="对Neo VM差异的PoC"></a>对Neo VM差异的PoC</h2><p>给了比较详细的PoC和脚本</p><h2 id="Ethereum-VM-Differences"><a href="#Ethereum-VM-Differences" class="headerlink" title="Ethereum VM Differences"></a>Ethereum VM Differences</h2><p><img src="/2023/09/25/NeoDiff/image-20231006202931015.png" alt="image-20231006202931015"></p><p>表明进行差分模糊测试时应该在空白的链上，采用相同的初始设置</p><p>或者手动删除这些假阳性</p><h2 id="语言语义的差异"><a href="#语言语义的差异" class="headerlink" title="语言语义的差异"></a>语言语义的差异</h2><ul><li>语义差异：<ul><li>编译时报错：neo-boa不支持range()和float</li></ul></li><li>字符串连接：<ul><li>+：neo-python编译成VMOP.ADD，整数加法<ul><li>‘xxx’+’!!!’=’xxx!!!’, not ‘yyy’</li></ul></li></ul></li><li>字符串乘法<ul><li>’x’<em>21 和 ’x’</em>20</li></ul></li><li>潜在的漏洞：Neo VM会进行类型转换，之前的安全机制如给key加前缀可能不再安全<ul><li><img src="/2023/09/25/NeoDiff/image-20231006204246703.png" alt="image-20231006204246703"></li></ul></li></ul><h2 id="Neo-VM的差异和漏洞"><a href="#Neo-VM的差异和漏洞" class="headerlink" title="Neo VM的差异和漏洞"></a>Neo VM的差异和漏洞</h2><ul><li>类型转换</li><li>执行引擎的差异</li><li>数学操作的不一致</li><li>VM崩溃</li></ul><h1 id="问题和思考"><a href="#问题和思考" class="headerlink" title="问题和思考"></a>问题和思考</h1><ul><li>变异策略生成的合约操作码能够执行的比例占多少</li><li>为什么说Ethereum VM没有类型</li><li>和EVMfuzzer相比，对于不一致性的对比更加细致（不再仅思考输出的不一致性，还考虑了中间过程）</li><li>状态哈希需要研究者手动定义对于diff来说哪些信息重要</li><li>minimization认为最短的序列不一定是最短；代码可能有跳转</li><li>python语义的对比：为什么是和python2 和 3对比，而不是直接比较</li></ul><p>本文定义的变异策略显示coverage已经足够好了</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Uncovering-Smart-Contract-VM-Bugs-Via-Differential-Fuzzing&quot;&gt;&lt;a href=&quot;#Uncovering-Smart-Contract-VM-Bugs-Via-Differential-Fuzzing&quot; class=&quot;headerlink&quot; title=&quot;Uncovering Smart Contract VM Bugs Via Differential Fuzzing&quot;&gt;&lt;/a&gt;Uncovering Smart Contract VM Bugs Via Differential Fuzzing&lt;/h1&gt;&lt;p&gt;Maier D, Fäßler F, Seifert J P. Uncovering Smart Contract VM Bugs Via Differential Fuzzing[C]//Reversing and Offensive-oriented Trends Symposium. 2021: 11-22.&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/categories/Blockchain/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="SmartContract" scheme="https://alleysira.github.io/tags/SmartContract/"/>
    
  </entry>
  
  <entry>
    <title>EVMFuzzer</title>
    <link href="https://alleysira.github.io/2023/09/19/EVMFuzzer/"/>
    <id>https://alleysira.github.io/2023/09/19/EVMFuzzer/</id>
    <published>2023-09-19T08:09:27.000Z</published>
    <updated>2023-10-10T12:53:28.834Z</updated>
    
    <content type="html"><![CDATA[<h1 id="EVMFuzzer-Detect-EVM-Vulnerabilities-via-Fuzz-Testing"><a href="#EVMFuzzer-Detect-EVM-Vulnerabilities-via-Fuzz-Testing" class="headerlink" title="EVMFuzzer: Detect EVM Vulnerabilities via Fuzz Testing"></a>EVMFuzzer: Detect EVM Vulnerabilities via Fuzz Testing</h1><p>Fu Y, Ren M, Ma F, et al. Evmfuzzer: detect evm vulnerabilities via fuzz testing[C]//Proceedings of the 2019 27th ACM joint meeting on european software engineering conference and symposium on the foundations of software engineering. 2019: 1110-1114.</p><span id="more"></span><p><a href="https://www.youtube.com/watch?v=9Lejgf2GSOk&amp;ab_channel=EVMFuzzer">EVMFuzzer: Detect EVM Vulnerabilities via Fuzz Testing - YouTube</a></p><p>对以太坊合约进行测试的挑战在于测试输入数据的格式以及预言机的存在，EVMFuzzer是第一个采用差分模糊测试技巧检查以太坊漏洞的工具。本文的核心思想是不断生成种子合约并输入给目标EVM和其他测试标准EVM，通过发现尽可能多的执行结果的不一致性，最终发现带有输出交叉引用的漏洞</p><p>给定目标EVM和对应的API，EVMFuzzer通过预定义的mutators生成新的种子合约，采用动态优先级调度算法来指导种子合约选择过程，最大化不一致性。最终EVMFuzzer将其他测试标准EVM作为交叉应用的预言机来避免手动检查</p><p>实验结果：将36295个真实世界的合约作为种子，生成了253153个合约，其中66.3的合约表现出了不同的性能。在4个EVM上发现了若干先前未知的漏洞，其中5个已经作为CVE记录在NVD了</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Oyente和MAIAN采用符号执行来发现智能合约的漏洞，如果EVM本身存在漏洞，会导致严重的后果</p><p>选择了10个通过了Oyente的合约在EVM上执行，发现了其中7个的gas消耗不一样</p><p>合约层面的验证无法保证以太坊交易执行的正确性，需要保证EVM执行的正确性</p><p>对EVM的测试面临着以下的挑战</p><ul><li>如何定义一般场景测试标准<ul><li>EVM有超过10种不同编程语言的实现</li></ul></li><li>如何生成能够引发bug的测试样例<ul><li>目前没有对EVM进行系统测试的工具</li></ul></li></ul><p>贡献</p><ul><li>给出一种对EVM进行差分模糊测试的评价标准，定义了8个变异器（种子合约生成），设计了动态优先级调度算法</li><li>实现了EVMFuzz，能够自动进行差分模糊测试</li><li>测试了目前广泛使用的EVM，发现了5个CVE</li></ul><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>例子</p><p><img src="/2023/09/19/EVMFuzzer/image-20230920151552188.png" alt="image-20230920151552188"></p><p>这个合约能够通过若干合约测试和验证工具，在不同EVM实现中结果不同，甚至可能会导致dos</p><p>分别在js-evm,py-evm,aleth上进行测试</p><p>aleth会打印执行路径然后一直占有CPU资源，指导系统kill所有进程然后宕机</p><p>aleth不会给出用户有好的反馈或者及时止损或者减少恶意占用的资源，最终导致dos</p><p>这个例子表示一些包含边界条件的合约可能触发EVM实现的边界条件，但是这种合约比较难以构造，因此可以采用差分模糊测试</p><h2 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work"></a>Related work</h2><ul><li>Fuzzing：采用边界数据作为输入来保证程序没有bug<ul><li>主流工具AFL类的，采用多种策略加速fuzzing</li></ul></li><li>Differential Testing：针对预期功能相同的不同实现进行测试，发现不同<ul><li>DLFuzz对深度学习框架进行差分模糊测试</li></ul></li><li>智能合约验证：Oyente从字节码构造控制流图再进行符号执行；Zeus是一个sound的分析器，将智能合约翻译到LLVM中</li></ul><p>EVMFuzzer面向的目标是EVM，其他工作主要关注智能合约</p><h2 id="Approach-Overview"><a href="#Approach-Overview" class="headerlink" title="Approach Overview"></a>Approach Overview</h2><p>Differential fuzz testing is to continuously provide invalid, unexpected or random data as inputs to several programs with the same functions.</p><p>如果发现运行结果不同，可能发现了bug</p><p>种子合约生成模块基于 静态分析</p><p>统一合约执行基于 循环模糊测试</p><p><img src="/2023/09/19/EVMFuzzer/image-20230920154124925.png" alt="image-20230920154124925"></p><h2 id="EVMFuzzer-design"><a href="#EVMFuzzer-design" class="headerlink" title="EVMFuzzer design"></a>EVMFuzzer design</h2><p>主要包含 种子合约生成模块和EVM执行模块，种子合约生成模块会不断生成高质量的种子，力图扩大不同EVM执行结果之间的区别。EVM执行模块会为目标EVM和其他测试标准EVM创建统一的执行环境</p><p><img src="/2023/09/19/EVMFuzzer/image-20230919164625085.png" alt="image-20230919164625085"></p><h3 id="种子合约生成"><a href="#种子合约生成" class="headerlink" title="种子合约生成"></a>种子合约生成</h3><p>输入合约，输出关键性质改变后的合约</p><ul><li>构造种子合约的重要位置标识的CAST抽象语法树，辅助后续的变异和分析</li><li>将seed合约放入池中</li><li>EVMFuzz对合约进行评估，排列为带有优先队列，对优先级进行动态调整</li><li>选择排在第一的合约，利用8个（arxiv）预定义的变异器和组合策略来指导变异并获得EVM的输入</li></ul><p>测试用例生成器</p><p>seed合约存储在seed pool中，EVMFuzzer根据动态优先级对候选合约进行排序，首位的合约会被选中进行变异，采用8个预定的编译器和组合策略进行变异</p><ul><li>种子变异：从3个细粒度（word char statement）设计了8个编译器，维护基于度量差异的优先级队列；如果度量差异增加，对应的变异器的权重按降序排列加入到队列中，否则不会更新队列</li><li>种子优先级和选择：为了保证多样性，其他优先级低的合约同样需要有一定的概率被选中，因此采用动态优先级调度算法维护一个候选队列，每个合约有初始的权限，随着等待时间增加</li></ul><h3 id="指标的公式"><a href="#指标的公式" class="headerlink" title="指标的公式"></a>指标的公式</h3><p>EVM作为基于交易的状态机，状态的改变基于操作码和输入的参数以及gas限制</p><ul><li>操作码序列：表示了程序的执行过程，能用于检查执行的正确性 $opSeqLen(i,C)$，i表示平台，执行合约C</li><li>消耗的gas：一个交易或一条消息中消耗的gas总量，直接和交易的执行费相关联，$gsdUsed(i,C)$</li></ul><p>根据两个指标，定义了差异信息的评估指标dif f，值越大表示产生不一致执行结果的概率越大 $output(i,C)$表示执行输出，对于函数调用是返回值；对于交易是balance</p><p>两个指标反应了实现和执行的差距，执行输出反应了EVM运行的正确性和一致性</p><h3 id="CAST的构造"><a href="#CAST的构造" class="headerlink" title="CAST的构造"></a>CAST的构造</h3><p>模糊测试之前，首先执行静态分析，生成CAST</p><p>智能合约的CAST是对Solidity源代码的抽象语法结构的结构化树形表示，树上的每个节点表示源码中出现的结构，CAST定义并分解了所有语句中的性质，分解成CAST方便进行变异，能够根据关键属性直接进行搜索、替代、删除或者插入操作符</p><p>CAST将种子合约的关键位置表示出来（和ehter交易相关的子树），主要包含6个语句符号 new, call , delegatecall , callcode, send and transfer</p><p>变异器主要作用于这些关键位置来测试EVM的核心功能，阴影部分就是重要的位置</p><p><img src="/2023/09/19/EVMFuzzer/image-20230920164427662.png" alt="image-20230920164427662"></p><h3 id="种子合约优先级"><a href="#种子合约优先级" class="headerlink" title="种子合约优先级"></a>种子合约优先级</h3><p>候选合约的重要性不同，使得合约之间指标差异增加的合约应当作为下一轮变异迭代的标准</p><p>同时，为了保证多样性，其他合约应该有一定概率被选中。因此采用动态优先级分配算法来维护一个候选队列，每个合约有初始的优先级，随着等待时间增加，值会增加</p><p><img src="/2023/09/19/EVMFuzzer/image-20230920170033059.png" alt="image-20230920170033059"></p><p>看看伪代码，指标差异优先级初始值为0-10，优先级等于=差异加上时间优先级，根据优先级进行降序排序</p><p>选中优先级最高的作为下一轮变异的合约，输出，对剩余合约的time_pri 加1</p><h3 id="种子合约的变异"><a href="#种子合约的变异" class="headerlink" title="种子合约的变异"></a>种子合约的变异</h3><p>为了生成高质量的种子合约，能够在不同的EVM中触发更多的不一致性</p><p>根据伪代码，首先生成CAST，根据上次迭代的差异信息更新每个变异器（做排序）</p><p><img src="/2023/09/19/EVMFuzzer/image-20230920171115727.png" alt="image-20230920171115727"></p><p>选择组合策略（输入）来变异候选种子合约，最后利用 <a href="https://www.npmjs.com/package/soltar">soltar - npm (npmjs.com)</a> 从CAST中重建代码，输出变异后的代码</p><ul><li>典型的变异器：需要保证被修改合约的语义正确性保证能够正确生成代码，根据合约的逻辑设计了8个变异器<ul><li><img src="/2023/09/19/EVMFuzzer/image-20230920182840510.png" alt="image-20230920182840510"><ul><li>对于方法内的本地变量，修改变量的类型</li><li>对于函数修改对应的属性</li><li>修改算术运算符</li><li>修改条件判断语句内的运算符</li><li>修改循环内的边界条件</li><li>对函数内的语句增加assert或者删去assert</li><li>删除函数的return</li><li>对于方法的控制流增加break或者continue</li></ul></li></ul></li><li>变异器选择：同样给这些变异器优先级，根据返回的dif进行调整权重，如果变异后差异变大，将变异器的id加入到队列中，降序排列<ul><li>除了权重更新外，还定义了组合策略，来增加随机性和多样性<ul><li>组合索引为奇数的变异器</li><li>组合索引为偶数的变异器</li><li>组合第一个和最后一个变异器</li><li>不带权重随机选一个变异器</li><li>每轮在上面的策略中随机选一个</li></ul></li></ul></li></ul><h3 id="统一的EVM执行"><a href="#统一的EVM执行" class="headerlink" title="统一的EVM执行"></a>统一的EVM执行</h3><p>为多个EVM提供统一的运行时环境，收到种子合约后编译为字节码，参数根据被调用函数的参数类型生成</p><ul><li><p>solc −bin −runtime xx.sol</p></li><li><p>对于每个数据类型，预先定义了一些常见的或者极端值，生成时随机选取</p></li></ul><p>之后调用每个EVM的执行接口自动在所有EVM上执行，将输出结果标准化后，根据测试指标计算差异信息，比较执行输出结果。</p><p>根据种子提高指标差异的程度，决定是否将种子放入seed pool中（保存了高质量的合约），该模块会记录潜在的异常，为了后续进行手工的问题根源分析</p><h3 id="种子合约选择"><a href="#种子合约选择" class="headerlink" title="种子合约选择"></a>种子合约选择</h3><p>dif的意义是为了评估生成的种子合约的质量，定义如下</p><p><img src="/2023/09/19/EVMFuzzer/image-20230920194726395.png" alt="image-20230920194726395"></p><p>看看伪代码</p><p>diff最大值为10，值进行标准化，时间优先级置0，更新flag</p><p><img src="/2023/09/19/EVMFuzzer/image-20230920200434697.png" alt="image-20230920200434697"></p><h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><p>回答的问题</p><ul><li>EVM之间是否存在不一致性<ul><li>gas消耗的不一致性<ul><li><img src="/2023/09/19/EVMFuzzer/image-20230920202213767.png" alt="image-20230920202213767"></li><li>原因：以太坊黄皮书未定义某些特定opcode的gas消耗，如MSOTRE,SLOAD等；采用的退款机制不同</li><li>将gas消耗的平均值作为基准，js-evm 好</li><li><img src="/2023/09/19/EVMFuzzer/image-20230920202945965.png" alt="image-20230920202945965"></li></ul></li><li>opcode的不一致性：仅1,275合约能同时在4个EVM上运行并返回相同结果，字节码长度不同<ul><li>原因可能是EVM进行了优化</li><li><img src="/2023/09/19/EVMFuzzer/image-20230920203426230.png" alt="image-20230920203426230"></li><li>结果可以看到aleth和geth保持一致，js-evm更小（某种程度上减轻了EVM的开销，但是这种开销减少的代价可能是丧失了鲁棒性）</li><li><img src="/2023/09/19/EVMFuzzer/image-20230920204613634.png" alt="image-20230920204613634"></li></ul></li></ul></li><li>EVMFuzz是否能高效地生成高质量的种子合约<ul><li>狠狠跑了3天，生成了25 3153份不同的合约，66.2%的合约成功出发了不一致性（因为包含了gas不一致，水分比较大）Ind.1是除此之外都crash，Ind.2是除此之外都不crash</li><li><img src="/2023/09/19/EVMFuzzer/image-20230920204015260.png" alt="image-20230920204015260"></li><li>为了说明变异器的质量，找了个复杂的合约进行了测试，记录每轮的weight变化</li><li>单独使用一种变异器的速度，evencomb最快但没跳出局部最优解，总体上comball效果最好，完全随机效果最差<ul><li><img src="/2023/09/19/EVMFuzzer/image-20230920204702036.png" alt="image-20230920204702036"></li></ul></li><li>详细分析CombAll来研究不同变异器的权重和作用，0.125作为基准</li><li><img src="/2023/09/19/EVMFuzzer/image-20230920204957741.png" alt="image-20230920204957741"></li><li><img src="/2023/09/19/EVMFuzzer/image-20230920205443157.png" alt="image-20230920205443157"></li></ul></li><li>是否能通过EVMFuzz发现EVM的漏洞<ul><li>需要手工分析，发现了5个CVE（现有的CVE中与EVM相关的有6个，智能合约的500个，总数为112913）</li><li><img src="/2023/09/19/EVMFuzzer/image-20230920205747171.png" alt="image-20230920205747171"></li></ul></li></ul><p>合约部署在以太坊上，分析了合约的行数，函数，相关的操作码和特定的操作码，其中超过6500份合约有超过500行代码，90个超过2000行，表明目标合约比较复杂</p><h2 id="Using-EVMFuzzer"><a href="#Using-EVMFuzzer" class="headerlink" title="Using EVMFuzzer"></a>Using EVMFuzzer</h2><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><img src="/2023/09/19/EVMFuzzer/image-20230919172850242.png" alt="image-20230919172850242"></p><p>后端集成了4个广泛使用的EVM作为基准</p><ul><li>ethereumjs-vm v2.4.0</li><li>py-evm v0.2.0-alpha.31</li><li>aleth v1.5.0-aplha.6</li><li>geth v1.8.13</li></ul><p>合约compiler solc 0.4.24版本</p><h3 id="运行的例子"><a href="#运行的例子" class="headerlink" title="运行的例子"></a>运行的例子</h3><p>用户提供EVM的源码/可执行文件和API，论文中的target EVM是加强版的js-EVM（之前她的B会的工作）</p><p>报告从3个维度来评价这个EVM</p><ul><li>代码实现完整性</li><li>gas计算的准确性</li><li>执行路径规划的合理性</li></ul><p><img src="/2023/09/19/EVMFuzzer/image-20230919174027003.png" alt="image-20230919174027003"></p><h2 id="Preliminary-Evaluation"><a href="#Preliminary-Evaluation" class="headerlink" title="Preliminary Evaluation"></a>Preliminary Evaluation</h2><p>初始的seed合约是36295个，实验在笔记本上跑的</p><p>根据2类内部测试指标（消耗的gas和操作码序列），发现了大量的不一致</p><p>33,424/36,295合约的操作码序列是正确的，用于进行gas的对比（排除了不同操作码带来的gas差异）</p><p>每个平台约50%的gas消耗都和其他平台不一样，aleth甚至达到90%</p><p><img src="/2023/09/19/EVMFuzzer/image-20230919190818271.png" alt="image-20230919190818271"></p><p>1275个合约成功在4个EVM上执行，返回了相同的输出但是序列的长度不同</p><p><img src="/2023/09/19/EVMFuzzer/image-20230919191002754.png" alt="image-20230919191002754"></p><p>aleth和geth的相同，作为baseline，js-evm的长度始终短于baseline，py-evm的长度高于baseline</p><p>可以推断出：EVM的执行和实现存在不一致，可以利用<code>gasUsed</code>和操作码序列指示器的度量差异来引导合约的生成，从而导致潜在的执行输出的不一致</p><p>发现的漏洞：发现了不一致后需要手工进行分析，探索根源，查看了EVM的实现，发现了5个CVE</p><p><img src="/2023/09/19/EVMFuzzer/image-20230919191848784.png" alt="image-20230919191848784"></p><p>其中一个针对geth的CVE，稳定触发 执行时段错误，原因在于异常处理程序没有处理所有边界情况</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>提出了第一个对EVM实现的差分模糊测试的工具，给出了两个度量标准（gas和opcode sequence），在生成的253,153个合约的执行中，超过一半的合约表现出了差异</p><p>未来工作：设计更通用的mutator，对更多EVM的安全性进行评估</p><ul><li>设计更多的变异器：目前仅在AST层面修改关键部分，后续可以在源码层次层架函数调用，合约继承等</li><li>更高效的优先级处理：目前是用堆实现的优先队列，插入删除的复杂度是$\Theta(logn)$，排序的复杂度是$\Theta(nlogn)$，可以有其他的思路，比如搞成系数</li><li>支持更多EVM的实现</li><li>更精确的选择标准：gas和opcode之间可以加系数，gas可能没有那么重要</li></ul><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>尝试配一下</p><p>安装solc-select，配置环境变量，source一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pip3 install solc-select</span><br><span class="line">sudo nano ~/.bashrc</span><br><span class="line">//add this line</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;/home/alleysira/.local/bin:<span class="variable">$PATH</span>&quot;</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line">solc-select install 0.4.24</span><br><span class="line">solc-select use 0.4.24</span><br></pre></td></tr></table></figure><p>配置wsl代理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/resolv.conf</span><br><span class="line">export ALL_PROXY=&quot;http://172.20.80.1:7890&quot;</span><br></pre></td></tr></table></figure><p>安装ethereum</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install software-properties-common</span><br><span class="line">sudo add-apt-repository -y ppa:ethereum/ethereum</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install ethereum #network issue</span><br></pre></td></tr></table></figure><p>补充安装numpy</p><p>pip3 install eth_utils</p><p>补上package.json</p><p>每日一乐</p><p><img src="/2023/09/19/EVMFuzzer/image-20230921200746505.png" alt="image-20230921200746505"></p><p>修改一下node的路径jsevm就可以运行了，修改为/usr/bin/node</p><p><img src="/2023/09/19/EVMFuzzer/image-20230921203024645.png" alt="image-20230921203024645"></p><p><img src="/2023/09/19/EVMFuzzer/image-20230921201837081.png" alt="image-20230921201837081"></p><p>会给出当前轮选择的变异策略，以及采用的变异器</p><p><img src="/2023/09/19/EVMFuzzer/image-20230921202131725.png" alt="image-20230921202131725"></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li>发现了不一致性后，如何解释一致性可能产生的影响——攻击者可以操作合约输出不一致的结果<ul><li>如何寻找bug的来源——手工分析</li></ul></li><li>能不能测试其他的安全组件？consensus</li><li>采用的中间表示形式是AST，换成3AC或者SSA是否具有可行性？<ul><li>后续的opcode不同和gas是否可能是由CAST转换为solidity的过程引入的</li><li>设计变异器时利用了控制流，直观理解是更合适</li><li><img src="/2023/09/19/EVMFuzzer/image-20230920183950597.png" alt="image-20230920183950597"></li></ul></li><li>time_pri仅加1，合理性在于初始值为0-10</li><li>dif的定义应该有问题，需要把abs拆开</li><li>编译器的版本为0.4.24，如果对新的版本的合约进行差分测试，需要进行哪些更改</li><li>考虑操作码一致性时，为什么不考虑结果不同的，也可以说明一定问题？</li><li>给出该论文的后续工作，已解决<ul><li><a href="https://scholar.google.com/scholar?start=0&amp;hl=en&amp;as_sdt=2005&amp;sciodt=0,5&amp;cites=7702365947421966340&amp;scipsc=">Fu: Evmfuzzer: detect evm vulnerabilities via fuzz testing - Google Scholar</a></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;EVMFuzzer-Detect-EVM-Vulnerabilities-via-Fuzz-Testing&quot;&gt;&lt;a href=&quot;#EVMFuzzer-Detect-EVM-Vulnerabilities-via-Fuzz-Testing&quot; class=&quot;headerlink&quot; title=&quot;EVMFuzzer: Detect EVM Vulnerabilities via Fuzz Testing&quot;&gt;&lt;/a&gt;EVMFuzzer: Detect EVM Vulnerabilities via Fuzz Testing&lt;/h1&gt;&lt;p&gt;Fu Y, Ren M, Ma F, et al. Evmfuzzer: detect evm vulnerabilities via fuzz testing[C]//Proceedings of the 2019 27th ACM joint meeting on european software engineering conference and symposium on the foundations of software engineering. 2019: 1110-1114.&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/categories/Blockchain/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="SmartContract" scheme="https://alleysira.github.io/tags/SmartContract/"/>
    
  </entry>
  
  <entry>
    <title>trusted_computing</title>
    <link href="https://alleysira.github.io/2023/09/17/trusted-computing/"/>
    <id>https://alleysira.github.io/2023/09/17/trusted-computing/</id>
    <published>2023-09-17T11:04:12.000Z</published>
    <updated>2023-10-10T12:15:07.084Z</updated>
    
    <content type="html"><![CDATA[<p>写写作业，记记笔记（maybe</p><span id="more"></span><h1 id="Week1-Reflections-on-Trusting-Trust——KEN-THOMPSON"><a href="#Week1-Reflections-on-Trusting-Trust——KEN-THOMPSON" class="headerlink" title="Week1: Reflections on Trusting Trust——KEN THOMPSON"></a>Week1: Reflections on Trusting Trust——KEN THOMPSON</h1><p>吹水部分提到了Dennis Ritchie（C语言之父），他俩有一次写了个20行逐字符相同的汇编程序（磕到了）</p><p>程序员这个职业是Ken写在个人收入申报表上的职业，因此他介绍了他写过的最好玩的一个程序</p><ul><li>Stage1：写出最短的编译运行后能够生成自己源码的程序</li><li>Stage2：learning program的思路是教会编译器如何处理给定的字符</li><li>Stage3：当编译器匹配到某个pattern时，编译出bug</li></ul><p>组合起来，修改编译器编译出bin、安装为库后，再恢复为正常的编译器，由于程序是可复制的，后续所有采用该库编译的代码都会有bug而无迹可寻</p><p>真的无迹可寻吗？如果反编译可执行文件，发现执行逻辑和源码不同，就会意识到程序有bug，寻找bug的源头可能会去检查编译器的版本，发现编译器没问题可能去查看依赖库（比较难找了）</p><p>结论：You can’t trust code that you did not totally create yourself. 不要信任不是自己亲手写的代码（反思自己平常用的github上star不多的代码）</p><p>最后呼吁媒体严肃对黑客这一群体的认识，媒体对他们的报告是“神童” 侵入计算机系统最轻是故意破坏公物，最坏是非法侵入和盗窃</p><h1 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h1><p>BLP模型中的安全等级可以更改</p><ul><li>谁可以更改：安全服务的使用者</li><li>什么时候可以更改：$\text{收益}\leq\text{成本}$ 时不会更改</li><li>如何判断是否应该改？本质是上一个问题，需要量化当前的收益，cybersecurity inssurance</li></ul><p>存在Covert Channel</p><p>完整性指信息的真实性 可靠性</p><p>可用性：信息匹配服务</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;写写作业，记记笔记（maybe&lt;/p&gt;</summary>
    
    
    
    
    <category term="Coursework" scheme="https://alleysira.github.io/tags/Coursework/"/>
    
    <category term="Trsted Computing" scheme="https://alleysira.github.io/tags/Trsted-Computing/"/>
    
  </entry>
  
  <entry>
    <title>program_analysis_NJU</title>
    <link href="https://alleysira.github.io/2023/08/31/program-analysis-NJU/"/>
    <id>https://alleysira.github.io/2023/08/31/program-analysis-NJU/</id>
    <published>2023-08-31T02:27:00.000Z</published>
    <updated>2023-10-11T13:03:47.778Z</updated>
    
    <content type="html"><![CDATA[<p>学习南京大学的静态程序分析技术课程</p><p>课程主页：<a href="https://tai-e.pascal-lab.net/lectures.html">Static Program Analysis | Tai-e (pascal-lab.net)</a></p><p>共计32小时</p><span id="more"></span><h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>PL的三个研究方向</p><ul><li>理论</li><li>环境</li><li>应用<ul><li>程序分析<ul><li>静态程序分析</li></ul></li></ul></li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230831102930623.png" alt="image-20230831102930623"></p><p>静态分析：在编译时对程序进行检测</p><p>静态程序分析的应用</p><ul><li>程序可靠性</li><li>安全性</li><li>编译优化<ul><li>O(1)</li></ul></li><li>程序理解<ul><li>IDE实现的call的提示：利用静态分析实现</li></ul></li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230831103339266.png" alt="image-20230831103339266"></p><p>运行程序前了解程序的性质和行为（写一个程序来分析，分析器）</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230831104435688.png" alt="image-20230831104435688"></p><ul><li>运行时可能指向同一地址吗<ul><li>需要加锁解决竞争问题</li></ul></li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230831104701170.png" alt="image-20230831104701170"></p><p>对于一个正常的语言写的程序，我们感兴趣的运行时的性质是否满足 是不可判定的，即不存在完美的静态分析</p><p>perfect static analysis满足</p><ul><li>sound：包含所有truth，过近似</li><li>complete：是truth的子集，欠近似</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230831105420735.png" alt="image-20230831105420735"></p><p>不存在perfect，因此想要一种useful的静态分析，可以仅满足一种性质，妥协另一种性质</p><ul><li>满足soundness：存在误报，false positive</li><li>满足complete：存在漏报，false negative</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230831105711467.png" alt="image-20230831105711467"></p><p>绝大多数的程序分析都是sound，妥协complete</p><p>sound一般对应的是正确性，如下例，考虑到两条分支后才能得出正确的结论</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230831150801393.png" alt="image-20230831150753259"></p><p>可能有两个结论，都是sound的</p><p>平常的思维是动态思维，静态分析无法获得运行时的数据</p><p>第一个结论需要维护path branch和一个条件，比较昂贵；第二个比较cheap，速度快</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230831151433500.png" alt="image-20230831151433500"></p><p>确保（足够接近）soundness的情况下，在精度和分析速度上做平衡</p><p><strong>抽象</strong> <strong>过近似</strong> 是静态分析的核心思想</p><p>过近似包括transfer函数和控制流</p><p>抽象就是把具体值转变为符号</p><p>用bottom符号表示错误</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230831152709196.png" alt="image-20230831152709196"></p><p>transfer functions定义了转换规则，根据分析的具体问题和语句的语义设计</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230831153019783.png" alt="image-20230831153019783"></p><p>3说明静态分析会产生误报</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230831153355882.png" alt="image-20230831153355882"></p><p>控制流：在每个merge的地方进行抽象，可能出现过近似，默认采用的方式</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230831153713197.png" alt="image-20230831153713197"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230831154741536.png" alt="image-20230831154741536"></p><h1 id="Intermediate-Representation"><a href="#Intermediate-Representation" class="headerlink" title="Intermediate Representation"></a>Intermediate Representation</h1><p><a href="https://www.bilibili.com/video/BV1zE411s77Z/?spm_id_from=333.788&amp;vd_source=fbfceeec0a697a64e4aba2132714eb9d">南京大学《软件分析》课程02（Intermediate Representation）_哔哩哔哩_bilibili</a></p><p>直接分析源代码存在弊端</p><p>静态分析需要一种程序表示的形式，没有严格的定义，因此介绍主流的IR</p><p>不介绍对C/C++的LLVM</p><h2 id="编译器和静态分析器"><a href="#编译器和静态分析器" class="headerlink" title="编译器和静态分析器"></a>编译器和静态分析器</h2><p>了解关系即可</p><p>编译的步骤：</p><ul><li><p>词法分析（符号和词的合法性），需要词法方法，正则表达式</p><ul><li>语法分析器parser，上下文无关文法</li></ul></li><li><p>语法分析，对AST进行分析，语义指简单的（类型检查）</p></li><li>代码生成，静态分析器在IR基础上做</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230831163003482.png" alt="image-20230831163003482"></p><p>正常的IR需要所有前端模块才能生成</p><h2 id="AST-vs-IR"><a href="#AST-vs-IR" class="headerlink" title="AST vs. IR"></a>AST vs. IR</h2><p>3地址码3-address code</p><p>IR更接近于机器码，不依赖于编程语言（方舟编译器可以将不同语言生成为统一的IR）</p><p>AST缺乏对控制流的表达</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230831163353046.png" alt="image-20230831163353046"></p><h2 id="IR-3AC"><a href="#IR-3AC" class="headerlink" title="IR: 3AC"></a>IR: 3AC</h2><p>没有形式化的定义</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230831163931505.png" alt="image-20230831163931505"></p><p>指令右端只有1个操作符，每个语句只包含3个地址</p><ul><li>变量名 a,b</li><li>常量 3</li><li>编译器自动生成的临时变量 t1</li></ul><p>常见的形式</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230831164147119.png" alt="image-20230831164147119"></p><h2 id="Soot"><a href="#Soot" class="headerlink" title="Soot"></a>Soot</h2><p>java中最流行的静态分析器</p><p><a href="https://github.com/Sable/soot/wiki/Tutorials">https://github.com/Sable/soot/wiki/Tutorials</a></p><p>对应的IR是 Jimple，带有类型的3地址码</p><p>冒号是一种特殊的赋值</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230831165004862.png" alt="image-20230831165004862"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230831170458580.png" alt="image-20230831170458580"></p><p>JVM中的4种调用</p><ul><li><p>invokespecial: call constructor, call superclass methods, call private methods</p></li><li><p>invokevirtual: instance method call (virtual dispatch)</p></li><li><p>invokeinterface: cannot optimization, checking interface implementation 不能优化</p></li><li><p>invokestatic: call static methods</p></li></ul><p>Java7 invokedynamic -&gt; Jaava static typing, dynamic runs on JVM</p><p>meethod signature: class name, return type, method name, parameter types</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230831170815120.png" alt="image-20230831170815120"></p><p>所有类的父类，java.lang.object</p><p>默认生成的构造函数init</p><p>clinit 类的初始化的函数，compiler加载引用的变量进行初始化 class load init</p><h2 id="SSA"><a href="#SSA" class="headerlink" title="SSA"></a>SSA</h2><p>一种IR，有利于某些算法的设计，80年代提出的技术</p><p>和3AC的区别是每个变量的定义有新的命名，每个变量仅有一个等式</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230901090511569.png" alt="image-20230901090511569"></p><p>如果有控制流，采用$\phi$函数</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230901090643097.png" alt="image-20230901090643097"></p><p>为什么使用SSA</p><ul><li><p>flow-sensitive 维护程序执行顺序，精度更高，SSA本身带有部分flow的信息</p></li><li><p>数据的存储更清晰</p></li></ul><p>为什么不用SSA</p><ul><li>引入变量太多</li><li>译为机器码可能开销太大</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230901091235279.png" alt="image-20230901091235279"></p><p>静态分析一般在CFG上分析，如何给定3AC建立CFG?</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230901091633485.png" alt="image-20230901091633485"></p><h2 id="Basic-Blocks"><a href="#Basic-Blocks" class="headerlink" title="Basic Blocks"></a>Basic Blocks</h2><p>basic blocks是最多的连续的3AC码的集合，满足以下指令：</p><ul><li>只能从第一个指令进入（没有其他控制流</li><li>出口是最后一个指令</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230901091648122.png" alt="image-20230901091648122"></p><ul><li>如果指令是goto的地址，只能作为入口</li><li>goto只能作为出口<ul><li>goto的下一句一定是入口 </li></ul></li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230901093246402.png" alt="image-20230901093246402"></p><p>仅确定入口即可</p><p>BB是CFG的节点，补充边就有了CFG</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230901093928280.png" alt="image-20230901093928280"></p><h2 id="CFG"><a href="#CFG" class="headerlink" title="CFG"></a>CFG</h2><p><img src="/2023/08/31/program-analysis-NJU/image-20230901094252846.png" alt="image-20230901094252846"></p><p>条件jump有2两个出口</p><p>B2是B1的后继，前驱只能有一个，后继可以有多个</p><p>entry也可以有很多</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230901101340886.png" alt="image-20230901101340886"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230901101445829.png" alt="image-20230901101445829"></p><p>IR和AST的区别</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230901101732041.png" alt="image-20230901101732041"></p><p>企业可能认为content-insentive比较慢，学术界关注的是content-sensitive的技术</p><h1 id="Data-Flow-Analysis-Applications"><a href="#Data-Flow-Analysis-Applications" class="headerlink" title="Data Flow Analysis Applications"></a>Data Flow Analysis Applications</h1><p>编译后端优化的技术</p><p>3个应用</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230901142516251.png" alt="image-20230901142516251"></p><h2 id="Overview-of-Data-Flow-Analysis"><a href="#Overview-of-Data-Flow-Analysis" class="headerlink" title="Overview of Data Flow Analysis"></a>Overview of Data Flow Analysis</h2><p>研究数据怎样在CFG中流动</p><p>静态程序分析是过拟合的，输出可能是假阳</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230901143647456.png" alt="image-20230901143647456"></p><p>过拟合和欠拟合都是安全的分析，应该将over改成safe</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230901143914835.png" alt="image-20230901143914835"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230901144138225.png" alt="image-20230901144138225"></p><p>主要介绍不同的数据流分析的应用</p><h2 id="Preliminaries-of-Data-Flow-Analysis"><a href="#Preliminaries-of-Data-Flow-Analysis" class="headerlink" title="Preliminaries of Data Flow Analysis"></a>Preliminaries of Data Flow Analysis</h2><p>形式化方法</p><p>程序执行前后会产生状态变化，与程序点关联</p><p>顺序执行的语句前一条语句的输出和后一条的输入相关，具体还有分支的形式</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230901144554623.png" alt="image-20230901144554623"></p><p>操作符是meet operator，可以是union或者其他运算符</p><p>数据流分析需要对每个程序点的所有可能状态的抽象（data flow value，绿色的）</p><p>domain是value的值域</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230901145243994.png" alt="image-20230901145243994"></p><p>数据流分析是为了找到对输入输出状态的约束的解，有两类</p><ul><li>基于状态的语义（转移函数）<ul><li>前向分析</li><li>反向分析（可能会对逆向的CFG进行前向分析）</li><li><img src="/2023/08/31/program-analysis-NJU/image-20230901150349427.png" alt="image-20230901150349427"></li></ul></li><li>基于控制流的约束<ul><li>Basic Blocks里面的<ul><li>$IN[s_{i+1}]=OUT[s_i],\text{for all }i\in\{1,\dots,n-1\}$</li></ul></li><li>BB之间的<ul><li>复合函数</li><li><img src="/2023/08/31/program-analysis-NJU/image-20230901150752423.png" alt="image-20230901150752423"></li><li><img src="/2023/08/31/program-analysis-NJU/image-20230901150828752.png" alt="image-20230901150828752"></li><li>红色的是反向的</li></ul></li></ul></li></ul><h2 id="Reaching-Definitions-Analysis"><a href="#Reaching-Definitions-Analysis" class="headerlink" title="Reaching Definitions Analysis"></a>Reaching Definitions Analysis</h2><p>不涉及函数调用，讨论的是方法内的CFG</p><p>变量是别名的形式（指针分析，别名分析，指向分析）</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230901152313029.png" alt="image-20230901152313029"></p><p>reaching definition</p><ul><li>存在一条路径能到达</li><li>不能被二次赋值</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230901152523679.png" alt="image-20230901152523679"></p><p>编译优化会用到，也可以用来分析undefined variable</p><p>是一种may-Analysis，过拟合</p><p>100个定义用100个definition来定义</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230901154814673.png" alt="image-20230901154814673"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230901155156563.png" alt="image-20230901155156563"></p><p>给出了转移函数的定义</p><p>因为无法确定BB之间的前驱关系，所有定义了当前BB内的定义的语句都需要被kill掉</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230901155520326.png" alt="image-20230901155520326"></p><p>对于control flow进行分析，定义</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230901155548910.png" alt="image-20230901155548910"></p><p>入口的output为空，entry没有定义 （may analyse一般为空，must analyse一般考虑为undefined）</p><p>除了entry的BB的output都为空（程序都没运行）</p><p>当任何OUT改变的话</p><p>会停机吗？</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230901161421363.png" alt="image-20230901161421363"></p><p>B3的Input=10110000</p><p>B3的Output=00000010 union (10110000 - 10001000) = 00000010 union 00110000 = 00110010</p><p>上一轮的BB的out都是空，全变了，再循环一轮</p><p>B2的out= 10111100    </p><p>B3的out= 00110110 </p><p><img src="/2023/08/31/program-analysis-NJU/image-20230901171055532.png" alt="image-20230901171055532"></p><p>根据转移函数的定义，当输入不变时输出不变</p><p>如何证明算法的收敛</p><p>$OUT[S]=gen_s\cup (IN[S] -kill_s)$</p><ul><li>$gen_s \text{和}kill_s$不变</li><li>more facts加入后，只会让多+1而不会多kill，单调递增的感觉</li><li>facts是有限的</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230901171929909.png" alt="image-20230901171929909"></p><p>为什么每个out不再变化就说明停机了？</p><p>Out不变，In不变，Out不变</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230901172108100.png" alt="image-20230901172108100"></p><p>算法到达了不动点，和单调性相关</p><h2 id="Live-Variables-Analysis"><a href="#Live-Variables-Analysis" class="headerlink" title="Live Variables Analysis"></a>Live Variables Analysis</h2><p>数据流分析的应用，归结为在格上求解不动点的问题</p><p>一般分析算法求出的是最大不动点和最小不动点</p><p>定义：某处变量的值是否能够在后面可以使用（用之前是live，不能被重定义）</p><p>live变量的信息可以用于寄存器分配，当寄存器满了的时候</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230904094328736.png" alt="image-20230904094328736"></p><p>定义中指出是some path，因此是一种may analysis，定义的直观含义是某点的变量是否会被后续用到</p><p>变量和定义的区别在哪里？</p><p>都用bit vector表示</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230904100041064.png" alt="image-20230904100041064"></p><p>采用backward的方法进行分析</p><p>In[B]= use_B union (Out[B] - redine[B])</p><p>通过具体情况枚举分析</p><p>use在define之前</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230904155628294.png" alt="image-20230904155628294"></p><p>更正：此处的$OUT[B]=\cup_S IN[s]$</p><p>给定的out求in，边界条件为in=空</p><p>一般情况下may analyse的初始化是空，must analyse是all，和reaching definition定义很像</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230904160245948.png" alt="image-20230904160245948"></p><p>0001000 </p><p>B4有两个后继，out[b4]=in[b2] union in[b5] = 0001000 union 0000000 = 0001000</p><p>in[b4]= 0100000 union (0001000 - 1000000) = 0101000</p><p>B2的Input是 100 1001，因为m是在define后用的</p><p>B1的输入0011101</p><p>第二轮 </p><p>0101001 </p><p><img src="/2023/08/31/program-analysis-NJU/image-20230904160646443.png" alt="image-20230904160646443"></p><p>计算INPUT的顺序不同会影响迭代的次数</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230904162203684.png" alt="image-20230904162203684"></p><h2 id="Available-Expressions-Analysis"><a href="#Available-Expressions-Analysis" class="headerlink" title="Available Expressions Analysis"></a>Available Expressions Analysis</h2><p>一种must analysis，为了实现对程序的优化而不是解决安全问题</p><p>从程序入口到p的所有路径必须经过表达式 $x\  op\  y$，并且表达式最后的求值之后，$x$和$y$不能被重定义</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230904162801564.png" alt="image-20230904162801564"></p><p>类似于表达式简化的思想，p点之后对该表达式可以进行替代</p><p>首先给出抽象</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230904162854755.png" alt="image-20230904162854755"></p><p>是一种前向分析</p><p>out = gen union (input - kill)</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230904165840491.png" alt="image-20230904165840491"></p><p>两个分支后是available的</p><p>因为所有pass都必须available，输入是前驱输出的交集</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230904165925795.png" alt="image-20230904165925795"></p><p>优化而不是找bug，不能误报</p><p>初始化为全1（因为要交）</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230904172544309.png" alt="image-20230904172544309"></p><p>out[B1]=10000</p><p>out[B2]=01010 union (10000 - 10000)=01010</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230904172906013.png" alt="image-20230904172906013"></p><p>B4 input=11111, Output= 00110 union (01010-00010) =01110</p><p>先算kill再算gen，根据定义</p><p>01010 union (00010 - 00111)=01010</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230904185613558.png" alt="image-20230904185613558"></p><p>三类定义的对比</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230904190155676.png" alt="image-20230904190155676"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230904191638058.png" alt="image-20230904191638058"></p><h1 id="Data-Flow-Analysis-Foundation"><a href="#Data-Flow-Analysis-Foundation" class="headerlink" title="Data Flow Analysis Foundation"></a>Data Flow Analysis Foundation</h1><p><img src="/2023/08/31/program-analysis-NJU/image-20230904192251591.png" alt="image-20230904192251591"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230904192304012.png" alt="image-20230904192304012"></p><p>上节课3个应用的算法均是迭代式算法，回答存在的问题</p><p>从23的基础上定义格</p><p>复习核心内容是8</p><h2 id="Iterative-Algorithm-Another-View"><a href="#Iterative-Algorithm-Another-View" class="headerlink" title="Iterative Algorithm, Another View"></a>Iterative Algorithm, Another View</h2><p>给定CFG，有k个statement，迭代算法每次更新节点的OUT[n]</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230904194220880.png" alt="image-20230904194220880"></p><p>进行形式化</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230904194710101.png" alt="image-20230904194710101"></p><p>实际上是不动点</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230904194725702.png" alt="image-20230904194725702"></p><ul><li>迭代式算法一定能终止并给出一个解吗？</li><li>假设能达到不动点，只有一个不动点吗？如果有若干个不动点，迭代式算法得到的不动点足够精确吗？</li><li>迭代式算法到达不动点或得到解需要多长时间？（复杂度）</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230904195054862.png" alt="image-20230904195054862"></p><h2 id="Partial-Order"><a href="#Partial-Order" class="headerlink" title="Partial Order"></a>Partial Order</h2><p>参考 <a href="https://zhuanlan.zhihu.com/p/365442689">偏序与等价关系 - 知乎 (zhihu.com)</a></p><p>偏序集的定义$P,\subseteq$，带有偏序关系的集合，并满足以下关系</p><ul><li>自反性</li><li>反对称性 </li><li>传递性</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230905100158884.png" alt="image-20230905100158884"></p><p>整数集上的小于关系不是偏序关系</p><p>子串是偏序关系</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230905100307750.png" alt="image-20230905100307750"></p><p>偏序集的含义是不是所有的元素互相之间必须满足偏序关系，如pin和sin没有偏序关系，但是{pin,sin,sing,gin}和singing构成偏序集</p><p>幂集</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230905100734386.png" alt="image-20230905100734386"></p><h2 id="Upper-and-Lower-Bounds"><a href="#Upper-and-Lower-Bounds" class="headerlink" title="Upper and Lower Bounds"></a>Upper and Lower Bounds</h2><p><img src="/2023/08/31/program-analysis-NJU/image-20230905101107238.png" alt="image-20230905101107238"></p><p>最小上界lub和最大下界glb</p><p>bound可以不在S当中，在P中即可</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230905101527501.png" alt="image-20230905101527501"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230905101943246.png" alt="image-20230905101943246"></p><p>偏序集的glb和lub是唯一的</p><p>证明：反证法，反对称性</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230905102005722.png" alt="image-20230905102005722"></p><h2 id="Lattice-Semilattice-Complete-and-Product-Lattice"><a href="#Lattice-Semilattice-Complete-and-Product-Lattice" class="headerlink" title="Lattice, Semilattice, Complete and Product Lattice"></a>Lattice, Semilattice, Complete and Product Lattice</h2><p>在程序分析中学格（</p><p>每两个元素存在glb和lub的偏序集称为格</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230905102436174.png" alt="image-20230905102436174"></p><p>半格：任意两个元素只存在glb或者lub</p><ul><li>只存在glb，称为meet半格</li><li>只存在lub，称为join半格</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230905102707115.png" alt="image-20230905102707115"></p><p>全格</p><p>格的任意一个子集，均存在glb和lub</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230905110741805.png" alt="image-20230905110741805"></p><p>整数集的子集为什么不是全格，但是格？</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230905111254543.png" alt="image-20230905111254543"></p><p>回顾格的定义，任意两个元素存在glb和lub即可；全格要求所有子集都有glb和lub</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230905110540907.png" alt="image-20230905110540907"></p><p>有限的格一定是全格，complete的lattice一定是有限的吗，不是</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230905111616613.png" alt="image-20230905111616613"></p><p>一般程序内的是有限的</p><p>积格的定义</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230905112107491.png" alt="image-20230905112107491"></p><ul><li>积格的lub：实际上是每个格内两个元素的lub</li><li>积格的glb：每个格内的两个元素的glb</li></ul><p>性质</p><ul><li>根据定义，积格也是格</li><li>积格是全格的积时，积格也是全格</li></ul><h2 id="Data-Flow-Analysis-Framework-via-Lattice"><a href="#Data-Flow-Analysis-Framework-via-Lattice" class="headerlink" title="Data Flow Analysis Framework via Lattice"></a>Data Flow Analysis Framework via Lattice</h2><p>介绍格是为了用格形式化数据流分析</p><p> <img src="/2023/08/31/program-analysis-NJU/image-20230905113959239.png" alt="image-20230905113959239"></p><p>有点类似沿着控制流上升到上界</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230905114738987.png" alt="image-20230905114738987"></p><p>试图回答第1个问题</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230905114859061.png" alt="image-20230905114859061"></p><p>需要单调性和不动点定理</p><h2 id="Monoticity-and-Fixed-point-Theorem"><a href="#Monoticity-and-Fixed-point-Theorem" class="headerlink" title="Monoticity and Fixed point Theorem"></a>Monoticity and Fixed point Theorem</h2><p>前面提到complete的格不一定是有限的，所以这里额外第二个条件是finite</p><p>从bottom出发，迭代f函数能够找到的第一个不动点叫做最小不动点；从top出发，求到的是最大不动点</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230905151443765.png" alt="image-20230905151443765"></p><p>证明不动点的存在：</p><p>根据$\perp$的定义，有$\perp \subseteq f(\perp)$</p><p>根据单调性的定义，$f(\perp)\subseteq f(f(\perp))$</p><p>递归地有 $\perp \subseteq f(\perp) \subseteq \dots f^i(\perp)$</p><p>根据$L$的有限性，存在一个$k$,$f^k(\perp)=f^{k+1}(\perp)=f^{fix}$</p><p>即存在不动点，回答了问题1</p><p>（可以假设不存在不动点，则根据单调性和有限性推出矛盾）</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230905154855422.png" alt="image-20230905154855422"></p><p>再证明得到的不动点是最小不动点</p><p>设存在另一个不动点为$x=f(x)$</p><p>根据$\perp$的定义，有$\perp \subseteq x$</p><p>根据单调性有 $f(\perp) \subseteq f(x)$ (数学归纳法的奠基)</p><p>采用数学归纳法，假设$f^i(\perp)\subseteq f^i(x)$</p><p>根据单调性，有$f^{i+1}(\perp)\subseteq f^{i+1}(x)=f(x)$</p><p>则有$f^{fix}=f^k(\perp)\subseteq f^k(x)=x$</p><p>即证明了求出的不动点是最小不动点，回答了问题2</p><p>间接证明了求出的不动点的唯一性</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230905155031011.png" alt="image-20230905155031011"></p><p>依然存在的问题，仅回答了lattice上函数的性质，没有和迭代式算法建立联系</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230905160510624.png" alt="image-20230905160510624"></p><h2 id="Relate-Iterative-Algorithm-to-Fixed-Point-Theorem"><a href="#Relate-Iterative-Algorithm-to-Fixed-Point-Theorem" class="headerlink" title="Relate Iterative Algorithm to Fixed Point Theorem"></a>Relate Iterative Algorithm to Fixed Point Theorem</h2><p><img src="/2023/08/31/program-analysis-NJU/image-20230905164944314.png" alt="image-20230905164944314"></p><p>关键是F的单调性</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230905165647774.png" alt="image-20230905165647774"></p><p>先证明两个运算的单调性</p><p>思路是利用最小上界的定义 偏序关系的传递性</p><p>证明下确界运算的思路类似</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230905172002679.png" alt="image-20230905172002679"></p><p>最后解答复杂性的问题</p><p>先介绍格的高度的定义</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230905172123723.png" alt="image-20230905172123723"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230905172819265.png" alt="image-20230905172819265"></p><p>复杂度取决于CFG节点个数和格的高度 </p><h2 id="May-Must-Analysis-A-Lattive-View"><a href="#May-Must-Analysis-A-Lattive-View" class="headerlink" title="May/Must Analysis, A Lattive View"></a>May/Must Analysis, A Lattive View</h2><p><img src="/2023/08/31/program-analysis-NJU/image-20230905173425800.png" alt="image-20230905173425800"></p><p>先抽象成一个积格进行理解，先看may alalysis</p><p>以reaching definition为例，作为一种may analysis 最下面No definitions can reach是所有变量都被初始化了，最上面是所有变量都可能被redefine，safe是指从找bug的角度，给所有变量报错是safe but useless，因此需要从下往上找到safe和unsafe的边界 truth</p><p>如何判断是否超过了truth（根据不动点</p><p>设计transfer function和cf merge的原则是safe approximation</p><p>根据单调性，求得的是最小不动点</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230905174535083.png" alt="image-20230905174535083"></p><p>must analyse解决的是优化问题，从top出发，所有表达式都能优化显然是错误的，bottom是安全的但是没用的，没有表达式可以优化</p><p>must analyse的分析不能有误报，要求是complete</p><p>另一个维度理解may的最小不动点：transfer function是固定的，join是求最小上界，每次迭代走的是minimal step，因此得到的是最小不动点</p><h2 id="Distributivity-and-MOP"><a href="#Distributivity-and-MOP" class="headerlink" title="Distributivity and MOP"></a>Distributivity and MOP</h2><p>考虑解的精确性，MOP是衡量的一个指标</p><p>总的transfer function就是各个f的组合</p><p>MOP是枚举所有的path的结果再join或meet（计算了每条路径最终的值</p><p>静态分析中有的路径可能是不可达的，导致结果不是完全精确的</p><p>实际上是不可枚举的</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230906103700614.png" alt="image-20230906103700614"></p><p>和迭代式算法的区别</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230906103918799.png" alt="image-20230906103918799"></p><p>x和y之间的关系</p><p>最小上界小于上界</p><p>所以MOP更准确</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230906104601252.png" alt="image-20230906104601252"></p><p>当F满足分配律，两者一样准确</p><p>之前提到的bit-vector或Gen/Kill问题都是distributive</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230906104858404.png" alt="image-20230906104858404"></p><h2 id="Constant-Propagation"><a href="#Constant-Propagation" class="headerlink" title="Constant Propagation"></a>Constant Propagation</h2><p>这个DFA不是distributive的</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230906105336040.png" alt="image-20230906105336040"></p><p>NAC: not a constant</p><p>一般不考虑未初始化的问题</p><p>对于两个常量分类讨论</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230906105930450.png" alt="image-20230906105930450"> </p><p> 关注赋值语句，kill掉与被赋值相关的常量</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230906111532756.png" alt="image-20230906111532756"></p><p>例子</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230906111959118.png" alt="image-20230906111959118"></p><h2 id="Worklist-Algorithm"><a href="#Worklist-Algorithm" class="headerlink" title="Worklist Algorithm"></a>Worklist Algorithm</h2><p>区别于迭代算法，实际的工具不采用迭代算法，worklist可以看做优化</p><p>回顾迭代式算法</p><p>仅遍历计算in变了的部分</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230906112920299.png" alt="image-20230906112920299"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230906113352119.png" alt="image-20230906113352119"></p><h1 id="Interprocedural-Analysis"><a href="#Interprocedural-Analysis" class="headerlink" title="Interprocedural Analysis"></a>Interprocedural Analysis</h1><p>过程间分析</p><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p><img src="/2023/08/31/program-analysis-NJU/image-20230906113916346.png" alt="image-20230906113916346"></p><p>过程内分析对方法调用进行最保守的假设，可以做任何事情</p><p>问题：过于保守，降低了精度</p><p>过程间分析需要call graph，调用的目的地址</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230906114450105.png" alt="image-20230906114450105"></p><h2 id="Call-graph"><a href="#Call-graph" class="headerlink" title="Call graph"></a>Call graph</h2><p>call edge连接call site和callee</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230906114617419.png" alt="image-20230906114617419"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230906114641085.png" alt="image-20230906114641085"></p><p>主要针对面向对象的语言，给出了4个算法</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230906114815381.png" alt="image-20230906114815381"></p><p>virtualcall实现多态，难以处理</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230906115124716.png" alt="image-20230906115124716"></p><p>具体调用的方法在运行时确定，取决于</p><ul><li>对象的类型</li><li>方法签名（可以唯一确定一个方法</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230906115354456.png" alt="image-20230906115354456"></p><p>优先当前类有方法体的方法，不能是抽象的，如果没有则去父类找</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230906115605922.png" alt="image-20230906115605922"></p><p>CHA需要类的继承的信息，根据A的类型来决定对应的call</p><p>OO语言的顶会</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230906200743561.png" alt="image-20230906200743561"></p><p>算法采用分类讨论</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230906201056655.png" alt="image-20230906201056655"></p><p>static call最简单</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230906201244904.png" alt="image-20230906201244904"></p><p>B类可能没有foo，因此需要一个Dispatch而不是直接用B.foo()\</p><p>私有和构造函数都能用dispatch解决</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230906201506211.png" alt="image-20230906201506211"></p><p>对于virtual call，包含了所有的子类的方法，因为</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230906201707497.png" alt="image-20230906201707497"></p><p>例子都属于virtual call</p><p>{C.foo()}</p><p>{A.foo(), C.foo(), D.foo()}</p><p>{A.foo(), C.foo(), D.foo()}</p><p>如果B b =new B(), Resolve(b.foo())={A.foo(), C.foo(), D.foo()} 结果不变</p><p>这里是一个special call吗？不是因为Java支持动态方法分配，且涉及到了继承关系</p><p>因为算法只考虑变量的声明类型</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230906211704923.png" alt="image-20230906211704923"></p><p>一般用在IDE中</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230906211826590.png" alt="image-20230906211826590"></p><p>navigate菜单中</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230906211956325.png" alt="image-20230906211956325"></p><p>reachable是处理过的方法</p><p>通过resolve发现新的方法</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230907095105736.png" alt="image-20230907095105736"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230907100051983.png" alt="image-20230907100051983"></p><h2 id="Interprocedural-CFG"><a href="#Interprocedural-CFG" class="headerlink" title="Interprocedural CFG"></a>Interprocedural CFG</h2><p>ICFG表示的是整个程序的结构</p><p>紧跟着call site的就是return site，利用call graph来解决ICFG</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230907100501603.png" alt="image-20230907100501603"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230907100605564.png" alt="image-20230907100605564"></p><p>为什么还保留一条额外的边</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230907100725411.png" alt="image-20230907100725411"></p><h2 id="Interprocedural-Data-Flow-Analysis"><a href="#Interprocedural-Data-Flow-Analysis" class="headerlink" title="Interprocedural Data Flow Analysis"></a>Interprocedural Data Flow Analysis</h2><p><img src="/2023/08/31/program-analysis-NJU/image-20230907101105920.png" alt="image-20230907101105920"></p><p>遇到call node需要kill掉left hand side variable的值 </p><p><img src="/2023/08/31/program-analysis-NJU/image-20230907103248743.png" alt="image-20230907103248743"></p><p>edge transfer就是给形参赋值</p><p>保留call to return edge是为了保证本地数据流关系的保留，即函数内部的</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230907104117327.png" alt="image-20230907104117327"></p><p>如果没有这条边，相当于函数addOne内还需要维护a的值，如下图，效率很低</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230907104201277.png" alt="image-20230907104201277"></p><p>kill的具体原因，需要用返回值覆盖</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230907105040021.png" alt="image-20230907105040021"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230907105101994.png" alt="image-20230907105101994"></p><p>如果是过程内分析，会进行最保守的假设，所有调用返回值都是NAC，imprecise</p><p>过程间分析更加精确</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230907105527714.png" alt="image-20230907105527714"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230907105536788.png" alt="image-20230907105536788"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230907105714714.png" alt="image-20230907105714714"></p><h1 id="Pointer-Analysis-Introduction"><a href="#Pointer-Analysis-Introduction" class="headerlink" title="Pointer Analysis Introduction"></a>Pointer Analysis Introduction</h1><h2 id="Motivation-1"><a href="#Motivation-1" class="headerlink" title="Motivation"></a>Motivation</h2><p>利用CHA来求目标方法会有多个，不精确</p><p>CHA利用对象的类和子类来分析</p><p>如果对x进行常量传播，x是NAC</p><p>指针分析更精确</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914182323812.png" alt="image-20230914182323812"></p><h2 id="Introduction-to-Pointer-Analysis"><a href="#Introduction-to-Pointer-Analysis" class="headerlink" title="Introduction to Pointer Analysis"></a>Introduction to Pointer Analysis</h2><p>指针分析回答指针可以指向哪些地址</p><p>作为一种may analysis，过近似，给出可能指向的所有地址</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911092021640.png" alt="image-20230911092021640"></p><p>OO语言内的指针包括filed和variable</p><p>指针分析的输入是一段程序，输出是如右表所示的表格</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911093038934.png" alt="image-20230911093038934"></p><h3 id="Alias-Analysis别名分析"><a href="#Alias-Analysis别名分析" class="headerlink" title="Alias Analysis别名分析"></a>Alias Analysis别名分析</h3><ul><li><p>指针分析：指针可以指向哪些对象</p></li><li><p>别名分析：两个指针能否指向同一地址</p></li></ul><p>显然，可以利用指针分析实现别名分析</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911093309820.png" alt="image-20230911093309820"></p><p>指针分析的应用：</p><ul><li>计算调用图</li><li>编译优化</li><li>漏洞检测 空指针</li><li>…</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230911093514885.png" alt="image-20230911093514885"></p><h2 id="Key-Factors"><a href="#Key-Factors" class="headerlink" title="Key Factors"></a>Key Factors</h2><p>非常复杂，在精度和效率之间取舍</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911093643312.png" alt="image-20230911093643312"></p><h3 id="Heap-Abstraction"><a href="#Heap-Abstraction" class="headerlink" title="Heap Abstraction"></a>Heap Abstraction</h3><p>堆抽象：如何对堆内存建模</p><p>因为在动态执行中，堆的对象可能是无穷的，静态分析需要在一定时间内得出结果，堆抽象需要将具体的对象抽象成有限数量的抽象的对象</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911093955437.png" alt="image-20230911093955437"></p><p>了解有两大流派，学习allocation sites技术</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911094118770.png" alt="image-20230911094118770"></p><p>根据对象的创建点来建模，$O_2$表示创建点</p><p>因为程序中创建对象的语句是有限的，显然抽象的对象数量是有限的</p><h3 id="Context-Sensitivity"><a href="#Context-Sensitivity" class="headerlink" title="Context Sensitivity"></a>Context Sensitivity</h3><p>上下文：考虑如何对调用点建模</p><p>方法可能被调用很多次，对应不同的上下文时，方法内的调用可能不同</p><ul><li><p>上下文敏感可以模拟 区分不同的上下文，上下文不同时，对同一个方法分析多次</p></li><li><p>上下文不敏感每个方法仅分析一次</p></li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230911100457311.png" alt="image-20230911100457311"></p><p>上下文敏感可以显著提高精度</p><p>学习计划是先学习不敏感，再学习敏感</p><h3 id="Flow-Sensitivity"><a href="#Flow-Sensitivity" class="headerlink" title="Flow Sensitivity"></a>Flow Sensitivity</h3><p>指如何对<strong>控制流</strong>进行建模</p><ul><li>控制流敏感：尊重语句的执行顺序</li><li>控制流不敏感：忽视控制流的顺序</li></ul><p>java的数据类型可以分为值类型和引用类型；</p><ul><li>基本类型也称为值类型，分别是字符类型 char，布尔类型 boolean以及数值类型 byte、short、int、long、float、double。</li><li>引用类型则包括类、接口、数组、枚举等。</li></ul><p>Java 将内存空间分为堆和栈。基本类型直接在栈中存储数值，而引用类型是将引用放在栈中，实际存储的值是放在堆中，通过栈中的引用指向堆中存放的数据。</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911101619604.png" alt="image-20230911101619604"></p><p>右边是flow不敏感分析的结果，目前主流是flow insensitive（对精度影响不大）</p><h3 id="Analysis-Scope"><a href="#Analysis-Scope" class="headerlink" title="Analysis Scope"></a>Analysis Scope</h3><p>回答应该分析程序中的哪些部分</p><ul><li>所有程序</li><li>需求驱动的分析：计算量更小；效率差异可能不够明显，仅满足特定需求<ul><li>如果有多个client的需求，可能会有重叠，不如进行全程序分析效率高</li></ul></li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230911104031780.png" alt="image-20230911104031780"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911104343223.png" alt="image-20230911104343223"></p><h2 id="Concerned-Statements"><a href="#Concerned-Statements" class="headerlink" title="Concerned Statements"></a>Concerned Statements</h2><p>只关心影响与指针有关的语句</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911105633949.png" alt="image-20230911105633949"></p><ul><li>本地变量：x 数量最多</li><li>静态field：C.f 和变量类似，不是重点</li><li>Instance field：x.f 对象的field</li><li>数组元素 Array[i]，一般会忽略index，静态分析无法得到，抽象成 <em>只有一个field的对象</em>，所有指都可以能取到，因此和instance field类似了</li></ul><p>结论：学会1 3即可（不是</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911110032514.png" alt="image-20230911110032514"></p><p>主要是5条语句</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911110354258.png" alt="image-20230911110354258"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911110406168.png" alt="image-20230911110406168"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911110735865.png" alt="image-20230911110735865"></p><h1 id="Pointer-Analysis-Foundations-1"><a href="#Pointer-Analysis-Foundations-1" class="headerlink" title="Pointer Analysis Foundations 1"></a>Pointer Analysis Foundations 1</h1><p><img src="/2023/08/31/program-analysis-NJU/image-20230911110905857.png" alt="image-20230911110905857"></p><h2 id="Rules"><a href="#Rules" class="headerlink" title="Rules"></a>Rules</h2><p>首先分析没有方法调用的程序（前4条语句），再学习如何处理方法调用</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911111820078.png" alt="image-20230911111820078"></p><p>规则是推导式的，$pt(p)$指的是p指向的对象</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911113127194.png" alt="image-20230911113127194"></p><p>new是将$o_i$加入到$pt(x)$中去</p><p>赋值将$y$指向的加入到$x$指向的</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911113140353.png" alt="image-20230911113140353"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911113613953.png" alt="image-20230911113613953"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911113800642.png" alt="image-20230911113800642"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911113809394.png" alt="image-20230911113809394"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911160527617.png" alt="image-20230911160527617"></p><h2 id="How-to-implement-pointer-analysis"><a href="#How-to-implement-pointer-analysis" class="headerlink" title="How to implement pointer analysis"></a>How to implement pointer analysis</h2><p>本质上是将指针信息传播给其他指针，也可以理解为求解包含约束</p><p>指针分析的关键是当指针集$pt(x)$变化时，将变化传播给其他相关的指针</p><p>利用图来传播</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911161609721.png" alt="image-20230911161609721"></p><p>指针流图pointer flow graph</p><p>有向图，表示对象如何在图中流动</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911161731273.png" alt="image-20230911161731273"></p><p>边的含义是x的变化可能流向y</p><p>如何建立PFG的边？根据程序的语句的4条规则</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911162000627.png" alt="image-20230911162000627"></p><p>c.f仅是一个指针表达式，不是一个指针，指针必须是对象</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911163008942.png" alt="image-20230911163008942"></p><p>实现包括两步</p><ul><li>构建指针流图</li><li>在PFG上传播指向信息</li></ul><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>分别对应4个语句</p><p>S是要分析的语句的集合</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911164230546.png" alt="image-20230911164230546"></p><p>WL包含了指针和指针集，是后续要分析的对象</p><p>简化只有2种语句</p><p>集合的减法是为了去重，去掉ptn已经有的指针</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911170359600.png" alt="image-20230911170359600"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911170411007.png" alt="image-20230911170411007"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911170430735.png" alt="image-20230911170430735"></p><p>已经是union了为什么要去重？不影响正确性，但是可以跳过</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911171405824.png" alt="image-20230911171405824"></p><p>另外两条对称的语句</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911172033462.png" alt="image-20230911172033462"></p><p>可能有其他同类的不同对象已经连接了实例方法，因此是may引入新的PFG边</p><p>执行这个例子</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912162251382.png" alt="image-20230912162251382"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912162437486.png" alt="image-20230912162437486"></p><h1 id="Pointer-Analysis-Foundations-2"><a href="#Pointer-Analysis-Foundations-2" class="headerlink" title="Pointer Analysis Foundations 2"></a>Pointer Analysis Foundations 2</h1><p>如何处理方法调用</p><p>过程间分析，需要call graph</p><p>与CHA方法对比，根据指针分析来确定call graph</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912164701071.png" alt="image-20230912164701071"></p><p>实际上指针分析和call graph是一起构建的，on the fly</p><p>复杂起来了（</p><ul><li><p>disptach：根据接受者对象和方法签名去找目标方法m，在做call graph</p></li><li><p>传receiver对象：$m_{this}$，OO语言很多操作通过this实现</p></li><li>传参：实参传给形参，变量之间连起来</li><li>传回返回值</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230912165752464.png" alt="image-20230912165752464"></p><p>solidity的dispatch只需要函数签名</p><p>问题：为什么this不加一个边？</p><p>连上会传递错误的信息，this只指向当前对象</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912170440967.png" alt="image-20230912170440967"></p><p>实际的操作</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912170522098.png" alt="image-20230912170522098"></p><p>从入口方法main函数进行分析，只分析reachable的方法，reachable对效率和精度有帮助</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912172112179.png" alt="image-20230912172112179"></p><p>黄色部分是新增的步骤，和call graph相关</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912172223253.png" alt="image-20230912172223253"></p><p>reachable方法</p><ul><li>入口方法</li><li>出现新的调用边</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230912173001173.png" alt="image-20230912173001173"></p><p>为什么只处理new和assign，因为这两个语句不需要语境</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912184947416.png" alt="image-20230912184947416"></p><p>为什么call graph存在$l\to m$就不再执行？实际上是对象的类型来决定目标方法的，虽然oi是新的对象，但是其他同类型的对象oj可能已经连过这一条边</p><p>这些判断条件存在的原因：为了实用性，减少不必要的操作</p><p>上下文非敏感，每个算法处理一次</p><p>算法的输出是每个变量的指针集以及调用图</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912185840030.png" alt="image-20230912185840030"></p><p>例子，动笔自己写一写</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912190641848.png" alt="image-20230912190641848"></p><p>和CHA的区别：更精确了</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912192345447.png" alt="image-20230912192345447"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912192951269.png" alt="image-20230912192951269"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912193211655.png" alt="image-20230912193211655"></p><h1 id="Pointer-Analysis-Context-Sentivity"><a href="#Pointer-Analysis-Context-Sentivity" class="headerlink" title="Pointer Analysis Context Sentivity"></a>Pointer Analysis Context Sentivity</h1><p>Java指针分析中对精度提升最明显的技术 </p><p>动态执行时该程序时$i=1$</p><p>采用常量传播分析是NAC</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912194827600.png" alt="image-20230912194827600"></p><p>需要上下文敏感的指针分析，每次调用id时对实参进行区分</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912195049875.png" alt="image-20230912195049875"></p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>上下文不敏感为什么会不准确 </p><ul><li>动态执行时，一个方法可能在不同的语境下被多次调用</li><li>不同调用语境中方法的变量可能指向不同对象</li><li>不同语境下的对象 <em>混合</em> 并 <em>传播</em> 到了程序的其他部分</li></ul><p>提高上下文敏感分析的效率</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912201100384.png" alt="image-20230912201100384"></p><p>最古老和最著名的技术是call-site当做上下文，对调用栈的抽象</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912201119775.png" alt="image-20230912201119775"></p><p>下节课介绍其他变种，后续介绍都是call-site</p><p>具体关注的是变量的上下文</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912201045606.png" alt="image-20230912201045606"></p><p>上下文敏感 堆</p><ul><li>OO程序会频繁操作对象，heap-intensive</li><li>为了提高精度需要对 对象加上下文<ul><li>粒度更细的抽象</li></ul></li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230912201334791.png" alt="image-20230912201334791"></p><p>为什么能提高精度？</p><p>动态执行时，每次调用都会创建新的对象</p><p>同一个语句，不同对象的操作可能不同</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912201515062.png" alt="image-20230912201515062"></p><p>例子</p><p>动态执行指向n1，堆不敏感的程序分析指向n1 n2</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912202332554.png" alt="image-20230912202332554"></p><p>有上下文敏感heap时，右边x.f语句会产生两个不同，意思是方法内对 对象的field也进行区分</p><p>如果没有变量上下文敏感，只做堆上下文敏感，相当于没做</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912205913463.png" alt="image-20230912205913463"></p><p>都加上下文才能提高精度</p><h2 id="Rules-1"><a href="#Rules-1" class="headerlink" title="Rules"></a>Rules</h2><p>先给出定义域和记号</p><p>程序的变量、对象都加上 上下文</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912210139484.png" alt="image-20230912210139484"></p><p>策略决定c的内容，可以理解为一系列call-site</p><p>注意field没有，具体的实例的field有，因为通过对象来访问</p><p>指针也分两类，分别是变量和对象的；因此表示方式是两类的并</p><p>具体实现指针分析器需要利用这些规则</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912213823131.png" alt="image-20230912213823131"></p><p>具体的理解</p><p>对于new语句，语境当中的规则：假设在方法m中，上下文是c，则给对象也加上下文</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912214053341.png" alt="image-20230912214053341"></p><p>对于assign语句，比较直观</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912214230647.png" alt="image-20230912214230647"></p><p>先分别取出x和y指向的对象，为什么不是同一个上下文c？</p><p>因为x和y的上下文相同，但是x和y指向的对象的语境不一定相同，上下文c和c‘可以相同</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912214620756.png" alt="image-20230912214620756"></p><p>load和store对称</p><p>对于调用的规则，如何决定c</p><p>假设调用在某个方法里，当前的语境是c</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912215123422.png" alt="image-20230912215123422"></p><ul><li>先取出对象指向的上下文</li><li>选择对应方法，与上下文无关，取决于类型</li><li>选择上下文：为目标方法$m$选择上下文，根据当前调用点$l$能得到的信息<ul><li>具体怎么选，请看下集</li></ul></li><li>传receiver object</li><li>传返回值</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230912215631131.png" alt="image-20230912215631131"></p><p>好像是直接用了L？考虑如果在例子外面套个循环，就需要一个方法select进行选择了；除了还有其他的表示方法</p><p>$c^t$ 是新的一个上下文</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912220108442.png" alt="image-20230912220108442"></p><p>目前Java流敏感分析的效果不够好</p><h2 id="Algorithms"><a href="#Algorithms" class="headerlink" title="Algorithms"></a>Algorithms</h2><p>算法有两部分，构造PFG，在PFG上传播指针信息</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913152920936.png" alt="image-20230913152920936"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913153854777.png" alt="image-20230913153854777"></p><p>区别在于每个节点表示的都是上下文敏感的变量或者field，节点额外带有上下文，笛卡尔积多了一个维度</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913153130047.png" alt="image-20230913153130047"></p><p>连边就根据4条规则</p><p>对于call比较复杂，方法dispatch，传参数，this不连边，传返回值</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913154003008.png" alt="image-20230913154003008"></p><p>打码之后和上下文不敏感的算法几乎一样</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913154510890.png" alt="image-20230913154510890"></p><p>首先看solve算法</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913154601481.png" alt="image-20230913154601481"></p><p>下面的集合也带有上下文信息</p><p>比如RM foo在ct下可达</p><p>CG也是上下文敏感的call-site和callee都有上下文，$c\to c^t$</p><p>入口函数的上下文为空</p><p>同一个call-site，目标函数内的context是一样的</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913162044882.png" alt="image-20230913162044882"></p><p>Addedge和Propagate和CI分析一致</p><h2 id="Variants"><a href="#Variants" class="headerlink" title="Variants"></a>Variants</h2><p>其他技术</p><p>给出select函数的定义</p><p>最常用的三种上下文敏感的变量</p><ul><li>call-site敏感</li><li>object敏感</li><li>type敏感</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230913162648159.png" alt="image-20230913162648159"></p><p>如果是上下文不敏感，可以看做是上下文敏感的特殊情况，select返回为空</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913164121180.png" alt="image-20230913164121180"></p><p>每个context包括一系列的call-sites，将call site加入到caller，类似于调用栈，也叫call string，K-CFA(k-Context-Free Analysis)</p><h3 id="call-site-sentivity"><a href="#call-site-sentivity" class="headerlink" title="call site sentivity"></a>call site sentivity</h3><p><img src="/2023/08/31/program-analysis-NJU/image-20230913164034410.png" alt="image-20230913164034410"></p><p>怎么得到当前的代码行数呢</p><p>递归调用的时候（方法调用自己），会出现无穷多次call-site</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913164548268.png" alt="image-20230913164548268"></p><p>因此需要一个深度$k$，限制上下文的长度为$k$，一般$k\leq3$，会合并连续相同的callsite然后取队列末尾的$k$个</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913165010456.png" alt="image-20230913165010456"></p><p>上下文层数越多，精度越高，一般是至少2层</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913170125124.png" alt="image-20230913170125124"></p><p>分析x.get具体指向的方法</p><p>动态的理解：会返回1</p><p>静态分析：得到One.get()</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913172604357.png" alt="image-20230913172604357"></p><p>利用调用点区分了14和15两个调用，如果是CI分析</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913172709985.png" alt="image-20230913172709985"></p><h3 id="object-sensitivity"><a href="#object-sensitivity" class="headerlink" title="object sensitivity"></a>object sensitivity</h3><p><img src="/2023/08/31/program-analysis-NJU/image-20230913193654682.png" alt="image-20230913193654682"></p><p>另一种表现形式的select，根据receiver object和heap context来区分</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913195207715.png" alt="image-20230913195207715"></p><p>this指的是上下文本身（对象）</p><p>和1call site进行对比</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913195721511.png" alt="image-20230913195721511"></p><p>换成2 call site能区分</p><p>object是否一定比call site好呢</p><p>this一样，调用的方法也一样</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913201016340.png" alt="image-20230913201016340"></p><ul><li>一般情况下精度是不可比较的</li><li>但是对Java这种OO语言，object更准确</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230913201700466.png" alt="image-20230913201700466"></p><h3 id="type-sensitivity"><a href="#type-sensitivity" class="headerlink" title="type sensitivity"></a>type sensitivity</h3><p>实际上是对object的抽象</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913202205377.png" alt="image-20230913202205377"></p><p>InType得到的不是生成的对象的类型，而是语句所在类</p><p>精度不如对象敏感技术，牺牲了精度换取速度</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913202510805.png" alt="image-20230913202510805"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913201401242.png" alt="image-20230913201401242"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913202953061.png" alt="image-20230913202953061"></p><h1 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h1><p>抽象什么是安全：在敌手存在时达成某个目标</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913205207631.png" alt="image-20230913205207631"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913205405562.png" alt="image-20230913205405562"></p><p>美国的NVD发现最多的漏洞是injection</p><p>injection和leak实际上是一类问题，信息流</p><h2 id="Information-Flow-Security"><a href="#Information-Flow-Security" class="headerlink" title="Information Flow Security"></a>Information Flow Security</h2><p>目标：阻止不必要的信息流</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913205701513.png" alt="image-20230913205701513"></p><ul><li>Access Control：标准方法，检查是否具有权限来访问特定信息；考虑信息是如何被处理的<ul><li>得到信息后如何使用？</li></ul></li><li>信息流安全 end2end<ul><li>跟踪程序如何安全地处理信息</li><li>考虑信息如何传播</li></ul></li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230913205921749.png" alt="image-20230913205921749"></p><p>信息论的定义</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913210049720.png" alt="image-20230913210049720"></p><p>给变量分级</p><p>不同等级变量之间信息如何流动</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913210226746.png" alt="image-20230913210226746"></p><p>最简单分法是2级分法（使用最广泛</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913210241719.png" alt="image-20230913210241719"></p><p>可以利用偏序关系（格）来建模</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913210345697.png" alt="image-20230913210345697"></p><p>可以有比较复杂的level设置</p><p>policy：限制信息如何在不同密级之间流动</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913211342441.png" alt="image-20230913211342441"></p><ul><li>高级变量不能影响低级变量</li><li>通过观测低级信息无法推测出高级信息</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230913211325855.png" alt="image-20230913211325855"></p><h2 id="Confidentiality-and-Integrity"><a href="#Confidentiality-and-Integrity" class="headerlink" title="Confidentiality and Integrity"></a>Confidentiality and Integrity</h2><p><img src="/2023/08/31/program-analysis-NJU/image-20230913211612588.png" alt="image-20230913211612588"></p><p>和密码学定义的Integrity不同，更像是真实性，外界信息的真实性</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913211740289.png" alt="image-20230913211740289"></p><p>给US air force提出的问题</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913212019260.png" alt="image-20230913212019260"></p><p>从完整性角度看，高级流向低级也不安全</p><p>扩展完整性的定义，之前的定义有点类似于正确性</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913212158190.png" alt="image-20230913212158190"></p><p>数据流和信息流的区别：</p><p>数据流可以看做具体的数据</p><p>信息流更加抽象，广义，可以将数据流看做是信息流</p><h2 id="Explicit-Flows-and-Covert-Channels"><a href="#Explicit-Flows-and-Covert-Channels" class="headerlink" title="Explicit Flows and Covert Channels"></a>Explicit Flows and Covert Channels</h2><p><img src="/2023/08/31/program-analysis-NJU/image-20230913212559603.png" alt="image-20230913212559603"></p><p>以上是显式流动</p><p>秘密可能作为条件语句的判断条件，称为隐式流</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913212739282.png" alt="image-20230913212739282"></p><p>while循环 是一个信息流，但不是数据流</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913213034386.png" alt="image-20230913213034386"></p><p>最后一个如果为负数，可能有error</p><p>统称上面这种类型为隐藏信道</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913213249693.png" alt="image-20230913213249693"></p><p>还有侧信道，观察缓存命中率</p><p>总结所有类型的CC非常有挑战性</p><p>一般情况下，Cover Channel泄露信息有限</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913213650461.png" alt="image-20230913213650461"></p><p>因此后续课程主要采用污点分析分析显式流</p><ul><li>感觉后者更有意义</li></ul><h2 id="Taint-Analysis"><a href="#Taint-Analysis" class="headerlink" title="Taint Analysis"></a>Taint Analysis</h2><p>使用最广泛的信息流分析工具</p><p>数据分类</p><ul><li>感兴趣的数据，label（同位素）</li><li>untainted </li></ul><p>污点数据来源于特定方法的返回值</p><p>关心污点数据是否会流动到特定的sink，一般是一些比较敏感的方法</p><p>是否存在从source到sink的流</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913213911354.png" alt="image-20230913213911354"></p><p>应用</p><ul><li>保密性： $\text{ secret data} \to \text{method}$</li><li>完整性：$\text{input} \to \text{critical command}$</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230913214159779.png" alt="image-20230913214159779"></p><p>两个性质的对称性</p><p>污点分析回答的问题</p><ul><li>标记数据是否会流动到某个sink（sink的指针会指向标记的数据吗？）</li></ul><p>两者是高度一致的，因此可以借助指针分析进行污点分析</p><ul><li>将标记的数据视为特殊的object</li><li>source是allocation site</li><li>利用指针分析进行污点数据传播</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230913214528489.png" alt="image-20230913214528489"></p><p>首先扩展指针分析的定义域，污点数据是指针分析的子集</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913214946878.png" alt="image-20230913214946878"></p><p>输入输出</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913215045186.png" alt="image-20230913215045186"></p><p>规则</p><p>call：如果dispatch方法来自source，认为可能是需要污点分析的</p><p>后续的传播和指针分析一样</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913215415014.png" alt="image-20230913215415014"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913215406095.png" alt="image-20230913215406095"></p><p>检查sink？调用sink方法时，参数是否是tainted</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913215502781.png" alt="image-20230913215502781"></p><p>例子</p><p>java中都是浅拷贝</p><p>x和y是别名</p><p>方便debug</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913220135749.png" alt="image-20230913220135749"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913220115069.png" alt="image-20230913220115069"></p><p>对于运算符重载，需要更复杂的机制设计</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913220301552.png" alt="image-20230913220301552"></p><h1 id="Datalog-Based-Program-Analysis"><a href="#Datalog-Based-Program-Analysis" class="headerlink" title="Datalog-Based Program Analysis"></a>Datalog-Based Program Analysis</h1><h2 id="Motivation-2"><a href="#Motivation-2" class="headerlink" title="Motivation"></a>Motivation</h2><p>命令式语言：</p><p>声明式语言：sql</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913221434446.png" alt="image-20230913221434446"></p><p>实现一个复杂的指针分析，采用不同语言的区别</p><p>回顾指针分析的rules和算法</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913221600990.png" alt="image-20230913221600990"></p><p>还需要考虑的细节</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913221610803.png" alt="image-20230913221610803"></p><p>如果用声明式语言实现</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913221806951.png" alt="image-20230913221806951"></p><p>可读性更强了</p><h2 id="Introduction-1"><a href="#Introduction-1" class="headerlink" title="Introduction"></a>Introduction</h2><p>声明式逻辑编程语言，Prolog的子集</p><p>曾经是数据库的查询语言</p><ul><li>程序分析</li><li>网络协议</li><li>吹牛</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230913222022073.png" alt="image-20230913222022073"></p><p>没有控制流？没有函数</p><p>表达能力不够</p><h3 id="data-predicate"><a href="#data-predicate" class="headerlink" title="data/predicate"></a>data/predicate</h3><p>事实</p><p>数据的表</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913222125660.png" alt="image-20230913222125660"></p><p>元组属于data，真的，称为fact</p><p>谓词由Atom表示</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913222349159.png" alt="image-20230913222349159"></p><p>原子可以判定真假 </p><p>下面这个类型也是原子</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913222547175.png" alt="image-20230913222547175"></p><h3 id="Rules-Logic"><a href="#Rules-Logic" class="headerlink" title="Rules/Logic"></a>Rules/Logic</h3><p>制定了如何推导fact</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913222737380.png" alt="image-20230913222737380"></p><p><code>，</code>是逻辑与</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913222823795.png" alt="image-20230913222823795"></p><p>如何理解规则</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913222951872.png" alt="image-20230913222951872"></p><p>考虑所有组合，如果一个组合可以让所有子目标为真，head为真，包含所有为真的谓词</p><p>交换subgoal不交换结果</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913223252088.png" alt="image-20230913223252088"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913223410217.png" alt="image-20230913223410217"></p><p>问题在于初始数据来源</p><ul><li><p>EDB：程序运行前定义好的；不变； </p></li><li><p>IDB：根据Rules定义，程序的输出，head只能是IDB</p></li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230913223615033.png" alt="image-20230913223615033"></p><p>表示 或</p><p>写两条语句或者采用<code>;</code></p><p>优先级低</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913223949083.png" alt="image-20230913223949083"></p><p>表示非采用<code>!</code></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913224015374.png" alt="image-20230913224015374"></p><p>否 是搜索所有情况吗</p><p>支持递归，能力强大的来源</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913224101296.png" alt="image-20230913224101296"></p><p>如果没有递归，只能支持基本的关系代数</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913224230753.png" alt="image-20230913224230753"></p><p>需要保证规则是safe，所有的变量是有限的</p><ul><li>表是有限的，表取反就是无限的</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230913224527154.png" alt="image-20230913224527154"></p><p>取反和递归必须分开</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913224943480.png" alt="image-20230913224943480"></p><p>程序如何执行？engine</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913225056738.png" alt="image-20230913225056738"></p><p>只能产生facts</p><h2 id="Pointer-Analysis"><a href="#Pointer-Analysis" class="headerlink" title="Pointer Analysis"></a>Pointer Analysis</h2><p>指针分析的EDB是语法分析可以直接获得到的信息</p><p>IDB是指针分析的结果</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914081639719.png" alt="image-20230914081639719"></p><p>通过定义域定义4类语句</p><p>IDB只有2类，变量指向和fields指向</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914082014217.png" alt="image-20230914082014217"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914082257853.png" alt="image-20230914082257853"></p><p>程序的可读性非常强，代码实现很干净</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914082932296.png" alt="image-20230914082932296"></p><p>首先运行New，因为varpoints都是空</p><p>将整个New复制到Varpointsto</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914083536305.png" alt="image-20230914083536305"></p><p>终止条件：不再能产生新的facts</p><p>如何处理函数</p><p>引入新的谓词 EDB和IDB</p><p>k应该包含参数信息，不然无法处理多态</p><p>和之前类似，传4部分信息</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914090327689.png" alt="image-20230914090327689"></p><p>增加对入口方法的处理即有了全程序分析</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914090712426.png" alt="image-20230914090712426"></p><h2 id="Taint-Analysis-1"><a href="#Taint-Analysis-1" class="headerlink" title="Taint Analysis"></a>Taint Analysis</h2><p>在指针分析的基础上，修改EDB和IDB</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914091418518.png" alt="image-20230914091418518"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914091438076.png" alt="image-20230914091438076"></p><p>_是因为不关心当前的下标</p><p>优势和劣势</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914095905639.png" alt="image-20230914095905639"></p><ul><li>简洁、可读性强</li><li>engine优化，效率高</li></ul><p>缺点</p><ul><li>表达性受限，不是图灵完备<ul><li>如果需要删除facts，无法实现</li><li>对于all的逻辑不是很好表达</li></ul></li><li>engine是黑盒，无法自行优化效率</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230914100142781.png" alt="image-20230914100142781"></p><h1 id="CFL-Reachability-and-IFDS"><a href="#CFL-Reachability-and-IFDS" class="headerlink" title="CFL-Reachability and IFDS"></a>CFL-Reachability and IFDS</h1><p>context free language是IFDS的理论基础</p><p>利用图可达进行程序分析表达</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914101547722.png" alt="image-20230914101547722"></p><p>放松心态，学懂50%就算成功！</p><h2 id="Feasiable-and-Realizable-Paths"><a href="#Feasiable-and-Realizable-Paths" class="headerlink" title="Feasiable and Realizable Paths"></a>Feasiable and Realizable Paths</h2><p>存在一些路径是不可达的</p><p>希望程序分析尽可能不被这些不可达路径污染，然而静态分析中这个问题是不可判定的</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914101250283.png" alt="image-20230914101250283"></p><p>红色路径是静态分析无法避免的错误</p><p>绿色路径可以通过上下文敏感避免</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914101854201.png" alt="image-20230914101854201"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914101908102.png" alt="image-20230914101908102"></p><p>realizable path：跨函数调用的返回应该和call匹配</p><p>unrealizable一定是不会执行的，如何识别</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914102037213.png" alt="image-20230914102037213"></p><p>括号匹配，太复杂就不适用，寻找系统的方法</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914102223380.png" alt="image-20230914102223380"></p><h2 id="CFL-reachability"><a href="#CFL-reachability" class="headerlink" title="CFL-reachability"></a>CFL-reachability</h2><p>上下文无关文法生成的是上下文无关语言</p><p>没学过编译但学过计算理论</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914102916339.png" alt="image-20230914102916339"></p><p>编程语言文法一般是CFG</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914103028029.png" alt="image-20230914103028029"></p><p>部分 括号匹配</p><p>有右括号一定有左括号，反之不一定成立（call了不一定return）</p><p>通过call-site进行括号的索引</p><p>如何形式化括号匹配的问题？写CFL的语法</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914104300136.png" alt="image-20230914104300136"></p><p>从规则来看，没有单独产生右括号的规则</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914104707483.png" alt="image-20230914104707483"></p><h2 id="IFDS"><a href="#IFDS" class="headerlink" title="IFDS"></a>IFDS</h2><p><img src="/2023/08/31/program-analysis-NJU/image-20230914104809038.png" alt="image-20230914104809038"></p><p>可以通过图可达性来表达的图分析算法</p><p>不再是迭代式算法，用图的方式（没有传播的过程）</p><p>过程间的 <em>有限 可分配的</em> 子集问题</p><p>定义域有限 流函数是distributive</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914105259135.png" alt="image-20230914105259135"></p><p>具体可以认为是先meet再transfer和调换顺序结果一致</p><p>回顾MOP，利用IFDS能够给出MRP</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914105804428.png" alt="image-20230914105804428"></p><p>是所有edge上的f的复合函数</p><p>MOP是把所有path的结果并起来</p><p>MRP只考虑realizaable path（返回边和callsite对应，不能返回到之前已经返回过的边），不再沿着假的边去分析，可能更精准</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914110511798.png" alt="image-20230914110511798"></p><p>显然是MOP的子集</p><p>构造supergraph，定义flow func</p><p>构造explded supergraph</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914111707351.png" alt="image-20230914111707351"></p><p>$G^*$由一系列的$G_{main}$和$G_p$组成</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914140129907.png" alt="image-20230914140129907"></p><p>每个call site都有3条edge</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914140322154.png" alt="image-20230914140322154"></p><p>flow function的设计采用 可能未初始化的变量 的设计</p><p>具体的函数形式为lambda表达式</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914141003251.png" alt="image-20230914141003251"></p><p>lambda表达式类似于匿名函数，$\lambda e_{param}\cdot e_{body}$</p><p>无论输入，输出$x,g$</p><p>S是所有没有被初始化的值</p><p>$\lambda \ S.{S-x}$</p><p>减去g为了提高精度，真实情况不会有这条边，增加这一条边传播了本地变量的信息</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914142144730.png" alt="image-20230914142144730"></p><p>有了supergraph之后，建立exploded supergraph，拆分了flow function</p><p>D=2</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914142834835.png" alt="image-20230914142834835"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914144611310.png" alt="image-20230914144611310"></p><p>和传统的程序分析的定义区分，之前通过n4的out来判断存在</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914150855265.png" alt="image-20230914150855265"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914151715271.png" alt="image-20230914151715271"></p><p>利用tabulation算法判断可达性</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914151704558.png" alt="image-20230914151704558"></p><p>如果d可达就涂成蓝色</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914151857768.png" alt="image-20230914151857768"></p><p>这个算法比较复杂，不做详细介绍</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914152005445.png" alt="image-20230914152005445"></p><p>E是边的个数，D是domain size</p><p>处理exit节点时， 找到对应的call边</p><p>额外还有call到return的 summary edge，加速</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914152618402.png" alt="image-20230914152618402"></p><p>可分配性的理解</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914153507313.png" alt="image-20230914153507313"></p><p>具体问题能够利用IFDS解决需要用可分配性判断</p><p>IFDS的flow函数只能处理一个元素</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914153649860.png" alt="image-20230914153649860"></p><p>如果需要多个输入事实来判断能否产生正确的输出，不能用IFDS</p><p>最后的两个例子可以用IFDS</p><p>x,y,x.f指向o，正确吗</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914154323952.png" alt="image-20230914154323952"></p><p>缺少别名信息，这个信息同时需要x和y，因此指针分析不能用标准的IFDS</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914154812428.png" alt="image-20230914154812428"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914154937595.png" alt="image-20230914154937595"></p><h1 id="Soundness-and-Soundiness"><a href="#Soundness-and-Soundiness" class="headerlink" title="Soundness and Soundiness"></a>Soundness and Soundiness</h1><p>程序分析约有50年，soundiness是2015年提出的</p><p>前沿的话题</p><h2 id="soundness"><a href="#soundness" class="headerlink" title="soundness"></a>soundness</h2><p>保守的近似，近似所有可能的程序行为</p><ul><li>学术界：分析真实程序语言编写的完整的程序，没有sound</li><li>工业界：所有工具都不得不牺牲soundness</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230914155709950.png" alt="image-20230914155709950"></p><p>每个编程语言存在的难以分析的feature</p><p>比如js的eval，c对指针加减</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914155955552.png" alt="image-20230914155955552"></p><p>因此现在论文的结果可能声称是sound，对hard one是unsound；</p><p>或者忽略</p><p>不分析会导致严重的结果吗？Java</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914161155068.png" alt="image-20230914161155068"></p><p>soundiness指真实的程序没法分析一些困难的语言的特征</p><p>大佬振臂高呼，提soundiness</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914161603588.png" alt="image-20230914161603588"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914161732880.png" alt="image-20230914161732880"></p><p>三类概念的区别</p><p>为什么下面的两类很困难</p><h2 id="Hard-Language-Feature-Java-Reflection"><a href="#Hard-Language-Feature-Java-Reflection" class="headerlink" title="Hard Language Feature: Java Reflection"></a>Hard Language Feature: Java Reflection</h2><p>对java和安卓分析的噩梦，notorious</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914162225436.png" alt="image-20230914162225436"></p><p>为什么难分析</p><p>在Java编程语言中，反射（Reflection）是指在运行时动态地获取、检查和操作类、对象、方法和属性的能力。它允许程序在运行时通过名称来获取类的信息，调用方法，访问字段，创建对象等，而不需要在编译时明确地引用类或方法。</p><p>Java反射提供了一组类和接口，如<code>Class</code>、<code>Method</code>、<code>Field</code>等，用于在运行时检查和操作类的结构。通过使用反射，可以实现以下功能：</p><ol><li><strong>获取类的信息</strong>：通过反射，可以获取类的名称、父类、实现的接口、构造函数、方法和字段等信息。</li><li><strong>动态创建对象</strong>：通过反射，可以在运行时通过类名创建对象的实例，而无需提前知道类的具体类型。</li><li><strong>调用方法</strong>：通过反射，可以在运行时调用对象的方法，包括公共方法、私有方法和静态方法。</li><li><strong>访问和修改字段</strong>：通过反射，可以在运行时访问和修改对象的字段（即成员变量），包括公共字段和私有字段。</li><li><strong>操作数组</strong>：通过反射，可以动态创建、访问和修改数组对象。</li></ol><p><img src="/2023/08/31/program-analysis-NJU/image-20230914163513966.png" alt="image-20230914163513966"></p><p>反射是运行时行为</p><p>为什么需要分析呢（应用在哪里，松耦合，编程更灵活）</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914164026620.png" alt="image-20230914164026620"></p><p>右边这个例子可能是错误的</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914164317486.png" alt="image-20230914164317486"></p><p>分析反射的技术：字符串分析+指针分析</p><p>直观的想法</p><p>存在的问题：这些变量可能是从文件中读入的；编码过的</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914164531901.png" alt="image-20230914164531901"></p><p>李老师和谭老师的工作绕不过去</p><p>类型推理+字符串分析+指针分析</p><p>在调用的时候利用参数来推理</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914165357239.png" alt="image-20230914165357239"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914165556297.png" alt="image-20230914165556297"></p><p>目前最新的工作也是他俩做的</p><p>第三类方法，利用动态分析的结果，依赖于test case，给出的都是真的</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914165745956.png" alt="image-20230914165745956"></p><h2 id="Hard-Language-Feature-Native-Code"><a href="#Hard-Language-Feature-Native-Code" class="headerlink" title="Hard Language Feature: Native Code"></a>Hard Language Feature: Native Code</h2><p><img src="/2023/08/31/program-analysis-NJU/image-20230914165932042.png" alt="image-20230914165932042"></p><p>native声明指方法由外部语言实现的，如跨语言调用C/C++</p><p>JNI</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914170548019.png" alt="image-20230914170548019"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914171130534.png" alt="image-20230914171130534"></p><p>现在的解决方案：</p><ul><li>手动建模native code<ul><li>用java简单模拟一下功能</li><li>大概比java实现快一个数量级</li></ul></li><li>binary分析</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230914171721458.png" alt="image-20230914171721458"></p><p><a href="http://soundiness.org/">Soundiness Home Page</a></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914172026836.png" alt="image-20230914172026836"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914172057149.png" alt="image-20230914172057149"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习南京大学的静态程序分析技术课程&lt;/p&gt;
&lt;p&gt;课程主页：&lt;a href=&quot;https://tai-e.pascal-lab.net/lectures.html&quot;&gt;Static Program Analysis | Tai-e (pascal-lab.net)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;共计32小时&lt;/p&gt;</summary>
    
    
    
    
    <category term="static analysis" scheme="https://alleysira.github.io/tags/static-analysis/"/>
    
  </entry>
  
  <entry>
    <title>GearBox</title>
    <link href="https://alleysira.github.io/2023/08/18/GearBox/"/>
    <id>https://alleysira.github.io/2023/08/18/GearBox/</id>
    <published>2023-08-18T08:03:48.000Z</published>
    <updated>2023-10-10T13:01:13.477Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GearBox-Optimal-size-Shard-Committees-by-Leveraging-the-Safety-Liveness-Dichotomy"><a href="#GearBox-Optimal-size-Shard-Committees-by-Leveraging-the-Safety-Liveness-Dichotomy" class="headerlink" title="GearBox: Optimal-size Shard Committees by Leveraging the Safety-Liveness Dichotomy"></a>GearBox: Optimal-size Shard Committees by Leveraging the Safety-Liveness Dichotomy</h1><p>David B, Magri B, Matt C, et al. GearBox: Optimal-size Shard Committees by Leveraging the Safety-Liveness Dichotomy[C]//Proceedings of the 2022 ACM SIGSAC Conference on Computer and Communications Security. 2022: 683-696.</p><span id="more"></span><p>分片是克服区块链可扩展性难题的新兴技术，没有分片，每个节点都必须监听和处理所有账本的信息</p><p>分片的基本思想是并行化账本协议：将节点划分为子集处理，通过执行轻量化的账本协议实例来处理部分原来的工作，分片越小，因为提高了并行化，分片共识协议的开销小，效率越高</p><p>沿着这个脉络，本文提出了一个新的方案——采用安全性-活性二分法，在分片共识种将活性和安全性拆分开，允许动态调整分片参数实现在当前腐化比例下最优的效率</p><ul><li>首先建立一个相对小的分片（诚实节点的比例可能很小）</li><li>在共识协议中仔细地用安全性来trade-off活性，来容忍小的诚实节点的比例，但不丧失安全性<ul><li>困难性在于分片想要获得活性，最坏情况下需要更高的诚实节点比例</li><li>采用一条永远满足活性和安全性的control chain来检测活性失败</li><li>分片被检测出不满足活性的情况下 重新设置为更大的分片大小和活性容忍度直到满足活，保证所有分片永远安全并且效率最优</li></ul></li><li>具体数据：10000参与方，30%的腐化比例，60-bit安全，之前的设计要求每个分片超过5800个参与方保证安全性，本方案最坏情况下需要1713节点，最好情况下需要35个节点</li></ul><p>在高并发的执行环境下，保证账本协议和子协议在通用组合下的安全性非常重要，为了证明协议的安全性，本文给出了分片账本、控制链和分片共识的理想的功能，形式化并证明了在UC框架下的安全性</p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>阻碍区块链大规模应用的障碍之一是较低的交易吞吐率，分片是克服这一困难的解</p><p>60bit安全的含义：保证安全性的概率为$1-2^{-60 } $</p><p>旧的安全性带来的参数要求：</p><ul><li>10000参与方，33%恶意，60bit安全，分片的大小为5886；</li><li>30bit的话，分片大小为3000；</li></ul><p>为了保证分片大小为几百，可以考虑降低安全性</p><p>区块链的安全性包含2个性质</p><ul><li>活性：交易在一定时间内会被打包，活性门限记作$L$</li><li>安全性：节点对输出的交易序列达成一致，安全性对应的门限记作$S$</li></ul><p>现有方案考虑的是最坏情况下的界，导致了活性和安全性的界相同</p><h2 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h2><p>采用活性和安全性分开的思想，企图实现尽可能小的分片大小，主要面对半同步网络（可以适用于同步网络），协议开始时采用激进的设置，活性门限较低（$S=0.89,L=0.05$），这样的设计会导致较小的分片大小，但是分片可能会死锁，因此引入了独立的一条链control-chain来检测分片的活性，分片需要向控制链发送heartbeat心跳交易，控制链可以解散死锁的分片，然后建立一个新的带有更高活性的分片，迭代直到寻找到了能够找到保持活性的最小分片大小；另一方面，没有检测到死锁时，可以动态降低分片的大小，已达到最优的分片大小</p><p>下面是两类实施本文方案的方法</p><ul><li>部分同步网络</li></ul><p>对于10000个节点，$L=0\%,S=99\%,Size=35\to L=30\%,S=39\%,Size=1713$</p><ul><li>混合模式</li></ul><p>能够运行同步的CC容忍50%的恶意敌手比例，在分片内为部分同步网络，能够切换到同步网络下（25%的恶意敌手之前）</p><p>静态与适应性安全：当敌手能够立即腐化超过半数委员会成员时，基于诚实大多数委员会保证安全的分片协议都基本会失败。Free2Shard能够容忍动态敌手，假设的安全模型不同，无法直接比较。如果假设腐化有时间延迟，可以通过重新选择委员会的方法保证安全性。</p><p>跨片通信：本文的分片可能丧失活性，依赖control-chain进行保证，基本思想是将相关交易的merkle树值包含在心跳信息中</p><p>UC形式化：给出了分片区块链的理想功能，证明了UC-realize，本文是第一个实现了任意组合下的安全性的分片区块链</p><h2 id="Technical-Overview"><a href="#Technical-Overview" class="headerlink" title="Technical Overview"></a>Technical Overview</h2><ul><li>Control chain 建模为一种定时的账本功能，对消息进行排序、打上时间戳。更形式化来说是全排序的广播，带有一致性和时间戳保证<ul><li>CC被所有参与方执行，但是仅存储分片的大小</li></ul></li><li>分片：建模为账本功能，参数包括分片委员会的大小和敌手比例<ul><li>协议不保证领导者恶意时的活性，因为可以利用cc进行恢复<ul><li>代价是需要经常更新委员会，解决无响应leader的机制更加复杂了</li></ul></li></ul></li><li>协议：协议的目标是实现一种分片的账本，开始时所有分片的委员会尽可能小，利用CC进行初始化和委员会重新选举<ul><li>协议的核心在于心跳消息，是的CC能够实时评估分片的活性，通过要求分片周期性发送区块的哈希值来实现，每次发送一个区块会设置一个超时时间，如果下一个有效的区块没有按时到来，分片被认为死锁</li><li>当分片死锁之后，采用更大的委员会重启来保证活性</li></ul></li></ul><h2 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work"></a>Related work</h2><p>目前对于分片区块链的研究，尤其是来自工业界的，对安全性的理解是启发式的，没有形式化的安全证明，因此这部分介绍少数几个知名的分片区块链</p><p>推荐综述[AFT19]Gang Wang, Zhijie Jerry Shi, Mark Nixon, and Song Han. 2019. SoK: Sharding on Blockchain. In Proceedings of the 1st ACM Conference on Advances in Financial Technologies, AFT 2019, Zurich, Switzerland, October 21-23, 2019. ACM, 41–61.<a href="https://doi.org/10.1145/3318041.3355457">https://doi.org/10.1145/3318041.3355457</a></p><p>分片区块链协议</p><ul><li>Elastico是第一个分片区块链，同步 每轮节点解PoW来确定委员会成员，puzzle的随机性来自于上一轮，作者希望实现小的分片委员会大小，但是6轮后不安全的概率为97%，导致协议的不安全</li><li>OmniLedger基于Elastico，PoW引入了身份，但是仅能在敌手小于25%实现高效率（能支持33%但是效率较差）</li><li>RapidChain作为同步的分片协议，能够容忍1/3的恶意敌手，每轮选举委员会，委员会及负责生成随机数</li><li>Monoxide提出了可横向扩展的区块链，提出了若干独立的并行的链，将网络的通信、计算和存储分散到不同区域内，当出现跨区交易时，采用最终原子性技术来保证一致性</li><li>Avarikioti[1]等人的工作提出了一个分片区块链的安全框架，基于比特币骨干协议，但是该框架不满足可组合性</li></ul><p>共性问题</p><ul><li>对于具体参数，委员会的大小必须足够大来保证分片的安全性</li><li>之前的文章没有考虑通用可组合性下的安全性</li></ul><h1 id="Preliminaries"><a href="#Preliminaries" class="headerlink" title="Preliminaries"></a>Preliminaries</h1><h2 id="安全模型"><a href="#安全模型" class="headerlink" title="安全模型"></a>安全模型</h2><p>需要给出同步和部分同布网络下UC安全的记号，假设参与方能够访问可靠的网络功能，时延上限为$\Delta_{NET}$，假设存在理想的签名功能，为了简洁，不给出所有功能的模型，而是给出参考文献，安全地实现本协议是一个很难并且独立的任务</p><ul><li>时间功能$\mathcal{F}_{CLOCK}$本质上等同于假设完美的同步 离散时钟，利用time slot表示两个时间刻度之间的间隙，也称tick，两个诚实参与者$P_i,P_j$分别在$r_i,r_j$时刻，则满足$|r_i-r_j|\leq 1$，参与者能够执行任意多项式复杂度的计算</li><li>网络$\mathcal{F}^{\Delta_{NET}}_{N-MC}$ 允许参与者进行多播消息，时延上限为$\Delta_{NET}$，当参与者对该上限不知情时是部分同步网络</li><li>敌手模型 考虑被腐化的敌手是静态的，5.3有扩展到适应性腐化的内容</li></ul><h1 id="Ledger-Functionalitiies"><a href="#Ledger-Functionalitiies" class="headerlink" title="Ledger Functionalitiies"></a>Ledger Functionalitiies</h1><h2 id="Sharded-Timed-Ledger"><a href="#Sharded-Timed-Ledger" class="headerlink" title="Sharded Timed Ledger"></a>Sharded Timed Ledger</h2><p>时序账本的账本$\mathcal{F}^\Delta_{BD-TL}$ 允许所有参与者输入消息，消息会被全局排序，提供时间戳，能保证一致性和活性</p><p><img src="/2023/08/18/GearBox/image-20230819180300128.png" alt="image-20230819180300128"></p><p>一致性要求了诚实节点的输出一定存在前缀的关系；活性要求发送的消息在$\Delta$时间内会出现在诚实节点的消息列表中</p><p>定义 $\mathcal{F}^\Delta_{BD-TL}:=\mathcal{F}^{\Delta,1}_{BD-STL}$，是仅有1个分片的特殊情况</p><p>时序账本可以用BFT类共识Hotstuff 或者 PoW的区块链来实现</p><p>分片的时序账本：简单来说是多个并行的时序账本的集合，每个独立的账本都是一个分片，假设分片的数量固定，每个分片有独立的标识符$sid$，以下给出$\mathcal{F}^{\Delta,1}_{BD-STL}$的形式化定义</p><p><img src="/2023/08/18/GearBox/image-20230819182237876.png" alt="image-20230819182237876"></p><p>和传统的链质量 链增长链前缀定义不同，看起来更简洁（？</p><p>本文的形式化更接近于 基于性质的定义，而不是传统的UC安全的定义</p><p>输出给敌手的含义是 对应的行为会向敌手泄露对应的行为发生了</p><h2 id="Shards"><a href="#Shards" class="headerlink" title="Shards"></a>Shards</h2><p>本质上一个分片就是一个账本，本文的定义为$\mathcal{F}^{s,\mathcal{L},\Delta}_{SHARD}$，由委员会的大小$s$，活性相关的敌手结构$\mathcal{L}$定义</p><p>敌手结构$\mathcal{L}$是一个集合，指分片功能必须在$(P_{i_1},\dots,P_{i_t})$为腐化节点时保持活性，其中$(P_{i_1},\dots,P_{i_t})\subset \mathcal{L}$</p><p>分片内的节点可以通过<code>SEND</code>命令发送交易，可以利用<code>CLOSE</code>命令关闭分片</p><p>分片需要保证的性质分别是</p><ul><li>证明的完备性：只有正确的描述才能产生有效的证明</li><li>抗审查性：防止敌手排除特定消息<ul><li>是活性不满足的情况下的一种保证</li></ul></li></ul><p><img src="/2023/08/18/GearBox/image-20230819184837902.png" alt="image-20230819184837902"></p><p><img src="/2023/08/18/GearBox/image-20230819185706285.png" alt="image-20230819185706285"></p><h1 id="Committee-selection-and-shard-consensus"><a href="#Committee-selection-and-shard-consensus" class="headerlink" title="Committee selection and shard consensus"></a>Committee selection and shard consensus</h1><p>分片的核心部分，讨论如何实现随机信标并分析委员会的大小</p><h2 id="Committee-selection"><a href="#Committee-selection" class="headerlink" title="Committee selection"></a>Committee selection</h2><p>委员会选择功能：$\mathcal{F}^{\mathcal{P,U}}_{COMSEL}$，其中集合$P$是参加委员会选择的节点，集合$\mathcal{U}$是委员会节点被选择出的集合</p><p>U和P的区别不明确</p><p><img src="/2023/08/18/GearBox/image-20230820091849435.png" alt="image-20230820091849435"></p><p><img src="/2023/08/18/GearBox/image-20230820091905102.png" alt="image-20230820091905102"></p><p>给出的选择方法看上去是随机选，实际上公有链上需要基于资源进行选择，因此需要一个虚拟的参与方集合  $\mathcal{U}$，这个集合是根据节点的资源生成的，因此不是简单的随机选</p><p>利用random beacon实现 $\mathcal{F}^{\mathcal{P,U}}_{COMSEL}$，所有参与者可以均匀随机选择随机性并且验证，具体实现是利用随机信标从$\mathcal{U}$中随机选一个$s$长的序列即可</p><p>Remark：目前实现中$\mathcal{U}$对应的是所有参与者，即一个参与者可能会出现在多个分片中，实际需要更复杂的机制来限制一个节点能够被分配的分片个数</p><p>其他实现委员会选择的方法：PoW和PoS，PoS可以分为：</p><ul><li>基于硬币投掷的随机性信标的均匀随机委员会选择</li><li>基于可验证随机函数的偏倚委员会选择（不满足抗偏置性，效率更高）</li></ul><h2 id="Shard-Consensus"><a href="#Shard-Consensus" class="headerlink" title="Shard Consensus"></a>Shard Consensus</h2><p>实现3.2中分片功能</p><p>$t_L$是活性能容忍的腐化节点数量，对应的安全性为$t_s:=s-2t_L-1$，仅在对应委员会大小下安全</p><p>调用$\mathcal{F}_{CT}^{\mathcal{P,D}}$能够获得大小为$s$的均匀随机的委员会，委员会的第一个成员作为特殊的leader，称为sequencer，周期性地提出新区块，如果至少$s-t_L$个人签署则认为有效</p><p>传统的BFT有换主的协议，本协议有外部的利用cc进行更换委员会的方式，不需要换主机制</p><p>因此分片活性的条件是至多$t_L$个腐化节点与领导者诚实</p><script type="math/tex; mode=display">\mathcal{F}_{SHARD}^{s,\mathcal{L},\Delta},\mathcal{L}=\{A\subseteq \{1,\dots,s \} |A|\leq t_L \land 1 \notin A \}</script><p>为了保证抗审查性，每个参与者发送新交易时包含若干旧交易，如果排序者没有包含这些就消息，拒绝为区块签名（丧失活性）</p><p>同样可以实现带有换主的分片共识，考虑到直接更换委员会效率较低，对应的功能为</p><script type="math/tex; mode=display">\mathcal{F}_{SHARD}^{s,\mathcal{L},\Delta},\mathcal{L}=\{A\subseteq \{1,\dots,s \} |A|\leq t_L \}</script><h2 id="确定委员会大小"><a href="#确定委员会大小" class="headerlink" title="确定委员会大小"></a>确定委员会大小</h2><p>分片协议需要获得最小的委员会大小$s_{min}$来保证腐化节点的数量小于给定的门限</p><p>超几何分布的形式，其中n是节点总数，s是委员会大小，$t’$是门限</p><script type="math/tex; mode=display">\operatorname{Pr}\left[\text { FAIL }_{t^{\prime}, s}^{t, n}\right]=\sum_{i=t^{\prime}+1}^{i=s} \frac{\left(\begin{array}{l}t \\i\end{array}\right)\left(\begin{array}{c}n-t \\s-i\end{array}\right)}{\left(\begin{array}{l}n \\s\end{array}\right)}</script><p>最大的腐化比例为$t’/s$，能够求出满足$\operatorname{Pr}\left[\text { FAIL }_{t^{\prime}, s}^{t, n}\right]\leq 2^{-\kappa}$的 $\kappa$，给出了python代码如何计算$\kappa$</p><p>委员会大小随着安全性要求指数级增长，因此降低诚实节点比例要求能够显著提高效率</p><p><img src="/2023/08/18/GearBox/image-20230820101337925.png" alt="image-20230820101337925"></p><p>表一给出了不同活性和安全性门限下的最小的委员会大小</p><p><img src="/2023/08/18/GearBox/image-20230820103157673.png" alt="image-20230820103157673"></p><h1 id="Constructing-a-sharded-ledger"><a href="#Constructing-a-sharded-ledger" class="headerlink" title="Constructing a sharded ledger"></a>Constructing a sharded ledger</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>为了实现$\mathcal{F}^{\Delta’,v}_{BD-TL}$，利用$\mathcal{F}^\Delta_{BD-TL}$作为控制链，$\mathcal{F}_{REPO}$存储分片确定的账本和之前的状态</p><p>反映了至少需要一方始终存储每个分片的状态的事实，分片功能有多个档位，即$\mathcal{F}_{SHARD}^{s_1,\mathcal{L},\Delta},\dots,\mathcal{F}_{SHARD}^{s_l,\mathcal{L},\Delta}$，其中委员会的大小逐渐增大</p><p>每个分片的共识协议 网络延迟和 活性结构均可以不同，分了方便分析固定了活性结构，延迟，活性保证$\gamma&gt;0$</p><p>GearBox能够保证两个性质</p><ul><li>安全性：对于每个大小为$s_i$的委员会，$\mathcal{F}_{SHARD}^{s_i,\mathcal{L},\Delta}$不满足安全性概率为$2^{-\kappa}$</li><li>Eventually live 最终活性：$\mathcal{F}_{SHARD}^{s_i,\mathcal{L},\Delta}$满足活性概率至少为$\gamma$</li></ul><p>首先运行$\mathcal{F}_{SHARD}^{s_1,\mathcal{L},\Delta}$观察是否满足活性，如果丧失活性则切换为$\mathcal{F}_{SHARD}^{s_2,\mathcal{L},\Delta}$，到达最大档位之后就是重启了</p><p>最坏情况下，$L=0.3,S=0.39$ 依然强于现有的共识方案</p><h2 id="分片区块链协议-Pi-BD-STL"><a href="#分片区块链协议-Pi-BD-STL" class="headerlink" title="分片区块链协议$\Pi_{BD-STL}$"></a>分片区块链协议$\Pi_{BD-STL}$</h2><p>检测活性失败的方法可以归纳为几类</p><ul><li>分片管理：$\mathcal{P}$中所有参与者执行的协议，为了维持分片的活性</li><li>分片操作：分片委员会成员的行为，仅执行与当前委员会相关的分片管理行为</li></ul><p>获得输入后，参与方执行实现了对应接口的指令</p><p>经典的一页协议</p><p><img src="/2023/08/18/GearBox/image-20230820111300956.png" alt="image-20230820111300956" style="zoom: 63%;"></p><p><img src="/2023/08/18/GearBox/image-20230820111322916.png" alt="image-20230820111322916"></p><p><img src="/2023/08/18/GearBox/image-20230820111404496.png" alt="image-20230820111404496" style="zoom:125%;"></p><p>定理5.1：以上协议在部分同步网络，静态敌手假设下 在 实现了UC 功能$\mathcal{F}_{BD-STL}^{\Delta’,v}$</p><p><img src="/2023/08/18/GearBox/image-20230820112558207.png" alt="image-20230820112558207"></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li>降低档位</li><li>适应性和移动腐化模型：重新选择委员会</li></ul><h2 id="跨片交易处理和通信"><a href="#跨片交易处理和通信" class="headerlink" title="跨片交易处理和通信"></a>跨片交易处理和通信</h2><p>本文不给出形式化的跨片通信机制的介绍</p><p>因为分片很可能重新启动，分片的交易不能立即认为有效，需要依赖控制链的CC交易，后续给出将gearbox利用到现有方案的方法</p><ul><li>Atomix（OmniLedger的跨片交易处理机制）：分片A的用户向发起到分片B的交易时，首先在A内发起export交易锁定金额，当export交易在A中被记录后，用户向B发送证明证明自己的交易被A接收了<ul><li>如果采用gearbox，可能导致A中的金额被锁定，B中被解锁，但是A在发送heartbeat之前崩溃了，导致双花</li><li>改进：用户的证明还需要证明该交易已经被CC确定了</li><li>分片的性能不受制于CC，因为一个heartbeat消息能够包含分片内的所有交易，即和跨片交易数量独立</li><li><img src="/2023/08/18/GearBox/image-20230820114026946.png" alt="image-20230820114026946"></li></ul></li><li>分片委员会驱动的跨片交易处理：分片的leader直接发送证明，开销转嫁到leader</li><li>向包含了证明的用户发放奖励，如果用户和leader都未能对跨片交易给出证明的话，存在激励机制鼓励其他用户进行</li></ul><h1 id="Instantiations"><a href="#Instantiations" class="headerlink" title="Instantiations"></a>Instantiations</h1><h2 id="Instantiation-of-Timed-Ledger"><a href="#Instantiation-of-Timed-Ledger" class="headerlink" title="Instantiation of Timed Ledger"></a>Instantiation of Timed Ledger</h2><p>之前都是模块化的设计，后续给出一个具体的协议</p><p>采用Hotstuff进行$\mathcal{F}_{BD-TL}^{\Delta}$，因为是固定换主的协议，但是不提供时间戳，leader将当前时间作为时间戳加入（假设weakly synchrnized clocks）</p><p>因为并不是所有的参与者需要从CC读写，CC需要满足1/3的安全性，最大为16037</p><h2 id="Instantiation-of-Shard-Consensus-and-Gearbox"><a href="#Instantiation-of-Shard-Consensus-and-Gearbox" class="headerlink" title="Instantiation of Shard Consensus and Gearbox"></a>Instantiation of Shard Consensus and Gearbox</h2><p>可以选择一种没有领导者替换或者像Hotstuff这种实现了领导者轮换制的共识协议，后续的分析主要是Hotstuff</p><p>具体可以选4个档位，活性的门限设置为10% 20% 25% 30%</p><h2 id="Instantiation-of-Randomness-Beacon"><a href="#Instantiation-of-Randomness-Beacon" class="headerlink" title="Instantiation of Randomness Beacon"></a>Instantiation of Randomness Beacon</h2><ul><li>可以采用外部无偏的随机数信标  <a href="https://drand.love/">Drand - Distributed Randomness Beacon.</a></li></ul><p>网页做的很好看</p><p><img src="/2023/08/18/GearBox/image-20230820151942150.png" alt="image-20230820151942150"></p><ul><li>可以采用外部PoS生成的公开可验证的随机数</li></ul><p>为了使用一种自给的方案，而不是依赖基于Hotstuff的CC，传统的PoS随机信标</p><p>UC安全的PVSS(ALBATROSS)要求每个参与方417120模幂运算，需要在CC链上写21.2Mbytes</p><p>VRF的效率更高，2112模幂+0.065MBytes的通信，然而存在偏置性，可以通过轻微增大委员会大小来减轻开销</p><h2 id="Efficiency-Analysis-of-Overall-Protocol"><a href="#Efficiency-Analysis-of-Overall-Protocol" class="headerlink" title="Efficiency Analysis of Overall Protocol"></a>Efficiency Analysis of Overall Protocol</h2><h3 id="为了活性需要选择的委员会个数"><a href="#为了活性需要选择的委员会个数" class="headerlink" title="为了活性需要选择的委员会个数"></a>为了活性需要选择的委员会个数</h3><ul><li>实际的敌手腐化比例为10%<ul><li>需要leader诚实，概率为90%</li><li>预期的委员会个数为2</li></ul></li><li>实际的腐化比例为30%<ul><li>选择出委员会中敌手比例不超过30%的概率是0.5</li><li>诚实领导者的概率为70%</li><li>期望的委员会个数小于6</li></ul></li></ul><h3 id="延迟和吞吐量"><a href="#延迟和吞吐量" class="headerlink" title="延迟和吞吐量"></a>延迟和吞吐量</h3><p>基于Hotstuff的实验结果,仅支持128节点，对后续的结果进行了推理</p><p>CC链的payload限制为128字节</p><p>延迟大概是$l=0.37s+6$，其中$s$是委员会的大小，约为6s</p><p>吞吐量计算公式约为$t=2400000/l$，约为404msg per sec</p><p>实际处理交易的分片的大小为1024Bytes</p><p>延迟大概是$l=0.67s+20$，其中$s$是委员会的大小，吞吐量计算公式约为$t=2400000/l$</p><p>委员会的大小取82, 232, 528, and 2264，延迟对应为75 175 374 1537 ms，吞吐量为32000,13714,6417和1561，实际的带宽取决于CC链的带宽</p><h3 id="可扩展性和分片数量的界"><a href="#可扩展性和分片数量的界" class="headerlink" title="可扩展性和分片数量的界"></a>可扩展性和分片数量的界</h3><p>由于HotStuff具有线性通信复杂度，而本文的委员会大小是有限的，因此我们的协议在通信复杂度方面具有可扩展性。</p><p>实际的分片数量受CC链的吞吐量限制，若CC链的吞吐量为400，分片每10s发heartbeat消息，则，能支持4000个分片，因此不支持无限的可扩展性，如果确实需要无限可扩展性，可以考虑采用多条CC链</p><h1 id="实验参数的分析"><a href="#实验参数的分析" class="headerlink" title="实验参数的分析"></a>实验参数的分析</h1><p>目标：2000节点，单片共识支持500个节点，单片错误概率小于$10^{-18}$，可扩展为4个分片（但好像不是我们的任务）</p><p><img src="/2023/08/18/GearBox/image-20230821092708085.png" alt="image-20230821092708085"></p><p><img src="/2023/08/18/GearBox/image-20230820185618306.png" alt="image-20230820185618306"></p><p><img src="/2023/08/18/GearBox/image-20230820185137655.png" alt="image-20230820185137655"></p><p>以下是K=18的结果</p><p><img src="/2023/08/18/GearBox/image-20230820185118323.png" alt="image-20230820185118323"></p><h1 id="Video"><a href="#Video" class="headerlink" title="Video"></a>Video</h1><p>链接：<a href="https://www.youtube.com/watch?v=pmeVnbRlJyQ&amp;ab_channel=TPBC">GearBox: An Efficient UC Sharded Ledger Leveraging the Safety-Liveness Dichotomy - YouTube</a></p><p><img src="/2023/08/18/GearBox/image-20230818184146046.png" alt="image-20230818184146046"></p><p>带入实际参数，想要满足安全性的话需要的节点太多，只能分2个片</p><p><img src="/2023/08/18/GearBox/image-20230818184310857.png" alt="image-20230818184310857"></p><p>如何进行优化</p><ul><li>降低全局敌手比例的界，找到实际中更精确的界</li><li>提高失败比例，比如40bit安全性可接受？</li></ul><p><img src="/2023/08/18/GearBox/image-20230818184637028.png" alt="image-20230818184637028"></p><p>仍然不够，实际的BFT算法超过1000节点效率就不高了</p><p>终极目标是：安全性不变，通过更少的分片内节点的数量，实现更高的效率（吞吐量）</p><p>如果想要保证安全性（全局敌手比例+60bit），只能从片内敌手比例入手了</p><p><img src="/2023/08/18/GearBox/image-20230818185205913.png" alt="image-20230818185205913"></p><p>当支持的片内敌手比例达到44%以下后，就需要1000个以上的节点了</p><p>难道不需要片内30%的比例来保证安全性吗？</p><p>本方案给出 安全性和活性二分法 来解决这个问题</p><p><img src="/2023/08/18/GearBox/image-20230818185503978.png" alt="image-20230818185503978"></p><p>如果$L=S$，就是之前的解</p><p>对于活性，假设诚实节点不会为冲突的区块签名，则活性可以归纳为</p><p><img src="/2023/08/18/GearBox/image-20230818190028903.png" alt="image-20230818190028903"></p><p>对于安全性，已知$2L+S&lt;1$成立，白色部分是剩下的部分</p><p><img src="/2023/08/18/GearBox/image-20230818190256418.png" alt="image-20230818190256418"></p><p>假设2个区块冲突了，即不满足安全性，则每个都被至少$1-L$个签名了，则同时为2个区块签名的节点数量（交叉的部分）大于$S$，即存在诚实节点为冲突的区块背书了，产生了冲突（不成立）</p><p>则得出结论：敌手比例小于$S$，能够满足安全性</p><p>问题：没有给出$2L+S&lt;1$的根据，在完整版论文的附录A</p><p><img src="/2023/08/18/GearBox/image-20230818190506447.png" alt="image-20230818190506447"></p><p>实际中一个更好的协议需要考虑</p><ul><li>最坏情况下，能够达到30%（半同步</li><li>一般情况下敌手比例会小于30%</li><li>当敌手比例小的时候，有更好的效率</li></ul><p><img src="/2023/08/18/GearBox/image-20230818191344481.png" alt="image-20230818191344481"></p><p>本方案类似于汽车的手动挡，安全性一定保证，活性以概率保证（丧失活性的概率是$2^\kappa$，以下是实现的结果</p><p><img src="/2023/08/18/GearBox/image-20230818191416876.png" alt="image-20230818191416876"></p><p>难点在于想要实现活性，但是不知道具体的敌手比例</p><p>解决方案是利用一条监控的链， 采用$S=L=1/3$，能够检测出活性不满足的情况</p><p>还需要解决死锁问题（不是传统意义的死锁，指丧失活性后。当分片需要调整安全性，换挡）</p><p><img src="/2023/08/18/GearBox/image-20230818193049568.png" alt="image-20230818193049568"></p><p><img src="/2023/08/18/GearBox/image-20230818193129685.png" alt="image-20230818193129685"></p><p>总结</p><ul><li>最主要的贡献：给出了将活性和安全性分开的两个不等式</li><li>提出了根据具体情况牺牲活性，来提高效率的思想</li><li>给出了UC安全的证明（看不懂</li></ul><p>可研究的点</p><ul><li>目前所有分片都从最低档开始逐级提高活性，能否有其他的机制，一步达到最优的活性的解<ul><li>首先运行少数分片实例</li><li>等待首批分片达到活性后，采用首批分片达到活性时的平均值作为其其余分片的初始配置</li></ul></li><li>本文实际上的分片是要求所有共识节点维护一条全局的链来收集状态，另外分片再维护分片的链进行交易处理<ul><li>Control Chain带来的开销需要考虑</li><li>考虑如何优化这种架构</li></ul></li><li>具体如何实现这个共识没有开源</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;GearBox-Optimal-size-Shard-Committees-by-Leveraging-the-Safety-Liveness-Dichotomy&quot;&gt;&lt;a href=&quot;#GearBox-Optimal-size-Shard-Committees-by-Leveraging-the-Safety-Liveness-Dichotomy&quot; class=&quot;headerlink&quot; title=&quot;GearBox: Optimal-size Shard Committees by Leveraging the Safety-Liveness Dichotomy&quot;&gt;&lt;/a&gt;GearBox: Optimal-size Shard Committees by Leveraging the Safety-Liveness Dichotomy&lt;/h1&gt;&lt;p&gt;David B, Magri B, Matt C, et al. GearBox: Optimal-size Shard Committees by Leveraging the Safety-Liveness Dichotomy[C]//Proceedings of the 2022 ACM SIGSAC Conference on Computer and Communications Security. 2022: 683-696.&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/categories/Blockchain/"/>
    
    
    <category term="BlockChain" scheme="https://alleysira.github.io/tags/BlockChain/"/>
    
    <category term="Sharding" scheme="https://alleysira.github.io/tags/Sharding/"/>
    
  </entry>
  
  <entry>
    <title>blockchain_security_practice</title>
    <link href="https://alleysira.github.io/2023/08/08/blockchain-security-practice/"/>
    <id>https://alleysira.github.io/2023/08/08/blockchain-security-practice/</id>
    <published>2023-08-08T07:24:54.000Z</published>
    <updated>2023-09-07T08:52:49.637Z</updated>
    
    <content type="html"><![CDATA[<p>记录进行区块链安全相关实践的内容</p><span id="more"></span><h1 id="Etherscan"><a href="#Etherscan" class="headerlink" title="Etherscan"></a>Etherscan</h1><p>网址 <a href="https://etherscan.io/">Ethereum (ETH) Blockchain Explorer (etherscan.io)</a></p><p>该地址下可以看到已经部署验证后的合约<a href="https://etherscan.io/contractsVerified">Ethereum Verified Contracts</a></p><p>以<a href="https://goerli.etherscan.io/address/0xD1077555f910F90EFC8Bd755EaA9B2772907189D#code">ERC20Staking</a>合约为例，能够看到合约的源代码，合约的ABI、合约的合约创建代码和合约的部署字节码</p><ul><li><p>合约创建代码定义了合约的初始状态、功能和行为。通常包括合约的构造函数和初始状态设置。以字节码的形式存在</p></li><li><p>合约的部署字节码，也称为运行时字节码，是智能合约在部署到以太坊网络后实际运行的字节码表示形式</p></li></ul><p><img src="/2023/08/08/blockchain-security-practice/image-20230808153518780.png" alt="image-20230808153518780"></p><p>可以对合约的字节代码进行反编译</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230808153721923.png" alt="image-20230808153721923"></p><p>顺便测试之前老师提到的 智能合约反编译的网站 <a href="https://ethervm.io/decompile">https://ethervm.io/decompile</a></p><p>填写合约地址，选择对应的测试网后能够进行反编译，给出合约的public函数和internal函数，合约源代码以及反汇编的结果</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230808154346951.png" alt="image-20230808154346951" style="zoom: 67%;"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230808154435450.png" alt="image-20230808154435450"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230808154716045.png" alt="image-20230808154716045"></p><h2 id="Blocksec-MetaDock"><a href="#Blocksec-MetaDock" class="headerlink" title="Blocksec-MetaDock"></a>Blocksec-MetaDock</h2><p>安装了MetaDock之后能够在浏览器的IDE中直接查看合约的源代码</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230808162645237.png" alt="image-20230808162645237"></p><ul><li>[ ] 但是好像没有之前老师的下载zip的功能，后续再请教一下老师</li></ul><h2 id="安装solidity编译器"><a href="#安装solidity编译器" class="headerlink" title="安装solidity编译器"></a>安装solidity编译器</h2><p>参考登链社区翻译的 <a href="https://solidity-cn.readthedocs.io/zh/develop/installing-solidity.html">文档</a> 在Ubuntu上安装编译器</p><p>最好安装<a href="https://github.com/crytic/solc-select">crytic/solc-select: Manage and switch between Solidity compiler versions (github.com)</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:ethereum/ethereum</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install solc</span><br></pre></td></tr></table></figure><p>安装成功</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230808162254861.png" alt="image-20230808162254861"></p><p>写了一个简单的合约后采用solc进行编译，下载的编译器版本只能编译0.8.21的合约</p><p>采用 <code>--bin</code> 参数能够在命令行直接输出字节码</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230808164530260.png" alt="image-20230808164530260"></p><p>采用<code>--abi --opcodes</code>参数能分别显示合约的abi和操作码</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230808164836841.png" alt="image-20230808164836841"></p><p>加-o 参数可以把编译结果写入文件</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230808165222863.png" alt="image-20230808165222863"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230808165241088.png" alt="image-20230808165241088"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230808165357492.png" alt="image-20230808165357492"></p><p>合约的源码 字节码和操作码之间的关系：</p><ul><li>源代码是人类可读的智能合约程序代码，通常使用 Solidity 这样的高级编程语言编写。源码首先被编译成EVM操作码，再被被编码成字节码 </li><li>操作码是EVM的基本指令，包括数学运算、位运算、流程控制等</li><li>字节码是合约在区块链上实际执行的形式，包括操作码opcode和操作数operand，每个字节对应一个操作码或者操作数；操作码一般是1个字节，操作数可以是多个字节</li></ul><h1 id="Ganache和MetaMask"><a href="#Ganache和MetaMask" class="headerlink" title="Ganache和MetaMask"></a>Ganache和MetaMask</h1><p><img src="/2023/08/08/blockchain-security-practice/image-20230809123056555.png" alt="image-20230809123056555" style="zoom:67%;"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230809123117003.png" alt="image-20230809123117003"></p><p>可以查看发币的交易</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230809123156744.png" alt="image-20230809123156744"></p><p>领取LINK token</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230809123255480.png" alt="image-20230809123255480"></p><p>安装好Ganathe后，将一个账户的私钥导入metamask并添加测试网络，填写RPC和链ID等信息</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230809150904086.png" alt="image-20230809150904086"></p><p>成功将metamask与ganathe连接</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230809123908501.png" alt="image-20230809123908501"></p><h1 id="Remix"><a href="#Remix" class="headerlink" title="Remix"></a>Remix</h1><p>将合约部署在测试网Sepolia上</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230809152038862.png" alt="image-20230809152038862"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230809152103463.png" alt="image-20230809152103463"></p><p>将合约部署在Ganathe上</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230809151550887.png" alt="image-20230809151550887"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230809151841133.png" alt="image-20230809151841133"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230809151740084.png" alt="image-20230809151740084"></p><h1 id="Smartbugs工具使用"><a href="#Smartbugs工具使用" class="headerlink" title="Smartbugs工具使用"></a>Smartbugs工具使用</h1><p>Smartbugs集成了19种智能合约漏洞检查的工具，并提供了统一的调用接口，现已为2.0版本（还挂在arxiv上</p><p>项目地址 <a href="https://github.com/smartbugs/smartbugs">smartbugs/smartbugs: SmartBugs: A Framework to Analyze Ethereum Smart Contracts (github.com)</a></p><p>支持的工具包括</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230808161355316.png" alt="image-20230808161355316" style="zoom:67%;"></p><p>对分析后结果进行解析，方便肉眼查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./reparse results <span class="comment"># 获得json</span></span><br><span class="line">./results2csv -p results &gt; results.csv <span class="comment">#得到csv文件</span></span><br></pre></td></tr></table></figure><p><img src="/2023/08/08/blockchain-security-practice/image-20230809104309202.png" alt="image-20230809104309202"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230809104629946.png" alt="image-20230809104629946"></p><h2 id="Confuzzius"><a href="#Confuzzius" class="headerlink" title="Confuzzius"></a>Confuzzius</h2><p>项目地址 <a href="https://github.com/christoftorres/ConFuzzius">christoftorres/ConFuzzius: A data dependency-aware hybrid fuzzer for Ethereum smart contracts (EuroS&amp;P 2021). (github.com)</a> 玩了个孔子的谐音梗</p><p>下载作者提供的docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull christoftorres/confuzzius</span><br><span class="line">docker run -i -t christoftorres/confuzzius</span><br><span class="line">python3 fuzzer/main.py -s examples/TokenSale/contracts/TokenSale.sol -c TokenSale --solc v0.4.26 --evm byzantium -t 10</span><br></pre></td></tr></table></figure><p>测试的合约是被测试合约为TokenSale.sol，比较简单</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.26;</span><br><span class="line"></span><br><span class="line">interface Token &#123;</span><br><span class="line">  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);</span><br><span class="line">  function allowance(address owner, address spender) external view returns (uint256);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract TokenSale &#123;</span><br><span class="line">  uint256 start = now;</span><br><span class="line">  uint256 end = now + 30 days;</span><br><span class="line">  address wallet = 0xCafEBAbECAFEbAbEcaFEbabECAfebAbEcAFEBaBe;</span><br><span class="line">  Token token = Token(0x1234567812345678123456781234567812345678);</span><br><span class="line"></span><br><span class="line">  address owner;</span><br><span class="line">  bool sold;</span><br><span class="line"></span><br><span class="line">  function Tokensale() public &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function buy() public payable &#123;</span><br><span class="line">    require(now &lt; end);</span><br><span class="line">    require(msg.value == 42 ether + (now - start) / 60 / 60 / 24 * 1 ether);</span><br><span class="line">    require(token.transferFrom(this, msg.sender, token.allowance(wallet, this)));</span><br><span class="line">    sold = true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function withdraw() public &#123;</span><br><span class="line">    require(msg.sender == owner);</span><br><span class="line">    require(now &gt;= end);</span><br><span class="line">    require(sold);</span><br><span class="line">    owner.transfer(address(this).balance);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验结果显示代码覆盖率非常优秀，能够检测出区块信息依赖和以太币泄露漏洞</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230726161506767.png" alt="image-20230726161506767"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230726161452774.png" alt="image-20230726161452774"></p><p>能够给出具体产生漏洞的交易序列：</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230726161536978.png" alt="image-20230726161536978"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230726161548380.png" alt="image-20230726161548380"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230726161601382.png" alt="image-20230726161601382"></p><h3 id="测试较为复杂的合约WalletLibrary"><a href="#测试较为复杂的合约WalletLibrary" class="headerlink" title="测试较为复杂的合约WalletLibrary"></a>测试较为复杂的合约WalletLibrary</h3><p><img src="/2023/08/08/blockchain-security-practice/image-20230726161201164.png" alt="image-20230726161201164"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230726161215584.png" alt="image-20230726161215584"></p><p>代码覆盖率依然比较优秀，74.99%（2881/3842），单个合约仅10.62s</p><h2 id="Mythril"><a href="#Mythril" class="headerlink" title="Mythril"></a>Mythril</h2><p>这个工具是HITB大会上Smashing Ethereum Smart Contracts for Fun and Real Profit这篇报告对应的工具，据Confuzzius作者在论文中提到，是Smartbugs1.0工具中效果最好的</p><p>项目地址 <a href="https://github.com/Consensys/mythril">Consensys/mythril: Security analysis tool for EVM bytecode. Supports smart contracts built for Ethereum, Hedera, Quorum, Vechain, Roostock, Tron and other EVM-compatible blockchains. (github.com)</a></p><h3 id="Smartbugs内的测试"><a href="#Smartbugs内的测试" class="headerlink" title="Smartbugs内的测试"></a>Smartbugs内的测试</h3><p>测试samples目录下所有合约</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jie@jie-virtual-machine:~/smartbugs$ ./smartbugs -t mythril -f samples/*.sol --processes 2 --mem-limit 4g --timeout 600</span><br></pre></td></tr></table></figure><p><img src="/2023/08/08/blockchain-security-practice/image-20230808190913454.png" alt="image-20230808190913454"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230808191054123.png" alt="image-20230808191054123"></p><h3 id="安装作者提供的工具"><a href="#安装作者提供的工具" class="headerlink" title="安装作者提供的工具"></a>安装作者提供的工具</h3><p>下载作者提供的docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mythril/myth</span><br></pre></td></tr></table></figure><p>参考文档<a href="https://mythril-classic.readthedocs.io/en/master/installation.html#docker">官方文档</a>进行调用</p><p>windows没跑出结果，已经在github上跟作者反应了，<a href="https://github.com/Consensys/mythril/issues/1790">Issues · Consensys/mythril (github.com)</a>，怀疑是powershell的问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@jie-virtual-machine:~$ docker run mythril/myth a /opt/mythril/solidity_examples/calls.sol mythril.interfaces.cli [ERROR]: Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/mythril/interfaces/cli.py&quot;</span>, line 966, <span class="keyword">in</span> parse_args_and_execute</span><br><span class="line">    address = load_code(disassembler, args)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/mythril/interfaces/cli.py&quot;</span>, line 717, <span class="keyword">in</span> load_code</span><br><span class="line">    address, _ = disassembler.load_from_solidity(</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/mythril/mythril/mythril_disassembler.py&quot;</span>, line 252, <span class="keyword">in</span> load_from_solidity</span><br><span class="line">    solc_binary = self.solc_binary or util.extract_binary(file)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/mythril/ethereum/util.py&quot;</span>, line 227, <span class="keyword">in</span> extract_binary</span><br><span class="line">    with open(file) as f:</span><br><span class="line">FileNotFoundError: [Errno 2] No such file or directory: <span class="string">&#x27;/opt/mythril/solidity_examples/calls.sol&#x27;</span></span><br></pre></td></tr></table></figure><p>换了Ubuntu之后，可以成功挂载本地合约进行测试了</p><p>实验命令和实验结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><span class="line">jie@jie-virtual-machine:~$ docker run -v $(<span class="built_in">pwd</span>):/tmp mythril/myth analyze /tmp/contracts/calls.sol</span><br><span class="line">==== External Call To User-Supplied Address ====</span><br><span class="line">SWC ID: 107</span><br><span class="line">Severity: Low</span><br><span class="line">Contract: Caller</span><br><span class="line">Function name: thisisfine()</span><br><span class="line">PC address: 461</span><br><span class="line">Estimated Gas Usage: 2077 - 36971</span><br><span class="line">A call to a user-supplied address is executed.</span><br><span class="line">An external message call to an address specified by the <span class="built_in">caller</span> is executed. Note that the callee account might contain arbitrary code and could re-enter any <span class="keyword">function</span> within this contract. Reentering the contract <span class="keyword">in</span> an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are <span class="keyword">in</span> place.</span><br><span class="line">--------------------</span><br><span class="line">In file: /tmp/contracts/calls.sol:15</span><br><span class="line"></span><br><span class="line">fixed_address.call(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">--------------------</span><br><span class="line">Initial State:</span><br><span class="line"></span><br><span class="line">Account: [CREATOR], balance: 0x0, nonce:0, storage:&#123;&#125;</span><br><span class="line">Account: [ATTACKER], balance: 0x0, nonce:0, storage:&#123;&#125;</span><br><span class="line"></span><br><span class="line">Transaction Sequence:</span><br><span class="line"></span><br><span class="line">Caller: [CREATOR], calldata: 000000000000000000000000deadbeefdeadbeefdeadbeefdeadbeefdeadbeef0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, decoded_data: , value: 0x0</span><br><span class="line">Caller: [CREATOR], <span class="keyword">function</span>: thisisfine(), txdata: 0x5a6814ec, value: 0x0</span><br><span class="line"></span><br><span class="line">==== Unchecked <span class="built_in">return</span> value from external call. ====</span><br><span class="line">SWC ID: 104</span><br><span class="line">Severity: Medium</span><br><span class="line">Contract: Caller</span><br><span class="line">Function name: thisisfine()</span><br><span class="line">PC address: 461</span><br><span class="line">Estimated Gas Usage: 2077 - 36971</span><br><span class="line">The <span class="built_in">return</span> value of a message call is not checked.</span><br><span class="line">External calls <span class="built_in">return</span> a boolean value. If the callee halts with an exception, <span class="string">&#x27;false&#x27;</span> is returned and execution continues <span class="keyword">in</span> the <span class="built_in">caller</span>. The <span class="built_in">caller</span> should check whether an exception happened and react accordingly to avoid unexpected behavior. For example it is often desirable to wrap external calls <span class="keyword">in</span> require() so the transaction is reverted <span class="keyword">if</span> the call fails.</span><br><span class="line">--------------------</span><br><span class="line">In file: /tmp/contracts/calls.sol:15</span><br><span class="line"></span><br><span class="line">fixed_address.call(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">--------------------</span><br><span class="line">Initial State:</span><br><span class="line"></span><br><span class="line">Account: [CREATOR], balance: 0x0, nonce:0, storage:&#123;&#125;</span><br><span class="line">Account: [ATTACKER], balance: 0x0, nonce:0, storage:&#123;&#125;</span><br><span class="line"></span><br><span class="line">Transaction Sequence:</span><br><span class="line"></span><br><span class="line">Caller: [CREATOR], calldata: 00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, decoded_data: , value: 0x0</span><br><span class="line">Caller: [SOMEGUY], <span class="keyword">function</span>: calluseraddress(address), txdata: 0xe1d10f790000000000000000000000000000000000000000000000000000000000000000, decoded_data: (<span class="string">&#x27;0x0000000000000000000000000000000000000000&#x27;</span>,), value: 0x0</span><br><span class="line">Caller: [CREATOR], <span class="keyword">function</span>: thisisfine(), txdata: 0x5a6814ec, value: 0x0</span><br><span class="line"></span><br><span class="line">==== External Call To User-Supplied Address ====</span><br><span class="line">SWC ID: 107</span><br><span class="line">Severity: Low</span><br><span class="line">Contract: Caller</span><br><span class="line">Function name: callstoredaddress()</span><br><span class="line">PC address: 639</span><br><span class="line">Estimated Gas Usage: 2057 - 36951</span><br><span class="line">A call to a user-supplied address is executed.</span><br><span class="line">An external message call to an address specified by the <span class="built_in">caller</span> is executed. Note that the callee account might contain arbitrary code and could re-enter any <span class="keyword">function</span> within this contract. Reentering the contract <span class="keyword">in</span> an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are <span class="keyword">in</span> place.</span><br><span class="line">--------------------</span><br><span class="line">In file: /tmp/contracts/calls.sol:28</span><br><span class="line"></span><br><span class="line">stored_address.call(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">--------------------</span><br><span class="line">Initial State:</span><br><span class="line"></span><br><span class="line">Account: [CREATOR], balance: 0x0, nonce:0, storage:&#123;&#125;</span><br><span class="line">Account: [ATTACKER], balance: 0x0, nonce:0, storage:&#123;&#125;</span><br><span class="line"></span><br><span class="line">Transaction Sequence:</span><br><span class="line"></span><br><span class="line">Caller: [CREATOR], calldata: 00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, decoded_data: , value: 0x0</span><br><span class="line">Caller: [CREATOR], <span class="keyword">function</span>: setstoredaddress(address), txdata: 0x2776b163000000000000000000000000deadbeefdeadbeefdeadbeefdeadbeefdeadbeef, decoded_data: (<span class="string">&#x27;0xdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef&#x27;</span>,), value: 0x0</span><br><span class="line">Caller: [ATTACKER], <span class="keyword">function</span>: callstoredaddress(), txdata: 0xd24b08cc, value: 0x0</span><br><span class="line"></span><br><span class="line">==== Unchecked <span class="built_in">return</span> value from external call. ====</span><br><span class="line">SWC ID: 104</span><br><span class="line">Severity: Medium</span><br><span class="line">Contract: Caller</span><br><span class="line">Function name: callstoredaddress()</span><br><span class="line">PC address: 639</span><br><span class="line">Estimated Gas Usage: 2057 - 36951</span><br><span class="line">The <span class="built_in">return</span> value of a message call is not checked.</span><br><span class="line">External calls <span class="built_in">return</span> a boolean value. If the callee halts with an exception, <span class="string">&#x27;false&#x27;</span> is returned and execution continues <span class="keyword">in</span> the <span class="built_in">caller</span>. The <span class="built_in">caller</span> should check whether an exception happened and react accordingly to avoid unexpected behavior. For example it is often desirable to wrap external calls <span class="keyword">in</span> require() so the transaction is reverted <span class="keyword">if</span> the call fails.</span><br><span class="line">--------------------</span><br><span class="line">In file: /tmp/contracts/calls.sol:28</span><br><span class="line"></span><br><span class="line">stored_address.call(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">--------------------</span><br><span class="line">Initial State:</span><br><span class="line"></span><br><span class="line">Account: [CREATOR], balance: 0x0, nonce:0, storage:&#123;&#125;</span><br><span class="line">Account: [ATTACKER], balance: 0x0, nonce:0, storage:&#123;&#125;</span><br><span class="line"></span><br><span class="line">Transaction Sequence:</span><br><span class="line"></span><br><span class="line">Caller: [CREATOR], calldata: 00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, decoded_data: , value: 0x0</span><br><span class="line">Caller: [SOMEGUY], <span class="keyword">function</span>: calluseraddress(address), txdata: 0xe1d10f790000000000000000000000000000000000000000000000000000000000000000, decoded_data: (<span class="string">&#x27;0x0000000000000000000000000000000000000000&#x27;</span>,), value: 0x0</span><br><span class="line">Caller: [CREATOR], <span class="keyword">function</span>: callstoredaddress(), txdata: 0xd24b08cc, value: 0x0</span><br><span class="line"></span><br><span class="line">==== External Call To User-Supplied Address ====</span><br><span class="line">SWC ID: 107</span><br><span class="line">Severity: Low</span><br><span class="line">Contract: Caller</span><br><span class="line">Function name: reentrancy()</span><br><span class="line">PC address: 777</span><br><span class="line">Estimated Gas Usage: 7090 - 61984</span><br><span class="line">A call to a user-supplied address is executed.</span><br><span class="line">An external message call to an address specified by the <span class="built_in">caller</span> is executed. Note that the callee account might contain arbitrary code and could re-enter any <span class="keyword">function</span> within this contract. Reentering the contract <span class="keyword">in</span> an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are <span class="keyword">in</span> place.</span><br><span class="line">--------------------</span><br><span class="line">In file: /tmp/contracts/calls.sol:19</span><br><span class="line"></span><br><span class="line">fixed_address.call(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">--------------------</span><br><span class="line">Initial State:</span><br><span class="line"></span><br><span class="line">Account: [CREATOR], balance: 0x0, nonce:0, storage:&#123;&#125;</span><br><span class="line">Account: [ATTACKER], balance: 0x0, nonce:0, storage:&#123;&#125;</span><br><span class="line"></span><br><span class="line">Transaction Sequence:</span><br><span class="line"></span><br><span class="line">Caller: [CREATOR], calldata: 000000000000000000000000deadbeefdeadbeefdeadbeefdeadbeefdeadbeef0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, decoded_data: , value: 0x0</span><br><span class="line">Caller: [SOMEGUY], <span class="keyword">function</span>: reentrancy(), txdata: 0xe11f493e, value: 0x0</span><br><span class="line"></span><br><span class="line">==== Unchecked <span class="built_in">return</span> value from external call. ====</span><br><span class="line">SWC ID: 104</span><br><span class="line">Severity: Medium</span><br><span class="line">Contract: Caller</span><br><span class="line">Function name: reentrancy()</span><br><span class="line">PC address: 777</span><br><span class="line">Estimated Gas Usage: 7090 - 61984</span><br><span class="line">The <span class="built_in">return</span> value of a message call is not checked.</span><br><span class="line">External calls <span class="built_in">return</span> a boolean value. If the callee halts with an exception, <span class="string">&#x27;false&#x27;</span> is returned and execution continues <span class="keyword">in</span> the <span class="built_in">caller</span>. The <span class="built_in">caller</span> should check whether an exception happened and react accordingly to avoid unexpected behavior. For example it is often desirable to wrap external calls <span class="keyword">in</span> require() so the transaction is reverted <span class="keyword">if</span> the call fails.</span><br><span class="line">--------------------</span><br><span class="line">In file: /tmp/contracts/calls.sol:19</span><br><span class="line"></span><br><span class="line">fixed_address.call(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">--------------------</span><br><span class="line">Initial State:</span><br><span class="line"></span><br><span class="line">Account: [CREATOR], balance: 0x0, nonce:0, storage:&#123;&#125;</span><br><span class="line">Account: [ATTACKER], balance: 0x0, nonce:0, storage:&#123;&#125;</span><br><span class="line"></span><br><span class="line">Transaction Sequence:</span><br><span class="line"></span><br><span class="line">Caller: [CREATOR], calldata: 00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, decoded_data: , value: 0x0</span><br><span class="line">Caller: [SOMEGUY], <span class="keyword">function</span>: calluseraddress(address), txdata: 0xe1d10f790000000000000000000000000000000000000000000000000000000000000000, decoded_data: (<span class="string">&#x27;0x0000000000000000000000000000000000000000&#x27;</span>,), value: 0x0</span><br><span class="line">Caller: [CREATOR], <span class="keyword">function</span>: reentrancy(), txdata: 0xe11f493e, value: 0x0</span><br><span class="line"></span><br><span class="line">==== State access after external call ====</span><br><span class="line">SWC ID: 107</span><br><span class="line">Severity: Medium</span><br><span class="line">Contract: Caller</span><br><span class="line">Function name: reentrancy()</span><br><span class="line">PC address: 839</span><br><span class="line">Estimated Gas Usage: 7090 - 61984</span><br><span class="line">Write to persistent state following external call</span><br><span class="line">The contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially <span class="keyword">if</span> the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract <span class="keyword">in</span> an intermediate state.</span><br><span class="line">--------------------</span><br><span class="line">In file: /tmp/contracts/calls.sol:20</span><br><span class="line"></span><br><span class="line">statevar = 0</span><br><span class="line"></span><br><span class="line">--------------------</span><br><span class="line">Initial State:</span><br><span class="line"></span><br><span class="line">Account: [CREATOR], balance: 0x0, nonce:0, storage:&#123;&#125;</span><br><span class="line">Account: [ATTACKER], balance: 0x0, nonce:0, storage:&#123;&#125;</span><br><span class="line"></span><br><span class="line">Transaction Sequence:</span><br><span class="line"></span><br><span class="line">Caller: [CREATOR], calldata: 000000000000000000000000deadbeefdeadbeefdeadbeefdeadbeefdeadbeef0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, decoded_data: , value: 0x0</span><br><span class="line">Caller: [SOMEGUY], <span class="keyword">function</span>: reentrancy(), txdata: 0xe11f493e, value: 0x0</span><br><span class="line"></span><br><span class="line">==== External Call To User-Supplied Address ====</span><br><span class="line">SWC ID: 107</span><br><span class="line">Severity: Low</span><br><span class="line">Contract: Caller</span><br><span class="line">Function name: calluseraddress(address)</span><br><span class="line">PC address: 891</span><br><span class="line">Estimated Gas Usage: 1576 - 36140</span><br><span class="line">A call to a user-supplied address is executed.</span><br><span class="line">An external message call to an address specified by the <span class="built_in">caller</span> is executed. Note that the callee account might contain arbitrary code and could re-enter any <span class="keyword">function</span> within this contract. Reentering the contract <span class="keyword">in</span> an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are <span class="keyword">in</span> place.</span><br><span class="line">--------------------</span><br><span class="line">In file: /tmp/contracts/calls.sol:24</span><br><span class="line"></span><br><span class="line">addr.call(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">--------------------</span><br><span class="line">Initial State:</span><br><span class="line"></span><br><span class="line">Account: [CREATOR], balance: 0x0, nonce:0, storage:&#123;&#125;</span><br><span class="line">Account: [ATTACKER], balance: 0x0, nonce:0, storage:&#123;&#125;</span><br><span class="line"></span><br><span class="line">Transaction Sequence:</span><br><span class="line"></span><br><span class="line">Caller: [CREATOR], calldata: 00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, decoded_data: , value: 0x0</span><br><span class="line">Caller: [SOMEGUY], <span class="keyword">function</span>: calluseraddress(address), txdata: 0xe1d10f79000000000000000000000000deadbeefdeadbeefdeadbeefdeadbeefdeadbeef, decoded_data: (<span class="string">&#x27;0xdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef&#x27;</span>,), value: 0x0</span><br><span class="line"></span><br><span class="line">==== Unchecked <span class="built_in">return</span> value from external call. ====</span><br><span class="line">SWC ID: 104</span><br><span class="line">Severity: Medium</span><br><span class="line">Contract: Caller</span><br><span class="line">Function name: calluseraddress(address)</span><br><span class="line">PC address: 891</span><br><span class="line">Estimated Gas Usage: 1576 - 36140</span><br><span class="line">The <span class="built_in">return</span> value of a message call is not checked.</span><br><span class="line">External calls <span class="built_in">return</span> a boolean value. If the callee halts with an exception, <span class="string">&#x27;false&#x27;</span> is returned and execution continues <span class="keyword">in</span> the <span class="built_in">caller</span>. The <span class="built_in">caller</span> should check whether an exception happened and react accordingly to avoid unexpected behavior. For example it is often desirable to wrap external calls <span class="keyword">in</span> require() so the transaction is reverted <span class="keyword">if</span> the call fails.</span><br><span class="line">--------------------</span><br><span class="line">In file: /tmp/contracts/calls.sol:24</span><br><span class="line"></span><br><span class="line">addr.call(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">--------------------</span><br><span class="line">Initial State:</span><br><span class="line"></span><br><span class="line">Account: [CREATOR], balance: 0x0, nonce:0, storage:&#123;&#125;</span><br><span class="line">Account: [ATTACKER], balance: 0x0, nonce:0, storage:&#123;&#125;</span><br><span class="line"></span><br><span class="line">Transaction Sequence:</span><br><span class="line"></span><br><span class="line">Caller: [CREATOR], calldata: 00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, decoded_data: , value: 0x0</span><br><span class="line">Caller: [SOMEGUY], <span class="keyword">function</span>: calluseraddress(address), txdata: 0xe1d10f790000000000000000000000000000000000000000000000000000000000000000, decoded_data: (<span class="string">&#x27;0x0000000000000000000000000000000000000000&#x27;</span>,), value: 0x0</span><br><span class="line">Caller: [CREATOR], <span class="keyword">function</span>: calluseraddress(address), txdata: 0xe1d10f790000000000000000000000000000000000000000000000000000000000000000, decoded_data: (<span class="string">&#x27;0x0000000000000000000000000000000000000000&#x27;</span>,), value: 0x0</span><br></pre></td></tr></table></figure><p>测试了另一个合约，需要修改编辑器版本，没有挂梯子域名解析错了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">jie@jie-virtual-machine:~$ docker run -v $(<span class="built_in">pwd</span>):/tmp mythril/myth analyze /tmp/contracts/killbilly.sol --solv 0.5.7</span><br><span class="line">mythril.interfaces.cli [ERROR]: Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/urllib3/connection.py&quot;</span>, line 200, <span class="keyword">in</span> _new_conn</span><br><span class="line">    sock = connection.create_connection(</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py&quot;</span>, line 60, <span class="keyword">in</span> create_connection</span><br><span class="line">    <span class="keyword">for</span> res <span class="keyword">in</span> socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/socket.py&quot;</span>, line 955, <span class="keyword">in</span> getaddrinfo</span><br><span class="line">    <span class="keyword">for</span> res <span class="keyword">in</span> _socket.getaddrinfo(host, port, family, <span class="built_in">type</span>, proto, flags):</span><br><span class="line">socket.gaierror: [Errno -3] Temporary failure <span class="keyword">in</span> name resolution</span><br><span class="line"></span><br><span class="line">The above exception was the direct cause of the following exception:</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py&quot;</span>, line 790, <span class="keyword">in</span> urlopen</span><br><span class="line">    response = self._make_request(</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py&quot;</span>, line 491, <span class="keyword">in</span> _make_request</span><br><span class="line">    raise new_e</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py&quot;</span>, line 467, <span class="keyword">in</span> _make_request</span><br><span class="line">    self._validate_conn(conn)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py&quot;</span>, line 1092, <span class="keyword">in</span> _validate_conn</span><br><span class="line">    conn.connect()</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/urllib3/connection.py&quot;</span>, line 604, <span class="keyword">in</span> connect</span><br><span class="line">    self.sock = sock = self._new_conn()</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/urllib3/connection.py&quot;</span>, line 207, <span class="keyword">in</span> _new_conn</span><br><span class="line">    raise NameResolutionError(self.host, self, e) from e</span><br><span class="line">urllib3.exceptions.NameResolutionError: &lt;urllib3.connection.HTTPSConnection object at 0x7f0a9f3649d0&gt;: Failed to resolve <span class="string">&#x27;solc-bin.ethereum.org&#x27;</span> ([Errno -3] Temporary failure <span class="keyword">in</span> name resolution)</span><br><span class="line"></span><br><span class="line">The above exception was the direct cause of the following exception:</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/requests/adapters.py&quot;</span>, line 486, <span class="keyword">in</span> send</span><br><span class="line">    resp = conn.urlopen(</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py&quot;</span>, line 844, <span class="keyword">in</span> urlopen</span><br><span class="line">    retries = retries.increment(</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py&quot;</span>, line 515, <span class="keyword">in</span> increment</span><br><span class="line">    raise MaxRetryError(_pool, url, reason) from reason  <span class="comment"># type: ignore[arg-type]</span></span><br><span class="line">urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host=<span class="string">&#x27;solc-bin.ethereum.org&#x27;</span>, port=443): Max retries exceeded with url: /linux-amd64/list.json (Caused by NameResolutionError(<span class="string">&quot;&lt;urllib3.connection.HTTPSConnection object at 0x7f0a9f3649d0&gt;: Failed to resolve &#x27;solc-bin.ethereum.org&#x27; ([Errno -3] Temporary failure in name resolution)&quot;</span>))</span><br><span class="line"></span><br><span class="line">During handling of the above exception, another exception occurred:</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/mythril/interfaces/cli.py&quot;</span>, line 958, <span class="keyword">in</span> parse_args_and_execute</span><br><span class="line">    disassembler = MythrilDisassembler(</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/mythril/mythril/mythril_disassembler.py&quot;</span>, line 60, <span class="keyword">in</span> __init__</span><br><span class="line">    self.solc_binary = self._init_solc_binary(solc_version)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/mythril/mythril/mythril_disassembler.py&quot;</span>, line 93, <span class="keyword">in</span> _init_solc_binary</span><br><span class="line">    solc_binary = util.solc_exists(version)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/mythril/ethereum/util.py&quot;</span>, line 140, <span class="keyword">in</span> solc_exists</span><br><span class="line">    solcx.install_solc(<span class="string">&quot;v&quot;</span> + version)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/solcx/install.py&quot;</span>, line 441, <span class="keyword">in</span> install_solc</span><br><span class="line">    data = requests.get(BINARY_DOWNLOAD_BASE.format(_get_os_name(), <span class="string">&quot;list.json&quot;</span>))</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/requests/api.py&quot;</span>, line 73, <span class="keyword">in</span> get</span><br><span class="line">    <span class="built_in">return</span> request(<span class="string">&quot;get&quot;</span>, url, params=params, **kwargs)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/requests/api.py&quot;</span>, line 59, <span class="keyword">in</span> request</span><br><span class="line">    <span class="built_in">return</span> session.request(method=method, url=url, **kwargs)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/requests/sessions.py&quot;</span>, line 589, <span class="keyword">in</span> request</span><br><span class="line">    resp = self.send(prep, **send_kwargs)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/requests/sessions.py&quot;</span>, line 703, <span class="keyword">in</span> send</span><br><span class="line">    r = adapter.send(request, **kwargs)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/requests/adapters.py&quot;</span>, line 519, <span class="keyword">in</span> send</span><br><span class="line">    raise ConnectionError(e, request=request)</span><br><span class="line">requests.exceptions.ConnectionError: HTTPSConnectionPool(host=<span class="string">&#x27;solc-bin.ethereum.org&#x27;</span>, port=443): Max retries exceeded with url: /linux-amd64/list.json (Caused by NameResolutionError(<span class="string">&quot;&lt;urllib3.connection.HTTPSConnection object at 0x7f0a9f3649d0&gt;: Failed to resolve &#x27;solc-bin.ethereum.org&#x27; ([Errno -3] Temporary failure in name resolution)&quot;</span>))</span><br></pre></td></tr></table></figure><h2 id="Sucurify2-0"><a href="#Sucurify2-0" class="headerlink" title="Sucurify2.0"></a>Sucurify2.0</h2><p>项目地址 <a href="https://github.com/eth-sri/securify2">eth-sri/securify2</a></p><h3 id="Smartbugs的实验"><a href="#Smartbugs的实验" class="headerlink" title="Smartbugs的实验"></a>Smartbugs的实验</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$./smartbugs -t securify -f samples/*.sol --processes 2 --mem-limit 4g --timeout 60</span><br></pre></td></tr></table></figure><p><img src="/2023/08/08/blockchain-security-practice/image-20230718103340279.png" alt="image-20230718103340279"></p><p>实验结果存储在<code>./results/securify</code>目录下</p><p>目录每个.sol文件分析后包括两个文件，以EtherLotto.sol为例具体来看。</p><ul><li><code>smartbugs.json</code>具体为调用工具时参数的情况</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//smartbugs.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;docker&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;command&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">&quot;detach&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;entrypoint&quot;</span>: <span class="string">&quot;&#x27;/sb/bin/do_solidity.sh&#x27; &#x27;/sb/EtherLotto.sol&#x27; &#x27;/sb/bin&#x27;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;image&quot;</span>: <span class="string">&quot;smartbugs/security:usolc&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;mem_limit&quot;</span>: <span class="string">&quot;4g&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;user&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;volumes&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;/tmp/tmp86tp_iz9&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;bind&quot;</span>: <span class="string">&quot;/sb&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;mode&quot;</span>: <span class="string">&quot;rw&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;filename&quot;</span>: <span class="string">&quot;samples/EtherLotto.sol&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;platform&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;cpu&quot;</span>: <span class="string">&quot;12th Gen Intel(R) Core(TM) i5-12500H&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;python&quot;</span>: <span class="string">&quot;3.10.6.final.0 (64 bit)&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;release&quot;</span>: <span class="string">&quot;5.19.0-45-generic&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;smartbugs&quot;</span>: <span class="string">&quot;2.0.7&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;system&quot;</span>: <span class="string">&quot;Linux&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;#46~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Wed Jun 7 15:06:04 UTC 20&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;result&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;duration&quot;</span>: <span class="number">17.345403909683228</span>,</span><br><span class="line">        <span class="attr">&quot;exit_code&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;logs&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">&quot;output&quot;</span>: <span class="string">&quot;result.tar&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;start&quot;</span>: <span class="number">1689647289.9699748</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;runid&quot;</span>: <span class="string">&quot;20230718_0228&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;solc&quot;</span>: <span class="string">&quot;0.4.26&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;tool&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;bin&quot;</span>: <span class="string">&quot;scripts&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;command&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">&quot;cpu_quota&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">&quot;entrypoint&quot;</span>: <span class="string">&quot;&#x27;$BIN/do_solidity.sh&#x27; &#x27;$FILENAME&#x27; &#x27;$BIN&#x27;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;securify&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;image&quot;</span>: <span class="string">&quot;smartbugs/security:usolc&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;info&quot;</span>: <span class="string">&quot;Securify uses formal verification, also relying on static analysis checks. Securify&#x27;s analysis consists of two steps. First, it symbolically analyzes the contract&#x27;s dependency graph to extract precise semantic information from the code. Then, it checks compliance and violation patterns that capture sufficient conditions for proving if a property holds or not.&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;mem_limit&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">&quot;mode&quot;</span>: <span class="string">&quot;solidity&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Securify&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;origin&quot;</span>: <span class="string">&quot;https://github.com/eth-sri/securify&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;output&quot;</span>: <span class="string">&quot;/results/&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;parser&quot;</span>: <span class="string">&quot;parser.py&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;solc&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;version&quot;</span>: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个文件是<code>result.tar</code>，解压后可以发现</p><ul><li><code>live.json</code>文件，具体内容为模式的定义</li><li><code>results.json</code>文件，给出了匹配的结果，包括violation 和 warning safe 和 conflicts</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//live.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;decompiled&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;finished&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;patternResults&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;DAO&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;completed&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasViolations&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasWarnings&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasSafe&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasConflicts&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;violations&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;warnings&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;safe&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;DAOConstantGas&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;completed&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasViolations&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasWarnings&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasSafe&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasConflicts&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;violations&quot;</span>: [</span><br><span class="line">        <span class="number">226</span>,</span><br><span class="line">        <span class="number">271</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;warnings&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;safe&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;MissingInputValidation&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;completed&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasViolations&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasWarnings&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasSafe&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasConflicts&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;violations&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;warnings&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;safe&quot;</span>: [</span><br><span class="line">        <span class="number">116</span>,</span><br><span class="line">        <span class="number">116</span>,</span><br><span class="line">        <span class="number">111</span>,</span><br><span class="line">        <span class="number">116</span>,</span><br><span class="line">        <span class="number">111</span>,</span><br><span class="line">        <span class="number">130</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;TODAmount&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;completed&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasViolations&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasWarnings&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasSafe&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasConflicts&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;violations&quot;</span>: [</span><br><span class="line">        <span class="number">271</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;warnings&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;safe&quot;</span>: [</span><br><span class="line">        <span class="number">226</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;TODReceiver&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;completed&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasViolations&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasWarnings&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasSafe&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasConflicts&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;violations&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;warnings&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;safe&quot;</span>: [</span><br><span class="line">        <span class="number">226</span>,</span><br><span class="line">        <span class="number">271</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;TODTransfer&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;completed&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasViolations&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasWarnings&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasSafe&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasConflicts&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;violations&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;warnings&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;safe&quot;</span>: [</span><br><span class="line">        <span class="number">226</span>,</span><br><span class="line">        <span class="number">271</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;UnhandledException&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;completed&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasViolations&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasWarnings&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasSafe&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasConflicts&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;violations&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;warnings&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;safe&quot;</span>: [</span><br><span class="line">        <span class="number">226</span>,</span><br><span class="line">        <span class="number">271</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;UnrestrictedEtherFlow&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;completed&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasViolations&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasWarnings&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasSafe&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasConflicts&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;violations&quot;</span>: [</span><br><span class="line">        <span class="number">226</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;warnings&quot;</span>: [</span><br><span class="line">        <span class="number">271</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;safe&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//results.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;/sb/EtherLotto.sol:EtherLotto&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;results&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;TODReceiver&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;violations&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;warnings&quot;</span>: [</span><br><span class="line">          <span class="number">48</span>,</span><br><span class="line">          <span class="number">51</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;safe&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;UnhandledException&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;violations&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;warnings&quot;</span>: [</span><br><span class="line">          <span class="number">48</span>,</span><br><span class="line">          <span class="number">51</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;safe&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;TODTransfer&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;violations&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;warnings&quot;</span>: [</span><br><span class="line">          <span class="number">48</span>,</span><br><span class="line">          <span class="number">51</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;safe&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;DAO&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;violations&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;warnings&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;safe&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;TODAmount&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;violations&quot;</span>: [</span><br><span class="line">          <span class="number">51</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;warnings&quot;</span>: [</span><br><span class="line">          <span class="number">48</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;safe&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;MissingInputValidation&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;violations&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;warnings&quot;</span>: [</span><br><span class="line">          <span class="number">20</span>,</span><br><span class="line">          <span class="number">23</span>,</span><br><span class="line">          <span class="number">32</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;safe&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;DAOConstantGas&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;violations&quot;</span>: [</span><br><span class="line">          <span class="number">48</span>,</span><br><span class="line">          <span class="number">51</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;warnings&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;safe&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;UnrestrictedEtherFlow&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;violations&quot;</span>: [</span><br><span class="line">          <span class="number">48</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;warnings&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;safe&quot;</span>: [</span><br><span class="line">          <span class="number">51</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据实验结果，可能是运行的分析时间较短，许多合约分析结果为空（比如Mytoken.sol)</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230718105438946.png" alt="image-20230718105438946"></p><p>parse后查看给出的results.json</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230809173729853.png" alt="image-20230809173729853"></p><h2 id="sFuzz"><a href="#sFuzz" class="headerlink" title="sFuzz"></a>sFuzz</h2><p>仅支持solidity源代码，对contractFuzzer的改进</p><p>项目地址<a href="https://github.com/duytai/sFuzz">duytai/sFuzz (github.com)</a>，未提供docker，只能自行编译</p><h3 id="Smartbugs的实验-1"><a href="#Smartbugs的实验-1" class="headerlink" title="Smartbugs的实验"></a>Smartbugs的实验</h3><p><img src="/2023/08/08/blockchain-security-practice/image-20230809101350192.png" alt="image-20230809101350192"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230809101656664.png" alt="image-20230809101656664"></p><h3 id="docker内的实验"><a href="#docker内的实验" class="headerlink" title="docker内的实验"></a>docker内的实验</h3><p>在骆九同学帮助下找到了docker，直接进行实验</p><p>按照<a href="https://github.com/duytai/sFuzz">duytai/sFuzz (github.com)</a>的教程，先给出两个合约</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230809153500386.png" alt="image-20230809153500386"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./fuzzer -g -r 0 -d 120 &amp;&amp; chmod +x fuzzMe &amp;&amp; ./fuzzMe</span><br></pre></td></tr></table></figure><p>获得了fuzzing后的结果</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230809153954541.png" alt="image-20230809153954541"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230809154619989.png" alt="image-20230809154619989"></p><h2 id="Slither"><a href="#Slither" class="headerlink" title="Slither"></a>Slither</h2><p>项目地址：<a href="https://github.com/crytic/slither#usage">Issues · crytic/slither (github.com)</a></p><h3 id="Smartbugs的测试"><a href="#Smartbugs的测试" class="headerlink" title="Smartbugs的测试"></a>Smartbugs的测试</h3><p><img src="/2023/08/08/blockchain-security-practice/image-20230809103030692.png" alt="image-20230809103030692"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230809104145895.png" alt="image-20230809104145895"></p><h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull trailofbits/eth-security-toolbox</span><br><span class="line"></span><br><span class="line">ethsec@9a9fde7fab15:~/etheno-examples/BrokenMetaCoin/contracts$ slither MetaCoin.sol --solc-solcs-select 0.5.0</span><br></pre></td></tr></table></figure><p>采用—solc-solcs-select 参数指定编译器版本，不然会报错</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230809110124068.png" alt="image-20230809110124068"></p><p>测试合约中的重入漏洞</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230809111650390.png" alt="image-20230809111650390"></p><h2 id="Solhint"><a href="#Solhint" class="headerlink" title="Solhint"></a>Solhint</h2><p>项目地址：<a href="https://github.com/protofire/solhint">protofire/solhint: Solhint is an open-source project to provide a linting utility for Solidity code. (github.com)</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>更新node版本为20.5.0</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo npm cache clean -f //清除nodejs的cache</span><br><span class="line">sudo npm install -g n //使用npm安装n模块</span><br><span class="line">npm view node versions // node所有版本</span><br><span class="line">sudo n latest // 升级到最新版本</span><br></pre></td></tr></table></figure><p>安装solhint</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g solhint</span><br><span class="line">solhint --version</span><br><span class="line">3.5.1</span><br><span class="line">solhint --init</span><br></pre></td></tr></table></figure><p>使用默认的规则测试不出结果</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230809122109397.png" alt="image-20230809122109397"></p><h3 id="Smartbugs的实验-2"><a href="#Smartbugs的实验-2" class="headerlink" title="Smartbugs的实验"></a>Smartbugs的实验</h3><p><img src="/2023/08/08/blockchain-security-practice/image-20230809122728437.png" alt="image-20230809122728437"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230809122840316.png" alt="image-20230809122840316"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230809122853930.png" alt="image-20230809122853930"></p><h1 id="Echidna"><a href="#Echidna" class="headerlink" title="Echidna"></a>Echidna</h1><p>参考资料 <a href="https://juejin.cn/post/7256976847665201212">智能合约模糊测试工具推荐——Echidna - 掘金 (juejin.cn)</a>、<a href="https://ethereum.org/zh/developers/tutorials/how-to-use-echidna-to-test-smart-contracts/">如何使用 Echidna 测试智能合约 | ethereum.org</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jie@jie-virtual-machine:~/share$ docker run -it -v `<span class="built_in">pwd</span>`:/src echidna:v2.2.1 </span><br></pre></td></tr></table></figure><h1 id="docker-1"><a href="#docker-1" class="headerlink" title="docker"></a>docker</h1><p>导出镜像和导入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker save image_id -o image.tar</span><br><span class="line">docker load -i image.tar</span><br><span class="line">docker tar image_id name:tag </span><br></pre></td></tr></table></figure><h1 id="Geth"><a href="#Geth" class="headerlink" title="Geth"></a>Geth</h1><p>官方下载发行版 <a href="https://geth.ethereum.org/downloads">Downloads | go-ethereum</a></p><p>有空可以再做一遍这个 <a href="https://geth.ethereum.org/docs/getting-started">Getting started with Geth | go-ethereum</a></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230823160539917.png" alt="image-20230823160539917"></p><p>再尝试1.11.6版本</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> E:\Geth1.<span class="number">11.6</span>&gt; geth -<span class="literal">-identity</span> <span class="string">&quot;node&quot;</span> -<span class="literal">-datadir</span> .\data\ -<span class="literal">-networkid</span> <span class="number">9599</span> -<span class="literal">-http</span> -<span class="literal">-http</span>.addr <span class="string">&quot;localhost&quot;</span> -<span class="literal">-http</span>.api=<span class="string">&quot;eth,net,web3,personal,miner,admin,txpool,debug&quot;</span> -<span class="literal">-allow</span><span class="literal">-insecure</span><span class="literal">-unlock</span> -<span class="literal">-http</span>.corsdomain <span class="string">&quot;*&quot;</span> -<span class="literal">-rpc</span>.gascap <span class="number">0</span> console</span><br></pre></td></tr></table></figure><p><img src="/2023/08/08/blockchain-security-practice/image-20230823161424799.png" alt="image-20230823161424799"></p><p>创建账户，然后将账户copy进json配置文件的alloc，将密钥保存到keystore目录下</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230823161937784.png" alt="image-20230823161937784"></p><p>查看账户</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230823162544339.png" alt="image-20230823162544339"></p><p>首先设置coinbase地址为当前账户，挖矿前的余额为0，开始挖矿后可以查看到挖矿状态，一段时间后查询余额</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230823163015429.png" alt="image-20230823163015429"></p><p>停止挖矿</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230823163047474.png" alt="image-20230823163047474"></p><p>利用区块号查看创世区块</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230823163434087.png" alt="image-20230823163434087"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230823163415266.png" alt="image-20230823163415266"></p><p>没有交易，再新建一个账户来处理交易</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230823163827741.png" alt="image-20230823163827741">eth.sendTransaction({from: eth.accounts[0], to: eth.accounts[1],value: web3.toWei(100,”ether”)})</p><h2 id="连接remix"><a href="#连接remix" class="headerlink" title="连接remix"></a>连接remix</h2><p>geth —http —http.corsdomain=”<a href="https://remix.ethereum.org">https://remix.ethereum.org</a>“ —http.api web3,eth,debug,personal,net —vmdebug —datadir .\data`</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230823174806363.png" alt="image-20230823174806363"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230823175012906.png" alt="image-20230823175012906" style="zoom:80%;"></p><h1 id="Hardhat"><a href="#Hardhat" class="headerlink" title="Hardhat"></a>Hardhat</h1><p>教程 <a href="https://hardhat.org/tutorial/testing-contracts">5. Testing contracts | Ethereum development environment for professionals by Nomic Foundation (hardhat.org)</a></p><p>npm安装 </p><p><img src="/2023/08/08/blockchain-security-practice/image-20230823181841584.png" alt="image-20230823181841584"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230823181923882.png" alt="image-20230823181923882"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230823182024043.png" alt="image-20230823182024043"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230823183046224.png" alt="image-20230823183046224"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230823183530947.png" alt="image-20230823183530947"></p><p>安装soldity-coverage工具</p><h1 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h1><p>学习教程 <a href="https://chain.link/education/blockchain-oracles">What Is an Oracle in Blockchain? » Explained | Chainlink</a></p><p>定义：将区块链和外部系统连接起来的实体，使得智能合约能够基于现实世界的输入和输出执行</p><p>例子：Alice 和 Bob赌球，合约如何得知比赛结果？Oracle</p><p>Oracle的安全性非常重要</p><p>中心化的oracle 单点故障，腐化, garbage in, garbage out</p><p>去中心化的Oracle更加安全，如chainlink</p><p>分类</p><ul><li>input oracles：最普遍的，从现实世界中获取信息传递给区块链</li><li>output oracles：合约向链下的系统发送命令来执行特定的操作，比如让银行进行某笔支付，或者让云服务存储某个数据</li><li>cross-chain oracles：在不同区块链间读写，支持跨链转移数据和资产</li><li>compute-enabled oracles：新类型，在逐渐被广泛使用，安全地链下计算来执行链上不现实或者昂贵的计算，计算零知识证明或者可验证随机数</li></ul><p>作为一种基础服务，历史的信誉可以查看</p><ul><li><a href="https://market.link/">Market.link</a>，已经停更，现在是Dune Analytics<ul><li><a href="https://dune.com/sergiimk/Oracle-Comparison-(Chainlink-API3-Band-Ocean">Oracle Comparison (Chainlink, API3, Band, Ocean) (dune.com)</a>)</li></ul></li><li><a href="http://reputation.link/">http://reputation.link/</a><ul><li>无法访问</li></ul></li></ul><p><img src="/2023/08/08/blockchain-security-practice/image-20230907113242784.png" alt="image-20230907113242784"></p><h2 id="在Remix中调用chainlink"><a href="#在Remix中调用chainlink" class="headerlink" title="在Remix中调用chainlink"></a>在Remix中调用chainlink</h2><p>样例合约是读取sepolia上  latest price answer from the <a href="https://docs.chain.link/data-feeds/price-feeds/addresses">BTC / USD feed</a> on the Sepolia testnet</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230907114835842.png" alt="image-20230907114835842"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230907114936147.png" alt="image-20230907114936147"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230907150342512.png" alt="image-20230907150342512"></p><h1 id="ERC和EIP"><a href="#ERC和EIP" class="headerlink" title="ERC和EIP"></a>ERC和EIP</h1><h2 id="ERC"><a href="#ERC" class="headerlink" title="ERC"></a>ERC</h2><p>Ethereum Request for Comments，定义了以太坊网络上创建智能合约和代币的规则和标准，ERC 标准为开发人员提供了一套共识规则，使他们能够在以太坊上创建兼容的智能合约和代币。</p><p>最著名的 ERC 标准之一是 ERC-20，它定义了代币合约的基本功能和交互方式。ERC-20 代币是以太坊上最常见的代币类型，广泛应用于加密货币交易所和钱包。它们具有标准的转账和余额查询功能，使得不同的 ERC-20 代币可以在以太坊生态系统中互相兼容。</p><p>此外，还有其他的 ERC 标准，如 ERC-721（非同质化代币）和 ERC-1155（可互换和非同质化代币的混合标准）。这些标准为不同类型的代币定义了不同的规范和功能，以满足不同的应用场景需求。总之，ERC 是以太坊上定义智能合约和代币标准的术语，它促进了以太坊生态系统的互操作性和发展。</p><p>具体的标准</p><p><a href="https://ethereum.org/en/developers/docs/standards/tokens/erc-20/">ERC-20 Token Standard | ethereum.org</a></p><p><a href="https://eips.ethereum.org/EIPS/eip-20">ERC-20: Token Standard (ethereum.org)</a></p><h3 id="ERC20代币发行"><a href="#ERC20代币发行" class="headerlink" title="ERC20代币发行"></a>ERC20代币发行</h3><p>教程 <a href="https://www.youtube.com/watch?v=gJuWQyZJ7S0&amp;t=11s&amp;ab_channel=MoralisWeb3">https://www.youtube.com/watch?v=gJuWQyZJ7S0&amp;t=11s&amp;ab_channel=MoralisWeb3</a></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230907163457554.png" alt="image-20230907163457554"></p><p>花钱总是要心疼/犹豫一下</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230907163509186.png" alt="image-20230907163509186"></p><p>部署合约的交易</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230907163542704.png" alt="image-20230907163542704"></p><p>符合ERC20的标准</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230907163632536.png" alt="image-20230907163632536"></p><p>查看本账户的余额</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230907163742011.png" alt="image-20230907163742011"></p><p>填写合约地址可以导入到metamask中去</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230907163944543.png" alt="image-20230907163944543"></p><p>查看ERC20的若干参数</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230907164115840.png" alt="image-20230907164115840"></p><h2 id="EIP"><a href="#EIP" class="headerlink" title="EIP"></a>EIP</h2><p>EIP 是以太坊改进提案（Ethereum Improvement Proposal）的缩写。EIP 是以太坊社区中用于提出和讨论关于以太坊网络改进的标准化文件。它们是以太坊社区成员之间进行协作和讨论的重要工具，用于引入新功能、修复问题、改进协议和提出新的标准。</p><p>EIP 的目的是促进以太坊网络的发展和创新，并提供一种透明和开放的方式来讨论和决策关于以太坊协议的变更。EIP 的提案可以涉及各种主题，包括协议改进、新功能的引入、标准化规范、网络升级、治理流程等。</p><p>每个 EIP 都有一个唯一的编号、标题和详细描述，其中包含了提案的目的、动机和技术细节。EIP 还可以包含相关的代码示例、实现建议和测试用例等。</p><p>EIP 分为几个不同的类别，包括核心协议（Core），标准化（Standards），元标准（Meta），信息（Informational）和退役（Retired）等。这些类别有助于对提案进行分类和组织，并提供了不同的审核和采纳流程。</p><p>以太坊社区的成员可以提出新的 EIP 提案，并通过社区的讨论、审核和投票过程来确定是否采纳。一旦 EIP 被采纳，它可能会成为以太坊网络的一部分，影响网络的协议和功能。</p><p>总之，EIP 是以太坊社区中用于提出和讨论关于以太坊网络改进的标准化文件，它们起到了推动以太坊发展和创新的重要作用。</p><p><a href="https://eips.ethereum.org/">Home | Ethereum Improvement Proposals</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录进行区块链安全相关实践的内容&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/categories/Blockchain/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>sharding-blockchain-survey</title>
    <link href="https://alleysira.github.io/2023/08/06/sharding-blockchain-survey/"/>
    <id>https://alleysira.github.io/2023/08/06/sharding-blockchain-survey/</id>
    <published>2023-08-06T01:14:25.000Z</published>
    <updated>2023-08-14T01:25:20.442Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Building-blocks-of-sharding-blockchain-systems-Concepts-approaches-and-open-problems"><a href="#Building-blocks-of-sharding-blockchain-systems-Concepts-approaches-and-open-problems" class="headerlink" title="Building blocks of sharding blockchain systems: Concepts, approaches,and open problems"></a>Building blocks of sharding blockchain systems: Concepts, approaches,and open problems</h1><p>继<a href="https://alleysira.github.io/2023/05/31/Sharding-Blockchain-Consensus-lyj/">Sharding_Blockchain_Consensus</a> 之后阅读刘老师的综述文章</p><p>分片技术是打破区块链去中心化、安全性和可扩展性不可能三角的最流行的方式，分片技术可以广义的理解为将区块链中的节点动态划分为彼此之间没有细粒度同步并且执行存储、计算和通信任务的子集，子集称为分片</p><p>现有的分片区块链设计仍有很多可探索的空间，本文从此出发，对现有的分片区块链进行了系统的分析，并将它们的架构概念分解为功能组件，并推导出它们所基于的系统模型和攻击者的假设。推导出的功能组件包括：</p><ul><li>节点选择、轮随机数、节点分配、片内共识、跨片交易处理、分片重配置、激励机制</li></ul><p>对于每个功能组件，本文描述了接口、功能和性质，给出了组件如何组合成一个分片区块链系统并讨论了每个组件的后续研究方向；同样关注了潜在的安全攻击和性能问题，例如系统吞吐量和延迟</p><span id="more"></span><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>传统的区块链系统是一个点对点的分布式自治系统，依赖原子广播协议实现复制状态机</p><p>理想的区块链系统努力实现去中心化的控制、对单一状态的共识、防篡改的记录、隐私保护、高可用性</p><p>现有的区块链系统在实际应用受限于不可能三角</p><ul><li>对于去中心化：区块链需要支持多种假设下的节点（如何加入/离开网络）</li><li>对于安全性：需要证明安全，保证区块链协议能够抵抗某一类攻击</li><li>对于可扩展性：现有的方案能够分成链下方案和链上方案<ul><li>链上：采用层次化的架构，核心的区块链系统仅验证少许聚合的资源转移（许多细粒度交易和净效应），概念上类似于一个银行，中央银行就是核心区块链；分片就是一种链上解决方案<ul><li>micropayment </li><li>payment channel networks</li><li>virtual payment channels</li><li>sidechains</li></ul></li><li>链下：避免传统区块链系统的计算开销，避免了所有节点之间就交易顺序达成一致所需的计算成本。</li></ul></li></ul><p>分片希望实现和传统区块链同等的安全性和去中心化，能否实现？</p><p>分片技术最初在数据库系统提出，第一个分片区块链工作发表于CCS16的ELASTICO</p><p>现有的分片工作主要存在以下问题：</p><ul><li>分片区块链系统的结构复杂，包含多个组件</li><li>不同的分片区块链采用的模型和假设不同（网络模型、敌手模型、交易模型），不容易理解设计和安全性</li><li>现有的分片区块链系统是端到端的描述方式，没有给出整体架构，各组件的功能不够清晰</li></ul><p>贡献</p><ul><li>将分片区块链拆解为功能组件，给出了每个组件的输入输出、功能和性质；给出了如何讲各组件组合成为完整的分片区块链</li><li>对分片区块链系统详尽的分类：从系统模型和功能组件两个方向对分片区块链进行了分类，对于每个组件归类除了解决方案</li><li>对组件的深度分析。对每个组件给出基本概念（目的、功能和基本步骤），识别并分析了每个方案在安全、吞吐量、延迟等方面可能存在的问题；给出了未来的研究方向</li></ul><h1 id="Preliminaries"><a href="#Preliminaries" class="headerlink" title="Preliminaries"></a>Preliminaries</h1><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>讲区块链、区块链共识机制再讲分片区块链</p><h3 id="Consensus"><a href="#Consensus" class="headerlink" title="Consensus"></a>Consensus</h3><p>介绍区块链的不可篡改性居然加了一句（except for some special redactable blockchains）</p><p>区块链的架构</p><ul><li>网络层：节点在P2P网络内进行消息同步，节点分布式，不存在中央节点</li><li>共识层：具有特定计算和通信能力的节点作为共识节点，通过特定共识算法，承担出块的工作，图中是BFT类共识；共识层决定区块链的一致性和活性</li><li>应用层</li></ul><p><img src="/2023/08/06/sharding-blockchain-survey/image-20230806104704355.png" alt="image-20230806104704355"></p><p>现有的区块链共识协议可以分为</p><ul><li>经典的分布式共识协议：BFT类，采用复制状态机的思想</li><li>基于工作量证明机制的共识</li><li>基于权益证明的共识</li><li>混合共识协议：单一委员会和多委员会共识（分片的一种）</li></ul><h3 id="Sharding-blockchains"><a href="#Sharding-blockchains" class="headerlink" title="Sharding blockchains"></a>Sharding blockchains</h3><p>当网络中节点增加时，增加分片数量即可提高处理能力</p><p>ELASTICO作为第一篇分片的工作，结合了分片技术提高区块链的交易吞吐率</p><p>可以分为三类</p><ul><li>通信分片：片内节点大多数时间仅进行片内通信</li><li>计算分片：每个分片只负责处理相关的交易，交易的分配是多样化的（根据交易ID进行分片）</li><li>存储分片：每个分片的节点仅存储所在分片的数据（交易历史、UTXO），交易历史存在区块链上，UTXO可以为了效率单独存储；实际上减少了节点的存储开销</li></ul><p>协调者负责跨片通信和片内共识</p><p><img src="/2023/08/06/sharding-blockchain-survey/image-20230806112006224.png" alt="image-20230806112006224"></p><p>分片和其他可扩展性解决方案进行对比，可以分为链上（layer1）和链下（layer2）两类方案</p><ul><li>链上方案：分片属于链上方案，还有DAG有向无环图和侧链方案<ul><li>有向无环图的区块链<ul><li>采用多条链跟随主链，每个新区块都会链接到若干个之前的区块，可以追溯到创世区块<ul><li>IOTA市值80位，conflux市值69位</li></ul></li><li>参考<a href="https://zhuanlan.zhihu.com/p/52424180">有向无环图 DAG - 知乎 (zhihu.com)</a></li></ul></li><li>侧链方案：采用额外的区块链执行交易，可能运行多个共识算法，侧链和主链之间需要一个two-way peg（一般用智能合约实现），用于在主链和侧脸之间资产交换</li></ul></li><li>链下方案：通过channel和主链进行小的交易处理，代表性工作是闪电网络和Perun</li></ul><h2 id="Notations"><a href="#Notations" class="headerlink" title="Notations"></a>Notations</h2><p><img src="/2023/08/06/sharding-blockchain-survey/image-20230808091029311.png" alt="image-20230808091029311"></p><h2 id="Definitions"><a href="#Definitions" class="headerlink" title="Definitions"></a>Definitions</h2><p><img src="/2023/08/06/sharding-blockchain-survey/image-20230808091411255.png" alt="image-20230808091411255"></p><ul><li>网络模型：分片区块链需要考虑全部区块链网络的网络模型和分片内的网络模型，可以不同<ul><li>同步：保证消息按照轮传播</li><li>部分同步：存在时延上限，但是不能作为协议参数</li><li>异步：不存在时延上限，但是最终诚实用户的消息能够到达彼此<ul><li>FLP问题指出异步系统中不存在确定性的共识算法能够保证在有限的时间内达成共识</li></ul></li></ul></li><li>节点准入模型<ul><li>许可网络：需要完成身份认证才能加入协议</li><li>非许可网络：节点可以在任何时间加入网络；没有身份认证机制；节点数量不可预测</li></ul></li><li>敌手模型<ul><li>腐化模型：包括腐化时机和腐化速度；密码协议更关心腐化问题。腐化速度对分片区块链更重要，决定了重配置阶段（更新委员会）<ul><li>根据敌手可以发动腐化的时机，可以分为静态和适应性腐化<ul><li>静态：协议运行前确定腐化对象</li><li>适应性腐化：敌手能够根绝运行时的消息适应性动态腐化目标节点</li></ul></li><li>根据腐化速度，可以分为温和腐化和立即腐化<ul><li>温和孵化：敌手需要$\tau$时间完成腐化<ul><li>分片区块链中的轮指所有分片成员不变继续运转的时间，轮的时长和敌手完成腐化的时间强相关</li><li><img src="/2023/08/06/sharding-blockchain-survey/image-20230808093516205.png" alt="image-20230808093516205"></li></ul></li><li>立即腐化：$\tau=0$<ul><li>使用较少，Algorand</li></ul></li></ul></li></ul></li><li>全局比例模型：敌手能够控制的算力资源或权益资源<ul><li>$[0,1/3)$</li><li>$[1/3,1/2)$</li></ul></li><li>片内比例模型：片内的节点数量固定，片内敌手控制的节点数量通过$f$等式表达，由片内共识算法决定；一般全局比例会低于片内比例<ul><li>$u=2f+1$：同步的BFT</li><li>$u=3f+1$：部分同步</li></ul></li></ul></li><li>交易模型<ul><li>UTXO模型：最常用，每个UTXO包括公钥地址和交易值，每个交易消耗现有的UTXO生成新的UTXO，UTXO的输入和输出值相同 </li><li>账户模型：每个用户拥有账户，账户地址用于存储余额</li><li>其他</li></ul></li><li>片内共识<ul><li>弱一致性：存在分叉，但是保证最终一致性<ul><li>链质量 链增长 链公共前缀</li></ul></li><li>强一致性：存在委员会运行分布式共识算法来确认交易和出块<ul><li>状态机复制：对于服务器集合，包含一个原始数据和若干备份，对线性增长的账本达成一致，需要满足一致性和活性</li><li><img src="/2023/08/06/sharding-blockchain-survey/image-20230808100317670.png" alt="image-20230808100317670" style="zoom:80%;"></li></ul></li></ul></li><li>分片区块链<ul><li>给出账本的定义</li><li><img src="/2023/08/06/sharding-blockchain-survey/image-20230808100551688.png" alt="image-20230808100551688"></li><li>安全的分片区块链定义：可视为一类特殊的账本，将一致性拆分为片内公共前缀和跨片无冲突；活性分别定义了片内交易确认时延和跨片交易确认时延</li><li><img src="/2023/08/06/sharding-blockchain-survey/image-20230808100842569.png" alt="image-20230808100842569" style="zoom:80%;"></li><li>交易确认时延，设交易提交时间为$t$，交易出现在诚实节点账本的时间为$t’$，则交易确认时延为$t’-t$</li><li>应答性：交易的确认时延仅和实际网络实验$\delta$相关，和上界$\Delta$无关</li></ul></li></ul><p>简单对各种组件排列组合就能得到新的分片区块链，作者给了216种（？</p><h1 id="Decomposing-sharding-blockchains-into-functional-components"><a href="#Decomposing-sharding-blockchains-into-functional-components" class="headerlink" title="Decomposing sharding blockchains into functional components"></a>Decomposing sharding blockchains into functional components</h1><p>依次介绍每个组件的基本内容，组合组件的方法，总结现有的分片区块链</p><h2 id="Decomposition-of-sharding-blockchains"><a href="#Decomposition-of-sharding-blockchains" class="headerlink" title="Decomposition of sharding blockchains"></a>Decomposition of sharding blockchains</h2><p>分片区块链的整体流程如图所示</p><p><img src="/2023/08/06/sharding-blockchain-survey/image-20230808102927605.png" alt="image-20230808102927605"></p><ul><li>节点选择：参数$k$表示每个分片内新的节点的数量，$m$是分片个数<ul><li><img src="/2023/08/06/sharding-blockchain-survey/image-20230808103202920.png" alt="image-20230808103202920"></li><li>在无许可环境中，可能会使用PoW或者PoS进行选择；</li><li>在许可环境中，由可信第三方来执行</li><li>需要满足公平性和鲁棒性，公平性限制恶意敌手的比例，鲁棒性指在恶意敌手不超过某个比例时snodes仍然会被诚实节点接受</li></ul></li><li>轮随机数：一般是交互式的分布式组件<ul><li><img src="/2023/08/06/sharding-blockchain-survey/image-20230808103822367.png" alt="image-20230808103822367"></li><li>bias-resistance <strong>抗偏置性</strong> 指敌手的参与不会影响结果的随机性</li><li>可用性保证随机数能够产生</li><li>轮随机数一般用于 将节点随机分配为分片，作为PoW的puzzle</li></ul></li><li>节点分配：将选择出的节点随机分配到$m$个分片中，每个分片$k$个新节点<ul><li><img src="/2023/08/06/sharding-blockchain-survey/image-20230808104409602.png" alt="image-20230808104409602"></li><li>实际上 $anode$ 和下轮参与协议的节点并不一定相同，不同的分片区块链存在不同的替代旧节点的规则</li></ul></li><li>片内共识：<ul><li>在普通区块链中，proposal是交易，在分片区块链中 $p$ 可以是交易，交易输入或者其他承诺的值</li><li><img src="/2023/08/06/sharding-blockchain-survey/image-20230808104851668.png" alt="image-20230808104851668"></li><li>可以划分为强共识和弱一致性共识</li><li>异步环境下只能实现活性或者一致性，一致性对分片更重要</li></ul></li><li>跨片交易处理：<ul><li><img src="/2023/08/06/sharding-blockchain-survey/image-20230808105414053.png" alt="image-20230808105414053"></li><li>跨片交易占据分片区块链系统的大部分交易</li><li>片内交易可以视为特殊的跨片交易</li><li>可划分为2个阶段<ul><li>输入分片生成的证明，证明交易的输入有效并且将证明发送其他相关分片</li><li>所有相关分片验证交易是否有效</li></ul></li></ul></li><li>分片重配置：决定下轮每个分片内的节点<ul><li><img src="/2023/08/06/sharding-blockchain-survey/image-20230808110515006.png" alt="image-20230808110515006"></li><li>需要设计自举阶段，当新节点加入分片时如何下载历史交易数据</li><li>安全性要求每个分片是诚实的</li></ul></li><li>激励机制<ul><li>包括对诚实节点的奖励和对恶意节点的惩罚</li><li><img src="/2023/08/06/sharding-blockchain-survey/image-20230808111215363.png" alt="image-20230808111215363"></li></ul></li></ul><h2 id="Composing-separate-components-into-sharding-blockchain-systems"><a href="#Composing-separate-components-into-sharding-blockchain-systems" class="headerlink" title="Composing separate components into sharding blockchain systems"></a>Composing separate components into sharding blockchain systems</h2><p>实际的分片区块链系统是上一节提到的组件的组合</p><p><img src="/2023/08/06/sharding-blockchain-survey/image-20230808111557856.png" alt="image-20230808111557856"></p><ul><li>NS NA ER SR可以视为阶段一，对分片成员列表的确认</li><li>Isc CSTp可以视为阶段二，负责交易处理</li></ul><p>根据片内共识，sharding blockchains could be divided into instant sharding blockchains and eventual sharding blockchains</p><p>以下是对现有分片区块链拆解后进行分类的结果</p><p><img src="/2023/08/06/sharding-blockchain-survey/image-20230808112726370.png" alt="image-20230808112726370"></p><p>表2对当前的分片区块链系统进行了总结与对比</p><p><img src="/2023/08/06/sharding-blockchain-survey/image-20230808113640210.png" alt="image-20230808113640210"></p><h1 id="Node-Selection"><a href="#Node-Selection" class="headerlink" title="Node Selection"></a>Node Selection</h1><p>困难点：</p><ul><li>所有节点对选择结果的视图应该一致</li><li>需要满足诚实节点的比例足够高</li><li>给出安全证明</li></ul><p>许可链中由CA完成，主要讨论无许可链中的情况，采用PoW或PoS，需要考虑难度的设计</p><p>节点选择过程一般会导致诚实节点的比例降低，为了量化这个降低的程度，给出了诚实部分下降程度的定义</p><p><img src="/2023/08/06/sharding-blockchain-survey/image-20230809181503587.png" alt="image-20230809181503587"></p><p>为了防止诚实节点的比例下降太多，给出了公平选择的定义</p><p><img src="/2023/08/06/sharding-blockchain-survey/image-20230809181956036.png" alt="image-20230809181956036"></p><p>现有方案</p><h2 id="基于PoW的节点选择"><a href="#基于PoW的节点选择" class="headerlink" title="基于PoW的节点选择"></a>基于PoW的节点选择</h2><p>两类，依赖底层的区块链或参考委员会reference committee</p><p>首先是依赖底层区块链的方法</p><p><img src="/2023/08/06/sharding-blockchain-survey/image-20230809182522545.png" alt="image-20230809182522545"></p><p><img src="/2023/08/06/sharding-blockchain-survey/image-20230809182702543.png" alt="image-20230809182702543"></p><ul><li>$str$是上一个区块的哈希值</li><li>$pub_i$包含节点的若干公开信息，用于证明节点的身份，一般包含公钥</li><li>$D=p\cdot2^\lambda$，有$Pr[H(str,nonce,pk_i)&lt;D]=p$，即$p$是节点发现解的概率</li></ul><p>发现解的节点作为新分片的成员，当足够数量的分片成员出现后，进行分片重配置</p><p>Omniledger的具体实现是在轮$e$，想要成为$e+1$轮分片成员的节点在identity blockchain上进行挖矿</p><p>其次是依赖参考委员会的方法</p><p><img src="/2023/08/06/sharding-blockchain-survey/image-20230809183412616.png" alt="image-20230809183412616"></p><p>包含两步</p><ul><li>挖矿。节点在当前轮针对特定puzzle进行挖矿，同样是PoW，求解后发送给委员会<ul><li>和之前的区别是同一轮内所有人求解的难题相同，即不出块；</li><li>同一个节点多次计算，不影响安全性，敌手的算力有限？</li></ul></li><li>新节点列表确认。数量足够后进行片内共识，确认后广播list<ul><li>RapidChain利用参考委员会来选择节点，难题是VSS生成的</li></ul></li></ul><p>依赖底层区块链存在的问题：敌手可能进行自私挖矿、固执挖矿、扣快攻击</p><ul><li>自私挖矿：敌手出块后不公开，等待私链更长后再公开，浪费诚实节点算力</li><li>固执挖矿：类似于自私挖矿，但是挖一个并行的私链，导致分叉</li><li>扣块攻击</li><li>日蚀攻击</li><li>网络分片攻击</li></ul><p>这些介绍和节点选择理论上没关系</p><p>backbone protocol给出了理论上敌手能够控制的区块比例上界为$t/(n-t)$,t是敌手的算力，n是全网的算力</p><p>基于委员会方法的问题：包含两方面，敌手挖矿时的时间优势，新节点列表的确认</p><ul><li>时间优势指敌手可以恶意延迟诚实节点发送的消息，敌手可以提前获得挖矿的puzzle，可以恶意延迟诚实节点的解;敌手可能给出多个解，需要解的数量超过某个下界（有详细的文章讨论这个问题</li><li>发现了足够多解后，委员会运行片内共识算法进行新节点的确认，BFT类共识片内有leader负责propose新节点的列表，恶意的leader可能censor这个列表<ul><li>普通节点投票时不检查有效性，导致恶意节点数量过多</li><li>如果检查了有效性不予投票，影响活性</li><li>可能通过门限投票机制解决</li></ul></li></ul><p>未来的研究方向：</p><ul><li>设计更公平的节点选择机制，HFDD尽可能小</li><li>分析各种攻击</li><li>采用严格的分析方法分析挖矿过程的安全性</li></ul><h2 id="基于PoS的节点选择"><a href="#基于PoS的节点选择" class="headerlink" title="基于PoS的节点选择"></a>基于PoS的节点选择</h2><p>节点本身的币越多，被选择的概率就越高，需要将系统内的币分成小的单元，每个单元均有参与节点选择的权利；用VRF判断单元是否被选中，同样有两类方法，依赖底层区块链或不依赖</p><ul><li>依赖底层区块链：节点同样根据PoS出块，某一时间段内的出块者作为分片成员</li><li>不依赖底层区块链：需要先选委员会<ul><li>CCS19这篇工作的选委员会机制为 $H(v’s\  address||H(b)) \bmod k$,其中$v$是节点，$b$是上轮的最后一个区块，$k$是分片数量</li><li>？哪里有PoS</li><li>D.R. Lee, Y. Jang, H. Kim, Poster: A proof-of-stake (PoS) blockchain<br>protocol using fair and dynamic sharding management, in: Proceedings<br>of the 2019 ACM SIGSAC Conference on Computer and Communications<br>Security, CCS 2019, London, UK, November 11-15, 2019, 2019, pp.<br>2553–2555.</li></ul></li></ul><p>存在的问题：</p><ul><li>无利害攻击：在各个分叉上挖矿，成本较小；增加自己成功的概率：需要惩罚机制</li><li>grinding attack：攻击者遍历区块链，在不同的分叉上尝试出块，提高自己成为下一个leader的概率，因为有的链e+1轮的出块者是根据前一轮的出块者决定的；可以用无偏的随机性来解决</li><li>长程攻击：新节点加入时用虚假的链骗他。PoW的链可以通过比较挖矿难度来判断主链，而PoS可以获得曾经有很高权益的节点的私钥，以较低的成本实现这样的攻击；采用检查点机制可以防御</li><li>权益流失攻击：长程攻击成功后敌手可以在新的链上发动双花，交易也会在新的链上记录，导致了诚实链权益损失</li></ul><p>未来的研究方向：</p><ul><li>实际应用密码工具的通信和计算开销需要考虑</li></ul><h2 id="基于CA的节点选择"><a href="#基于CA的节点选择" class="headerlink" title="基于CA的节点选择"></a>基于CA的节点选择</h2><p>首先在CA处进行身份认证，CA在节点数量足够或当前轮最后公布节点列表</p><h1 id="Epoch-randomness"><a href="#Epoch-randomness" class="headerlink" title="Epoch randomness"></a>Epoch randomness</h1><p>首先给出轮随机数相关的基本概念，再给出现有的生成随机数的方案（VRF、PVSS)，再比较现有的DRB，分析未来的研究方向</p><h2 id="Basic-Concepts"><a href="#Basic-Concepts" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h2><p>可以用做puzzle，作为节点随机分配的种子</p><p>需要解决的问题：</p><ul><li>确定参加轮随机数协议的节点</li><li>每轮调用 随机数协议的时间点需要确定</li><li>随机数生成协议的时间 系统开销和失败概率需要仔细考虑</li><li>生成的随机数的性质需要满足分片区块链的要求</li></ul><p>当节点互不信任时，如何公平地产生随机数：密码学工具，如DRB，满足</p><ul><li>公开可验证性：任何不直接参与协议的第三方同样能利用公开的信息验证产生的随机数</li><li>不可预测性：任何节点不能预测未来的随机值</li><li>抗偏置性：节点甚至合谋的节点也不能将随机数影响为对自己有利的</li><li>可用性/活性：节点甚至合谋的节点也不影响协议进程</li></ul><h2 id="Existing-approaches"><a href="#Existing-approaches" class="headerlink" title="Existing approaches"></a>Existing approaches</h2><p>主要包括VRF、PVSS、门限签名、Hash和VDF</p><ul><li>VRF：所有节点用私钥作为输入生成随机数，输出的随机数带有零知识证明，节点将VRF的输出和轮随机数结合后签名，最小的作为leader或者委员会成员<ul><li>目的：本地生成可验证和不可预测随机数</li><li>Algorand, Ouroboros Praos, and DVRFs</li></ul></li><li><p>门限签名：签名算法需要门限个参与者才行执行，验证算法任何人都可以执行</p><ul><li>在随机数生成中的具体使用：所有参与者提供对共同消息的签名份额，验证收到的签名份额具体并输出随机数</li><li>密钥分发<ul><li>可信的dealer</li><li>DKG</li></ul></li></ul></li><li><p>PVSS：分发阶段dealer计算加密的份额，并发送非交互式零知识证明</p><ul><li>节点秘密生成一个随机值</li><li>广播随机值的承诺和份额</li><li>验证后揭露秘密，节点未能揭露则执行秘密分享的恢复算法</li></ul></li><li><p>Hash：PoW</p></li><li>VDF：计算必然缓慢，验证高效</li><li>同态加密、MACPABE多Authority的</li></ul><h2 id="现有DRB方案的比较"><a href="#现有DRB方案的比较" class="headerlink" title="现有DRB方案的比较"></a>现有DRB方案的比较</h2><p><img src="/2023/08/06/sharding-blockchain-survey/image-20230811112615922.png" alt="image-20230811112615922"></p><p>通信复杂度指所有节点每轮发送的bit，计算复杂度指每个节点每轮的操作数，验证复杂度指外部验证者每轮的操作数</p><ul><li>基于PoW和PoS的方案更适合大规模和动态参与者</li><li><p>RandRunner 受网络延迟和网络崩溃的影响非常小</p></li><li><p>Ouroboros , RandShare, Scrape and HydRand 通信复杂度过高，适合小集合参与者</p></li></ul><h2 id="Problems-and-future-directions"><a href="#Problems-and-future-directions" class="headerlink" title="Problems and future directions"></a>Problems and future directions</h2><ul><li>安全性：<ul><li>随机性的三个属性</li><li>VDF方案的安全性依赖于具体过程的时间复杂度，实际中难以设置参数</li></ul></li><li>性能：参与节点越多，系统一般越安全<ul><li>完美安全性的协议计算和通信复杂度都非常高，如Ouroboros</li><li>基于门限密码的方案需要执行DKG</li><li>大多数协议不支持频繁的节点集合更新</li></ul></li><li>形式化的安全性分析<ul><li>形式化定义：协议的可组合性</li><li>精确的假设：大多数方案是同步模型</li><li>安全性证明</li></ul></li></ul><h1 id="Node-assignment"><a href="#Node-assignment" class="headerlink" title="Node assignment"></a>Node assignment</h1><p>将新节点随机分配到不同的分片中，否则敌手可能在特定分片内可能获得控制权</p><ul><li>需要确保分配过程的随机性</li><li>合理设置参数，每个分片内诚实大多数：需要采用特定数学模型来严格分析最终的分布</li></ul><h2 id="现有方案"><a href="#现有方案" class="headerlink" title="现有方案"></a>现有方案</h2><p>$n,m,u$ 分别是节点总数，分片个数和每个分片内节点数</p><h3 id="二项分布"><a href="#二项分布" class="headerlink" title="二项分布"></a>二项分布</h3><p>节点分配过程视作随机采样问题，分配前的节点看做无限池，每次从池中取一个节点，该节点诚实和恶意的概率不变（不够合理）</p><p>当选择出的委员会为恶意，则称该分布失败</p><p>设$Q_0$表示目标的诚实节点比例，$X$表示取的次数，敌手的算力占比为$\rho$，则敌手在分片内占比为$1-Q_0$的概率为</p><script type="math/tex; mode=display">Pr[X=u(1-Q_0)]=C_{\mu}^{\mu(1-Q_0)}\rho^{\mu (1-Q_0)}(1-\rho)^{\mu Q_0}</script><p>因此失败的概率可以记作</p><script type="math/tex; mode=display">Pr[X\geq \mu(1-Q_0)+1]= \sum^{\mu}_{x=\mu(1-Q_0)+1} C_{\mu}^{x}\rho^{x}(1-\rho)^{\mu-x}</script><p>Omniledger采用了二项分布</p><h3 id="超几何分布"><a href="#超几何分布" class="headerlink" title="超几何分布"></a>超几何分布</h3><p>不再是无限池，每次选择节点后不再放回，节点的诚实和恶意的概率发生变化</p><p>失败的概率为</p><script type="math/tex; mode=display">Pr[X\geq (1-Q_0)\mu+1]=\sum^{\mu}_{x=(1-Q_0)\mu+1}\frac{C_{\rho n}^xC^{\mu-x}_{(1-\rho)n}}{C_n^\mu}</script><p>根据其他参数来选择 $\rho$ 使得失败概率足够小，如$10^{-5}$</p><p>RapidChain和SGX sharding采用了超几何分布对轮的安全性进行分析</p><h3 id="其他分布"><a href="#其他分布" class="headerlink" title="其他分布"></a>其他分布</h3><p>实际上二项分布和超几何分布都基于 节点的分配时随机的，然而现有方案可能依赖特定规则</p><p>如Polyshard在编码后的分片上进行计算以及分片异构的Pyramid</p><h2 id="Problems-and-future-directions-1"><a href="#Problems-and-future-directions-1" class="headerlink" title="Problems and future directions"></a>Problems and future directions</h2><p>节点选择和节点分配是相互联系的</p><p><img src="/2023/08/06/sharding-blockchain-survey/image-20230811153629981.png" alt="image-20230811153629981"></p><ul><li>现有方案忽略了A到B的安全性，事实上B中的敌手比例比A中的更高($&gt;\rho$)，因为<ul><li>敌手可能在消息发送中占优，即能够更早开始挖矿</li><li>如果参考委员会当中的leader是恶意的，可能会进行censor，增加被控制节点的比例</li></ul></li><li>无限池假设不够准确</li><li>累计超几何分布的失败率不够精确<ul><li>仅第一个委员会的概率是正确的，后续的委员会选择受前一个委员会的影响</li></ul></li></ul><h1 id="Intra-shard-consensus"><a href="#Intra-shard-consensus" class="headerlink" title="Intra-shard consensus"></a>Intra-shard consensus</h1><p>片内共识是分片区块链的关键模块，本章首先给出片内共识的基本概念，再划分为立即和最终分片，给出了状态机复制算法，总结了片内共识算法存在的问题</p><h2 id="Basic-concepts"><a href="#Basic-concepts" class="headerlink" title="Basic concepts"></a>Basic concepts</h2><p>片内共识算法的目的是高效地处理片内的交易以及和其他分片合作处理跨片交易，需要片内共识算法给出对相关交易输入的可用性证明，证明是签名的形式</p><p>除此之外，在某些采用参考委员会的分片区块链中，片内共识算法用于确认新委员的名单，片内共识算法影响具体的效率，需要考虑的问题包括：</p><ul><li>片内共识算法的可扩展性：与通信和计算复杂度相关</li><li>需要处理分片区块链特有的不同提案</li><li>片内的网络环境和整个区块链的网络之间的关系</li></ul><p>片内共识算法可以分为两类</p><ul><li>强一致性共识算法：每个分片均有委员会，委员会作为出块者，委员会运行BFT类共识，对应立即分片区块链</li><li>弱一致性共识算法：分片内采用PoW或者PoS，对应最终分片区块链</li></ul><h2 id="现有的方案"><a href="#现有的方案" class="headerlink" title="现有的方案"></a>现有的方案</h2><h3 id="Strong-consistency"><a href="#Strong-consistency" class="headerlink" title="Strong consistency"></a>Strong consistency</h3><p>经典的分布式共识算法，实现状态机复制</p><p>对节点的假设不同：宕机、拜占庭节点；一般认为拜占庭节点包括宕机，能够容忍拜占庭节点的协议具有更强的适应性和鲁棒性，主要介绍BFT类的共识</p><h4 id="同步网络"><a href="#同步网络" class="headerlink" title="同步网络"></a>同步网络</h4><h5 id="分布式共识协议"><a href="#分布式共识协议" class="headerlink" title="分布式共识协议"></a>分布式共识协议</h5><p>拜占庭将军问题首先提出了法定人数问题，防止恶意的leader模棱两可，即同一轮向不同的诚实节点发送不同的提案</p><p>在部分同步网络中，若敌手模型为$u=3f+1$，则法定人数为$2f+1$</p><p>设恶意的leader同一轮向不同节点发送了不同的提案$p,p’$，则如果两者投票分别为$x$，$2x-(3f+1)$就是该轮同时对两个提案投票的节点个数，则需要满足$2x-(3f+1)&lt; f+1$，即$x&lt; 2f+1$，因此设置投票法定人数为$2f+1$即可</p><p>同步的HotStuff采用了流水线的技术来改善提案效率，采用两阶段的基于领导者的方法来处理交易，交易的确认时延为$2\Delta$</p><p><img src="/2023/08/06/sharding-blockchain-survey/image-20230811164850841.png" alt="image-20230811164850841"></p><h5 id="和分片区块链结合"><a href="#和分片区块链结合" class="headerlink" title="和分片区块链结合"></a>和分片区块链结合</h5><p>在分片区块链当中，片内和全局的消息传播模型可能不同</p><p>Rapidchain采用了实用同步BFT共识协议，敌手模型为$u=2f+1$，利用参考委员会生成的随机数选举leader，片内共识主要包括四轮</p><ul><li>propose：领导者广播消息和哈希值</li><li>echo：节点收到消息后广播哈希值，确保每个诚实节点都能收到leader发送的消息</li><li>pending：如果恶意leader发送了多条消息，诚实节点能够检查到，将冲突消息标记为pending（待定）并广播，恶意leader将会被取代</li><li>accept：诚实节点收到f+1个有效的echo后认为提案是有效的，广播带有accept的哈希值</li></ul><p>Rapidchain允许leader利用pending的区块，即可以提出新的区块时重新提案pending区块的区块头</p><p>采用同步网络模型，因此容忍委员会的敌手为$50\%$，牺牲了交易处理的效率</p><p>每个节点需要每轮等待$\Delta$时间，导致了交易确认时间和实际的网络时延无关，不满足响应性。在半同步网络和异步网络中无法直接使用$\Delta$</p><h4 id="部分同步"><a href="#部分同步" class="headerlink" title="部分同步"></a>部分同步</h4><p>部分同步网络是大多数区块链采用的网络模型，首先给出经典方案再和分片区块链结合</p><h5 id="分布式共识算法"><a href="#分布式共识算法" class="headerlink" title="分布式共识算法"></a>分布式共识算法</h5><ul><li><p>Paxos：本来是为分布式数据库维护设计的算法，支持$u=2f+1$个宕机节点，不支持拜占庭节点，实际上在区块链中的应用很少</p><ul><li>主节点向超过50%的备份节点发送prepare消息</li><li>备份节点验证消息的合法性，向主节点返回承诺后的消息；</li><li>主节点在收到足够多的承诺消息后构造承诺证明，向备份节点发送包括承诺证明的确认消息；</li><li>备份节点收到确认消息后验证合法性，向主节点返回确认消息的确认消息</li></ul></li><li><p>PBFT：大多数分片区块链或基于委员会的共识协议均采用PBFT类的共识，非常重要，敌手模型为$u=3f+1$，采用消息验证码进行身份认证；实现了一致性和活性</p><ul><li>共识部分具体流程如图所示，复杂度$O(n^3)$<img src="/2023/08/06/sharding-blockchain-survey/image-20230811175214951.png" alt="image-20230811175214951"></li><li>在propose阶段，client给所有节点上传提案$p$</li><li>pre-prepare阶段：主节点给所有节点发送构造的pre-prepare消息$(pre-prepare,H(m),s,v)$，$s$是序列号，$v$是视图，记录主节点的更替，视图转换后值+1</li><li>prepare阶段：备份节点确认对于当前的$(s,v)$没有冲突的准备消息，然后广播prepare消息$(prepare,H(p),s,v)$</li><li>commit阶段：收到$2f+1$个有效的prepare消息后，备份节点认为$p$是已经准备好了，广播commit消息$(commit,H(p),s,v)$</li><li>reply阶段：收到$2f+1$个有效的commit消息后，备份节点认为$p$已经被承诺了，将承诺后的提案和签名发送给client</li></ul><p>PBFT包括以上的共识部分和视图转换部分，当主节点不能及时处理数据时，备份节点发起视图转换，换主后新的主节点开始工作，采用round robin的方式进行更换，检查点机制用于协助视图转换，所有commited的提案中最大的序列号被认为是稳定的checkpoint</p><ul><li>视图转换复杂度为$O(n^4)$，视图转换的具体协议如下所示：<ul><li>view-change message broadcast阶段，节点$i$广播视图转换消息$vc_i:(view-change,v+1,S^<em>,C,U,i)$，其中$S^</em>$​代表当前稳定的检查点的序列号，$C$是$S^<em>$的$2f+1$个commit投票，$U$包含节点$i$当前视图下, 序列号大于$S^</em>$, 且已经形成prepared的消息集合</li><li>view-change acknowledgment阶段，备份节点验证vc消息并且构造对应的ack消息$vca_i:(view-change-ack,v+1,i,j,H(vc_j))$，直接发送给新视图的主节点（轮转决定）</li><li>new-view broadcast阶段，对每个视图转换消息$vc_j$，当主节点收到$2f-1$个ack后，$vc_j$就认为有效放入集合S中，新的主节点构造新视图消息$nv:(new-view,v+1,S,U^<em>)$，其中$U^</em>$包括当前稳定的检查点和检查点之后的序列号最小的pre-prepare消息，节点根据nv更新自己本地的状态，进入视图v+1</li></ul></li></ul></li><li><p>Hotstuff是对PBFT的改进，同样是部分同步网络，$u=3f+1$，特点包括：</p><ul><li>采用流水线处理提案，每轮的消息包括前一轮的法定证明和当前轮的新天</li><li>采用BLS签名聚合$2f+1$个投票为1个签名，降低了通信复杂度</li><li>每轮负责收集投票和发送提案的主节点都要更换</li><li><img src="/2023/08/06/sharding-blockchain-survey/image-20230811182751759.png" alt="image-20230811182751759"></li><li>观察到第4轮没有填仍然进行，考虑到活性</li><li>现有其他的BFT类共识，scalable Byzantine fault tolerance，Pala</li></ul></li></ul><h5 id="和分片区块链结合-1"><a href="#和分片区块链结合-1" class="headerlink" title="和分片区块链结合"></a>和分片区块链结合</h5><p>Paxos和分片区块链结合的工作很少，现在的工作都基于PBFT类共识</p><ul><li>ELASTICO直接使用PBFT，无法处理跨片交易，效率较低</li><li>Omniledger基于Byzcoin设计了Omnicon<ul><li>Byzcoin将MAC替换为数字签名，利用了树型的通信结构和CoSi协议，结合了CoSi和PBFT</li><li>指出CoSi容易受到错误，通信树的深度太大了，进行了改进</li></ul></li><li>ZILLIQA利用EC-Schnorr multi-signature protocol提高了PBFT的效率</li><li>Chainspace采用MOD-SMART的PBFT作为片内共识</li></ul><h4 id="异步网络"><a href="#异步网络" class="headerlink" title="异步网络"></a>异步网络</h4><h5 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a>共识算法</h5><p>FLP不可能定义给出了在异步网络下不存在确定性共识算法能够解决一致性问题</p><p>HoneyBadger BFT是异步下BFT共识的代表，敌手模型为$u=3f+1$</p><p>异步BFT依赖于可靠广播RBC和异步二进制协议ABA</p><ul><li>交易收集阶段，u个参与节点同时收集交易</li><li>交易门限加密阶段对收集到的交易进行B/U加密</li><li>RBC广播阶段，每个节点依赖于RBC广播并收集信息，RBC包括echo和ready两轮</li><li>ABA共识阶段，leader负责收集所有加密的值并且初始化ABA算法</li><li>交易门限解密阶段，如果加密的交易集有效，每个节点运行门限解密算法</li></ul><p>其他异步网络下的分布式共识协议还有：MinBFT、Dumbo-MVBA、BEAT等</p><p>目前没有分片区块链采用异步共识作为片内共识算法，可能是跨片交易依赖于共识协议在每个分片内的活性，当分片区块链处理跨分片交易时，多个分片需要合作并在一定时间内响应，然而异步网络下的共识机制牺牲了活性来保证安全性</p><h3 id="weak-consistency"><a href="#weak-consistency" class="headerlink" title="weak consistency"></a>weak consistency</h3><p>最终分片区块链一般使用 PoW PoS或者其他弱一致性方法在每个分片内生成区块，不存在委员会</p><ul><li><p>Monoxide提出了楚弩挖矿来实现PoW的片内共识算法，能够防御1%攻击，矿工需要在多个链上进行挖矿，m个不同链上的区块的区块头形成merkle树，树根和nonce作为hash的输入，然而矿工需要收集并验证m个区块链上所有的信息，实际上并没有实现可扩展性</p></li><li><p>Parallel Chains将VRF和PoS结合起来在每个分片内生成区块</p></li></ul><h2 id="问题和未来的研究方向"><a href="#问题和未来的研究方向" class="headerlink" title="问题和未来的研究方向"></a>问题和未来的研究方向</h2><p>分别从立即分片区块链和最终分片区块链的角度进行总结</p><h3 id="立即分片区块链"><a href="#立即分片区块链" class="headerlink" title="立即分片区块链"></a>立即分片区块链</h3><ul><li>降低分片成员间的通信复杂度：片内分布式共识算法一般依赖多轮投票来达成一致，在投票阶段如果每个成员均发送签名、收集和验证签名，通信量很大；而且每个分片内为了保证安全性，分片成员个数需要达到安全门限</li><li>恶意委员检测和恢复机制：多个分片运行分布式共识算法，可能会有特定的委员会被敌手掌握，如何检测通过其他诚实分片检测恶意分片的委员会并且设计特定的机制来取代恶意委员会是未来的研究方向</li><li>片内和跨片的高效的视图转换机制：降低分片成员的通信复杂度，如何降低leader的负担、公平合理地选择新的leader；处理跨片交易时可能不同分片委员会之间的视图不一致，如何处理（leader诚实执行片内工作，丢弃跨片交易）</li><li>和分片区块链更好的结合：片内共识算法还需要处理跨片交易，需要多个分片运行多轮片内共识；输入可能多样化，不只是交易</li></ul><h3 id="最终分片区块链"><a href="#最终分片区块链" class="headerlink" title="最终分片区块链"></a>最终分片区块链</h3><ul><li>1%攻击问题。以PoW为例，敌手可以集中他的算力在某个分片上进行挖矿，安全性要求是敌手不能超过该分片51%的算力。假设存在m个分片，则敌手成功的所需要的算力降低为51%/m，当m足够大时，51%/m近似等于1%。因此在最终分片区块链上如何解决1%攻击非常重要</li><li>复杂的跨片交易处理。分片内产生的区块不能被立即确认，区块需要达到一定深度时才能保证稳定，因此跨片交易处理在最终分片区块链中更加复杂。</li></ul><h1 id="Cross-shard-transaction-processing"><a href="#Cross-shard-transaction-processing" class="headerlink" title="Cross-shard transaction processing"></a>Cross-shard transaction processing</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>分片区块链中交易是跨片交易的概率非常高，概率随分片数量增加而增加</p><p>Rapidchain当分片为16时，跨片交易的占比为99.8%，处理跨片交易的机制对分片区块链的性能影响很大</p><p>跨片交易处理过程中需要解决2个问题</p><ul><li>跨片通信和处理机制的设计，一个交易的输入可能被多个分片控制，多个分片需要协作判断交易的有效性</li><li>防止双花攻击的机制。防止交易输入被双花</li></ul><h2 id="现有方案-1"><a href="#现有方案-1" class="headerlink" title="现有方案"></a>现有方案</h2><ul><li><p>立即分片区块链：2阶段承诺和交易拆分</p></li><li><p>最终分片区块链：中继交易解决方案</p></li></ul><h3 id="两阶段承诺-2PC-方案"><a href="#两阶段承诺-2PC-方案" class="headerlink" title="两阶段承诺(2PC) 方案"></a>两阶段承诺(2PC) 方案</h3><p>大多数跨片交易处理方案基于2PC进行设计，包括准备阶段和承诺阶段</p><p>存在一个协调者负责收集输入的可用性证明并在相关分片内进行发送</p><ul><li>在准备阶段，协调者收集证据来证明交易的输入的可用性，证据一般是片内节点运行BFT共识输出的，一般是多个签名或单个聚合签名的形式，同时该输入应该被锁定</li><li>承诺阶段，协调者将所有输入的可用证明发送给所有相关的分片，包括输入分片和输出分片，如果所有输入有效，交易就被认为是有效的，在相关分片内进行了承诺，输入会被花费，输出将会被创建</li></ul><p>根据协调者的角色，可以将2PC方案分为客户端驱动的2PC和分片驱动的2PC</p><ul><li>客户端驱动的2PC：客户端负责在准备阶段收集证明并在承诺阶段发送给相关分片<ul><li><img src="/2023/08/06/sharding-blockchain-survey/image-20230812170637555.png" alt="image-20230812170637555"></li><li>Omniledger采用了客户端驱动的2PC方案，每个分片内由leader签名是否accept</li></ul></li><li>分片驱动的2PC：1个或2个分片承担协调者的作用。准备阶段输入分配生成输入的可用性证明，承诺阶段一个有效的交易会在所有输入和输出分片中被接受。和客户端驱动的2PC相比，客户端的压力被减轻了，只需要提交交易等待回复<ul><li><img src="/2023/08/06/sharding-blockchain-survey/image-20230812171601751.png" alt="image-20230812171601751"></li><li>图a中所有的输入分片都是协调者，图b中一个输入分片负责进行协调，两类的通信复杂度相同</li><li>Chainspace RSTB Fleetchain采用了分片驱动的跨片交易处理机制</li></ul></li></ul><h3 id="交易拆分方案"><a href="#交易拆分方案" class="headerlink" title="交易拆分方案"></a>交易拆分方案</h3><p>RapidChain提出的，将多输入多输出的跨片交易拆分为多个单输入单输出的交易</p><p>如图所示，由输出分片的委员会对交易进行拆分，如果两个输入委员会分别对$tx_1,tx_2$通过，则输出委员会会正确执行$tx_3$</p><p><img src="/2023/08/06/sharding-blockchain-survey/image-20230812172946353.png" alt="image-20230812172946353"></p><p>Instachain采用了交易拆分方案，如果一个交易输入有效，另一个交易输入无效，则有效输入对应的子交易会直接发送给输出分片（？</p><h3 id="交易中继方案"><a href="#交易中继方案" class="headerlink" title="交易中继方案"></a>交易中继方案</h3><p>一般在最终分片区块链中使用，，每个委员会内不运行BFT，交易或可用性证明不会立即确认，无法采用2PC方法。</p><p>核心思想：保证在每个输入分片内输入相关的交易未得到足够确认前，输出分片不会把交易作为有效交易</p><p>基本步骤</p><ul><li>输入分片的矿工收集跨片交易$tx$，验证账户的余额是否大于交易额，如果满足则认为合法</li><li>矿工发现PoW的解后，构造包含$tx$的区块，其他矿工验证区块，生成对应的中继交易$\psi$，发送给输出分片的矿工</li><li>输出分片的矿工收到中继交易后验证合法性，如果中继交易$\psi$已经达到了对应安全的深度$\lambda$，确定交易成功</li></ul><p>Monoxide采用了中继交易的形式</p><h2 id="问题和未来的研究方向-1"><a href="#问题和未来的研究方向-1" class="headerlink" title="问题和未来的研究方向"></a>问题和未来的研究方向</h2><p>给出3类方案对应的问题</p><h3 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h3><ul><li>客户端驱动的方案（使用不广泛）<ul><li>leader恶意：准备阶段leader可能给出错误的证明或无法回复，如果恶意的leader对不合法的输入进行保证，其他分片可能会通过</li><li>如果客户端在commit阶段未能发送对应的证明，可能导致交易被永远锁定<ul><li>客户端恶意或者离线</li></ul></li><li>客户端负担加重：客户端需要记录分片的状态和参与节点的IP地址，为了和leader通信</li></ul></li><li>分片驱动的<ul><li>运行多次BFT，设计流水线处理的片内共识处理机制</li><li>可能的攻击：<ul><li>重放攻击，利用之前交易的可用性证明伪造出新的交易的可用性证明，添加标识符即可防御；</li><li>交易泛洪攻击：敌手可能伪造大量由特定分片进行处理的交易，破坏活性；将交易分配给不同分片进行防御</li></ul></li><li>恶意的协调者：特定输入或输出分片的领导者作恶，延迟可用性证明得到处理等行为</li></ul></li></ul><h3 id="拆分交易"><a href="#拆分交易" class="headerlink" title="拆分交易"></a>拆分交易</h3><p>没有给出具体的实现细节，需要进一步研究</p><ul><li>产生$c_{out}$分片公钥的方法不明确，一般决定输入分片的方法是利用公钥的哈希值来确定输入分片，然而在交易拆分阶段，需要生成多个公钥地址，具体的方式没有给出</li><li>新生成的输出可能被非法地花费：其中一个有效一个无效；或者输出分片的leader知道新交易的私钥</li><li>处理多输出交易的方法没有给出，比较复杂</li><li>交易数量增加，增加计算和存储开销</li></ul><h3 id="中继交易"><a href="#中继交易" class="headerlink" title="中继交易"></a>中继交易</h3><ul><li>交易确认延迟比较长：每个输出分片先确认，输出分片再确认</li><li>处理多输入消息比较困难：基于账户模型比较少，UTXO比较多，open problem</li><li>一旦出现分叉，链的安全性受到影响</li></ul><h1 id="Shard-reconfiguration"><a href="#Shard-reconfiguration" class="headerlink" title="Shard reconfiguration"></a>Shard reconfiguration</h1><h2 id="Basic-concepts-1"><a href="#Basic-concepts-1" class="headerlink" title="Basic concepts"></a>Basic concepts</h2><p>为什么需要重配置：敌手可能发动腐化攻击控制节点，影响共识安全性</p><p>关键问题：</p><ul><li>确保每个人分片内的诚实节点数量超过门限</li><li>重配置阶段系统能够正常处理交易</li><li>腐化攻击不会成功</li></ul><p>基本步骤：</p><ul><li>在轮$e$，轮$e+1$的节点已经经过节点选择机制确认了</li><li>轮$e$末尾，节点替换已经达成一致</li><li>分片的新成员和旧成员协商，获得对应的账户、交易数据</li><li>旧成员不再工作，新节点开始处理交易，进入轮$e+1$</li></ul><p>目前的重配置仅部分委员会节点会被替换，原因是时间成本太高（历史交易数据</p><h2 id="Existing-approaches-1"><a href="#Existing-approaches-1" class="headerlink" title="Existing approaches"></a>Existing approaches</h2><ul><li><p>随机分配：每个旧节点被替换的概率相同，利用$PRG(H(c||\xi_e))$决定置换</p></li><li><p>特定规则</p><ul><li>时间顺序：类似于滑动窗口，取代时间最长的节点</li><li>有界布谷鸟：根据节点每轮处理的交易数量进行排序<ul><li><img src="/2023/08/06/sharding-blockchain-survey/image-20230812185632818.png" alt="image-20230812185632818"></li></ul></li></ul></li></ul><h2 id="Problems-and-future-directions-2"><a href="#Problems-and-future-directions-2" class="headerlink" title="Problems and future directions"></a>Problems and future directions</h2><ul><li>对腐化参数的定量分析：$\tau$ 表示敌手完成腐化需要的时间，PoW需要满足$\tau &gt;2T_e$,目前的文献缺少对这个参数的分析</li><li><p>新加入节点的自举：下载历史数据的过程，潜在的问题</p><ul><li>敌手可能提供假数据，如何验证正确性</li><li>性能：需要时间很长</li></ul></li><li><p>对新委员的安全性分析：对于随机替换方案，现有的分析假设了替换所有委员会节点；时间序列替换存在 敌手可能针对性攻击新加入节点的问题，导致安全性降低；对于有界布谷鸟规则，没有给出如何踢出I中的节点，实际上每个分片内节点处理的交易数量差不多</p></li><li>初始化阶段：如何安全的初始化创世区块，目前假设是可信第三方，可以考虑MPC</li></ul><h1 id="Motivaition-mechanism"><a href="#Motivaition-mechanism" class="headerlink" title="Motivaition mechanism"></a>Motivaition mechanism</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p>需要激励机制的原因</p><ul><li>节点越多，链越安全</li><li>节点消耗了计算资源和带宽，需要补偿或激励</li></ul><p>难点是奖励公平，作恶受到惩罚</p><p>一般假设节点是理性的，为了获得最大化的收益</p><p>包括incentive和penalty，研究很少</p><h2 id="现有方案-2"><a href="#现有方案-2" class="headerlink" title="现有方案"></a>现有方案</h2><ul><li>对出块者和leader的奖励：可能是一个节点获得奖励；也可能是运行BFT的委员会所有成员，再进行公平的分配<ul><li>Lever Manshaei等人的工作基于博弈论进行了分析 </li></ul></li><li>对负面行为的惩罚：需要先缴纳保证金<ul><li>捣乱sabotage：不投票、leader不出块、块内包含无效的交易</li><li>恶意行为：leader发两个冲突的提案，委员会成员投多次</li></ul></li><li>基于声誉的奖励：idea来自P2P系统，基于历史的行为打分，包括响应时间、处理的交易、节点相关的恶意行为数量，声誉越高的节点获得的奖励越多</li></ul><h2 id="问题和未来研究方向"><a href="#问题和未来研究方向" class="headerlink" title="问题和未来研究方向"></a>问题和未来研究方向</h2><ul><li>结合分片区块链：<ul><li>片内共识算法决定了需要更公平的奖励，所有人都想当leader，可能发起恶意的视图转换协议，敌手可能发起攻击，导致当前leader渎职然后换主，Hotstuff这种固定换主的共识协议更容易进行激励机制的设计</li><li>跨片交易处理的协调者如何奖励</li></ul></li><li>详细的分析，目前没有过对分片区块链激励机制的理论研究，需要经济学的基础</li></ul><h1 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h1><ul><li><p>分片共识综述</p><ul><li>[AFT19] 73分类比较抽象，组件分析不够明确 </li><li>[IEEE Access]216对每个方案进行了介绍，没有宏观的分类和分析</li><li>[arxiv19]116提供了更形式化的分析以及评价指标</li><li>[FC21] 72分析了跨片通信</li><li>[AFT22] 217主要分析了分片区块链的节点分配协议</li></ul></li><li><p>区块链共识</p></li><li>可扩展性</li></ul><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>本文将分片区块链解构为若干组件，分析了每个组件的基本概念，现有的解决方案和存在的问题以及未来的研究方向。简化了分片区块链的设计，每个组件可以单独改善，给出的未来研究方向具有一定意义</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Building-blocks-of-sharding-blockchain-systems-Concepts-approaches-and-open-problems&quot;&gt;&lt;a href=&quot;#Building-blocks-of-sharding-blockchain-systems-Concepts-approaches-and-open-problems&quot; class=&quot;headerlink&quot; title=&quot;Building blocks of sharding blockchain systems: Concepts, approaches,and open problems&quot;&gt;&lt;/a&gt;Building blocks of sharding blockchain systems: Concepts, approaches,and open problems&lt;/h1&gt;&lt;p&gt;继&lt;a href=&quot;https://alleysira.github.io/2023/05/31/Sharding-Blockchain-Consensus-lyj/&quot;&gt;Sharding_Blockchain_Consensus&lt;/a&gt; 之后阅读刘老师的综述文章&lt;/p&gt;
&lt;p&gt;分片技术是打破区块链去中心化、安全性和可扩展性不可能三角的最流行的方式，分片技术可以广义的理解为将区块链中的节点动态划分为彼此之间没有细粒度同步并且执行存储、计算和通信任务的子集，子集称为分片&lt;/p&gt;
&lt;p&gt;现有的分片区块链设计仍有很多可探索的空间，本文从此出发，对现有的分片区块链进行了系统的分析，并将它们的架构概念分解为功能组件，并推导出它们所基于的系统模型和攻击者的假设。推导出的功能组件包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;节点选择、轮随机数、节点分配、片内共识、跨片交易处理、分片重配置、激励机制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于每个功能组件，本文描述了接口、功能和性质，给出了组件如何组合成一个分片区块链系统并讨论了每个组件的后续研究方向；同样关注了潜在的安全攻击和性能问题，例如系统吞吐量和延迟&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/categories/Blockchain/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="Sharding" scheme="https://alleysira.github.io/tags/Sharding/"/>
    
  </entry>
  
  <entry>
    <title>IST23</title>
    <link href="https://alleysira.github.io/2023/07/26/IST23/"/>
    <id>https://alleysira.github.io/2023/07/26/IST23/</id>
    <published>2023-07-26T10:10:47.000Z</published>
    <updated>2023-07-26T10:36:52.805Z</updated>
    
    <content type="html"><![CDATA[<p>Chu H, Zhang P, Dong H, et al. A survey on smart contract vulnerabilities: Data sources, detection and repair[J]. Information and Software Technology, 2023: 107221.</p><p>发表于IST23 CCFB，介绍智能合约发展的综述文章</p><span id="more"></span><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>智能合约满足不可篡改性和无第三方的性质，现有研究聚焦于特定领域，如开发周期、攻击方法、安全监测工具等，本文从vulnerability data sources, vulnerability detection, and vulnerability defense三个方面进行研究。首先分析智能合约现有的安全问题和挑战，调查现有的漏洞分类框架和常见的安全漏洞，分析现有安全工具的性能，总结了智能合约安全相关研究</p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>主要研究合约层的安全，考虑以下几个问题</p><ul><li>矿工恶意，操纵交易顺序</li><li>合约相互调用可能存在风险</li><li>链上合约是由开发者写的，可能存在漏洞</li><li>合约独有的机制（如gas）可能会存在特定的安全问题</li></ul><p>发现合约的漏洞后，只能通过自毁进行止损，无法通过发布补丁或更新版本的方式进行修复</p><p>2016年以来主要的区块链攻击如表1所示</p><p><img src="/2023/07/26/IST23/image-20230726183149593.png" alt="image-20230726183149593"></p><p>作者调查了2015-2022年关于智能合约安全的文章，选出了49篇具有代表意义的</p><p>本文贡献：</p><ul><li>对智能合约安全时间和挑战全面的分析。</li><li>对智能合约安全监测和防御方法系统的回顾。包括现有的漏洞检测工具、性能测试工具和漏洞修复方法，对保证安全性的方法进行了总结</li><li>阐述了现有研究的不足和未来的研究方向。针对各种安全挑战，分析了现有智能合约安全方法的优缺点。特别是，本文广泛研究了可用的评估数据集，现有的漏洞修复方法和基于人工智能的漏洞检测方法。指出了解决这些不足的未来研究方向。</li></ul><h1 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;Chu H, Zhang P, Dong H, et al. A survey on smart contract vulnerabilities: Data sources, detection and repair[J]. Information and Software Technology, 2023: 107221.&lt;/p&gt;
&lt;p&gt;发表于IST23 CCFB，介绍智能合约发展的综述文章&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/categories/Blockchain/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="SmartContract" scheme="https://alleysira.github.io/tags/SmartContract/"/>
    
  </entry>
  
  <entry>
    <title>ConFuzzius</title>
    <link href="https://alleysira.github.io/2023/07/23/ConFuzzius/"/>
    <id>https://alleysira.github.io/2023/07/23/ConFuzzius/</id>
    <published>2023-07-23T03:09:40.000Z</published>
    <updated>2023-10-10T13:01:59.383Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ConFuzzius-A-Data-Dependency-Aware-Hybrid-Fuzzer-for-Smart-Contracts"><a href="#ConFuzzius-A-Data-Dependency-Aware-Hybrid-Fuzzer-for-Smart-Contracts" class="headerlink" title="ConFuzzius: A Data Dependency-Aware Hybrid Fuzzer for Smart Contracts"></a>ConFuzzius: A Data Dependency-Aware Hybrid Fuzzer for Smart Contracts</h1><p>这篇工作发表于<code>EuroS&amp;P21</code></p><p>Torres C F, Iannillo A K, Gervais A, et al. Confuzzius: A data dependency-aware hybrid fuzzer for smart contracts[C]//2021 IEEE European Symposium on Security and Privacy (EuroS&amp;P). IEEE, 2021: 103-119.</p><span id="more"></span><ul><li><p>符号执行的方法存在过拟合，导致假阳率</p></li><li><p>现有的模糊测试方法分析浅层的漏洞比较有效，对于执行时的深层的漏洞分析不够有效，导致较低的代码覆盖率/假阳</p></li><li>传统程序测试中已经证明结合符号执行和模糊测试的可行性</li></ul><p>ConFuzzius是第一个针对智能合约的混合模糊测试器，采用进化的模糊测试方法执行合约的浅层部分，约束求解来生成符合复杂条件的输入，防止进化模糊测试方法探索深层部分。</p><p>ConFuzzius充分利用动态的数据依赖分析来生成更可能导致出现漏洞的交易序列</p><p>实验数据采用精选的128个合约和包含21000真实世界的合约，结果显示比当前最好的工具多检测出了23%的漏洞，代码覆盖率达到了69%，动态数据依赖分析可以加速漏洞检测18%</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>如果允许一个参与者修改智能合约，合约的信任将不复存在</p><p>智能合约系统中不允许中立的第三方，不能被废止，不可篡改性的代价是智能合约在部署前必须经过大量的测试</p><p>验证智能合约行为的四种方法：</p><ul><li>单元测试：需要人力来覆盖代码的全部部分，仅能去除测试用例中的一小部分bug</li><li>符号执行：抽象分析程序的行为；对于复杂的合约检测速度慢（路径爆炸）</li><li>静态分析：不执行代码，过度近似合约的行为，能够获得整个合约的执行情况；但是存在假阳率，需要手工检查</li><li>模糊测试：通过自动生成测试用例来快速推理合约，比静态分析假阳率低；代码覆盖率低</li></ul><p>模糊测试的挑战：</p><ul><li>输入生成：输入空间可能很大</li><li>状态探索：智能合约是基于状态的应用，执行可能依赖于特定输入序列下可达的状态</li><li>环境依赖：智能合约的运行时环境暴露了和底层区块链相关的额外的输入（时间戳、其他部署的合约），导致合约的执行流程可能依赖于环境信息和交易信息</li></ul><p>作者解决三个挑战的思路是采用符号污点分析来生成五点输入的路径约束。观察到模糊器不处理时，启动约束求解器解决当前的约束问题，将这个解决方案收集在一个变异池中，模糊器可以从中获取来跨越具有挑战性的合约条件。</p><p>现有的混合工具（如Driller）在卡住时停止fuzzer并且切换到conbolic(concrete symbolic)方法来越过复杂条件，之后重启fuzzer，本文的解决方法保持模糊器运行并且只使用约束求解来生成模糊器最终会通过变异池选择的即时数据。</p><p>除了约束求解之外，本文进行路径终止分析来清除变异池中的不相关输入。</p><p>挑战2：为了处理合约的状态性，采用遗传算法的选择和交叉算子。遗传算法包括三个操作：</p><ul><li><p>选择：从中种群选择2个个体</p></li><li><p>交叉：交叉算法将2个个体结合生成2个新的个体，挑战在于如何生成有意义的输入。因此，个体之间的数据依赖性指导我们的选择和交叉算子，只有当它们遵循一个写后读（RAW）数据依赖关系时才接受两个个体。</p></li><li><p>变异</p></li></ul><p>挑战3：为了解决环境依赖的困难问题，对执行环境（即以太坊虚拟机）进行工具化，以模糊环境信息，并将合约的输入建模为一个元组，包含交易和环境数据。</p><p>贡献</p><ul><li>第一个智能合约hybrid模糊器的设计</li><li>利用状态变量间动态数据依赖，在运行时高效的生成输入序列</li><li>ConFuzzius，第一个hybrid模糊器的实现</li><li>对128个经过筛选的智能合约和21K个真实世界的智能合约进行了CONFUZZIUS的评估，并证明了方法不仅可以检测到更多的漏洞（高达23％），而且可以实现比现有符号执行工具和模糊器更高的代码覆盖率（高达69％）</li></ul><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><h3 id="Ethereum-Smart-Contracts"><a href="#Ethereum-Smart-Contracts" class="headerlink" title="Ethereum Smart Contracts"></a>Ethereum Smart Contracts</h3><p>简单介绍智能合约和EVM</p><h3 id="fuzzing"><a href="#fuzzing" class="headerlink" title="fuzzing"></a>fuzzing</h3><p>模糊测试（Fuzzing）或模糊测试是一种自动化的软件测试技术，通过将畸形或意外的数据作为程序的输入，执行程序并监控其效果，来查找程序中的漏洞。</p><h4 id="进化模糊"><a href="#进化模糊" class="headerlink" title="进化模糊"></a>进化模糊</h4><p>指采用遗传算法收敛，测试用例的一代被定义为一个种群，而单个测试用例是一个个体。简而言之，每个一代的个体都根据适应度函数进行评估。在每一代结束时，只有最适应的个体被允许繁殖，遵循达尔文的自然选择或“适者生存”的思想。最终，个体将在收敛于最优解的过程中触发漏洞。</p><p><img src="/2023/07/23/ConFuzzius/image-20230723170403119.png" alt="image-20230723170403119"></p><p>初始种群可以随机选或者启发式采样</p><p>终止条件可以是到达指定时间或者超过最大的代数</p><h4 id="混合模糊"><a href="#混合模糊" class="headerlink" title="混合模糊"></a>混合模糊</h4><p>模糊测试在解决复杂条件时比较困难，导致代码覆盖率低</p><p>流行的解决办法是采用符号执行，理论上可以探索所有路径，但实际上由于程序复杂时路径指数级增长，导致不具备可扩展性；另一个缺陷是和执行环境的交互太少。</p><p>混合测试的想法是各取所长，在模糊器不能继续覆盖代码时，自动切换为符号执行，为没有覆盖的分支条件进行穷举搜索，当符号执行发现了未覆盖的分支条件后，求解并回退为模糊器</p><p>模糊测试和符号执行的交错保证了对程序浅的路径快速的执行和对复杂路径的覆盖</p><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>一般满足ERC-20. 用户想要以每天加1ether的价格出售代币，第一天代币的售价为42</p><p><img src="/2023/07/23/ConFuzzius/image-20230725093137613.png" alt="image-20230725093137613"></p><p>存在三个漏洞：</p><ul><li><p>访问权限：构造函数typo，compiler默认该函数为<code>public</code></p></li><li><p>时间戳依赖：<code>now</code></p></li><li>ether泄露：只有转出的代码，没有转入合约的代码</li></ul><p><img src="/2023/07/23/ConFuzzius/image-20230725094046555.png" alt="image-20230725094046555"></p><h3 id="输入生成"><a href="#输入生成" class="headerlink" title="输入生成"></a>输入生成</h3><p>输入数据生成可以是完全随机的（黑盒）或由运行时信息驱动的（灰盒），原始的方法是从之前的输入进行变异生成新的输入，然而现实世界中有比较复杂的条件，如figure1 line21，对应的CFG如下</p><p><img src="/2023/07/23/ConFuzzius/image-20230725095443342.png" alt="image-20230725095443342"></p><p>传统的随机策略将不能通过该条件（因为$2^{256}$次尝试才能产生一个合理的解harvey依赖于计算为每个分支编译输入的的开销矩阵，本文采用约束求解来按需生成复杂条件的值。本文的fuzzer不直接传播该值而是存储在变异池中，fuzzer可以从池中选择（每个函数声明都对应一个变异池）</p><p>开始时变异池为空，fuzzer用随机数据输入目标函数，一旦无法发现新的路径时，激活约束求解器生成新的值，采用符号五点分析来生成约束求解器需要的表达，污点采用符号值的形式</p><h3 id="状态探索"><a href="#状态探索" class="headerlink" title="状态探索"></a>状态探索</h3><p>合约的状态不同时，以太坊的同一条交易可能出现不同的结果</p><p>例子中先调用<code>bug</code>和<code>Tokensale</code>函数再调用<code>withdraw</code>函数，攻击者能够实现恶意提款，然而在实际的分析中自动发现函数调用特定顺序可能触发漏洞是具有挑战性的工作。</p><p>a transaction influences the output of a subsequent set of transactions if and only if it modifies a storage variable that one of the subsequent transactions will use.</p><p>观察：交易影响合约的storge变量并且该变量被后续的合约使用，即写后读的数据依赖</p><p>ConFuzzius追踪所有交易读和写的storge，然后进行将所有交易组合成写后读的形式</p><p><img src="/2023/07/23/ConFuzzius/image-20230725102212941.png" alt="image-20230725102212941"></p><h3 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h3><p>EVM在执行区块内的交易时会分析其中包含的区块信息</p><p>本文将区块信息建模为可fuzz的输入来解决这个问题，和交易数据一样进行模糊测试的流程</p><p>修改EVM实现能够在合执行时插入模糊的区块信息</p><p>还需要模拟对其他合约的调用：通过对合约调用进行实现，并将返回值建模为可模糊的输入来类似地解决这个挑战，修改的EVM在运行时注入模糊的返回值。</p><h2 id="Design-and-Implementation"><a href="#Design-and-Implementation" class="headerlink" title="Design and Implementation"></a>Design and Implementation</h2><h3 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h3><p><img src="/2023/07/23/ConFuzzius/image-20230725104943384.png" alt="image-20230725104943384"></p><ul><li>进化模糊器</li><li>EVM</li><li>执行路径分析器</li></ul><p>python 6000行</p><p>输入合约的源代码和区块链的状态（后者可选），将合约编译后获得ABI和EVM字节码，进化模糊器基于ABI生成输入，基于标准的遗传算法进行变异，将新生成的个体发送给EVM执行，EVM将执行路径发送给分析器，分析器执行若干分析（符号污点分析，数据依赖分析）</p><p>终止条件：已经生成多少代或过去了多少时间</p><h3 id="进化模糊器"><a href="#进化模糊器" class="headerlink" title="进化模糊器"></a>进化模糊器</h3><ul><li>对个体编码：<ul><li>不好的编码可能影响效率，本方案的编码如图所示，将个体表示为输入的序列，每个输入包含一个环境信息和一个交易的k-v对<ul><li>环境信息包括区块信息和调用返回值、数据大小、节点规模等</li><li>交易包含发送方的地址、交易金额、gas上限，data<ul><li>data前4个字节是函数选择器，后面是参数</li></ul></li></ul></li><li><img src="/2023/07/23/ConFuzzius/image-20230725111651222.png" alt="image-20230725111651222"></li></ul></li><li>种群初始化：最开始为N个个体，每个仅有交易，交易内的函数选择器是循环选取的，函数声明是基于ABI获取的，针对不同参数类型为每个函数生成参数，过去的k代不再影响代码覆盖率时重新选，这种软重启的方法将多样性重新引入种群并在种群变得同质化时延迟过早的收敛。<ul><li>固定长度：随机选或者从触发有效输入域的情况的一组输入中获取</li></ul></li><li>适度评估：评估个体的适度非常关键，由于需要多次计算效率，需要非常高（指数级影响），<em>虽然获得完整的代码覆盖并不一定意味着所有的漏洞都会被发现，但未被探索的代码里的漏洞不可能被发现</em>。适度函数定义基于分支覆盖和数据依赖，对个体$i$的适度函数定义如下：<ul><li>$fit(i)=fit_{branch}(i)+fit_{RAW}(i)$</li><li>$fit_{branch}(i)$：计算该个体仍未探索过的分支，迭代该个体的执行路径然后分析所有条件分支jump指令，通过从堆栈中提取真分支的跳转目标来获取其跳转目标，并通过将程序计数器增加一来获取假分支的跳转目标。对于目的地址不在执行分支上的情况，将$fit_{branch}(i)$加1，优先选出探索更多分支的个体；</li><li>同样能够生成有用交易序列的个体也很重要。$fit_{RAW}(i)$利用执行路径分析器给出的交易依赖考虑该因素，初始时为0，当出现raw后+1</li></ul></li><li>选择：为交叉阶段选择两个个体，本文选择的是参考文献[41]中提出的Linar ranking selection，将种群考虑为一个整体，而不是子集；<ul><li>Linar ranking selection：适度高的个体排在前面，被选择的概率和个体适度在种群中的排名成比例；可以给更适应的个体更多的权重，同时仍然允许一些机会选择适应度较低的个体，并潜在地为种群的多样性做出贡献。</li><li>传统的线性排名选择没有考虑数据依赖，两个个体一个采用线性排名方法选择，第二个个体是基于与第一个个体具有RAW依赖性的迭代方式进行选择的</li></ul></li><li><p>交叉：交叉算子通过对输入两个现有个体进行重新组合生成两个新的个体。</p><ul><li>本文不是随机组合两个个体，而是只有在第一个个体对存储位置进行写操作时，第二个个体才进行读操作（即RAW依赖性），才会将它们组合起来。</li><li>两种排列方式，个体 $ab/ba$</li><li>和传统的方法相比，本方案在合并两个个体而不是拆分开交换输入序列</li><li>如果两个个体间不存在依赖性，返回未加修饰的1/2个个体</li><li>存在RAW关系不意味着一定能交叉，存在交叉概率$p_c$</li><li>防止个体变得太长，交叉前检查长度的和小于$l$<ul><li>$l$ 越小处理时间越短，发现漏洞的时间越短——效率</li><li>反之，发现的漏洞可能更多——完备性</li></ul></li></ul></li><li><p>变异：变异算子随机编辑个体的某些部分来产生一个新的个体，为种群带来多样性</p><ul><li>遍历输入序列，基于概率$p_m$变异每个交易和环境信息的值</li><li>变异可以有两种形式<ul><li>采用随机的值取代原来的值</li><li>采用变异池中的值替代：类似于短期内存，允许模糊器重用之前观察到或学习到的值<ul><li>总共有9个不同的变异池：senders, amounts, gaslimits, function arguments, timestamps, block numbers, call results, call data sizes, and external code sizes</li><li>每个池是循环数组，大小能存10个值</li></ul></li></ul></li></ul></li></ul><h3 id="EVM"><a href="#EVM" class="headerlink" title="EVM"></a>EVM</h3><p>EVM负责在测试的合约的运行时字节码上执行个体生成的交易。性能对模糊器整体的性能表现影响很大，需要有很高的交易处理速度</p><p>现有的智能合约客户端需要对交易进行RLP编码来序列化交易数据，作者发现实际的EVM执行时间和编解码相比可以忽略不计，因此本工具采用了开源的<a href="https://github.com/ethereum/py-evm">EVM python</a>实现，集成到了模糊器中。该实现去除了挖矿的负担和编解码交易的时间，极大地增加了执行效率（合理吗？）</p><p>修改了EVM的设计</p><ul><li>使得能够得到交易的执行路径，包括指令名、计数器、执行栈、调用深度、执行期间是否出现内部错误</li><li>简化设计，采用简单的存储模拟器记录执行时的状态变化，均保留在内存中<ul><li>方便进行EVM状态的快照和恢复</li><li>允许插入定制的环境信息或修改函数调用结果</li></ul></li></ul><h3 id="执行分析器"><a href="#执行分析器" class="headerlink" title="执行分析器"></a>执行分析器</h3><p>从EVM收到执行路径后，执行</p><ul><li>代码覆盖率评估：计算执行路径中程序计数器的值</li><li>数据依赖分析：在模糊器执行过程中记录所有状态变量以及状态变量的读写情况，和现有静态分析的方案相比，本方案动态的获得运行时的状态变量的情况<ul><li>静态分析快 需要源代码；对于复杂的数组需要源代码</li><li>动态运行时分析可以追踪复杂的变量，缺点是额外的运行时间和实现开销，下图是以太坊对不同类型的状态变量计算方式</li><li><img src="/2023/07/23/ConFuzzius/image-20230725162130918.png" alt="image-20230725162130918"></li></ul></li><li>符号污点分析：产生符号约束，污点的形式是符号值的形式，跟踪污点的流动<ul><li>仅对能进行fuzz的指令进行动态污点分析</li><li>跨存储的污点的传播使得能够实现跨交易的污点分析</li><li>污点传播的逻辑遵循过度污点策略，如果指令的输入中至少有一个被污染，那么该指令的输出将被标记为污染</li></ul></li><li>约束求解：模糊测试无法通过复杂的条件语句时，进化模糊器可能会过早收敛，约束求解器用于生成一个有效的输入来越过复杂的条件<ul><li>作者自己实现的轻量级符号执行器仅执行算数相关的指令，比较逻辑和比特级运算符</li><li>否定最后一个约束条件，将逻辑公式中其余的符号变量替换为已用作触发执行跟踪的具体值，并使用Z3 SMT求解器生成输入以到达开放分支</li><li>实例化减小了公式的复杂度</li><li>将生成的输入加入到变异池中</li></ul></li><li>终止分析：执行路径可能包含输入有效性的反馈，模糊器获得并得知一个输入是否有效、终止分析检查执行路径中表示执行正确和错误的操作码。检查到错误后分析最后一个路径约束，获得导致终止的输入并从池中移除</li><li>漏洞检测：综合以上输出进行漏洞检测，为下述漏洞类型设计了检测器：<ul><li>断言错误</li><li>整数溢出</li><li>重入</li><li>交易顺序依赖</li><li>区块依赖</li><li>未处理异常</li><li>不安全的delegate调用</li><li>ether泄露</li><li>未受保护的自毁</li></ul></li></ul><p>很难不赞同（</p><p><img src="/2023/07/23/ConFuzzius/image-20230725165033079.png" alt="image-20230725165033079"></p><h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><p>回答3个关键问题</p><ul><li>相比于当前的符号执行或者fuzzing的工具，confuzzius是否实现了更高的代码覆盖率？</li><li>相比于当前的符号执行或者fuzzing的工具，confuzzius是否发现更多的漏洞？</li><li>ConFuzzius的不同组件在代码覆盖率和漏洞检测方面的相关性有多强？</li></ul><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><ul><li>测试代码覆盖率 有源码 21147份合约，根据EVM字节码指令个数分为2类（采用标准的k-means分类算法，Elbow and the Silhouette方法确定分类器数量<ul><li>小于3632，17803份合约</li><li><img src="/2023/07/23/ConFuzzius/image-20230725171840387.png" alt="image-20230725171840387"></li><li>3344份合约</li></ul></li><li>测试漏洞检测：128份合约（包含148注释出的漏洞），基于smartbugs，缺失了部分漏洞类型，作者从Smart Contract Weakness Classification进行了扩展</li></ul><h3 id="baseline"><a href="#baseline" class="headerlink" title="baseline"></a>baseline</h3><p><img src="/2023/07/23/ConFuzzius/image-20230725172412638.png" alt="image-20230725172412638"></p><p>因为本工具是模糊测试和符号执行结合的，对比方案分别是符号执行和模糊测试两类</p><p>Smartbugs的结论是Mythril的效果比SmartCheck Securify和Maian更好</p><p>M-PRO采用了类似的交易序列结合策略</p><p>ILF是当前较好的fuzzing工具（比contractfuzzer和ECHIDNA好）</p><p>sFuzz基于AFL，没有和之前工作的对比</p><h3 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h3><p>每个实验进行10次，每次的种子独立</p><ul><li>第一个数据集 10 mins；1 hours<ul><li>初步测试显示，大多数工具在这些时间之后并没有产生更多的覆盖率</li></ul></li><li>第二个数据集每个合约10分钟</li></ul><p>cluster 10个节点，每个128GB，CentOS release 7.6.1810，2个Intel® Gold 6132 CPUs with 14 cores, each clocked at 2.60 GHz.</p><p>代码覆盖率10代不变即种群重新初始化，个体最长长度为5</p><p>Z3 version 4.8.5，时间上限100ms</p><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><ul><li><p>代码覆盖率：ConFuzzius在第一个数据集上大小合约结果均表现最优（91% 81%）</p><ul><li>大小合约差距最小（10%），Mythirl（31%）</li><li><img src="/2023/07/23/ConFuzzius/image-20230725174913977.png" alt="image-20230725174913977"></li><li>更短时间内实现更高的覆盖率，1 second 66% instruction coverage, whereas ILF and<br>SFUZZ achieve solely 12% and 15%, respectively</li><li><img src="/2023/07/23/ConFuzzius/image-20230725175443751.png" alt="image-20230725175443751"></li></ul></li><li><p>漏洞检测：10类漏洞，第二个数据集（真/假）</p><ul><li><img src="/2023/07/23/ConFuzzius/image-20230725175644457.png" alt="image-20230725175644457"></li><li>测出了106/148个漏洞，约71%</li></ul></li><li>组件评估：分别评估约束求解、写后读数据依赖分析和环境实例化三部分组件的重要性，随机选了100个合约<ul><li><img src="/2023/07/23/ConFuzzius/image-20230725180309420.png" alt="image-20230725180309420"></li><li>意义最大的组件可能是Constraint Solving</li></ul></li></ul><h2 id="Realted-work"><a href="#Realted-work" class="headerlink" title="Realted work"></a>Realted work</h2><ul><li>软件模糊测试：AFL是当前最广泛使用的模糊测试器，基于遗传算法；KLEE和SAGE是白盒模糊器，在受限环境中执行代码。Driller同样是混合模糊器，混合了选择性concolic方法</li><li>智能合约模糊测试：<ul><li>ContractFuzzer基于输入种子产生输出，部署了整个定制的测试网来模糊测试交易，Confuzzius仅模拟EVM，更加高效且不依赖用户提供的输入种子</li><li>Echidna是基于性质的智能合约测试工具，利用了基于语法的模糊测试，依赖于用户定义的谓词（solidity的断言），无法自动化检查漏洞</li><li>Harvey基于指令细粒度成本度量指标预测新的输入</li><li>ILF基于 模仿学习（imitation learning），在模糊测试前需要学习阶段，依赖一个神经网络</li><li>sFuzz基于AFL，基于随机策略生成交易序列</li><li>EHTPLOIT是基于模糊测试的智能合约漏洞生成器</li></ul></li><li>智能合约符号执行：<ul><li>MPRO：结合了符号执行和数据依赖分析</li><li>ETHracer采用相反的混合方式，先符号执行再fuzz，完全随机</li></ul></li><li>智能合约静态分析：<ul><li>ZEUS：自动化验证的框架</li><li>Securify：静态分析出语义信息，检查violation和compliance</li><li>VANDAL，类似的工具</li></ul></li></ul><h2 id="攻击检测器设计思路"><a href="#攻击检测器设计思路" class="headerlink" title="攻击检测器设计思路"></a>攻击检测器设计思路</h2><ul><li>Assertion Failure：检查执行路径是否包括ASSERTFAIL or INVALID</li><li>Integer Overflow：由于不是所有的溢出都有害而且编译器可能为了优化引入整数溢出<ul><li>当溢出编辑了合约的状态才认为是有害的，计算的记过写入存储或被用来发钱</li><li>分析执行路径是否包含ADD, MUL or SUB指令</li><li>从栈中提取计算符然后执行算术操作，和栈中的结果比较</li><li>如果不同，将计算结果标记为污点，如果被标记的结果进入<code>SSTORE</code> <code>CALL</code>指令</li></ul></li><li>重入漏洞：检查<code>call</code>的gas是否大于2300，转账金额大于0；如果<code>call</code>之前出现<code>SLOAD</code>,<code>call</code>之后<code>SSTORE</code>，<code>CALL</code>的存储地址和<code>SLOAD</code>一样</li><li>交易顺序依赖：检查是否两条执行路径发送者不同，前一条路径写某一存储位置，后一个读</li><li>区块依赖：检查<code>CREATE</code>, <code>CALL</code>,<code>DELEGATECALL</code>, or <code>SELFDESTRUCT</code>是否包含或依赖<code>BLOCKHASH</code>, <code>COINBASE</code>, <code>TIMESTAMP</code>, <code>NUMBER</code>, <code>DIFFICULTY</code>, or <code>GASLIMIT</code></li><li>未处理异常：检查是否有<code>call</code>，并且压入1；再检查结果是否有对应的<code>JUMP I</code></li><li>不安全的<code>delagatecall</code>：检查DELEGATECALL是否以<code>STOP</code>终止，并且发送的地址是攻击者（fuzzer生成攻击者和善良参与者的地址）</li><li>Ether泄露：检查<code>call</code>指令，接收者是从未在之前交易内向合约发送过ether的攻击地址，并且从来没有被非攻击者地址当做参数发送过</li><li>Ether锁定：检查合约是否能接受但不能发送ether<ul><li>接受ether：检查是否有交易值大于0，以<code>stop</code>终止</li><li>发送ether：检查不包含任何<code>CREATE</code>, <code>CALL</code>, <code>DELEGATECALL</code>, or <code>SELFDESTRUCT</code> instruction</li></ul></li><li>Unprotected Selfdestruct：依赖于攻击者账户，检查执行路径包含<code>SELFDESTRUCT</code>，发起者是攻击者地址，并且之前没有被当参数传递过</li></ul><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>第一个混合的fuzzer/</p><p>解决了三个挑战：</p><ul><li>输入生成：进化模糊算法+约束求解</li><li>状态探索：对状态数据依赖分析，生成交易序列</li><li>环境依赖：建模区块相关的信息作为fuzz的输入</li></ul><p>实验在128 21K的数据集上分别测试了覆盖率、测出漏洞类型和工具组件重要性的结果</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>玩了个孔子的谐音梗<a href="https://github.com/christoftorres/ConFuzzius">christoftorres/ConFuzzius: A data dependency-aware hybrid fuzzer for Ethereum smart contracts (EuroS&amp;P 2021). (github.com)</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull christoftorres/confuzzius</span><br><span class="line">docker run -i -t christoftorres/confuzzius</span><br><span class="line">python3 fuzzer/main.py -s examples/TokenSale/contracts/TokenSale.sol -c TokenSale --solc v0.4.26 --evm byzantium -t 10</span><br></pre></td></tr></table></figure><p>被测试合约为TokenSale.sol，比较简单</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.26;</span><br><span class="line"></span><br><span class="line">interface Token &#123;</span><br><span class="line">  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);</span><br><span class="line">  function allowance(address owner, address spender) external view returns (uint256);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract TokenSale &#123;</span><br><span class="line">  uint256 start = now;</span><br><span class="line">  uint256 end = now + 30 days;</span><br><span class="line">  address wallet = 0xCafEBAbECAFEbAbEcaFEbabECAfebAbEcAFEBaBe;</span><br><span class="line">  Token token = Token(0x1234567812345678123456781234567812345678);</span><br><span class="line"></span><br><span class="line">  address owner;</span><br><span class="line">  bool sold;</span><br><span class="line"></span><br><span class="line">  function Tokensale() public &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function buy() public payable &#123;</span><br><span class="line">    require(now &lt; end);</span><br><span class="line">    require(msg.value == 42 ether + (now - start) / 60 / 60 / 24 * 1 ether);</span><br><span class="line">    require(token.transferFrom(this, msg.sender, token.allowance(wallet, this)));</span><br><span class="line">    sold = true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function withdraw() public &#123;</span><br><span class="line">    require(msg.sender == owner);</span><br><span class="line">    require(now &gt;= end);</span><br><span class="line">    require(sold);</span><br><span class="line">    owner.transfer(address(this).balance);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验结果显示代码覆盖率非常优秀，能够检测出区块信息依赖和以太币泄露漏洞</p><p><img src="/2023/07/23/ConFuzzius/image-20230726161506767.png" alt="image-20230726161506767"></p><p><img src="/2023/07/23/ConFuzzius/image-20230726161452774.png" alt="image-20230726161452774"></p><p>具体产生漏洞的交易序列：</p><p><img src="/2023/07/23/ConFuzzius/image-20230726161536978.png" alt="image-20230726161536978"></p><p><img src="/2023/07/23/ConFuzzius/image-20230726161548380.png" alt="image-20230726161548380"></p><p><img src="/2023/07/23/ConFuzzius/image-20230726161601382.png" alt="image-20230726161601382"></p><h3 id="测试较为复杂的合约WalletLibrary"><a href="#测试较为复杂的合约WalletLibrary" class="headerlink" title="测试较为复杂的合约WalletLibrary"></a>测试较为复杂的合约WalletLibrary</h3><p><img src="/2023/07/23/ConFuzzius/image-20230726161201164.png" alt="image-20230726161201164"></p><p><img src="/2023/07/23/ConFuzzius/image-20230726161215584.png" alt="image-20230726161215584"></p><p>代码覆盖率依然比较优秀，74.99%（2881/3842），单个合约仅10.62s</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>其他人对Confuzzius的复现总结 <a href="https://hackmd.io/@UKzRuqmuT7OSwI3Hjf0tPA/ryg6RkwLF">CONFUZZIUS Comparisons - HackMD</a></li><li><p>会议简要视频介绍<a href="https://www.youtube.com/watch?v=_NuOxLJNJhI&amp;ab_channel=IEEEEuropeanSymposiumonSecurityandPrivacy">IEEE EuroS&amp;P 2021 - ConFuzzius: A Data Dependency-Aware Hybrid Fuzzer for Smart Contracts - YouTube</a></p></li><li><p>后续可以阅读：</p><ul><li>现有工具对比测试：[ICSE20]Smartbugs1.0、2.0</li><li>模糊测试：[CCS19]ILF &gt;[ISSTA20]Echindna</li><li>符号执行：[HITB18]Mythril&gt;[ASE19]Manticore</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;ConFuzzius-A-Data-Dependency-Aware-Hybrid-Fuzzer-for-Smart-Contracts&quot;&gt;&lt;a href=&quot;#ConFuzzius-A-Data-Dependency-Aware-Hybrid-Fuzzer-for-Smart-Contracts&quot; class=&quot;headerlink&quot; title=&quot;ConFuzzius: A Data Dependency-Aware Hybrid Fuzzer for Smart Contracts&quot;&gt;&lt;/a&gt;ConFuzzius: A Data Dependency-Aware Hybrid Fuzzer for Smart Contracts&lt;/h1&gt;&lt;p&gt;这篇工作发表于&lt;code&gt;EuroS&amp;amp;P21&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Torres C F, Iannillo A K, Gervais A, et al. Confuzzius: A data dependency-aware hybrid fuzzer for smart contracts[C]//2021 IEEE European Symposium on Security and Privacy (EuroS&amp;amp;P). IEEE, 2021: 103-119.&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/categories/Blockchain/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="SmartContract" scheme="https://alleysira.github.io/tags/SmartContract/"/>
    
  </entry>
  
  <entry>
    <title>Oyente</title>
    <link href="https://alleysira.github.io/2023/07/18/Oyente/"/>
    <id>https://alleysira.github.io/2023/07/18/Oyente/</id>
    <published>2023-07-18T07:33:15.000Z</published>
    <updated>2023-07-23T10:49:38.382Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Making-Smart-Contracts-Smarter"><a href="#Making-Smart-Contracts-Smarter" class="headerlink" title="Making Smart Contracts Smarter"></a>Making Smart Contracts Smarter</h1><p>这篇工作发表于big4 <code>CCS16</code>，一作是来自NUS的Loi Luu</p><p>本文针对以太坊智能合约的安全问题展开研究，介绍了智能合约运行时的若干安全问题。作为改进，提出了增强以太坊的操作语义的方法，使智能合约更不容易受到攻击。</p><p>对于智能合约开发者，本文提出了Oyente，采用符号执行的方法进行智能合约潜在安全漏洞的查找。实验部分针对19366个合约进行分析，Oyente标记了8833个合约为有风险的。</p><p>同时还讨论了几个案例研究中其他攻击的严重程度，这些案例研究有源代码可用，并在主要的以太坊网络中确认了攻击。</p><span id="more"></span><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>区块链用户通过向智能合约地址发布交易（交易的接受者是合约地址）来调用合约，当交易被确认后，所有参与者在当前区块链的状态下，以交易负载作为输入执行合约代码，通过共识协议对输出和合约的下一个状态达成一致</p><p>过去6个月，约15000个智能合约在以太坊中部署</p><p><img src="/2023/07/18/Oyente/image-20230718160000047.png" alt="image-20230718160000047"></p><h3 id="智能合约的安全问题"><a href="#智能合约的安全问题" class="headerlink" title="智能合约的安全问题"></a>智能合约的安全问题</h3><p>不同于传统的分布式应用，以太坊网络是无授权的</p><p>任意敌手可能能够操纵合约执行（允许矿工选择打包哪些交易，交易的顺序，区块时间戳）</p><p>不像传统的分布式应用可以通过发布补丁来修复错误，智能合约是不可逆转、不可篡改的</p><p>因此，设计安全的智能合约系统和合约部署前的正确性推理都是至关重要的</p><p>作者认为出现安全问题的原因是合约编写者对底层执行语义的假设与智能合约系统的实际语义之间存在语义差距。</p><p>对于时间戳依赖和交易顺序依赖攻击，作者认为他们是第一个提出这个问题的团队；对于其他一些前人已经提出的问题（异常处理和逻辑漏洞），本文分析了这些攻击的影响</p><p>本文的工作强调了<em>智能合约语义中微妙或缺失的抽象，这些抽象导致开发人员产生了<strong>虚假的安全感</strong></em>。我们提出了对以太坊协议的改进，这些改进不需要对现有智能合约进行更改，然而这种更改需要所有客户端更新，实际不太可能部署。因此提出了Oyente进行部署前的漏洞检测。</p><p>Oyente针对以太坊智能合约进行符号验证，直接采用字节码，不需要高层的表达（Solidity，Serpent），因为以太坊本身只存储合约的EVM字节码</p><h3 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h3><ul><li>列出了以太坊智能合约新类型的安全漏洞</li><li>形式化了以太坊智能合约的语义，为列出的漏洞给出了修改建议</li><li>提出了Oyente，一种采用符号执行检测以太坊智能合约漏洞的工具</li><li>在真实的以太坊合约上运行了Oyente，并确认了攻击</li></ul><h2 id="BACKGROUND"><a href="#BACKGROUND" class="headerlink" title="BACKGROUND"></a>BACKGROUND</h2><h3 id="Consensus-Protocol"><a href="#Consensus-Protocol" class="headerlink" title="Consensus Protocol"></a>Consensus Protocol</h3><p>区块链的状态$\sigma$是地址到账户的映射，地址为$\gamma$的账户的状态是$\sigma [\gamma]$</p><p>不同于比特币账户仅持有币，以太坊地址支持智能合约账户，包括币、EVM字节码和永久私有存储</p><p>从概念上，以太坊可以理解为一种基于交易的状态机，$\sigma \mathop{\to}\limits^T  \sigma’ $</p><h3 id="Smart-Contracts-in-Ethereum"><a href="#Smart-Contracts-in-Ethereum" class="headerlink" title="Smart Contracts in Ethereum"></a>Smart Contracts in Ethereum</h3><p>一个智能合约的状态包括：</p><ul><li>私有存储</li><li>余额：ether的数量</li></ul><p>用户通过向合约地址发送交易（以太币+输入）来调用合约</p><p><img src="/2023/07/18/Oyente/image-20230718165841643.png" alt="image-20230718165841643"></p><p>以太坊字节码的每一条指令均有预先定义的gas，当用户发送交易调用合约时，需要向矿工支付gas进行补偿。交易发送这设置gasLimit和gasPrice。如果实际的gas消耗大于gasLimit，仍然会被扣除gasLimit的gas然后不执行。</p><h2 id="SECURITY-BUGS-IN-CONTRACTS"><a href="#SECURITY-BUGS-IN-CONTRACTS" class="headerlink" title="SECURITY BUGS IN CONTRACTS"></a>SECURITY BUGS IN CONTRACTS</h2><h3 id="Transaction-Ordering-Dependence"><a href="#Transaction-Ordering-Dependence" class="headerlink" title="Transaction-Ordering Dependence"></a>Transaction-Ordering Dependence</h3><p>考虑到区块内包含若干交易，如果存在新的区块内包含对同一个合约的两次调用，用户无法得知自己调用时合约的状态，只有打包的矿工可以决定交易的顺序，也就是状态的更新顺序</p><ul><li>考虑两个交易分别由owner和任意参与者发起，交易顺序决定了参与者拿到的ether的数量<ul><li>如果owner恶意，观察到有交易调用合约时，将奖励修改为0，有一定概率会获利</li><li>和miner合谋就更容易获利了</li></ul></li></ul><h3 id="Timestamp-Dependence"><a href="#Timestamp-Dependence" class="headerlink" title="Timestamp Dependence"></a>Timestamp Dependence</h3><p><img src="/2023/07/18/Oyente/image-20230718190624360.png" alt="image-20230718190624360"></p><p>其中的other contract variables like <strong>Last_payout</strong> which contribute to the generation of the random seed are also known.</p><h3 id="Mishandled-Exceptions"><a href="#Mishandled-Exceptions" class="headerlink" title="Mishandled Exceptions"></a>Mishandled Exceptions</h3><p>根据合约调用的方式，被调用合约中的异常可能会传播到调用者，也可能不会传播到调用者。</p><p>比如<code>send</code>后应检查返回值</p><p>国王被替代后会获得补偿，但是如果15行的send失败，会导致当前的国王失去补偿</p><p><img src="/2023/07/18/Oyente/image-20230718191420149.png" alt="image-20230718191420149"></p><p>一般发生在向动态地址发送ether，不知道该支付的gas。</p><h3 id="Deliberately-exceeding-the-call-stack-depth-limit"><a href="#Deliberately-exceeding-the-call-stack-depth-limit" class="headerlink" title="Deliberately exceeding the call-stack depth limit"></a>Deliberately exceeding the call-stack depth limit</h3><p>EVM限制调用栈深度为1024，如果通过<code>call</code>和<code>send</code>调用其他合约，栈深度加一</p><p>恶意敌手可以故意使得15行的send失败，但是无法获利</p><h3 id="Reentrancy-Vulnerability"><a href="#Reentrancy-Vulnerability" class="headerlink" title="Reentrancy Vulnerability"></a>Reentrancy Vulnerability</h3><p><img src="/2023/07/18/Oyente/image-20230718192828640.png" alt="image-20230718192828640"></p><h2 id="TOWARDS-A-BETTER-DESIGN"><a href="#TOWARDS-A-BETTER-DESIGN" class="headerlink" title="TOWARDS A BETTER DESIGN"></a>TOWARDS A BETTER DESIGN</h2><p>轻量化的定义捕捉了以太坊的关键</p><p><img src="/2023/07/18/Oyente/image-20230718193217278.png" alt="image-20230718193217278"></p><h3 id="Operational-Semantics-of-Ethereum"><a href="#Operational-Semantics-of-Ethereum" class="headerlink" title="Operational Semantics of Ethereum"></a>Operational Semantics of Ethereum</h3><p>全局区块链的状态可以定义为$<BC,\sigma>,\sigma$是状态，$\varGamma$是新交易集合</BC,\sigma></p><p><img src="/2023/07/18/Oyente/image-20230718193518629.png" alt="image-20230718193518629" style="zoom:80%;"></p><p>矿工形成和验证区块的操作如图所示。一次只有一个“当选领袖”成功执行Propose规则。领导者广播块B后，其他矿工使用Accept规则</p><p>安全问题：leader可能任意选择时间戳，存在TOD漏洞</p><p>以太坊中交易执行会访问三类空间：</p><ul><li>操作数LIFO的栈</li><li>辅助内存$l$，无限增长的数组</li><li>合约的长期存储$str$，长期存储是持久性的，并且在交易之间保留其值。这使其适合存储需要在多次调用合约之间持久存在的数据。</li></ul><p>定义虚拟机的执行状态 $\mu=<A,\sigma>,A$是调用栈</A,\sigma></p><p><img src="/2023/07/18/Oyente/image-20230718194517649.png" alt="image-20230718194517649" style="zoom:80%;"></p><p>将交易抽象为一个三元组$<id,v,l>$,$id$是调用合约的标识符，$v$是要存储进合约的金额，$l$是输入的参数</id,v,l></p><p><img src="/2023/07/18/Oyente/image-20230719091442282.png" alt="image-20230719091442282"></p><p>交易满足两个语义上的性质：</p><ul><li>原子性：每个交易要么全部失败，要么全部执行。all or nothing</li><li>一致性：交易保证区块链系统从一个有效的状态到另一个有效的状态</li></ul><p>本文将EVM抽象成了ETHERLITE，它是一个带有存储和一些类似以太坊的特性的堆栈机器。EtherLite的指令包括</p><p><img src="/2023/07/18/Oyente/image-20230719092528248.png" alt="image-20230719092528248"></p><p><img src="/2023/07/18/Oyente/image-20230719092723997.png" alt="image-20230719092723997"></p><p>call本质上类似于远程程序执行，第二行是调用栈溢出出现异常的情况；第二个return是正确返回的情况，EXC是返回异常</p><p>观察规则TX-EXCEPTION和EXC，前者仅放弃执行，后者返回0；因此交易不满足原子性</p><p>剩余3个指令：</p><ul><li><code>suicide</code>：将所有ether转移给接收者，终止当前合约；类似于call但不是call</li><li><code>create</code>：创建新的和余额账户，接受3个参数；成功后返回合约的地址，失败返回flag 0;考虑如果合约初始化正在执行，但是没有实际的代码段；初始化失败，导致出现了zombie账户，存入的ether全部锁定，会破坏一致性<ul><li>创建新的地址，分配存储，指定的ether存入该地址</li><li>初始化合约的存储</li><li>代码段存入合约</li></ul></li><li><code>getstate</code>：抽象指令，获得当前区块的时间戳，区块id等</li></ul><h3 id="Recommendations-for-Better-Semantics"><a href="#Recommendations-for-Better-Semantics" class="headerlink" title="Recommendations for Better Semantics"></a>Recommendations for Better Semantics</h3><h4 id="解决TOD——Guarded-Transaactions"><a href="#解决TOD——Guarded-Transaactions" class="headerlink" title="解决TOD——Guarded Transaactions"></a>解决TOD——Guarded Transaactions</h4><p>保证合约的调用结果不依赖于交易顺序</p><p><img src="/2023/07/18/Oyente/image-20230719094721711.png" alt="image-20230719094721711"></p><p>额外增加了保护条件$g$，即异常通过时需要满足$g$，如果$g$不满足，抛弃当前交易，默认为true，满足向后兼容</p><p>例子：在<code>Puzzle</code>合约中，用户发布交易可以指定$g\equiv(reward==R)$</p><p>“保护交易（guarded transactions）”类似于大多数现代处理器支持的“比较和交换（CAS）”指令。CAS是一个标准的多线程同步原语，而“保护事务”为以太坊提供了相同的能力。</p><h4 id="确定性时间戳"><a href="#确定性时间戳" class="headerlink" title="确定性时间戳"></a>确定性时间戳</h4><p>允许合约获取区块时间戳实际上是一个冗余的特征，导致合约容易被敌手利用</p><p>时间戳一般用为以下2个途径：</p><ul><li>作为确定性的随机种子：并不明智，熵太低，容易被操纵；作者给出了2个解决方案<a href="https://github.com/randao/randao">randao/randao: RANDAO: A DAO working as RNG of Ethereum (github.com)</a>和<a href="https://eprint.iacr.org/2015/1015#:~:text=On Bitcoin as a public randomness source Joseph,are broadcast every time new blocks are mined.">On Bitcoin as a public randomness source (iacr.org)</a>（从挖出的区块中提取熵的机制）</li><li>作为分布式网络中的全局时间</li></ul><p>作者建议用区块的编号（索引）作为全局时钟，以太坊约12s产生一个区块</p><p>$timestamp - lastTime &gt; 24 hours\to blockNumber - lastBlock &gt; 7,200$</p><h4 id="更好的异常处理"><a href="#更好的异常处理" class="headerlink" title="更好的异常处理"></a>更好的异常处理</h4><p>任何时候都检查返回值，目前Solidity编译器插入代码段进行异常转发，但是在call和send中不会增加</p><p>因此可以在EVM中增加throw和catch的指令，需要更新客户端</p><h2 id="THE-Oyente-TOOL"><a href="#THE-Oyente-TOOL" class="headerlink" title="THE Oyente TOOL"></a>THE Oyente TOOL</h2><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>之前提出的better design需要所有客户端更新，因此实际部署的可能性不高。因此作者提出了部署前的安全检查工具Oyente，能够实现</p><ul><li>开发者写出更安全的合约</li><li>用户避免调用危险的合约</li></ul><p>符号执行将程序变量的值表示为输入符号值的符号表达式。每个符号路径都有一个路径条件，它是一个公式，通过累积输入符号值必须满足的约束条件来构建。如果路径条件不可满足，则路径是不可行的。否则，路径是可行的。</p><p>静态地对程序进行推理，动态执行需要模拟EVM的运行，比传统的静态污点分析和一般的数据流分析的精度更高</p><p><img src="/2023/07/18/Oyente/image-20230719111941121.png" alt="image-20230719111941121"></p><p>输入包括字节码和以太坊的状态，输出合约是否有漏洞（3类），并输出有问题的符号路径</p><p>CFG作者期望后续可以作为交互式的debugger</p><p>Oyente解释EVM指令集，以准确地映射指令到约束条件，bit级准确度。</p><p>模块化设计：</p><ul><li>CFGBuilder：构造CFG</li><li>Explorer：主要部分，符号化执行合约，输出发送给下一个模块</li><li>CoreAnalysis：采用逻辑匹配漏洞</li><li>Validator：筛选部分假阳</li></ul><h3 id="Implemantation"><a href="#Implemantation" class="headerlink" title="Implemantation"></a>Implemantation</h3><p>python 4000行代码</p><p>采用 <a href="https://github.com/Z3Prover/z3">Z3Prover/z3: The Z3 Theorem Prover (github.com)</a>作为求解器判断可满足性</p><ul><li>CFGBuilder：构建一个主要的控制流图，其中包含所有基本块作为节点，以及一些代表跳转的边，其目标可以通过在相应源节点上进行本地调查来确定。但是，在此阶段无法静态确定某些边，因此它们在后续的符号执行过程中动态构建。</li><li>Explorer：主要部分，从CFG入口开始，核心是一个解释器循环，获取要运行的状态，然后在该状态的上下文中符号执行单个指令。这个循环一直持续，直到没有剩余状态，或者达到用户定义的超时。<ul><li>查询Z3来确定分支条件是否满足，进行条件跳转；</li><li>如果2个分支都满足，采用深度优先的方法都执行</li><li>解释阶段末，产生若干符号路径，Z3用于消除不可达的路径</li></ul></li><li>CoreAnalysis：采用逻辑匹配漏洞，检查是否存在3类漏洞，目前仅分析有明确ehter流的路径<ul><li>TOD：当交易顺序改变后，发送ehter不同；即两条trace的ehter flow不一样</li><li>时间戳依赖漏洞：发送的条件包括时间戳，检测时时间戳不变，给定trace检查是否有时间戳</li><li>异常处理：被调用的合约异常时将0压入调用者的操作符栈，仅每次call后检查合约运行结果是否为0</li><li>重入漏洞：遇到每个call时，获得执行call前路径的条件；检查使用更新变量（例如存储值）的条件后是否依然满足。如果是，认为这是一个漏洞，因为被调用者可以在完成调用之前重新执行调用。</li></ul></li><li>Validator：筛选部分假阳<ul><li>询问Z3检查路径是否可达</li><li>不太完备，还需要手工进行假阳的分析</li></ul></li></ul><h2 id="EVALUATION"><a href="#EVALUATION" class="headerlink" title="EVALUATION"></a>EVALUATION</h2><p>定性和定量分析</p><p>运行了以太坊前145,9999个区块的所有智能合约</p><ul><li>尝试测量安全性漏洞的普遍性</li><li>强调了本方案的设计是由现实世界合约特点驱动的，Oyente足够解决这些问题</li><li>给出了一些研究案例，展示了开发者可能对以太坊微妙的语义存在的误解</li></ul><h3 id="Benchmarks-and-Tool-Robustness"><a href="#Benchmarks-and-Tool-Robustness" class="headerlink" title="Benchmarks and Tool Robustness"></a>Benchmarks and Tool Robustness</h3><p>19366份合约，总价值3068654Ether，3千万美元</p><ul><li>大多数合约没有Ether</li><li>10%有至少1Ether</li><li>最富的合约占所有合约的Ether总数的38.9%</li><li>平均ether为318.5 Ether (合约也有贫富差距)</li></ul><p>选择基于字节码而不是源码，在Amazon EC2，分析时间长达3000h，发现了366213条路径</p><h3 id="定量实验"><a href="#定量实验" class="headerlink" title="定量实验"></a>定量实验</h3><p><img src="/2023/07/18/Oyente/image-20230719154205499.png" alt="image-20230719154205499"></p><p>平均分析一个合约350s, 6mins，每个合约平均路径为19</p><p>发现了8833份合约存在bug，仅175份有源码，手动检查发现6.4%的假阳率</p><p><img src="/2023/07/18/Oyente/image-20230719154323611.png" alt="image-20230719154323611"></p><p><img src="/2023/07/18/Oyente/image-20230719154833676.png" alt="image-20230719154833676"></p><p>exception最多：116有源码，全是真阳性，互相调用比较频繁</p><p>TOD：135份合约，32有源码，9个误报，假阳的例子，存在2个ether发送而且顺序无关，argue后续可以采用更花时间的设计来解决这种问题</p><p><img src="/2023/07/18/Oyente/image-20230719155103653.png" alt="image-20230719155103653"></p><p>时间戳依赖：52个合约 7个有源码，检查时间戳在Ether流的path条件上</p><p>重入漏洞：2份源码，其中一个是TheDao，另一个有重入漏洞但是无法利用</p><h3 id="定性实验"><a href="#定性实验" class="headerlink" title="定性实验"></a>定性实验</h3><p>针对合约思考了可能的攻击事件</p><h1 id="SmartBugs实验"><a href="#SmartBugs实验" class="headerlink" title="SmartBugs实验"></a>SmartBugs实验</h1><p><img src="/2023/07/18/Oyente/image-20230719152819796.png" alt="image-20230719152819796"></p><p>在BecToken.sol 覆盖率很高，但是复杂的合约smartbillion中覆盖率仅20%</p><h1 id="Videos"><a href="#Videos" class="headerlink" title="Videos"></a>Videos</h1><p><a href="https://www.youtube.com/watch?v=EIEB_FKZLEE&amp;pp=ygUeTWFraW5nIFNtYXJ0IENvbnRyYWN0cyBTbWFydGVy">https://www.youtube.com/watch?v=EIEB_FKZLEE&amp;pp=ygUeTWFraW5nIFNtYXJ0IENvbnRyYWN0cyBTbWFydGVy</a></p><p><a href="https://nexisato.github.io/2021/07/16/paper-20210716/">【论文阅读・SmartContract】Making Smart Contracts Smarter | Kaleidoscope—— 万花筒 (nexisato.github.io)</a></p><p>$./smartbugs -t oyente -f samples/*.sol —processes 2 —mem-limit 4g —timeout 600</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Making-Smart-Contracts-Smarter&quot;&gt;&lt;a href=&quot;#Making-Smart-Contracts-Smarter&quot; class=&quot;headerlink&quot; title=&quot;Making Smart Contracts Smarter&quot;&gt;&lt;/a&gt;Making Smart Contracts Smarter&lt;/h1&gt;&lt;p&gt;这篇工作发表于big4 &lt;code&gt;CCS16&lt;/code&gt;，一作是来自NUS的Loi Luu&lt;/p&gt;
&lt;p&gt;本文针对以太坊智能合约的安全问题展开研究，介绍了智能合约运行时的若干安全问题。作为改进，提出了增强以太坊的操作语义的方法，使智能合约更不容易受到攻击。&lt;/p&gt;
&lt;p&gt;对于智能合约开发者，本文提出了Oyente，采用符号执行的方法进行智能合约潜在安全漏洞的查找。实验部分针对19366个合约进行分析，Oyente标记了8833个合约为有风险的。&lt;/p&gt;
&lt;p&gt;同时还讨论了几个案例研究中其他攻击的严重程度，这些案例研究有源代码可用，并在主要的以太坊网络中确认了攻击。&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/categories/Blockchain/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="SmartContract" scheme="https://alleysira.github.io/tags/SmartContract/"/>
    
  </entry>
  
  <entry>
    <title>Securify</title>
    <link href="https://alleysira.github.io/2023/07/10/securify/"/>
    <id>https://alleysira.github.io/2023/07/10/securify/</id>
    <published>2023-07-10T01:56:44.000Z</published>
    <updated>2023-08-08T15:57:39.925Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Securify-Practical-Security-Analysis-of-Smart-Contracts"><a href="#Securify-Practical-Security-Analysis-of-Smart-Contracts" class="headerlink" title="Securify: Practical Security Analysis of Smart Contracts"></a>Securify: Practical Security Analysis of Smart Contracts</h1><p>发表于big4 <code>CCS18</code> 一作是来自ETH的Petar Tsankov，通信作者是IC的Arthur Gervais</p><p>本文对以太坊的智能合约进行安全分析，满足可扩展性、完全自动化并且能够证明特定属性的安全/不安全。</p><p>安全分析分为两步：</p><ul><li>通过符号分析合约的依赖图，从代码中精确地提取出语义信息</li><li>检查是否符合或违反模式（pattern），条件是否满足某个性质</li></ul><p>为了实现可扩展性，所有模式都是用指定的域特定语言（DSL）规定的</p><p>目前已经代码开源，分析了18k个合约，被专家用于安全审计</p><span id="more"></span><h2 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h2><p>合约的广泛应用需要强安全保证，然而设计没有安全漏洞合约非常具有挑战性。</p><p>每几个月都有安全漏洞+每个漏洞都很贵</p><p>关键的挑战：</p><ul><li>合约编程语言的图灵完备性，导致自动验证任意属性是不可判定的。现有解决方法依赖于相对通用的测试和符号执行的方法Oyente和Mythril，存在以下缺陷，导致用户需要检查所有报告中的误报并且担心漏报<ul><li>由于欠近似，可能错过重要的违反行为</li><li>由于对域上特定元素不精确的建模，假阳率</li><li>对现实智能合约的代码覆盖率不高，Oyente只有20%</li></ul></li></ul><p>实际上，许多智能合约的安全属性本质上很难直接进行推理。解决这些挑战的可行途径是针对重要的领域特定属性构建一个自动验证器，目前的工作有仅针对 重入漏洞的 </p><p><img src="/2023/07/10/securify/image-20230710110632238.png" alt="image-20230710110632238"></p><p>本文重要的一个观察结果是 可以从数据流图来检查是否符合或违反模式，原因是现实世界中漏洞倾向于违反许多简单的性质，采用pattern而不是property是因为pattern实质上更适合自动推理</p><p>本文的技术思想是定义两类模式反映给定的安全性质：</p><ul><li>符合模式：即表示符合性质</li><li>违反模式</li></ul><p>现有符号执行的工具存在的问题：</p><ul><li>不报告确定性的违反模式（合并了警告和违反），需要用户手动进行分类，实验结果显示用户手动工作量减少了65.9%</li><li>现有的分析工具无法报告不安全的行为，用户需要手动检查未覆盖的代码</li></ul><p>符号执行的方法对数字性质支持更好（溢出），本方案对审计更复杂合约的支持更好</p><p>主要贡献：</p><ul><li>提出了一种在Datalog中对以太坊合约的依赖关系图进行符号编码的反编译器。</li><li>提出了一组合规和违规的安全模式，捕捉足够的条件来证明和反驳实际安全属性。</li><li>给出了一种端到端的实现，完全自动化合约的分析</li><li>对现有以太坊智能合约进行了广泛评估，证明了Securify可以有效地证明合约的正确性并发现违规行为。</li></ul><h2 id="MOTIVATING-EXAMPLES"><a href="#MOTIVATING-EXAMPLES" class="headerlink" title="MOTIVATING EXAMPLES"></a>MOTIVATING EXAMPLES</h2><p> 2 examples 200 millions worth of USD IN 2017</p><h3 id="Stealing-Ether"><a href="#Stealing-Ether" class="headerlink" title="Stealing Ether"></a>Stealing Ether</h3><p><img src="/2023/07/10/securify/image-20230712145246637.png" alt="image-20230712145246637"></p><p>存在的安全问题：对安全非常重要的变量 <code>owner</code>是所有用户来说都是可写的，应该进行限制</p><p>然而由于address的空间过大，无法轻易判断是否满足该性质</p><p>Securify的检测方法是检查是否存在 <code>owner = _owner</code>的赋值不依赖于<code>caller</code> 指令(返回交易发送者的地址)</p><p>具体实现思路是通过分析合约的依赖推断数据控制流图依赖，在这里，Securify推断赋值<code>owner = _owner</code>不依赖于<code>caller</code>指令，这意味着任何用户都可以访问该赋值。一些符号检查工具执行了对相似性质的不精确检查，导致假阳率和假阴率</p><h3 id="Frozen-Funds"><a href="#Frozen-Funds" class="headerlink" title="Frozen Funds"></a>Frozen Funds</h3><p><img src="/2023/07/10/securify/image-20230712150820192.png" alt="image-20230712150820192"></p><p>攻击：以太坊的智能合约可以用特定的<code>kill</code>指令移除区块链，如果攻击者移除 <code>walletLibrary</code>，存储的资金将被冻结</p><p>安全问题：允许用户存储以太币，但不保证能够取出，因为取回函数依赖于外部库，可以从以下两方面检查是否存在这个问题：</p><ul><li>用户能够存储以太币</li><li>合约没有非零数量以太币转移的指令</li></ul><p>Securify检查两个条件的连接，首先检查是否有<code>stop</code>指令，执行不依赖于转移的以太币为0。假设该<code>stop</code>指令对一些交易是可达的，表明用户可以用正数个ether到达，即存储以太币。其次检查是否对于所有的<code>call</code>指令，从合约中提取的ether数量为0</p><h2 id="THE-SECURIFY-SYSTEM"><a href="#THE-SECURIFY-SYSTEM" class="headerlink" title="THE SECURIFY SYSTEM"></a>THE SECURIFY SYSTEM</h2><p>以判断<code>owner</code>为例，介绍整体流程</p><p><img src="/2023/07/10/securify/image-20230712152705941.png" alt="image-20230712152705941"></p><p>绿色的输入：包括合约的字节码和定义的pattern（采用Domain-Specific Language，DSL编写），输入同样可以是solidity编写的合约</p><h3 id="反编译EVM字节码"><a href="#反编译EVM字节码" class="headerlink" title="反编译EVM字节码"></a>反编译EVM字节码</h3><p>首先转换成无栈的静态单指令(static-single assignment form, SSA)的形式</p><p>识别函数，比如ABI_9DA8 对应的函数为<code>initOwner</code></p><p>执行部分求值来解析内存和存储偏移量、跳转目的地，这些对于精确地静态分析代码都很重要</p><h3 id="推断语义事实"><a href="#推断语义事实" class="headerlink" title="推断语义事实"></a>推断语义事实</h3><p>分析合约推断出数据和控制流依赖</p><p>Securify推导语义事实的方式是通过层次化 Datalog（一种语言） 声明式指定的，并且完全自动化，使用现有的可扩展引擎。</p><p>声明式方法的关键优势是：</p><p>（i）推理规则简洁地捕捉了对不同组件（例如合约存储）的抽象推理</p><p>（ii）更多的事实和推理规则可以轻松地添加</p><p>（iii）推理规则以模块化的方式指定（例如，内存分析独立于合约存储分析）</p><h3 id="检查安全模式"><a href="#检查安全模式" class="headerlink" title="检查安全模式"></a>检查安全模式</h3><p>获得所有语义事实后，SECURIFY检查符合模式和违反模式的集合。所有模式由DSL编写，方便安全专家进行扩展。DSL 是对 Securify 推导的语义事实的逻辑公式片段。其存储偏移量（表示为X）和执行这个指令的标签L都不依赖于任何可能执行合约的调用者指令的结果，则违规模式匹配。否定由 ¬ 表示，合取由 ∧ 表示</p><p><img src="/2023/07/10/securify/image-20230712161430145.png" alt="image-20230712161430145"></p><h3 id="SECURIFY的输出"><a href="#SECURIFY的输出" class="headerlink" title="SECURIFY的输出"></a>SECURIFY的输出</h3><p>对于违规模式的匹配，SECURIFY能够输出导致该模式的指令所在行，如果有源码的话可以对应到solidity的行。对于没有匹配到的性质，将会给出warning</p><h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><ul><li><p>当前版本无法分析出数值性质，比如整数溢出</p></li><li><p>无法支持可达性，假设所有指令都是可达的</p></li><li>并不是所有的违规模式都会被攻击者利用</li></ul><h2 id="SEMANTIC-FACTS"><a href="#SEMANTIC-FACTS" class="headerlink" title="SEMANTIC FACTS"></a>SEMANTIC FACTS</h2><p>本节中，介绍 Securify 使用的控制流和数据流依赖关系的自动推导。在这个过程中推导出的事实被称为语义事实，并且后来用于检查安全属性。首先介绍理解此分析所必需的背景：EVM 指令集和分层 Datalog。然后介绍Securify推导的语义事实和声明式推理规则，这些规则在分层 Datalog 中指定，用于推导这些语义事实。</p><h3 id="Backgroud"><a href="#Backgroud" class="headerlink" title="Backgroud"></a>Backgroud</h3><h4 id="EVM"><a href="#EVM" class="headerlink" title="EVM"></a>EVM</h4><p>EVM指令集支持若干操作码，SECURIFY处理了所有的操作码并给出精简后的相关性较高的指令，包括：</p><ul><li>算术运算符和比较 <code>add</code></li><li>密码学哈希函数 <code>sha3</code></li><li>环境信息 <code>balance</code></li><li>区块信息 <code>number</code> <code>timestamp</code></li><li>内存和存储操作 <code>mload</code> <code>mstore</code> load/store data from the memory/contract storage</li><li>系统操作 如<code>call</code></li><li>控制流指令 如 <code>goto</code></li></ul><h4 id="分层的Datalog"><a href="#分层的Datalog" class="headerlink" title="分层的Datalog"></a>分层的Datalog</h4><p>声明式逻辑语言，编写事实（谓词）和规则来推断事实。</p><h3 id="Facts-and-Inference-Rules"><a href="#Facts-and-Inference-Rules" class="headerlink" title="Facts and Inference Rules"></a>Facts and Inference Rules</h3><p>Securify首先提取了一组基本事实，这些事实对于每个指令都是成立的。这些基本事实构成了Datalog程序的输入，用于推导合约的其他事实。我们使用术语“语义事实”来指代由Datalog程序推导出的事实。在Datalog程序中，合约中出现的所有程序元素，包括指令标签、变量、字段、字符串和整数常量，都被表示为常量。</p><h2 id="SECURITY-PATTERNS"><a href="#SECURITY-PATTERNS" class="headerlink" title="SECURITY PATTERNS"></a>SECURITY PATTERNS</h2><p><img src="/2023/07/10/securify/image-20230712170622099.png" alt="image-20230712170622099"></p><h1 id="Videos"><a href="#Videos" class="headerlink" title="Videos"></a>Videos</h1><ul><li><p>[x] CCS 2018 <a href="https://www.youtube.com/watch?v=7v-bd9maqm8">(1) Securify: Practical Security Analysis of Smart Contracts - YouTube</a></p></li><li><p>[ ] SURI 2018 <a href="https://www.youtube.com/watch?v=YNbj_JElzuc&amp;list=PL95IbaKDuVrLeLaRmDof5o3_FE75tdcZP">(1) Securify: Practical Security Analysis of Smart Contracts | Petar Tsankov - YouTube</a></p></li></ul><p><img src="/2023/07/10/securify/image-20230711225346559.png" alt="image-20230711225346559"></p><p>关键性质是在调用指令后不执行状态的改变，然而智能合约是图灵完备的，无法判定，作者观察出了危险调用和安全调用满足的一些简单的性质</p><p><img src="/2023/07/10/securify/image-20230711225523413.png" alt="image-20230711225523413"></p><p>工具当时可以在线访问，现在已经down了 <a href="http://www.securify.ch/">www.securify.ch</a></p><p>发表会议时已经有了1k+的订阅 许多专家使用</p><p><img src="/2023/07/10/securify/image-20230711230448123.png" alt="image-20230711230448123"></p><p>总体思路</p><ul><li>从EVM字节码出发</li></ul><p><img src="/2023/07/10/securify/image-20230711231815757.png" alt="image-20230711231815757"></p><p><img src="/2023/07/10/securify/image-20230711231850438.png" alt="image-20230711231850438"></p><p><img src="/2023/07/10/securify/image-20230711232107609.png" alt="image-20230711232107609"></p><p><img src="/2023/07/10/securify/image-20230711232308582.png" alt="image-20230711232308582"></p><h1 id="Experiment-on-Smartbugs"><a href="#Experiment-on-Smartbugs" class="headerlink" title="Experiment on Smartbugs"></a>Experiment on Smartbugs</h1><p>根据github <a href="https://github.com/smartbugs/smartbugs">smartbugs/smartbugs: SmartBugs: A Framework to Analyze Ethereum Smart Contracts (github.com)</a>的installation在虚拟机上安装docker</p><p>配置完用户组重启才能生效</p><p>采用securify对samples目录下的10个.sol文件进行分析，2线程 4g内存限制 每个任务最长分析时间为60s，github给出的实验命令是600s，考虑到虚拟机是2core 4g ram，实际测试设置为60s</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$./smartbugs -t securify -f samples/*.sol --processes 2 --mem-limit 4g --timeout 600</span><br></pre></td></tr></table></figure><p><img src="/2023/07/10/securify/image-20230718103340279.png" alt="image-20230718103340279"></p><p>实验结果存储在<code>./results/securify</code>目录下</p><p>目录每个.sol文件分析后包括两个文件，以EtherLotto.sol为例具体来看。</p><ul><li><code>smartbugs.json</code>具体为调用工具时参数的情况</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//smartbugs.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;docker&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;command&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">&quot;detach&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;entrypoint&quot;</span>: <span class="string">&quot;&#x27;/sb/bin/do_solidity.sh&#x27; &#x27;/sb/EtherLotto.sol&#x27; &#x27;/sb/bin&#x27;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;image&quot;</span>: <span class="string">&quot;smartbugs/security:usolc&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;mem_limit&quot;</span>: <span class="string">&quot;4g&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;user&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;volumes&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;/tmp/tmp86tp_iz9&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;bind&quot;</span>: <span class="string">&quot;/sb&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;mode&quot;</span>: <span class="string">&quot;rw&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;filename&quot;</span>: <span class="string">&quot;samples/EtherLotto.sol&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;platform&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;cpu&quot;</span>: <span class="string">&quot;12th Gen Intel(R) Core(TM) i5-12500H&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;python&quot;</span>: <span class="string">&quot;3.10.6.final.0 (64 bit)&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;release&quot;</span>: <span class="string">&quot;5.19.0-45-generic&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;smartbugs&quot;</span>: <span class="string">&quot;2.0.7&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;system&quot;</span>: <span class="string">&quot;Linux&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;#46~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Wed Jun 7 15:06:04 UTC 20&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;result&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;duration&quot;</span>: <span class="number">17.345403909683228</span>,</span><br><span class="line">        <span class="attr">&quot;exit_code&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;logs&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">&quot;output&quot;</span>: <span class="string">&quot;result.tar&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;start&quot;</span>: <span class="number">1689647289.9699748</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;runid&quot;</span>: <span class="string">&quot;20230718_0228&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;solc&quot;</span>: <span class="string">&quot;0.4.26&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;tool&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;bin&quot;</span>: <span class="string">&quot;scripts&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;command&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">&quot;cpu_quota&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">&quot;entrypoint&quot;</span>: <span class="string">&quot;&#x27;$BIN/do_solidity.sh&#x27; &#x27;$FILENAME&#x27; &#x27;$BIN&#x27;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;securify&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;image&quot;</span>: <span class="string">&quot;smartbugs/security:usolc&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;info&quot;</span>: <span class="string">&quot;Securify uses formal verification, also relying on static analysis checks. Securify&#x27;s analysis consists of two steps. First, it symbolically analyzes the contract&#x27;s dependency graph to extract precise semantic information from the code. Then, it checks compliance and violation patterns that capture sufficient conditions for proving if a property holds or not.&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;mem_limit&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">&quot;mode&quot;</span>: <span class="string">&quot;solidity&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Securify&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;origin&quot;</span>: <span class="string">&quot;https://github.com/eth-sri/securify&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;output&quot;</span>: <span class="string">&quot;/results/&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;parser&quot;</span>: <span class="string">&quot;parser.py&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;solc&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;version&quot;</span>: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个文件是<code>result.tar</code>，解压后可以发现</p><ul><li><code>live.json</code>文件，具体内容为模式的定义</li><li><code>results.json</code>文件，给出了匹配的结果，包括violation 和 warning safe 和 conflicts</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//live.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;decompiled&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;finished&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;patternResults&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;DAO&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;completed&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasViolations&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasWarnings&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasSafe&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasConflicts&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;violations&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;warnings&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;safe&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;DAOConstantGas&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;completed&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasViolations&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasWarnings&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasSafe&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasConflicts&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;violations&quot;</span>: [</span><br><span class="line">        <span class="number">226</span>,</span><br><span class="line">        <span class="number">271</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;warnings&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;safe&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;MissingInputValidation&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;completed&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasViolations&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasWarnings&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasSafe&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasConflicts&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;violations&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;warnings&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;safe&quot;</span>: [</span><br><span class="line">        <span class="number">116</span>,</span><br><span class="line">        <span class="number">116</span>,</span><br><span class="line">        <span class="number">111</span>,</span><br><span class="line">        <span class="number">116</span>,</span><br><span class="line">        <span class="number">111</span>,</span><br><span class="line">        <span class="number">130</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;TODAmount&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;completed&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasViolations&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasWarnings&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasSafe&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasConflicts&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;violations&quot;</span>: [</span><br><span class="line">        <span class="number">271</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;warnings&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;safe&quot;</span>: [</span><br><span class="line">        <span class="number">226</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;TODReceiver&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;completed&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasViolations&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasWarnings&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasSafe&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasConflicts&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;violations&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;warnings&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;safe&quot;</span>: [</span><br><span class="line">        <span class="number">226</span>,</span><br><span class="line">        <span class="number">271</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;TODTransfer&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;completed&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasViolations&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasWarnings&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasSafe&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasConflicts&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;violations&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;warnings&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;safe&quot;</span>: [</span><br><span class="line">        <span class="number">226</span>,</span><br><span class="line">        <span class="number">271</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;UnhandledException&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;completed&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasViolations&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasWarnings&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasSafe&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasConflicts&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;violations&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;warnings&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;safe&quot;</span>: [</span><br><span class="line">        <span class="number">226</span>,</span><br><span class="line">        <span class="number">271</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;UnrestrictedEtherFlow&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;completed&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasViolations&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasWarnings&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasSafe&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasConflicts&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;violations&quot;</span>: [</span><br><span class="line">        <span class="number">226</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;warnings&quot;</span>: [</span><br><span class="line">        <span class="number">271</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;safe&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//results.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;/sb/EtherLotto.sol:EtherLotto&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;results&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;TODReceiver&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;violations&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;warnings&quot;</span>: [</span><br><span class="line">          <span class="number">48</span>,</span><br><span class="line">          <span class="number">51</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;safe&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;UnhandledException&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;violations&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;warnings&quot;</span>: [</span><br><span class="line">          <span class="number">48</span>,</span><br><span class="line">          <span class="number">51</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;safe&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;TODTransfer&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;violations&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;warnings&quot;</span>: [</span><br><span class="line">          <span class="number">48</span>,</span><br><span class="line">          <span class="number">51</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;safe&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;DAO&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;violations&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;warnings&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;safe&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;TODAmount&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;violations&quot;</span>: [</span><br><span class="line">          <span class="number">51</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;warnings&quot;</span>: [</span><br><span class="line">          <span class="number">48</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;safe&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;MissingInputValidation&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;violations&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;warnings&quot;</span>: [</span><br><span class="line">          <span class="number">20</span>,</span><br><span class="line">          <span class="number">23</span>,</span><br><span class="line">          <span class="number">32</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;safe&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;DAOConstantGas&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;violations&quot;</span>: [</span><br><span class="line">          <span class="number">48</span>,</span><br><span class="line">          <span class="number">51</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;warnings&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;safe&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;UnrestrictedEtherFlow&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;violations&quot;</span>: [</span><br><span class="line">          <span class="number">48</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;warnings&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;safe&quot;</span>: [</span><br><span class="line">          <span class="number">51</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据实验结果，可能是运行的分析时间较短，许多合约分析结果为空（比如Mytoken.sol)</p><p><img src="/2023/07/10/securify/image-20230718105438946.png" alt="image-20230718105438946"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Securify-Practical-Security-Analysis-of-Smart-Contracts&quot;&gt;&lt;a href=&quot;#Securify-Practical-Security-Analysis-of-Smart-Contracts&quot; class=&quot;headerlink&quot; title=&quot;Securify: Practical Security Analysis of Smart Contracts&quot;&gt;&lt;/a&gt;Securify: Practical Security Analysis of Smart Contracts&lt;/h1&gt;&lt;p&gt;发表于big4 &lt;code&gt;CCS18&lt;/code&gt; 一作是来自ETH的Petar Tsankov，通信作者是IC的Arthur Gervais&lt;/p&gt;
&lt;p&gt;本文对以太坊的智能合约进行安全分析，满足可扩展性、完全自动化并且能够证明特定属性的安全/不安全。&lt;/p&gt;
&lt;p&gt;安全分析分为两步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过符号分析合约的依赖图，从代码中精确地提取出语义信息&lt;/li&gt;
&lt;li&gt;检查是否符合或违反模式（pattern），条件是否满足某个性质&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了实现可扩展性，所有模式都是用指定的域特定语言（DSL）规定的&lt;/p&gt;
&lt;p&gt;目前已经代码开源，分析了18k个合约，被专家用于安全审计&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/categories/Blockchain/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="SmartContract" scheme="https://alleysira.github.io/tags/SmartContract/"/>
    
  </entry>
  
  <entry>
    <title>ContractFuzzer</title>
    <link href="https://alleysira.github.io/2023/07/04/ContractFuzzer/"/>
    <id>https://alleysira.github.io/2023/07/04/ContractFuzzer/</id>
    <published>2023-07-04T08:02:37.000Z</published>
    <updated>2023-08-17T03:51:56.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ContractFuzzer-Fuzzing-Smart-Contracts-for-Vulnerability-Detection"><a href="#ContractFuzzer-Fuzzing-Smart-Contracts-for-Vulnerability-Detection" class="headerlink" title="ContractFuzzer: Fuzzing Smart Contracts for Vulnerability Detection"></a>ContractFuzzer: Fuzzing Smart Contracts for Vulnerability Detection</h1><p>软工顶会 <code>ASE18</code></p><p>基于智能合约的ABI生成fuzz的输入，针对不同漏洞类型定义了新的测试oracle，利用EVM记录智能合约的运行时行为，分析日志来报告安全漏洞。实验对6991份智能合约标记出了459个漏洞。</p><span id="more"></span><h2 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h2><p>截止 2018.3， 以太坊智能合约和DApps的数量超过2百万，以太坊账户管理的ether超过9800万，约为5800 USD。管理如此多财富的智能合约成为了黑客的攻击目标。</p><p>智能合约容易受攻击的原因：</p><ul><li>智能合约的执行依赖于区块链和其他智能合约，开发者可能忽视合约间的隐含关系</li><li>编程语言和运行时环境比较新颖，开发者对缺陷理解不到位</li><li>智能合约的不可篡改性使得难以在部署后更新，漏洞修复可能需要较长时间</li></ul><p>其他解决方案存在的问题：</p><ul><li>不准确，误报率较高</li><li>符号验证所有的可能路径存在路径爆炸问题，如果只验证部分路径，也可能导致假阴性。</li></ul><p>贡献</p><ul><li>第一个以太坊智能合约fuzzing的框架</li><li>提供了一系列新的测试oracle</li><li>系统的测试了6991个真实的合约</li></ul><h2 id="A-REVIEW-OF-SMART-CONTRACTS"><a href="#A-REVIEW-OF-SMART-CONTRACTS" class="headerlink" title="A REVIEW OF SMART CONTRACTS"></a>A REVIEW OF SMART CONTRACTS</h2><p>区块链的状态 $s$ 是从地址到账户的映射，账户可以由人类和程序拥有。以太坊可以看做是基于交易的状态机，状态由每个交易更新，交易的有效性由共识协议验证。交易实际上是一个账户向另一个账户发送的消息，可以包括二进制数据（输入）和ether</p><p>安全威胁：blockchain level, EVM level, and smart contract level.</p><p>Moreover, even using the <em>block.blockhash()</em> function with <em>block.number</em> as parameters for random number generation is still vulnerable either due the execution mechanism of EVM or due to the transparency of the blockchain.</p><h2 id="DEF1N1NG-TEST1NG-ORACLES-FOR-VULNERAB1L1T1ES-OF-SMART-CONTRACTS"><a href="#DEF1N1NG-TEST1NG-ORACLES-FOR-VULNERAB1L1T1ES-OF-SMART-CONTRACTS" class="headerlink" title="DEF1N1NG TEST1NG ORACLES FOR VULNERAB1L1T1ES OF SMART CONTRACTS"></a>DEF1N1NG TEST1NG ORACLES FOR VULNERAB1L1T1ES OF SMART CONTRACTS</h2><ul><li>Gasless Send：<code>send()</code>是由<code>call()</code>实现的，检查<code>call()</code>的输入为0且gas limit是2300，检查<code>send()</code>是否返回<strong><em>ErrOutOfGas\</em></strong></li><li>Exception Disorder：根调用没有返回异常但是嵌套的调用返回异常，即一场没有正确地传播到根调用</li><li>Reentrancy<ul><li>检查函数调用 A 是否在源自调用 A 的调用链中出现多次</li><li>检查是否有<code>call()</code>调用并且值大于0；是否有足够的gas来执行复杂操作；被<code>call()</code>调用的是工具自身的代理合约</li><li>ContractFuzzer 只有在能够成功对目标合约发起重入攻击时才会标记重入漏洞</li></ul></li><li>Timestamp/Block Number Dependency<ul><li>检查是否调用了TIMESTAMP操作码</li><li>检查是否<code>call()</code>是<code>send()</code>，发送了ether</li><li>检查<code>call()</code>的值是否大于0</li></ul></li><li>DelegateCall<ul><li>检查是否存在deletegatecall的调用</li><li>调用的函数从输入中获取</li></ul></li><li>FreezingEther<ul><li>检查是否能收到ether</li><li>是否使用delegatecall，不存在transfer/send/call/suicide等将ether转移到其他地址的调用</li><li>标记出余额&gt;0，无法采用自身合约转出ether</li></ul></li></ul><h2 id="THE-SMART-CONTRACT-FUZZER"><a href="#THE-SMART-CONTRACT-FUZZER" class="headerlink" title="THE SMART CONTRACT FUZZER"></a>THE SMART CONTRACT FUZZER</h2><p><img src="/2023/07/04/ContractFuzzer/image-20230705150229282.png" alt="image-20230705150229282"></p><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>0-5 共6步</p><p>包括离线EVM检测工具和在线模糊测试工具，EVM进行合约的运行，模糊测试工具提取信息</p><p>采用爬虫将Ehterscan网站的合约的二进制码 ABI 构造参数等爬下来，部署在测试网上</p><p>合约用来作为模糊测试的对象和被其他合约调用</p><p>步骤2 用于测试合约间的交互</p><p>工具将生成符合ABI规范的有效模糊测试输入，以及在步骤3中跨越有效性边界的突变输入。</p><h3 id="Static-Analysis-of-Smart-Contracts"><a href="#Static-Analysis-of-Smart-Contracts" class="headerlink" title="Static Analysis of Smart Contracts"></a>Static Analysis of Smart Contracts</h3><p>extract the signatures of the public functions supported by those contracts.</p><p>该工具基于每个智能合约的 ]SON 格式导出的 ABI，提取 ABI 中声明的所有函数签名，计算函数签名前4字节的哈希值作为function selector并构建key-value(selector-address vector)的映射</p><p>将ABI的JSON解析，提取函数描述和参数的数据类型，address类型必须采用能够提供相应函数的合约的地址</p><p>For a given ABI function of a smart contract under test, how can we effectively determine subset of smart contracts that it can interact with? function selector，call的参数和函数签名的前4个字节对应</p><p>是否正确</p><p><img src="/2023/07/04/ContractFuzzer/image-20230705153449574.png" alt="image-20230705153449574"></p><p>首先反汇编，提取出ABI，提取出函数体，定位函数代码段，如果行以PUSH4开头，当前行加入到selector当中，最后输出Map，搜索Map查询所有的支持selector作为ABI的合约地址放进一个私有的智能合约池中用来进行交互</p><h3 id="Fuzzing-Input-Generation"><a href="#Fuzzing-Input-Generation" class="headerlink" title="Fuzzing Input Generation"></a>Fuzzing Input Generation</h3><p>生成固定长度和非固定长度的输入的算法不同</p><ul><li>固定长度 <em>INT\<M></M></em>, <em>UINT\<M></M></em>, <em>BYTES\<M> 和数组 \<type>[M]</type></M></em><ul><li>首先在有效输入域上随机生成值</li><li>然后我们还构建了另一组种子输入，这些种子输入在基于静态分析的智能合约中经常使用</li><li>两类结合作为候选值</li></ul></li><li>非固定长度的值 <em>bytes string \<type>[]</type></em><ul><li>随机生成一个正整数作为长度，随机从输入域上选</li></ul></li></ul><p>为每个函数都生成候选输入的集合，因此循环执行生成k个实例作为候选集，编码成字节码供调用</p><p>为重入漏洞生成输入需要在两个合约间交互式调用</p><p><img src="/2023/07/04/ContractFuzzer/image-20230705161724227.png" alt="image-20230705161724227"></p><p><em>BountyHunt</em> send ether with a call at line 5 before setting the value of the corresponding bounryAccount to 0 at line 7.</p><h3 id="Instrumenting-EVM-to-Collect-Test-Oracles"><a href="#Instrumenting-EVM-to-Collect-Test-Oracles" class="headerlink" title="Instrumenting EVM to Collect Test Oracles"></a>Instrumenting EVM to Collect Test Oracles</h3><p>需要收集的三类信息：</p><ul><li>call和delegatecall的属性</li><li>调用的操作码</li><li>执行时合约的状态</li></ul><p><img src="/2023/07/04/ContractFuzzer/image-20230705162927210.png" alt="image-20230705162927210"></p><p>为了支持重入漏洞和异常中断漏洞的检测，记录了Call的链</p><p><em>EVM.Call()</em> and <em>EVM.DelegateCall()</em> function 来记录call的信息</p><p><em>interpreter.Run()</em> 来记录opCode</p><h3 id="Vulnerability-Analysis-and-Report"><a href="#Vulnerability-Analysis-and-Report" class="headerlink" title="Vulnerability Analysis and Report"></a>Vulnerability Analysis and Report</h3><p>当初始调用的调用堆栈变为空时，EVM中的检测模块将首先根据收集到的检测信息检查这些子oracle。然后，检测模型将这些子oracle发送到侦听本地主机端口8888的HTTP服务器。服务器将收集子oracle的结果，然后对每个测试oracle的复合条件执行最终检查。</p><h2 id="EXPERIMENT-AND-RESULTS-ANALYSIS"><a href="#EXPERIMENT-AND-RESULTS-ANALYSIS" class="headerlink" title="EXPERIMENT AND RESULTS ANALYSIS"></a>EXPERIMENT AND RESULTS ANALYSIS</h2><p>PC中配置了两个dockers来帮助设置测试客户端和以太坊测试网络。在docker运行测试客户端中，在node.js运行时中使用以太坊javascript API (web3.js库)与testnet docker中的geth客户端进行交互。测试网络docker安装geth客户端1.7.0版本，然后还在该docker中创建了一个以太坊私有区块链，其中一个对等节点作为测试网络。</p><p>当时Etherscan有9960个合约，全部爬下来去掉了无法部署的合约，剩下6991</p><p>contract creation code (bytecode), the ABI interfaces, and the constructor argument of those contracts作为输入</p><p>首先进行静态分析，得到每个ABI的私有的合约池并提取出ABI函数用于生成输入</p><p>对于每个合约采用3类账户进行调用：创建者账户；外部账户；AttackAgent（重入）</p><p>每个账户2种调用模式：带有ehter和无ether的</p><p>对于每个 ABI 函数，如果包含参数，ContractFuzzer 将生成 k 个输入来调用它。否则，我们将简单地对其执行一次调用。结合 3 种账户类型和 call.value() 的 2 种选择，我们将为带参数的函数生成 6<em>k 次调用，为不带参数的函数生成 6 (3\</em>2) 次调用。用一个较大的值初始化 k，以便 ContractFuzzer 可以有广泛的候选调用可供选择。当模糊特定的智能合约时，我们会将为其每个 ABI 函数生成的所有调用合并到智能合约的调用池中。然后ContractFuzzer启动HTTP服务器来收集和分析测试预言机。对于每个智能合约，ContractFuzzer 从其调用池中随机选择调用来执行模糊测试，模拟智能合约函数的不同调用顺序。最后，服务器收集并分析结果以形成报告。经过大约 80 个小时的模糊测试后，我们停止了实验，直到结果逐渐收敛。</p><p>和Oyente verification tool进行实验结果对比</p><p><img src="/2023/07/04/ContractFuzzer/image-20230705164932309.png" alt="image-20230705164932309"></p><p>除了时间戳和区块号依赖有假阳率，其他均没有，手动进行了核查</p><p>误报情况的原因是，对这两种类型的漏洞的测试预言机定义不精确。事实上，在这两种情况的测试预言机定义中，检查了操作码（TIMESTAMP 和 NUMBER）的使用以及测试的 ABI 函数中ether转移调用的使用。还没有检查在读取 TIMESTAMP 和 NUMBER 和使用它们来计算以太币转移的条件之间是否存在数据流定义使用链。但是，记录此类信息可能涉及通过检测所测试的智能合约进行昂贵的数据流跟踪。考虑到实际较高的真阳性率，作者认为ContractFuzzer的解决方案是一种具有成本效益的权衡。</p><p><img src="/2023/07/04/ContractFuzzer/image-20230705165527293.png" alt="image-20230705165527293"></p><p>Oyentle支持4种漏洞检测，调用深度漏洞已经在EIP150 hardfork中修复了，交易顺序依赖攻击contractFuzzer不支持，只比较了时间戳依赖和重入攻击</p><p>对于时间戳依赖漏洞，contractFuzzer假阴（未检测出）的原因：</p><ul><li>时间被硬编码，并将区块时间戳与之进行比较，但是不涉及以太币转移 Table.7</li><li>在有限的测试时间内，某些条件很难触发。例如，一个合约在触发时间戳相关的以太币传输之前需要函数的特定调用模式。我们可以使用不同的函数调用串行执行更广泛的模糊测试来改善这种情况。comprehensive input generation schemes</li></ul><p><img src="/2023/07/04/ContractFuzzer/image-20230705170242332.png" alt="image-20230705170242332"></p><p>对于重入漏洞，contractFuzzer假阴的原因是一些智能合约的漏洞在转移以太之前必须执行复杂的条件检查。然而，这些条件很难由ContracFuzzer触发。</p><p>Oyente假阳的三类：</p><ul><li>uses <em>send()</em> and <em>transfer()</em> operation with a limited gas，被调用者没有足够的gas进行重入</li><li>严格检查caller是否为合约的拥有者</li><li>只能将ehter转给硬编码的地址</li></ul><p>未来研究方向：</p><ul><li>降低假阳率</li><li>增加支持的漏洞类型</li><li>扩展到其他区块链平台</li></ul><h2 id="配置实验环境"><a href="#配置实验环境" class="headerlink" title="配置实验环境"></a>配置实验环境</h2><p>首先下载姜博老师在<a href="https://github.com/gongbell/ContractFuzzer">github.com</a>提供的container，结果居然在百度龟速盘，卒</p><p>容器大小约为3g，考虑到用网络从windows传给虚拟机比较慢，设置了vmware的共享文件夹，不是很好用</p><p>参考<a href="https://blog.csdn.net/wkd_007/article/details/128908085">samba配置</a>，在Ubuntu配置了samba服务器，可以在windows访问，实际传输文件约为80Mbps</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker load&lt;contractfuzzer.tar </span><br><span class="line">$ docker run -i -t contractfuzzer/contractfuzzer:latest</span><br></pre></td></tr></table></figure><p>启动docker后，运行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./run.sh --contracts_dir ./examples/exception_disorder</span><br></pre></td></tr></table></figure><p>大概运行了2h</p><p><img src="/2023/07/04/ContractFuzzer/image-20230718180501857.png" alt="image-20230718180501857"></p><p>查看reporter目录下的文件</p><p><img src="/2023/07/04/ContractFuzzer/image-20230718181052754.png" alt="image-20230718181052754"></p><p><img src="/2023/07/04/ContractFuzzer/image-20230718183538899.png" alt="image-20230718183538899"></p><p><img src="/2023/07/04/ContractFuzzer/image-20230718183428822.png" alt="image-20230718183428822"></p><ol><li><code>contract_fuzzer</code> is one part of ContractFuzzer, which generates contract call messages based on contract’s ABI definition;</li><li><code>contract_tester</code> is one part of ContractFuzzer, which sends the contract call messages to our instrumented Geth client.</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/ContractFuzzer/examples/exception_disorder/fuzzer/reporter <span class="comment"># cat tester_run.log</span></span><br><span class="line">Error: Transaction 0x32f2a2da9954f099f2e37db287c92286a4cd9110f9b18a6f3258deea477b3960 wasn<span class="string">&#x27;t processed in 240 seconds!</span></span><br><span class="line"><span class="string">    at Object.callback (/ContractFuzzer/contract_tester/node_modules/truffle-contract/contract.js:177:35)</span></span><br><span class="line"><span class="string">    at /ContractFuzzer/contract_tester/node_modules/web3/lib/web3/method.js:142:25</span></span><br><span class="line"><span class="string">    at /ContractFuzzer/contract_tester/node_modules/web3/lib/web3/requestmanager.js:89:9</span></span><br><span class="line"><span class="string">    at XMLHttpRequest.request.onreadystatechange (/ContractFuzzer/contract_tester/node_modules/web3/lib/web3/httpprovider.js:128:7)</span></span><br><span class="line"><span class="string">    at XMLHttpRequestEventTarget.dispatchEvent (/ContractFuzzer/contract_tester/node_modules/xhr2/lib/xhr2.js:64:18)</span></span><br><span class="line"><span class="string">    at XMLHttpRequest._setReadyState (/ContractFuzzer/contract_tester/node_modules/xhr2/lib/xhr2.js:354:12)</span></span><br><span class="line"><span class="string">    at XMLHttpRequest._onHttpResponseEnd (/ContractFuzzer/contract_tester/node_modules/xhr2/lib/xhr2.js:509:12)</span></span><br><span class="line"><span class="string">    at IncomingMessage.&lt;anonymous&gt; (/ContractFuzzer/contract_tester/node_modules/xhr2/lib/xhr2.js:469:24)</span></span><br><span class="line"><span class="string">    at IncomingMessage.emit (events.js:185:15)</span></span><br><span class="line"><span class="string">    at IncomingMessage.emit (domain.js:422:20)</span></span><br><span class="line"><span class="string">    at endReadableNT (_stream_readable.js:1106:12)</span></span><br><span class="line"><span class="string">    at process._tickCallback (internal/process/next_tick.js:178:19)</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/gongbell/ContractFuzzer/issues/13">github上的解释</a>是</p><p>“The existing private blockchain has slowed down over time and now the mining speed is too low. truffle-contract is timing out while trying to push the transaction”</p><p>实际更换在windows的wsl上运行docker后不再存在这个问题（依然存在</p><p><img src="/2023/07/04/ContractFuzzer/image-20230814124807320.png" alt="image-20230814124807320"></p><p><img src="/2023/07/04/ContractFuzzer/image-20230814124754747.png" alt="image-20230814124754747"></p><h2 id="和xls交流后记录"><a href="#和xls交流后记录" class="headerlink" title="和xls交流后记录"></a>和xls交流后记录</h2><ul><li>学习智能合约的开发：<a href="https://github.com/smartcontractkit/full-blockchain-solidity-course-js">https://github.com/smartcontractkit/full-blockchain-solidity-course-js</a></li><li>测试网领取测试币<ul><li>chainlink：<a href="https://faucets.chain.link/sepolia">Get Sepolia Testnet LINK Tokens | Chainlink Faucets</a> 20 test LINK, 0.1测试币</li></ul></li><li><p><img src="/2023/07/04/ContractFuzzer/image-20230722093718219.png" alt="image-20230722093718219"></p><ul><li><a href="https://sepoliafaucet.com/">Sepolia Faucet</a>，每天0.5ETH</li><li><a href="https://goerlifaucet.com/">Goerli Faucet</a>，每天0.02ETH，Goerli需要在主网上充值0.001eth，测试网领取测试币</li></ul></li><li><p>继续学习contractFuzzer的实现，尝试将链部署在Ganache上</p></li><li>以后写合约考虑使用<a href="https://learnblockchain.cn/docs/hardhat/hardhat-network/">Hardhat网络</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;ContractFuzzer-Fuzzing-Smart-Contracts-for-Vulnerability-Detection&quot;&gt;&lt;a href=&quot;#ContractFuzzer-Fuzzing-Smart-Contracts-for-Vulnerability-Detection&quot; class=&quot;headerlink&quot; title=&quot;ContractFuzzer: Fuzzing Smart Contracts for Vulnerability Detection&quot;&gt;&lt;/a&gt;ContractFuzzer: Fuzzing Smart Contracts for Vulnerability Detection&lt;/h1&gt;&lt;p&gt;软工顶会 &lt;code&gt;ASE18&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;基于智能合约的ABI生成fuzz的输入，针对不同漏洞类型定义了新的测试oracle，利用EVM记录智能合约的运行时行为，分析日志来报告安全漏洞。实验对6991份智能合约标记出了459个漏洞。&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/categories/Blockchain/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="SmartContract" scheme="https://alleysira.github.io/tags/SmartContract/"/>
    
  </entry>
  
  <entry>
    <title>blockchain security survey</title>
    <link href="https://alleysira.github.io/2023/06/20/blockchain-security-survey/"/>
    <id>https://alleysira.github.io/2023/06/20/blockchain-security-survey/</id>
    <published>2023-06-20T03:48:28.000Z</published>
    <updated>2023-07-23T10:43:54.051Z</updated>
    
    <content type="html"><![CDATA[<div class="table-container"><table><thead><tr><th style="text-align:center">论文</th><th style="text-align:center">来源</th><th style="text-align:center">内容</th></tr></thead><tbody><tr><td style="text-align:center">区块链安全问题：研究现状与展望</td><td style="text-align:center">自动化学报  2019</td><td style="text-align:center">本文定义了区块链系统设计追求的安全目标, 从机制漏洞、攻击手段和安全措施三方面对区块链各层级的安全问题进行分析, 提出了区块链的平行安全概念框架</td></tr><tr><td style="text-align:center">区块链公链应用的典型安全问题综述</td><td style="text-align:center">软件学报  2022</td><td style="text-align:center">以比特币和以太坊为例, 剖析了针对面向代币交易和应用的区块链系统的各类安全威胁以及应对方法;  接着分析钱包和用户的安全隐患</td></tr><tr><td style="text-align:center">区块链系统攻击与防御技术研究进展</td><td style="text-align:center">软件学报  2020</td><td style="text-align:center">本文从层级分类、攻击关联分析两个维度对区块链已有安全问题的系统架构、攻击原理、防御策略展开研究</td></tr><tr><td style="text-align:center">区块链中攻击方式的研究</td><td style="text-align:center">计算机学报  2021</td><td style="text-align:center">分析区块链攻击方式，提出了对攻击方式的分类方法，体现了不同攻击方式间的差异性和关联性，归纳攻击的特点并给出了预防措施和检测方法</td></tr><tr><td style="text-align:center">智能合约漏洞检测研究综述</td><td style="text-align:center">计算机科学与探索  2022</td><td style="text-align:center">通过对常见漏洞的分析，漏洞检测方法和工具的国内外现状调研并分析优缺点，复现部分工具进行实验，以检测速度、准确率以及支持的漏洞数量为标准，展示漏洞检测工具的性能</td></tr><tr><td style="text-align:center">区块链的网络安全：威胁与对策</td><td style="text-align:center">信息安全学报  2018</td><td style="text-align:center">本文针对区块链数据的完整性、匿名性与隐私保护的安全需求, 系统分析了区块链的安全攻击, 综述了安全保护技术研究进展</td></tr><tr><td style="text-align:center">智能合约漏洞及检测技术研究综述</td><td style="text-align:center">网络安全技术与应用 2022</td><td style="text-align:center">详细介绍了智能合约的14种典型安全漏洞，总结了漏洞防范的方法；针对漏洞检测技术进行分类，介绍检测工具解决的问题，实现原理，比较检测技术和工具的优劣</td></tr><tr><td style="text-align:center">区块链安全能力测评与分析报告</td><td style="text-align:center">中国信通院  2021</td><td style="text-align:center">综合分析区块链基础设施安全能力测评情况，总结了安全隐患，对2021-2023年区块链基础设施安全新方向提出展望</td></tr><tr><td style="text-align:center">网络安全国家标准研究项目研究报告</td><td style="text-align:center">北航  伍前红 2018</td><td style="text-align:center">国内外区块链发展现状和相关政策；区块链安全需求以及面临的主要威胁；区块链应用典型案例；区块链安全参考架构；区块链安全标准化建议</td></tr><tr><td style="text-align:center">区块链的安全威胁与取证</td><td style="text-align:center">付章杰-南京信息工程大学</td><td style="text-align:center">本报告介绍了区块链取证的背景，区块链取证的研究现状与存在的技术挑战，研究内容主要包括通用感知和精准取证</td></tr></tbody></table></div><span id="more"></span><h1 id="智能合约漏洞检测研究综述-李雷孝-计算机科学与探索"><a href="#智能合约漏洞检测研究综述-李雷孝-计算机科学与探索" class="headerlink" title="智能合约漏洞检测研究综述-李雷孝-计算机科学与探索"></a>智能合约漏洞检测研究综述-李雷孝-计算机科学与探索</h1><p>介绍了重入攻击漏洞、整数溢出以及访问控制漏洞的分析</p><p>给出了形式化验证、符号执行、机器学习等方法和工具的现状以及优缺点</p><p>复现了部分工具，给出了检测速度、准确率、漏洞数量等性能对比</p><h2 id="区块链和智能合约"><a href="#区块链和智能合约" class="headerlink" title="区块链和智能合约"></a>区块链和智能合约</h2><p>安全问题出现的原因主要有:</p><ul><li><p>智能合约一旦部署不可修改</p></li><li><p>合约执行后不可逆</p></li><li><p>编程语言自身问题或程序员的逻辑问题</p></li></ul><p>智能合约的设计准则：</p><ul><li>可观察性</li><li>客观可核查</li><li>相对性</li><li>可执行性</li></ul><p>智能合约一般采用高级语言Solidity编写，智能合约应用采用EVM字节码编码后存储在区块链上</p><h2 id="智能合约的漏洞"><a href="#智能合约的漏洞" class="headerlink" title="智能合约的漏洞"></a>智能合约的漏洞</h2><p><img src="/2023/06/20/blockchain-security-survey/image-20230620164027253.png" alt="image-20230620164027253"></p><ul><li><p>重入漏洞：<code>fallback</code>函数在调用结束前让攻击者有机会再执行被调用的函数，类似于递归调用</p><ul><li><code>fallback</code>在合约调用没有匹配到函数签名，或者调用没有带任何数据时被自动调用。</li></ul></li><li><p>整数溢出：以太坊提供了SafeMath库，会提前检测整数溢出</p><ul><li>乘法</li><li>加法</li><li>减法</li></ul></li><li><p>访问控制漏洞：合约中函数的权限设置不合理，如未定义类型的函数默认为public</p></li><li>交易顺序依赖攻击：算出PoW的矿工可以选择打包哪些交易，攻击者可以观察交易池中存在哪些可能对自己不利的交易，攻击者可以创建包含更高gas的交易，使得自己被优先打包，核心问题是矿工根据gas交易来选择打包的交易</li><li>对可预测变量的依赖：以太坊的随机数通过区块的某些属性来生成，攻击者可能能够预测到随机数的生成</li><li>tx-origin滥用：<code>tx-origin</code>作为一个全局变量，能够回溯整个调用栈被返回租出发起交易的合约地址，当合约使用该变量进行验证或授权，可能能够绕过某些判断语句</li><li>DoS：可能导致合约被锁定，用户的加密货币无法取回</li><li>动态数组双重访问攻击：不同变量可能存储在同一个位置，可能导致变量被覆盖，目前没有有效的工具<ul><li>绕过</li><li>提权</li></ul></li></ul><h2 id="智能合约漏洞检测方法"><a href="#智能合约漏洞检测方法" class="headerlink" title="智能合约漏洞检测方法"></a>智能合约漏洞检测方法</h2><p>不可篡改性：上链前</p><h3 id="形式化验证"><a href="#形式化验证" class="headerlink" title="形式化验证"></a>形式化验证</h3><ul><li>BAN逻辑</li><li>模型检验</li><li>密码学原语代数属性的形式化方法</li><li><p>基于定理证明</p></li><li><p>形式化验证包括</p><ul><li>模型检验：列举出所有可能的状态主义检验</li><li>演绎验证</li></ul></li><li>形式化验证的工具：<ul><li>ZEUS. KALRA S, GOEL S, DHAWAN M, et al. ZEUS: analyzing safety of smart contracts[C]//Proceedings of the 25th Annual Network and Distributed System Security Symposium, San Diego, Feb 18-21, 2018: 1-15.<ul><li>无法检测重入攻击和跨功能的分析策略</li></ul></li><li>Isabelle/HOL：针对EVM 字节码进行检测</li></ul></li></ul><h3 id="符号执行的审计方法"><a href="#符号执行的审计方法" class="headerlink" title="符号执行的审计方法"></a>符号执行的审计方法</h3><p>将代码中的变量符号化符号化程序输入，符号执行能够为所有的执行路径维护一组约束，执行之后，约束求解<br>器将用于求解约束并确定该执行的输入，最后利用约束求解器得到新的测试输入，检测符号值是否可以产生漏洞。</p><p><img src="/2023/06/20/blockchain-security-survey/image-20230620173459648.png" alt="image-20230620173459648"></p><p>步骤：符号化、逐条解释、更新状态搜集路径约束，完成所有路径的探索（安全问题）</p><ul><li><p>Oyente 第一个用于以太坊上的漏洞检测支持重入漏洞、交易顺序依赖以及伪随机等安全漏洞的检测，但是该工具对于自杀合约和<code>tx-origin</code> 的滥用问题并不能做到有效的检测</p></li><li><p>Mythril <a href="https://pypi.org/project/mythril/">mythril · PyPI</a><a href="https://pypi.org/project/mythril/">mythril · PyPI</a></p></li><li>MythX <a href="https://mythx.io/">MythX: Smart contract security service for Ethereum</a></li></ul><h3 id="利用模糊测试的审计方法"><a href="#利用模糊测试的审计方法" class="headerlink" title="利用模糊测试的审计方法"></a>利用模糊测试的审计方法</h3><p>提供非预期输入监视异常结果来发现软件漏洞。</p><p>核心思想是将自动或半自动生成的随机数输入程序并检测到程序的异常。</p><p>工具：</p><ul><li>ContractFuzzer 分析日志进行分析检测  JIANG B, LIU Y, CHAN W K. ContractFuzzer: fuzzing smart contracts for vulnerability detection[C]//Proceedings of the 33rd ACM/IEEE International Conference on Automated Software Engineering, Montpellier, Sep 3-7, 2018. New York: ACM, 2018: 259-269.</li><li>SoliAudit 机器学习和模糊测试结合  LIAO J W, TSAI T T, HE C K, et al. SoliAudit: smart contract<br>vulnerability assessment based on machine learning and fuzz testing[C]//Proceedings of the 6th International Conference on Internet of Things: Systems, Management and Security, Granada, Oct 22-25, 2019. Piscataway: IEEE, 2019: 458-465.</li><li>GasFuzzer 检测交易中有较高gas 消耗异常的工具</li></ul><h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><p>多将代码转换为控制流图，利用CFG进行切片，对切片矩阵建立了机器学习的决策模型</p><p>准确率较高，研究丰富</p><h3 id="其他方法的漏洞检测技术"><a href="#其他方法的漏洞检测技术" class="headerlink" title="其他方法的漏洞检测技术"></a>其他方法的漏洞检测技术</h3><p>以太坊中，透明公开的智能合约占了总交易量和总交易金额的2/3 左右，但是有大约77.3%的智能合约是不透明非开源的</p><ul><li><p>Erays 采用逆向工程进行漏洞检测，难以实现高自动化，更适合于手动分析并且高度依赖专家经验 ZHOU Y, KUMAR D, BAKSHI S, et al. Erays: reverse engineering Ethereum’s opaque smart contracts[C]//Proceedings of the 27th USENIX Security Symposium, Baltimore, Aug 15-17, 2018. Berkeley: USENIX Association, 2018: 1371-1385.</p></li><li><p>Dc-Hunter 计算待检测合约和已知合约的相似性</p></li><li>Slither 将智能合约转化为中间表示SlithIR  FEIST J, GREICO G, GROCE A. Slither: a static analysis<br>framework for smart contracts[C]//Proceedings of the 2nd International Workshop on Emerging Trends in Software Engineering for Blockchain, Montreal, May 27, 2019. Piscataway: IEEE, 2019: 8-15.</li><li>EASYFLOW  GAO J B, LIU H, LIU C, et al. EASYFLOW: keep Ethereum away from overflow[C]//Proceedings of the 41st International Conference on Software Engineering: Companion Proceedings, Montreal, May 25-31, 2019. Piscataway: IEEE, 2019: 23-26.</li><li>SmartCheck  TIKHOMIROV S, VOSKRESENSKAYA E, IVANITSKIY I, et al. SmartCheck: static analysis of ethereum smart contracts [C]//Proceedings of the 1st IEEE/ACM International Workshop on Emerging Trends in Software Engineering for Blockchain, Gothenburg, May 27-Jun 3, 2018. New York:ACM, 2018: 9-16.</li></ul><h3 id="各类方案存在的问题"><a href="#各类方案存在的问题" class="headerlink" title="各类方案存在的问题"></a>各类方案存在的问题</h3><ul><li>形式化验证：数学推导和证明门槛高，自动化程度低</li><li>符号执行：涉及到路径遍历和约束问题，耗时</li><li>模糊测试：随机种子难以设计</li><li>机器学习方法：检测结果最好，依赖于开源的智能合约；需要对每种漏洞进行建模，降低了通用性</li><li>特征匹配：依赖开源代码，误报率高</li></ul><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p>450个智能合约</p><p>对VaaS、Oyente、ContractFuzzer、DR-GCN、Slither进行了对比，主要测试可重入和可预测变量的依赖两种类型漏洞进行检测</p><p><img src="/2023/06/20/blockchain-security-survey/image-20230620193254180.png" alt="image-20230620193254180"></p><p>实验结果显示机器学习的准确率最高，效率较高，但是支持的漏洞少，通用性差</p><p>Vaas 是商用级别的漏洞检测工具</p><h2 id="未来研究方向"><a href="#未来研究方向" class="headerlink" title="未来研究方向"></a>未来研究方向</h2><ul><li>符号执行的路径优化</li><li>提高自动化程度：深度学习</li><li>提高漏洞类型覆盖率：目前众多漏洞检测工具个体支持检测的漏洞类型最多不超过10 种，但现有常见的漏洞类型多达 20 多种。机器学习实现通用模型</li><li>准确率和效率：解决假阳等问题</li><li>智能合约开源程度较低</li><li>机器学习方法构建通用模型</li><li>跨平台的漏洞检测工具</li><li>缺乏统一的评价指标</li></ul><h1 id="区块链安全问题-研究现状与展望-袁勇-自动化学报"><a href="#区块链安全问题-研究现状与展望-袁勇-自动化学报" class="headerlink" title="区块链安全问题: 研究现状与展望-袁勇-自动化学报"></a>区块链安全问题: 研究现状与展望-袁勇-自动化学报</h1><p>定义了区块链系统设计追求的安全目标, 从机制漏洞、攻击手段和安全措施三方面对区块链各层级的安全问题进行全面分析, 提出了区块链的平行安全概念框架, 并总结未来区块链安全问题的研究重点.</p><h2 id="区块链的安全目标"><a href="#区块链的安全目标" class="headerlink" title="区块链的安全目标"></a>区块链的安全目标</h2><p><img src="/2023/06/20/blockchain-security-survey/image-20230620200830216.png" alt="image-20230620200830216" style="zoom:67%;"></p><ul><li><p>实现保密性需要设计三类机制</p></li><li><p>共识安全部分主要参考了backbone，需要阅读这篇</p></li><li><p>强一致性不会出现分叉，确认快，前向安全</p></li><li><p>隐私保护</p><ul><li>身份隐私保护身份信息、物理地址、IP和链上的公私钥不关联</li><li>交易隐私保护：交易本身对非授权节点匿名，交易之间的关联被切断</li></ul></li><li><p>智能合约安全</p><ul><li>编写安全<ul><li>设计没问题</li><li>代码安全</li></ul></li><li>运行安全：合约执行出现漏洞或被攻击后，不会对节点和本地设备造成影响，不会影响调用合约的其他合约异常<ul><li>模块化：智能合约的高内聚低耦合</li><li>隔离运行：运行在虚拟化等隔离环境中</li></ul></li></ul></li></ul><h2 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h2><p>数据层、网络层、共识层、激励层、合约层和应用层六层</p><p><img src="/2023/06/20/blockchain-security-survey/image-20230620203308163.png" alt="image-20230620203308163"></p><ul><li>数据层：<ul><li>量子计算</li><li>密钥管理：区块链应用中的主流密钥管理方法包括本地存储、离线存储、托管钱包和门限钱包. <ul><li>密钥保护秘密分享[CCS11]</li></ul></li><li>交易联系：环签名、零知识证明、zk-SNARK</li><li>代码漏洞：数字签名的延展性</li></ul></li><li>网络层<ul><li>P2P: 缺乏身份认证、节点实际上身份不对等</li><li>网络拓扑：日蚀攻击</li><li>隐私：数据与IP地址的关联性；Tor；<ul><li>混币：去中心化和中心化混币</li></ul></li></ul></li><li>共识层：共识机制在安全性建模时需要考虑网络时序性、节点数量拓展、在线离线切换、算力或权益的动态分布、共识难度变更、区块链增长速率等多变量因素. 由于共识机制下层的网络环境复杂, 新的共识机制不断涌现, 传统的可证明安全框架无法完全适用于区块链. 共识机制的安全性面临建模困难、安全性证明不完备的问题.<ul><li>又提到了backbone</li><li>目前对共识机制的可证明安全研究集中在PoW和PoS中</li><li>假设不可靠：依赖诚实节点拥有的算力和权益大多数</li><li>一致性：弱一致性共识算法可能存在分叉<ul><li>受网络影响严重，同步性缺失时无法保持强一致性</li></ul></li><li>分片：周期性节点轮换、跨片交易的原子性</li><li>Dust Attack: 造成网络拥堵、大量交易排队验证；可能泄露账户关联性</li><li>区块链初始化困难问题：创世区块的安全生成<ul><li>依赖第三方</li><li>由现有的、成熟的区块链过渡到新区块的创世区块</li></ul></li></ul></li><li>激励层：激励层还需要策略性行为检测和动态的奖励机制优化，主要解决经济学的 激励不相容问题<ul><li>无利害关系攻击Nothing at Stake: 利益最大化的矿工会同时在分叉上进行挖矿</li><li>区块奖励归零0，仅依赖交易费是否安全</li></ul></li><li>合约层：<ul><li>外部数据调用问题：Oracle作为可信实体，实际上无法保证一致性和真实性</li><li>形式化验证和程序分析工具不完善</li></ul></li></ul><h1 id="区块链公链应用的典型安全问题综述-魏松杰-软件学报"><a href="#区块链公链应用的典型安全问题综述-魏松杰-软件学报" class="headerlink" title="区块链公链应用的典型安全问题综述-魏松杰-软件学报"></a>区块链公链应用的典型安全问题综述-魏松杰-软件学报</h1><p>本文首先介绍了区块链技术, 回顾其面临的安全风险; 其次以比特币和以太坊两个典型系统为例, 剖析了针对面向代币交易和应用的区块链系统的各类安全威胁以及应对方法; 接着分析了钱包交易所等区块链周边设施和区块链用户的安全隐患; 最后对文中安全问题进行了分类总结, 提出可行技术线路和防御方法, 展望当前区块链安全的研究热点和发展趋势.</p><h2 id="区块链1-0-比特币的安全问题"><a href="#区块链1-0-比特币的安全问题" class="headerlink" title="区块链1.0 比特币的安全问题"></a>区块链1.0 比特币的安全问题</h2><p>重放攻击往往出现在存在硬分叉的区块链中,一条链上的交易数据在另一条链上也有极大可能也是合法的. 攻击者只需抓取一条链上的交易数据, 再复制到另一条链上广播, 即可发动重放攻击</p><p>空快攻击的防御思路：区块链设计者可以设计共识, 使矿工的收益与块中的交易数目挂钩, 打包的块中的交易越多, 矿工的奖励就越高; 使矿工的挖矿难度与块中的交易数目挂钩, 根据打包的块中的交易数目略微减少矿工的挖矿难度,使得包含交易多的块更容易被挖出, 从而激励矿工们打包更多的交易.</p><p>长程攻击（PoS）：</p><ul><li>变节攻击：利用其他地址里的权利, 例如B 的地址, 哪怕在攻击者进行攻击时B地<br>址内的权益已经清空了, 只要B的地址内在攻击者需要的历史时刻下有大量的权益, 攻击者在获得该地址的私钥后, 就可以利用自己和B 的权益进行变节攻击</li></ul><p>比特币等典型区块链中每个节点拥有两个节点表, NEW TABLE 存储了节点知晓但还未连接过的其他节点IP; TRIED TABLE 存储了曾经连接过但现在可能没有建立连接的其他节点IP. 攻击者需要利用傀儡节点IP或无效IP 填满两个节点表, 才能达到隔离节点的目的</p><h2 id="区块链2-0-以太坊的安全问题"><a href="#区块链2-0-以太坊的安全问题" class="headerlink" title="区块链2.0 以太坊的安全问题"></a>区块链2.0 以太坊的安全问题</h2><p>Gas 是以太坊为了防止恶意用户部署无限循环运行的合约, 而要求用户为所部署合约的每一步支付的费用, 智能合约的逻辑越复杂, 花费的 Gas 就越多. Gas价格是指花费每个Gas 所需要的以太币的数量, 可由用户自行调整</p><p>GHOST 协议, 以权重最高的子树作为合法主链</p><p><img src="/2023/06/20/blockchain-security-survey/image-20230622161248631.png" alt="image-20230622161248631"></p><p>交易顺序依赖攻击：降低实际开销成本</p><h2 id="区块链周边安全问题"><a href="#区块链周边安全问题" class="headerlink" title="区块链周边安全问题"></a>区块链周边安全问题</h2><ul><li>钱包<ul><li>在线钱包（热钱包）外界通过互联网访问私钥存储的地方</li><li>冷钱包：非联网状态，能够避免黑客攻击。硬件设备设计的缺陷可能存在==导致漏洞</li></ul></li><li>矿池：<ul><li>远程管理机制</li><li>恶意挖矿策略<ul><li>自私挖矿：诚实节点为了获得超额的挖矿奖励，可能转入恶意矿池进行挖矿</li><li>跳池攻击：根据算力大小给矿池内参与挖矿的矿工结算收益, 结算模式有很多, 例如Proportional 模式、PPS 模式、PPLNS 模式等；<ul><li>在Proportional 模式下, 从矿池挖到上个区块到挖到当前区块的时<br>间被称为一个挖矿周期, 每个矿工的区块奖励与一个挖矿周期内其有效工作量证明(share) 所占全部有效工作量的百分比成正比. 因此矿工们收益最高的策略是当当前挖矿周期长度到达一个阀值后, 跳槽到另一个才发现新区块、挖矿周期较短的矿池重新开始挖矿</li><li>可以采用更优的收益结算模式，如PPS模式或者PPLNS模式</li><li>PPS: 矿工的收益=矿池用于奖励矿工的总币量×某个矿工提供的算力/当前网络难度.</li><li>PPLNS: 矿工的收益=矿池用于奖励矿工的总币量×出块时该名矿工提交的有效工作量证明在总有效提交中占比.</li></ul></li><li>扣块攻击：恶意矿工在挖到新区块后不向矿池提交, 而是直接丢弃该区块, 从而减少矿池收入的攻击.</li></ul></li></ul></li></ul><h2 id="用户的安全问题"><a href="#用户的安全问题" class="headerlink" title="用户的安全问题"></a>用户的安全问题</h2><ul><li>社会工程学</li><li>中间人攻击</li><li>撞库攻击</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>大多数攻击针对的是区块链的共识层，设计漏洞较少、安全性较高的共识算法</p><p>针对PoW的攻击比较多</p><p>研究问题与最新进展</p><ul><li>数据层<ul><li>量子计算</li><li>隐私保护：多方零知识证明</li></ul></li><li>网络层<ul><li>针对区块链网络的异常检测系统</li></ul></li><li>共识层<ul><li>避免双花攻击：跨链的双花攻击 doi: 10.1109/TPS-ISA48467.2019.00014</li><li>其他类型的双花攻击</li></ul></li><li>激励层<ul><li>设计新的矿池收益结算模式，避免跳池攻击</li><li>扣快攻击的解决策略</li></ul></li><li>合约层<ul><li>智能合约漏洞检测<ul><li>机器学习</li><li>智能合约代码修复，修复字节码</li></ul></li></ul></li><li>应用层<ul><li>分析查找非法交易相关地址</li></ul></li></ul><p>当前智能合约安全的研究重点主要为智能合约漏洞检测与修复. 现有的漏洞检测方案可以针对智能合约中的简单漏洞进行检测并提供审计报告, 部分降低了智能合约开发者出错的可能和人工审计成本. 但由于智能合约版本更新换代较快, 各个平台采用的智能合约底层框架不尽相同, 现有方案很难为所有平台所有版本的智能合约提供漏洞检测服务, 因此设计一种通用性强的智能合约漏洞检测工具是未来研究方向之一. </p><p>除了漏洞检测, 未来还可以通过研究标准化的智能合约编写工具以及智能合约漏洞自动修复工具来减少智能合约的安全风险. 另外, 站在智能合约设计者的角度, 为预防在复杂合约的编程过程中可能出现的安全漏洞以及因此而带来的风险, 设计一种“图灵完备”的安全脚本智能合约语言也是可以考虑的方案之一.</p><p>跨链场景下的攻击模型和防御方案</p><h1 id="区块链安全标准体系研究-伍前红"><a href="#区块链安全标准体系研究-伍前红" class="headerlink" title="区块链安全标准体系研究-伍前红"></a>区块链安全标准体系研究-伍前红</h1><p>智能合约就其本质而言，也是一种共识的概念。值得注意的是上述的共识机制、共识算法，都是针对已经发生的交易，进行记录并同步到所有节点。而智能合约究其目的，是确保未发生的交易，在条件满足后能自动触发并生成新的交易，并且这些未来的新交易能保证在各节点上记录的一致性。从这个意义上讲，智能合约是对未来交易的共识。具体而言，智能合约的技术包括合约的签署和分发，合约条件的触发以及最终的记录入链等。</p><p>主要讲解区块链的政策，在金融、医疗、物流等方面的实际应用</p><p>智能合约的安全漏洞</p><ul><li>整数溢出类</li><li>拒绝服务类：合约无法响应</li><li>竞争条件：重入、交易顺序依赖</li><li>底层函数误用</li><li>权限验证错误类：tx.origin</li><li>算法缺陷：伪随机数利用不够随机</li><li>用户错误使用：授权错误</li><li>可见性声明：未正确声明合约的接口，public和private等</li><li>段地址攻击、无限制增发和销毁</li></ul><p><img src="/2023/06/20/blockchain-security-survey/image-20230623103830841.png" alt="image-20230623103830841"></p><h1 id="区块链安全能力测评与分析报告2021-中国信通院"><a href="#区块链安全能力测评与分析报告2021-中国信通院" class="headerlink" title="区块链安全能力测评与分析报告2021-中国信通院"></a>区块链安全能力测评与分析报告2021-中国信通院</h1><p><img src="/2023/06/20/blockchain-security-survey/image-20230623121621506.png" alt="image-20230623121621506"></p><p><img src="/2023/06/20/blockchain-security-survey/image-20230623121657709.png" alt="image-20230623121657709"></p><p><img src="/2023/06/20/blockchain-security-survey/image-20230623121834821.png" alt="image-20230623121834821"></p><p><img src="/2023/06/20/blockchain-security-survey/image-20230623122149405.png" alt="image-20230623122149405"></p><p><img src="/2023/06/20/blockchain-security-survey/image-20230623122135523.png" alt="image-20230623122135523"></p><h1 id="智能合约漏洞及检测技术研究综述-网络安全技术与应用"><a href="#智能合约漏洞及检测技术研究综述-网络安全技术与应用" class="headerlink" title="智能合约漏洞及检测技术研究综述-网络安全技术与应用"></a>智能合约漏洞及检测技术研究综述-网络安全技术与应用</h1><ul><li>短地址漏洞：短地址漏洞通常指的是用户在交易所提取代币时，输入一个短地址，但交易所对用户所输入的地址长度没有检查其是否合法而引起的交易异常事件。以太坊虚拟机没有严格检查地址位数的机制，且具有自动补齐缺失位数的机制，这使短地址攻击漏洞更容易发生。为防范此漏洞，交易所需要做好校验用户输入地址长度工作，有效阻止恶意的短地址，减少经济损失</li><li>以太币冻结漏洞：合约需要设置接受和转出以太币的功能</li><li>时间戳依赖漏洞：更改可靠的时间戳来源</li><li><code>delegatecall()</code>函数可以任意执行其他智能合约的中的代码</li><li>可利用外部的随机数据源取代使用区块变量开发而成的PRG</li><li>存储变量重复命名</li><li>严格balance比较漏洞</li></ul><p><img src="/2023/06/20/blockchain-security-survey/image-20230623170930876.png" alt="image-20230623170930876"></p><ul><li>模糊测试是将自动或半自动生成的具有随机性的数据作为输入，运行将其作为输入数据的程序并持续监控，以检测程序异常情况。</li><li>符号执行是将输入数据变为符号值，程序的输出值是输入符号值的一个函数。</li><li>形式化验证通过形式化语言把合约中的概念、判断、推理转化成智能合约模型，可以消除自然语言的歧义性、不通用性，进而采用形式化工具对智能合约建模、分析和验证，进行一致性测试，最后自动生成验证过的合约代码，形成智能合约生产的可信全生命周期。</li><li>智能合约漏洞分析中，使用污点分析技术能够将来自程序外部的输入数据标记为污点数据，通过跟踪与污点数据相关的信息流向，可以判断污点数据及其相关数据是否会影响关键程序实现的功能完整性，进一步检测出合约程序漏洞。</li><li>程序分析技术<ul><li>静态分析</li><li>动态分析：运行时方法实现</li></ul></li></ul><p>漏洞检测的主流技术仍为模糊测试、符号执行以及形式化验证。但同时也存在一些问题，现有的检测技术难以形成全面、体系的智能合约检测框架；检测技术优势较为单一，无法兼顾多种检测技术优势；对运行中的智能合约，未实现灵活、有效的合约维护、升级机制。对漏洞检测技术的研究，有利于推动智能合约安全性研究，保障区块链上智能合约的安全，进而降低了合约参与者的经济风险。</p><h1 id="区块链的网络安全-威胁与对策-信息安全学报"><a href="#区块链的网络安全-威胁与对策-信息安全学报" class="headerlink" title="区块链的网络安全: 威胁与对策-信息安全学报"></a>区块链的网络安全: 威胁与对策-信息安全学报</h1><p>本文针对区块链数据的完整性、匿名性与隐私保护的安全需求, 系统分析了区块链的安全攻击, 综述了安全保护技术研究进展, 尤其对区块链密码学安全防护技术进行了对比分析。</p>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;论文&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;来源&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;内容&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;区块链安全问题：研究现状与展望&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;自动化学报  2019&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;本文定义了区块链系统设计追求的安全目标, 从机制漏洞、攻击手段和安全措施三方面对区块链各层级的安全问题进行分析, 提出了区块链的平行安全概念框架&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;区块链公链应用的典型安全问题综述&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;软件学报  2022&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;以比特币和以太坊为例, 剖析了针对面向代币交易和应用的区块链系统的各类安全威胁以及应对方法;  接着分析钱包和用户的安全隐患&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;区块链系统攻击与防御技术研究进展&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;软件学报  2020&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;本文从层级分类、攻击关联分析两个维度对区块链已有安全问题的系统架构、攻击原理、防御策略展开研究&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;区块链中攻击方式的研究&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;计算机学报  2021&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;分析区块链攻击方式，提出了对攻击方式的分类方法，体现了不同攻击方式间的差异性和关联性，归纳攻击的特点并给出了预防措施和检测方法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;智能合约漏洞检测研究综述&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;计算机科学与探索  2022&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;通过对常见漏洞的分析，漏洞检测方法和工具的国内外现状调研并分析优缺点，复现部分工具进行实验，以检测速度、准确率以及支持的漏洞数量为标准，展示漏洞检测工具的性能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;区块链的网络安全：威胁与对策&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;信息安全学报  2018&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;本文针对区块链数据的完整性、匿名性与隐私保护的安全需求, 系统分析了区块链的安全攻击, 综述了安全保护技术研究进展&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;智能合约漏洞及检测技术研究综述&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;网络安全技术与应用 2022&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;详细介绍了智能合约的14种典型安全漏洞，总结了漏洞防范的方法；针对漏洞检测技术进行分类，介绍检测工具解决的问题，实现原理，比较检测技术和工具的优劣&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;区块链安全能力测评与分析报告&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;中国信通院  2021&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;综合分析区块链基础设施安全能力测评情况，总结了安全隐患，对2021-2023年区块链基础设施安全新方向提出展望&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;网络安全国家标准研究项目研究报告&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;北航  伍前红 2018&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;国内外区块链发展现状和相关政策；区块链安全需求以及面临的主要威胁；区块链应用典型案例；区块链安全参考架构；区块链安全标准化建议&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;区块链的安全威胁与取证&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;付章杰-南京信息工程大学&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;本报告介绍了区块链取证的背景，区块链取证的研究现状与存在的技术挑战，研究内容主要包括通用感知和精准取证&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/categories/Blockchain/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="SmartContract" scheme="https://alleysira.github.io/tags/SmartContract/"/>
    
  </entry>
  
  <entry>
    <title>Sharding_Blockchain_Consensus</title>
    <link href="https://alleysira.github.io/2023/05/31/Sharding-Blockchain-Consensus-lyj/"/>
    <id>https://alleysira.github.io/2023/05/31/Sharding-Blockchain-Consensus-lyj/</id>
    <published>2023-05-31T08:23:34.000Z</published>
    <updated>2023-07-23T10:47:12.730Z</updated>
    
    <content type="html"><![CDATA[<p>云南创新研究院研讨会 刘懿中老师分片共识研究分享</p><span id="more"></span><h1 id="分片区块链共识机制研究"><a href="#分片区块链共识机制研究" class="headerlink" title="分片区块链共识机制研究"></a>分片区块链共识机制研究</h1><h2 id="区块链共识机制"><a href="#区块链共识机制" class="headerlink" title="区块链共识机制"></a>区块链共识机制</h2><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531163125372.png" alt="image-20230531163125372"></p><p>1982年提出了拜占庭将军问题</p><p>FLP提出异步环境下没有确定性一致算法</p><p>2016年ELASTICO是首个分片共识，结合数据库领域的分片技术</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531163950433.png" alt="image-20230531163950433"></p><p>分片的基本流程</p><ul><li>选出块者<ul><li>随机出块</li></ul></li><li>生成区块并广播</li><li>节点验证更新区块链</li></ul><p>一致性consistency：指诚实节点输出的交易互为前缀</p><ul><li>强一致性：PBFT</li><li>弱一致性：PoW PoS</li></ul><p>活性liveness：交易一定会被处理</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531164356367.png" alt="image-20230531164356367"></p><p>性能+安全性都取决于共识机制</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531164845023.png" alt="image-20230531164845023"></p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531164926354.png" alt="image-20230531164926354"></p><p>经典的分布式一致算法能够容忍宕机错误（crash）</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531165205097.png" alt="image-20230531165205097"></p><p>现在研究工作集中于异步网络环境下，信工所路远老师 清华段斯斯老师等均有相关研究工作</p><p>异步DKG，如何在动态环境下更新委员会，实现动态门限签名</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531165353683.png" alt="image-20230531165353683"></p><p>PoW的能防止女巫攻击</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531165444310.png" alt="image-20230531165444310"></p><p>PoW和PoS的安全性已经足够好了，但是性能比较低，设计混合共识的动机</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531165609984.png" alt="image-20230531165609984"></p><p>先用PoW和PoS选委员会，委员会内跑PBFT等</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531165938027.png" alt="image-20230531165938027"></p><p>多个委员会，每个委员会并行处理交易，分片登场了</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531170048237.png" alt="image-20230531170048237"></p><h2 id="分片区块链技术"><a href="#分片区块链技术" class="headerlink" title="分片区块链技术"></a>分片区块链技术</h2><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531170221192.png" alt="image-20230531170221192"></p><p>如果在安全性上妥协，可以提高可扩展性</p><p>分片的思想就是将节点划分到不同的子集，每个分片负责维护本分片区块链</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531170346117.png" alt="image-20230531170346117"></p><p>共识节点分片，交易分片</p><ul><li><p>计算分片：分片内只验证分片内的交易</p></li><li><p>存储分片：片内节点只存片内的区块链</p></li><li>通信分片：大多数情况不需要和分片外节点通信</li></ul><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531170603682.png" alt="image-20230531170603682"></p><p>时期epoch是为了防止节点的腐化攻击设置的，进行重新配置</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531170753693.png" alt="image-20230531170753693"></p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531171408957.png" alt="image-20230531171408957"></p><p>完整的分片区块链系统</p><ul><li>节点选择<ul><li>permissionless：PoW/PoS</li><li>permissioned：CA</li></ul></li><li>随机数生成与节点分配：节点划分为不同分片过程中一般需要随机化分配（不随机的方案需要考虑敌手控制的节点低于某个阈值）<ul><li>VRF 门限签名 VSS TEE</li></ul></li><li>分片内共识：都可以<ul><li>PBFT PoW</li><li>有的交易需要跨片协同交易</li></ul></li><li>跨片交易处理</li><li>分片重配置：应对敌手corruption</li><li>激励机制：有一些博弈论的结论</li></ul><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531171805722.png" alt="image-20230531171805722"></p><p>公平性是节点选中的概率相同，鲁棒性指一定能选出来</p><p>委员会中心化问题后续可以再了解了解</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531171935276.png" alt="image-20230531171935276"></p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531172038191.png" alt="image-20230531172038191"></p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531172228946.png" alt="image-20230531172228946"></p><p>BLS签名不管签名的 $t$ 个人是谁，签名是unique，需要DKG，实际上DKG</p><p>随机数生成复杂度一般是$O(n^2)$，因此需要先选一部分节点来做</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531173107903.png" alt="image-20230531173107903"></p><p>利用概率来考虑如何进行节点分配</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531173338979.png" alt="image-20230531173338979"></p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531173458813.png" alt="image-20230531173458813"></p><p>一致性的定义基于backbone protocol </p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531173630844.png" alt="image-20230531173630844"></p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531173726776.png" alt="image-20230531173726776"></p><p>2 phase commitment</p><ul><li>准备阶段 两个分片运行片内共识，确认交易可用性，锁定输入（防止双花，直到第二轮片内共识结束）</li><li>承诺阶段 </li></ul><p>多输入输出拆分后不需要跨片吗，没理解</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531174150817.png" alt="image-20230531174150817"></p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531174655816.png" alt="image-20230531174655816"></p><p>替换的方法：</p><ul><li>随机</li><li>时间规则（rapid chain）</li><li>有界布谷鸟</li></ul><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531174810883.png" alt="image-20230531174810883"></p><p>基于博弈论的思想，分片+博弈+reputation的研究很少，有研究价值</p><p>以上研究内容发表在computer science review，中科院Q1的综述</p><h2 id="Fleetchain"><a href="#Fleetchain" class="headerlink" title="Fleetchain"></a>Fleetchain</h2><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531175230991.png" alt="image-20230531175230991"></p><p>分片内签名可以聚合$O(n^2)\to O(n)$，是否可以在分片内签名聚合</p><p>片间复杂度同样降低$O(m^2)\to O(m)$</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531175429371.png" alt="image-20230531175429371"></p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531175438271.png" alt="image-20230531175438271"></p><p>共识协议的安全性一般依赖于数字签名的安全性</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531175529500.png" alt="image-20230531175529500"></p><p>将hotstuff每轮换leader改成stable leader</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531175600846.png" alt="image-20230531175600846"></p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531175612448.png" alt="image-20230531175612448"></p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531175639194.png" alt="image-20230531175639194"></p><p>两部分都是线性复杂度</p><h2 id="跨片交易处理"><a href="#跨片交易处理" class="headerlink" title="跨片交易处理"></a>跨片交易处理</h2><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531175713097.png" alt="image-20230531175713097"></p><p>交易输入地址可能是共有的，众筹服务器！</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531175835847.png" alt="image-20230531175835847"></p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531175944598.png" alt="image-20230531175944598"></p><p>由用户将每个分片给的证明再转发</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531180116957.png" alt="image-20230531180116957"></p><p>分片直接互相广播，用户无感知</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531180154281.png" alt="image-20230531180154281"></p><p>1个交易2个BFT，如果2次BFT处理1k个交易，输入merkle树根，输出树的路径证明</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531180335584.png" alt="image-20230531180335584"></p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531180437719.png" alt="image-20230531180437719"></p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531180507265.png" alt="image-20230531180507265"></p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531180613883.png" alt="image-20230531180613883"></p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531180625949.png" alt="image-20230531180625949"></p><h2 id="跨片视图转换"><a href="#跨片视图转换" class="headerlink" title="跨片视图转换"></a>跨片视图转换</h2><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531180651927.png" alt="image-20230531180651927"></p><p>不同分片的领导者片间可能作恶，片内诚实</p><p>比如片间不发送证明，领导者censor</p><p>思想是本分片监控其他分片领导者是否作恶，作恶则运行BFT给出作恶的证明，发送给作恶分片进行视图转换</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531180923215.png" alt="image-20230531180923215"></p><ul><li>记得扒一下老师的工作</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;云南创新研究院研讨会 刘懿中老师分片共识研究分享&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/categories/Blockchain/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="Consensus" scheme="https://alleysira.github.io/tags/Consensus/"/>
    
    <category term="Sharding" scheme="https://alleysira.github.io/tags/Sharding/"/>
    
  </entry>
  
  <entry>
    <title>FSS</title>
    <link href="https://alleysira.github.io/2023/05/06/FSS/"/>
    <id>https://alleysira.github.io/2023/05/06/FSS/</id>
    <published>2023-05-06T06:53:58.000Z</published>
    <updated>2023-06-06T09:50:06.382Z</updated>
    
    <content type="html"><![CDATA[<p>Elette Boyle’s lecture on FSS from <a href="[The 12th BIU Winter School on Cryptography | BIU Cyber Center](https://cyber.biu.ac.il/event/the-12th-biu-winter-school-on-cryptography/">12th BIU Winter School</a>)</p><span id="more"></span><h1 id="Function-Secret-Sharing"><a href="#Function-Secret-Sharing" class="headerlink" title="Function Secret Sharing"></a>Function Secret Sharing</h1><p><img src="/2023/05/06/FSS/image-20230506145622804.png" alt="image-20230506145622804"></p><p>简单介绍加性秘密分享</p><p>考虑分享一个秘密的函数，份额通信量非常小（compact）</p><p>FSS is compressing the truth table of additive secret sharing </p><p>3Hours：</p><ul><li>定义和性质</li><li>构造</li><li>扩展和应用</li></ul><h2 id="definition"><a href="#definition" class="headerlink" title="definition"></a>definition</h2><ul><li>$Gen(1^\lambda,f)\to(f_0,f_1)$ some times $k_0,k_1$</li><li><p>$Eval(b,k_b,x)\to y_b$, $x$ is the public input,$y_b$ is the output share </p><p>satisfying</p></li><li><p>secrecy (semantic security): $\forall f,f’ \in \mathcal{F}, \{k_b \in f\} \approx \{ k_b \in f’\}$</p><ul><li>statistically close</li><li>relaxed bond: relaxed on hardness problem</li><li>simulation security</li></ul></li><li><p>reconstruction: $y_0+y_1=f(x)$</p><ul><li>other forms are acceptable</li></ul></li><li><p>FSS For All functions(truth table)</p><ul><li>using additive secret sharing but the share size is  $O(2^n),where \ input\ len\ is\ nbits$</li></ul></li><li><p>Linear functions over ring $R$</p><ul><li>using  coefficients additive secret sharing</li></ul></li><li><p>polynomials</p><ul><li>also using  coefficients additive secret sharing</li></ul></li></ul><p>Notes: <em>secret</em> linear combination of <em>public</em> function of x and All the constructions above are information-secure </p><p>for some classes of functions can only get computational security</p><ul><li>Point functions<ul><li>$f_{\alpha,\beta}(x)=\alpha $ only when $x=\alpha$, else eval 0</li></ul></li></ul><h3 id="Sample-Application"><a href="#Sample-Application" class="headerlink" title="Sample Application"></a>Sample Application</h3><p>similar to PIR</p><p><img src="/2023/05/06/FSS/image-20230506154438168.png" alt="image-20230506154438168"></p><p> <img src="/2023/05/06/FSS/image-20230506154931929.png" alt="image-20230506154931929"></p><p>2服务器 计算安全的PIR的结果和FSS结果不谋而合 （<strong>corollary</strong>）</p><p>AES is unbreakable, means lightweight crypto</p><p>FSS for points Functions \to 2- server PIR</p><p><img src="/2023/05/06/FSS/image-20230506155829634.png" alt="image-20230506155829634"></p><p>正确显然成立，黑色框是0的秘密分享，$y_A\  y_B$求和后只剩下$val[i]$</p><p> FSS for Point Functions ⇒ Private Increment satisifying p</p><p>Q: garble circuits as a weak case of FSS</p><p>A: yes, reconstruction is not additive, former applications won’t go directly </p><p>Q: how to complete private read and write an the same time</p><p>A: Not possible. reading needs server to store same data, writing needs server to hold shared data, changing sever numbers may </p><p>Q: point functions can’t be described as low degree <strong>polynomial</strong> having FSS for low degree polynomials and FSS for distributed point function</p><h2 id="Construction"><a href="#Construction" class="headerlink" title="Construction"></a>Construction</h2><h3 id="point-functions"><a href="#point-functions" class="headerlink" title="point functions"></a>point functions</h3><p>DPF的第一个构造来自于[CG99]对PIR的构造，$n$是函数输入的bits</p><p><img src="/2023/05/06/FSS/image-20230606164441993.png" alt="image-20230606164441993"></p><h3 id="comparison-functions"><a href="#comparison-functions" class="headerlink" title="comparison functions"></a>comparison functions</h3>]]></content>
    
    
    <summary type="html">&lt;p&gt;Elette Boyle’s lecture on FSS from &lt;a href=&quot;[The 12th BIU Winter School on Cryptography | BIU Cyber Center](https://cyber.biu.ac.il/event/the-12th-biu-winter-school-on-cryptography/&quot;&gt;12th BIU Winter School&lt;/a&gt;)&lt;/p&gt;</summary>
    
    
    
    <category term="Crypto" scheme="https://alleysira.github.io/categories/Crypto/"/>
    
    
    <category term="Crypto" scheme="https://alleysira.github.io/tags/Crypto/"/>
    
  </entry>
  
  <entry>
    <title>Rabin81</title>
    <link href="https://alleysira.github.io/2023/04/14/Rabin81/"/>
    <id>https://alleysira.github.io/2023/04/14/Rabin81/</id>
    <published>2023-04-14T08:37:35.000Z</published>
    <updated>2023-07-23T10:46:47.907Z</updated>
    
    <content type="html"><![CDATA[<p>Michael O. Rabin. How to exchange secrets with oblivious transfer. Technical Report TR-81, Aiken Computation Lab, Harvard University, 1981.</p><span id="more"></span><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Alice和Bob分别拥有一个对方想要解密的加密文件，密钥为1 bit秘密$SA\ SB$，因此两人想要交换$SA\ SB$</p><p>但是存在问题，如果密钥错误，文件会损坏不能再解密。因此Alice和Bob都想要保证能够正确解密文件</p><p>如果Bob给了Alice错误的密钥$S\neq SB$，交换得到了正确的$SA$，这是Alice不希望发生的情况</p><p>如果Bob发送一条消息， <strong>My secret is S, signed Bob.</strong> Alice可以收到$S$后不发给Bob $SA$，这是Bob不希望发生的情况，Alice也可以耍赖 <strong>“I gave Bob the password SA and he has not used it; I am willing to reveal it again right now.”</strong> 尽管Bob最终能够得到$SA$，Alice已经占据了时间优势</p><p>进行归纳，协议的流程总是分为$Alcie \to^{I_i} Bob, Bob \to^{J_i} Alice $，总会存在一个$k$满足Bob可以从$\{I_1,\dots,I_k\}$中得知$SA$，而Alice不能从$\{J_1,\dots,J_{k-1}\}$中得知$SB$，因此需要设计一种协议保证：</p><p>当Bob得知$SA$时，Alice一定可以得知$SB$</p><p>假设：当Bob发送$SA$去读文件时，Alice能够知道这一情况；反之亦然</p><h1 id="Exchange-of-Secrets-Protocol"><a href="#Exchange-of-Secrets-Protocol" class="headerlink" title="Exchange of Secrets Protocol"></a>Exchange of Secrets Protocol</h1><p>假设Alice和Bob目前分别有了公钥$K_A,K_B$可以进行公钥加密与签名。为了简洁，后续的流程中省略了签名</p><ul><li><p>Alice选择两个大素数$p,q$并计算一次性密钥$n_A=pq$，发送给Bob</p></li><li><p>类似地，Bob选择两个大素数$p_1,q_1$并计算一次性密钥$n_B=p_1q_1$，发送给Alice</p></li><li><p>Bob随机选$x\leq n_A$，计算$c \equiv x^2 \bmod n_A$，发送$c$给Alice</p></li><li><p>Alice已知$p,q$，计算出$x_1^2\equiv c \bmod n_A$，发送$x_1$给Bob</p><ul><li>可能会有四个解$\pm x,\pm y$</li><li>Bob可能作弊，发送自己无法求根的$c$，可能会允许R分解$n$，可以通过添加零知识证明来防御 [GMR85]</li></ul></li><li><p>Bob计算$gcd(x-x_1,n_A)=d$，有$Pr(d=p\ or\ q)=1/2$</p><ul><li>如果$x_1\neq \pm x,x_1^2 -x^2\equiv 0 \bmod n_A,(x_1-x)(x_1+x)\equiv0 \bmod n_A$</li><li>即得知 $p,q$，所以概率$Pr(d=p\ or\ q)=1/2$</li></ul></li><li><p>Bob同样执行 $3-4$ 步，定义</p></li><li><script type="math/tex; mode=display">v_B=\begin{cases}0 & if\ gcd(x-x_1,n_A)=p\ or \ q\\1 & otherwise\end{cases}</script></li><li><p>Bob发送$\varepsilon_B=S_B\oplus v_B$</p></li><li><p>同样地，Alice发送$\varepsilon_A=S_A\oplus v_A$</p></li><li><p>Alice将秘密$S_A$放在消息$m_A$中，采用公钥加密$E_{n_A}(m_A)=C$并发送给Bob</p><ul><li>提供$m_A$的一小段前缀来区分4个根</li><li>公钥加密算法采用依赖整数分解的算法即可</li></ul></li><li><p>Bob将秘密$S_B$放在消息$m_B$中，采用公钥加密$E_{n_B}(m_B)=C’$并发送给Bob</p></li></ul><h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p>定理：任何参与方都不能获得秘密的概率为$1/4$</p><p>证明：如果任何参与方在协议正常结束前终止交互，另一方也会停止，两方都无法获得对方的秘密。</p><p>不妨设Alice已经发给了Bob$E_{n_A}(m_A)$，Bob成功解密并对比得到$SA$，当Bob尝试使用$SA$进行文件解密时，根据假设，Alice能够得知$v_B=0$，因此Alice能够计算出$S_B=\varepsilon_B \oplus v_B$；Bob发送$E_{n_B}(m_B)$的情况同理；</p><p>因此任何参与方都不能获得秘密的概率为两方都不能计算出$p,q,p_1,q_1$的概率，即$(1/2)^2=1/4$</p><h2 id="Remark"><a href="#Remark" class="headerlink" title="Remark"></a>Remark</h2><ul><li><p>协议不能迭代执行，考虑当Alice已经知道$SB$，但是直到第二轮结束才查询文件，Bob可能不知道第二轮的$v_A=0$是否成立</p></li><li><p>可以通过修改OT子协议实现正确率</p><ul><li>收到$n_A$后，Bob随机选$x,y\leq n_A$，发送$x^2,y^2 \bmod n_A$，收到解$x_1,y_1$后不知道$p,q$的概率为$1/4$</li><li>协议总的失败率为$(1/4)^2=1/16$</li><li>但是这种方法存在一个上限，如果$Pr[v_B=0]\to0$，则Alice很可能认为Bob知道p，q，即$Pr[\varepsilon_B=S_B]\to 1$</li></ul></li></ul><h1 id="Future-work"><a href="#Future-work" class="headerlink" title="Future work"></a>Future work</h1><ul><li>OT子协议在没有假设的前提下也是有效的，是否能找到其他应用场景</li><li>对EOS协议的假设能否变弱、</li><li>能否构造永远能终止的EOS，或者有人能证明非零的不终止概率是必要的？</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Michael O. Rabin. How to exchange secrets with oblivious transfer. Technical Report TR-81, Aiken Computation Lab, Harvard University, 1981.&lt;/p&gt;</summary>
    
    
    
    <category term="MPC" scheme="https://alleysira.github.io/categories/MPC/"/>
    
    
    <category term="MPC" scheme="https://alleysira.github.io/tags/MPC/"/>
    
    <category term="OT" scheme="https://alleysira.github.io/tags/OT/"/>
    
  </entry>
  
  <entry>
    <title>SV21</title>
    <link href="https://alleysira.github.io/2023/04/13/SV21/"/>
    <id>https://alleysira.github.io/2023/04/13/SV21/</id>
    <published>2023-04-13T10:46:04.000Z</published>
    <updated>2023-07-23T10:47:19.180Z</updated>
    
    <content type="html"><![CDATA[<p>[SV21 ISIT]Private Data Access in Blockchain Systems Employing Coded Sharding</p><p>面向编码分片的区块链（PolyShard），数据采用RS码编码后保存，采用PIR保护余额查询</p><span id="more"></span><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>区块链的共识主要包含两方面：</p><ul><li>谁拥有出块的权利</li><li>谁对链的视图将被所有人认可</li></ul><p>在比特币中分别为PoW和最长链原则</p><p>区块链系统的三个性能指标：</p><ul><li>security threshold：区块链系统能容忍的恶意节点数量，取决于共识算法</li><li>吞吐量：每个时间单元的交易量，区块大小固定时，可以根据验证通过的区块数量衡量</li><li>存储效率：每个节点存储完整区块链数据的比例</li></ul><p>比特币和以太坊采用完整复制的思想，导致存储效率为最低值1</p><p>水平扩展（horizontal scaling）：随着网络规模线性地增加吞吐量、降低存储效率</p><p>编码分片（coded sharding）被认为是解决不可能三角的方案之一</p><p>区块链的分片是指将将网络划分为小的子网，每个子网掌握不相交的交易集合和不相交的账户</p><p>编码的分片中，区块链是一个编码的块形成的链，是对跨分片的块进行编码得到的</p><h1 id="Privacy-in-Blockchain"><a href="#Privacy-in-Blockchain" class="headerlink" title="Privacy in Blockchain"></a>Privacy in Blockchain</h1><p>假名（pseudonym）：公钥</p><p>钱包：与发送方和接收方相关联的一对假名</p><p>交易的隐私包含：</p><ul><li>被记录到区块里的过程</li><li>上链后从区块里读：如果客户端下载了完整的账本，敌手无法发现与客户端相关的账户<ul><li>但是随着区块链规模增加，会影响客户端的存储</li><li>采用SPV，只需要存储区块头，但是只能验证支付，无法验证</li></ul></li></ul><p>目前保护<em>余额查询</em> 这一过程隐私的方法：</p><ul><li>钱包假名机制是暂时的，即可以更换公钥</li><li>公钥无法追踪到用户身份</li></ul><p>It is not difficult to realize that transaction-privacy based on ephemeral nature of wallets is an illusion. （好有哲理）</p><p>因此有了中心化的混币机构（可能作恶，可能滥用财产，容易受到去匿名攻击）</p><p>如果采用PIR，可以实现余额查询的隐私保护</p><h2 id="Private-Information-Retrieval"><a href="#Private-Information-Retrieval" class="headerlink" title="Private Information Retrieval"></a>Private Information Retrieval</h2><p>$n$个服务器，每个服务器都有完整的$k$个比特的字符串$(x_1,x_2,\dots,x_k)$，获取$x_i$，但是任何服务器都不知道哪个比特被查询了</p><p>评价PIR的标准之一是rate，是指取回的符号/下载的符号，类似有效率</p><h2 id="Contribution"><a href="#Contribution" class="headerlink" title="Contribution"></a>Contribution</h2><ul><li>形式化了使用PIR在编码分片区块链上进行交易隐私保护</li><li>构造了从RS码存储的数据中进行查询的PIR</li><li>容忍最多$n-k$半诚实服务器合谋</li></ul><h1 id="Transaction-Privacy-with-Coded-Sharding"><a href="#Transaction-Privacy-with-Coded-Sharding" class="headerlink" title="Transaction Privacy with Coded Sharding"></a>Transaction Privacy with Coded Sharding</h1><h2 id="Private-Data-Access-System-model"><a href="#Private-Data-Access-System-model" class="headerlink" title="Private Data Access: System model"></a>Private Data Access: System model</h2><p>节点个数为$n$，分片个数为$k$，每个分片内账户总数为$m$</p><p>同步网络，网络可以是动态的，但是假设网络规模永远为$n$个节点</p><p>主要考虑$T$个epoch，$B_j(t)$表示第$j$个分片内的区块，$j\in[k],t\in[T]$，假设没有跨片交易，$X_j(t)$为$B_j(t)$包含的交易</p><p>$X_j(t)=(X_j^{send}(t),X_j^{receive}(t))$</p><p>$X_j^{send}(t),X_j^{receive}(t)$每个元素都属于$\mathbb{F}_q^m$，即$(1\times m)$向量，$q$的值取决于单个交易的最大单元</p><p>账户$p$向账户$q$发送b个单位密码货币，记为</p><script type="math/tex; mode=display">X_j^{send}(t,p)=-b,X_j^{receive}(t,q)=b</script><p>$X_j^{send}(t,p)$是$X_j^{send}$的第$p$个分量</p><p>只考虑线性码，第$i$个节点在epoch $t$存储$Y_i(t)$的是$\{X_j(t),j\in[k]\}$的线性组合</p><script type="math/tex; mode=display">Y_i(t)=\sum^k_{j=1}g_{ij}X_j(t),i\in[n]</script><p>$g_i=[g_{i1},\dots,g_{ik}]^T$是第$i$个节点的生成向量，$X_j(t)$为$1\times 2m$向量，考虑$T$个epoch后节点$i$的内容$Z_i(T)$</p><script type="math/tex; mode=display">Z_i =\left[\begin{matrix}Y_i(1)\\Y_i(2)\\\vdots\\Y_i(T)\end{matrix}\right]= \left[\begin{matrix}X_1(1) &\dots & X_k(1) \\X_1(2) &\dots  &X_k(2)  \\\vdots  &\ddots  &\vdots \\X_1(T) & \dots & X_k(T) \end{matrix}\right]\left[\begin{matrix}g_{i1}\mathbb{1}_{2m}  \\g_{i2}\mathbb{1}_{2m} \\\vdots  \\g_{ik}\mathbb{1}_{2m}  \end{matrix}\right]=U \cdot(g_i \otimes\mathbb{1}_{2m})\\</script><p>$\mathbb{1}_{2m}$是$2m\times1$维的全1向量，$U:(T\times 2km)$包含了$T$个epoch内所有分片，涉及总用户$km$的交易历史</p><p>考虑$j$个分片内的用户$p$，会想知道自己付的钱是否被打包，即$X_j(t),U(t,2(j-1)m)$</p><p>每一行为一个epoch，出块$k$个，第$j$个块的范围为$[2(j-1)m,2mj]$，则$p$对应的send位置为$2(j-1)m+p$;</p><p>同理，可以查询receive位置$2(j-1)m+p+m=2j+p-m$</p><p>如果服务器对send位置和receiver位置（即p）不知情（oblivious），能够防御恶意服务器将假名和用户的真实网络地址联系起来</p><p>统计账户可以记作$\sum_{t=1}^T U(t,2(j-1)m+p)+U(t,2j-m+p)$</p><p>服务器可以分为：</p><ul><li>curious-but-honest：想要猜出$p$，但是会正确响应</li><li>stragglers：拖延很久争取时间猜出$p$，之后正确响应</li><li>malicious：尝试猜出$p$，可能返回错误结果</li></ul><p>当用户$p$想要读取$X_j(t,p)=U(t,2(j-1)m+p)$时，生成$n$个随机的$1\times 2m$向量$\{q_i(j,p)\in\mathbb{F}_q^{2m}|i=1,2,\dots,n \}$，向第$i$个节点发送$(t,q_i(j,p))$</p><p>每个节点返回$\mathcal{A}(Y_i(t),q_i(j,p)):=a_i=q_i(j,p)^TY_i(t)$，扩张n倍</p><p>收到所有$a_i$后，计算$\hat{X}_j(t,p)=\sum^n_{i=1} a_i$</p><p>协议需要满足：</p><ul><li>正确性：$\hat{X}_j(t,p)=X_j(t,p)$对所有$j,p$均成立</li><li>隐私性：信息论安全 对在$\{1,\dots,2m\}$均匀随机的$P$和curious-but-honest的服务器集合$\mathcal{D}$，满足 $I(P:\cup_{i\in\mathcal{D}}q_i(j,p))=0$</li></ul><h2 id="Overiew-of-Reed-Solomon-Codes"><a href="#Overiew-of-Reed-Solomon-Codes" class="headerlink" title="Overiew of Reed-Solomon Codes"></a>Overiew of Reed-Solomon Codes</h2><p>假设采用广义RS码 (generalized Reed-Solomon code, GRS) 对区块进行编码</p><h3 id="复习信息论"><a href="#复习信息论" class="headerlink" title="复习信息论"></a>复习信息论</h3><p>$(n,k)$ 线性码：n是码长，k是线性空间维数</p><p><img src="/2023/04/13/SV21/image-20230415101504909.png" alt="image-20230415101504909" style="zoom:50%;"></p><p>生成矩阵：$G:k\times n$，每一行是生成向量</p><p>校验矩阵：$H: (n-k)\times n$，每一行是一个n元线性方程组的系数，$n-k$ 行确定了一个n维线性空间</p><p>若c为码字，有$Hc^T=0$</p><p><img src="/2023/04/13/SV21/image-20230415101709876.png" alt="image-20230415101709876" style="zoom:50%;"></p><p><img src="/2023/04/13/SV21/image-20230415102007666.png" alt="image-20230415102007666" style="zoom:50%;"></p><p>$C_{GRS}$是MDS码，最小距离$n-k+1$</p><p><img src="/2023/04/13/SV21/image-20230415103611131.png" alt="image-20230415103611131" style="zoom: 67%;"></p><p>$H_{(n-k)\times A},A\leq n-k$ 列满秩，说明$H$内 存在$A\times A$可逆矩阵</p><h2 id="Private-Data-Access-with-Curious-but-honest-Servers"><a href="#Private-Data-Access-with-Curious-but-honest-Servers" class="headerlink" title="Private Data Access with Curious-but-honest Servers"></a>Private Data Access with Curious-but-honest Servers</h2><p>如果敌手是malicious，可以通过固定查询检测出，所有回复$q^TY_1(t)\dots q^TY_n(t)$是一个码字，则$q^TY_1(t)\in \mathbb{F}_q$</p><p>因此从敌手的角度来说保持curious but honest是更加明智的选择</p><p>假设curious but honest服务器的数量 $d\leq n-k$</p><h3 id="PIR-protocol"><a href="#PIR-protocol" class="headerlink" title="PIR protocol"></a>PIR protocol</h3><p>构造查询向量的思想：混合</p><ul><li>$\mathcal{C}_{GRS}$的奇偶校验向量（思想来自于[TIT18]）</li><li>半随机向量(q)</li><li>生成矩阵的逆矩阵的行向量</li></ul><p>最终用户$p$构造的查询向量为$\{q_i(j,p)\in \mathbb{F}^{2m}_q|i=1,\dots,n\}$</p><p>分别向每个服务器$i$发送查询$q_i(j,p),t$</p><p>收到回复$\mathcal{A}(Y_i(t),q_i(j,p))=a_i=q_i(j,p)^TY_i(t)$后，客户端计算$X_j(t,p)=\sum^n_{i=1} a_i$</p><p>以下给出查询向量$q_i(j,p)$的构造方式：</p><p>分别记GRS码的校验矩阵和生成矩阵为：</p><script type="math/tex; mode=display">H_{GRS}=\left [\begin{matrix}h_1^T\\h_2^T\\\vdots \\h^T_{n-k}\end{matrix}\right ]_{(n-k) \times n} G_{GRS}=\left [\begin{matrix}G_1 \  G_2\end{matrix}\right ]_{k \times n}</script><p>其中$G_1:k\times k,G_2:k\times(n-k)$，$G_1$是$G_{GRS}$可逆的子矩阵，$h^T_l=[h_{l1},h_{l2},\dots,h_{ln}],1\leq l\leq(n-k)$</p><p>$G_1^{-1}=[\tilde\phi_1,\dots,\tilde\phi_k],\tilde\phi_i:k\times 1,\phi_j^T=[\tilde\phi_j \ 0]_{1\times n}$，即$\tilde\phi_j$后面补$n-k$ 个$0$</p><p>假设curious but honest服务器的数量为$d$</p><p>均匀随机选择$d$个向量$r_1,\dots,r_d \in \mathbb{F}^{2m}_q$，计算$r_{d+1}=(\sum^d_{i=1} r_i)+e_p$，其中$e_p=[0\ 0\ \dots\ 1_p\ \dots\ 0]_{2m \times 1}$</p><script type="math/tex; mode=display">R_p=[r_1 \  r_2\  \dots \ r_{d+1}]_{2m \times (d+1)}\\\Psi_j=\left [\begin{matrix}h_1^T + \phi_j^T\\h_2^T+\phi_j^T \\\vdots\\h_d^T+\phi_j^T\\\phi_j^T\end{matrix}\right ]_{(1+d)\times n}\\Q=R_p\Psi _j:2m\times n</script><p>此时矩阵$Q$的每一列分别为$q_i(j,p)$，令$\varphi_{i}=\phi^T_{ji},i\in[n]$</p><script type="math/tex; mode=display">q_1(j,p)=\left[\begin{matrix}\sum^{d}_{k=1} r_{k,1}(h_{k,1}+\varphi_1 )+r_{d+1,1}\varphi_{1}\\\sum^{d}_{k=1} r_{k,2}(h_{k,1}+\varphi_1 )+r_{d+1,2}\varphi_{1}\\\vdots \\\sum^{d}_{k=1} r_{k,2m}(h_{k,1}+\varphi_1 )+r_{d+1,2m}\varphi_{1}\end{matrix}\right ]\\q_i(j,p)=\left[\begin{matrix}\sum^{d}_{k=1} r_{k,1}(h_{k,i}+\varphi_i )+r_{d+1,1}\varphi_{i}\\\sum^{d}_{k=1} r_{k,2}(h_{k,i}+\varphi_i )+r_{d+1,2}\varphi_{i}\\\vdots \\\sum^{d}_{k=1} r_{k,2m}(h_{k,i}+\varphi_i )+r_{d+1,2m}\varphi_{i}\end{matrix}\right ],i\in[n]</script><p>接下来证明这种构造满足正确性和隐私性</p><h3 id="Privacy"><a href="#Privacy" class="headerlink" title="Privacy"></a>Privacy</h3><p>设作恶的服务器为$d\leq n-k,\mathcal{D}={i_1,\dots,i_d}$，则发送给所有作恶节点的查询向量组成$2m\times d$的矩阵$Q_D$</p><p>对$R=[r_1 \ r_2 \cdots \ r_d ]_{2m\times d},E_p=[e_p \ \cdots \  e_p]_{2m\times d},rank-one,\Phi=[h_1 \ h_2 \ \cdots \ h_d]_{d\times d}$</p><script type="math/tex; mode=display">\Delta_D=\left[\begin{matrix}\hat\phi_{j1} \\& \hat\phi_{j2} \\& & \ddots\\& & & \hat\phi_{jd}\end{matrix}\right ]_{d\times d}</script><p>有$Q_D=R_p \cdot\Psi_{j,D}=R\Phi+ E_p\Delta _D$</p><h3 id="Correctness"><a href="#Correctness" class="headerlink" title="Correctness"></a>Correctness</h3><p>根据$a_i=q_i(j,p)^TY_i(t),Y_i(t)=\sum^k_{j=1}g_{ij}X_j(t),i\in[n]$</p><script type="math/tex; mode=display">\begin{align}X_j(t,p) &=\sum^n_{i=1} a_i \\& = \sum_{i=1}^n q_i(j,p)^TY_i(t) \\& = (\sum_{l=1}^dr_l^T\sum^n_{i=1}(h_{l_i}+\phi_{ji})Y_i(t))+r_{d+1}\sum^n_{i=1}\phi_{ji}Y_i(t)\end{align}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;[SV21 ISIT]Private Data Access in Blockchain Systems Employing Coded Sharding&lt;/p&gt;
&lt;p&gt;面向编码分片的区块链（PolyShard），数据采用RS码编码后保存，采用PIR保护余额查询&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/categories/Blockchain/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="PIR" scheme="https://alleysira.github.io/tags/PIR/"/>
    
  </entry>
  
  <entry>
    <title>SecretFlow隐语PSI实验环境配置与测试</title>
    <link href="https://alleysira.github.io/2023/04/08/SecretFlow%E9%9A%90%E8%AF%ADPSI%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%B5%8B%E8%AF%95/"/>
    <id>https://alleysira.github.io/2023/04/08/SecretFlow%E9%9A%90%E8%AF%ADPSI%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%B5%8B%E8%AF%95/</id>
    <published>2023-04-08T14:03:51.000Z</published>
    <updated>2023-07-23T10:47:04.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SecretFlow隐语PSI实验环境配置与测试"><a href="#SecretFlow隐语PSI实验环境配置与测试" class="headerlink" title="SecretFlow隐语PSI实验环境配置与测试"></a>SecretFlow隐语PSI实验环境配置与测试</h1><p>配置SecretFlow 并测试两方PSI的效率</p><p>官方文档 <a href="https://www.secretflow.org.cn/docs/secretflow/zh_CN/developer/benchmark/psi_benchmark.html#">隐语PSI Benchmark白皮书 — SecretFlow 文档</a></p><span id="more"></span><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><p>配置conda</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install wget</span><br><span class="line">wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh</span><br><span class="line">bash Miniconda3-latest-Linux-x86_64.sh</span><br><span class="line"><span class="comment"># choose miniconda3 location</span></span><br><span class="line">~/.miniconda3</span><br><span class="line">Do you wish the installer to initialize Miniconda3 by running conda init? [yes|no]</span><br><span class="line">[no] &gt;&gt;&gt; yes</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"></span><br><span class="line">conda --version</span><br></pre></td></tr></table></figure><p>新建conda环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conda create -n sf-benchmark python=3.8</span><br><span class="line">conda activate sf-benchmark</span><br><span class="line">pip install -U secretflow</span><br><span class="line">mkdir sf-benchmark</span><br><span class="line">cd sf-benchmark</span><br></pre></td></tr></table></figure><p>生成.csv集合数据脚本，调用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 gene_psi.py 1000000</span><br></pre></td></tr></table></figure><p>脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python3 gene_psi.py</span></span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> sample</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_with_N_digits</span>(<span class="params">n</span>):</span></span><br><span class="line">    range_start = <span class="number">10</span> ** (n - <span class="number">1</span>)</span><br><span class="line">    range_end = (<span class="number">10</span>**n) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> randint(range_start, range_end)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">row_list = []</span><br><span class="line">len1 = <span class="number">10</span>**<span class="number">2</span></span><br><span class="line">len2 = <span class="number">10</span></span><br><span class="line">len3 = <span class="number">10</span></span><br><span class="line">len4 = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &gt; <span class="number">1</span>:</span><br><span class="line">    len1 = <span class="built_in">int</span>(sys.argv[<span class="number">1</span>])</span><br><span class="line">    len2 = <span class="built_in">int</span>(len1 / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &gt; <span class="number">2</span>:</span><br><span class="line">    len3 = <span class="built_in">int</span>(sys.argv[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">len4 = <span class="built_in">int</span>(len3 / <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(len1, len2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(len1):</span><br><span class="line">    data_list = [random_with_N_digits(<span class="number">38</span>)] <span class="comment"># should use 10^38 equals 2^128</span></span><br><span class="line">    row_list.append(data_list)</span><br><span class="line"></span><br><span class="line">row_list2 = sample(row_list, len2)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(len2, len1):</span><br><span class="line">    data_list = [random_with_N_digits(<span class="number">38</span>)]</span><br><span class="line">    row_list2.append(data_list)</span><br><span class="line"></span><br><span class="line">row_list3 = sample(row_list, len4)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(len4, len3):</span><br><span class="line">    data_list = [random_with_N_digits(<span class="number">38</span>)]</span><br><span class="line">    row_list3.append(data_list)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(row_list2))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(row_list3))</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;psi_1.csv&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    writer = csv.writer(file)</span><br><span class="line">    writer.writerow([<span class="string">&quot;id&quot;</span>])</span><br><span class="line">    writer.writerows(row_list)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;psi_2.csv&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    writer = csv.writer(file)</span><br><span class="line">    writer.writerow([<span class="string">&quot;id&quot;</span>])</span><br><span class="line">    writer.writerows(row_list2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;psi_3.csv&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    writer = csv.writer(file)</span><br><span class="line">    writer.writerow([<span class="string">&quot;id&quot;</span>])</span><br><span class="line">    writer.writerows(row_list3)</span><br></pre></td></tr></table></figure><h2 id="测试安装是否成功"><a href="#测试安装是否成功" class="headerlink" title="测试安装是否成功"></a>测试安装是否成功</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python3 foot.py</span></span><br><span class="line"><span class="keyword">import</span> secretflow <span class="keyword">as</span> sf</span><br><span class="line">sf.init([<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;carol&#x27;</span>], address=<span class="string">&#x27;local&#x27;</span>)</span><br><span class="line">dev = sf.PYU(<span class="string">&#x27;alice&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"></span><br><span class="line">data, target = load_iris(return_X_y=<span class="literal">True</span>, as_frame=<span class="literal">True</span>)</span><br><span class="line">data[<span class="string">&#x27;uid&#x27;</span>] = np.arange(<span class="built_in">len</span>(data)).astype(<span class="string">&#x27;str&#x27;</span>)</span><br><span class="line">data[<span class="string">&#x27;month&#x27;</span>] = [<span class="string">&#x27;Jan&#x27;</span>] * (<span class="number">2</span>^<span class="number">20</span>) + [<span class="string">&#x27;Feb&#x27;</span>] * (<span class="number">2</span>^<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># generate data, notice the content ./data</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.makedirs(<span class="string">&#x27;./data&#x27;</span>, exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">da, db, dc = data.sample(frac=<span class="number">0.9</span>), data.sample(frac=<span class="number">0.8</span>), data.sample(frac=<span class="number">0.7</span>)</span><br><span class="line"></span><br><span class="line">da.to_csv(<span class="string">&#x27;data/alice.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br><span class="line">db.to_csv(<span class="string">&#x27;data/bob.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br><span class="line">dc.to_csv(<span class="string">&#x27;data/carol.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">alice, bob = sf.PYU(<span class="string">&#x27;alice&#x27;</span>), sf.PYU(<span class="string">&#x27;bob&#x27;</span>)</span><br><span class="line">spu = sf.SPU(sf.utils.testing.cluster_def([<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;bob&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">input_path = &#123;alice: <span class="string">&#x27;data/alice.csv&#x27;</span>, bob: <span class="string">&#x27;data/bob.csv&#x27;</span>&#125;</span><br><span class="line">output_path = &#123;alice: <span class="string">&#x27;data/alice_psi.csv&#x27;</span>, bob: <span class="string">&#x27;data/bob_psi.csv&#x27;</span>&#125;</span><br><span class="line">spu.psi_csv(<span class="string">&#x27;uid&#x27;</span>, input_path, output_path, <span class="string">&#x27;alice&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = da.join(db.set_index(<span class="string">&#x27;uid&#x27;</span>), on=<span class="string">&#x27;uid&#x27;</span>, how=<span class="string">&#x27;inner&#x27;</span>, rsuffix=<span class="string">&#x27;_bob&#x27;</span>, sort=<span class="literal">True</span>)</span><br><span class="line">expected = df[da.columns].astype(&#123;<span class="string">&#x27;uid&#x27;</span>: <span class="string">&#x27;int64&#x27;</span>&#125;).reset_index(drop=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">da_psi = pd.read_csv(<span class="string">&#x27;data/alice_psi.csv&#x27;</span>)</span><br><span class="line">db_psi = pd.read_csv(<span class="string">&#x27;data/bob_psi.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pd.testing.assert_frame_equal(da_psi, expected)</span><br><span class="line">pd.testing.assert_frame_equal(db_psi, expected)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(da_psi)</span><br></pre></td></tr></table></figure><h2 id="实际实验测试脚本"><a href="#实际实验测试脚本" class="headerlink" title="实际实验测试脚本"></a>实际实验测试脚本</h2><p>启动节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RAY_DISABLE_REMOTE_CODE=<span class="literal">true</span> </span><br><span class="line">ray start --head --node-ip-address=<span class="string">&quot;192.168.31.128&quot;</span> --port=<span class="string">&quot;9394&quot;</span> --resources=<span class="string">&#x27;&#123;&quot;alice&quot;: 2&#125;&#x27;</span> --include-dashboard=False   </span><br><span class="line">ray start --address=<span class="string">&quot;192.168.31.128:9394&quot;</span> --resources=<span class="string">&#x27;&#123;&quot;bob&quot;: 2&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>通过更换reports的protocol参数进行3个两方PSI协议的测试，脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python3 benchmark.py</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> absl <span class="keyword">import</span> app</span><br><span class="line"><span class="keyword">import</span> spu</span><br><span class="line"><span class="keyword">import</span> secretflow <span class="keyword">as</span> sf</span><br><span class="line"></span><br><span class="line"><span class="comment"># init log</span></span><br><span class="line">logging.basicConfig(stream=sys.stdout, level=logging.INFO)</span><br><span class="line"></span><br><span class="line"><span class="comment"># SPU settings</span></span><br><span class="line">cluster_def = &#123;</span><br><span class="line">    <span class="string">&#x27;nodes&#x27;</span>: [</span><br><span class="line">        <span class="comment"># listen_address and address should have the same port</span></span><br><span class="line">        <span class="comment"># &lt;&lt;&lt; !!! &gt;&gt;&gt; replace &lt;192.168.0.1:12945&gt; to alice node&#x27;s local ip &amp; free port</span></span><br><span class="line">        <span class="comment"># 192.168.31.128 is my own ip address </span></span><br><span class="line">        &#123;<span class="string">&#x27;party&#x27;</span>: <span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;local:0&#x27;</span>, <span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;192.168.31.128:12345&#x27;</span>, <span class="string">&#x27;listen_address&#x27;</span>: <span class="string">&#x27;0.0.0.0:12345&#x27;</span>&#125;,</span><br><span class="line">        <span class="comment"># &lt;&lt;&lt; !!! &gt;&gt;&gt; replace &lt;192.168.0.2:12946&gt; to bob node&#x27;s local ip &amp; free port</span></span><br><span class="line">        &#123;<span class="string">&#x27;party&#x27;</span>: <span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;local:1&#x27;</span>, <span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;192.168.31.128:12333&#x27;</span>, <span class="string">&#x27;listen_address&#x27;</span>: <span class="string">&#x27;0.0.0.0:12333&#x27;</span>&#125;,</span><br><span class="line">        <span class="comment"># &lt;&lt;&lt; !!! &gt;&gt;&gt; if you need 3pc test, please add node here, for example, add carol as rank 2</span></span><br><span class="line">        <span class="comment"># &#123;&#x27;party&#x27;: &#x27;carol&#x27;, &#x27;id&#x27;: &#x27;local:2&#x27;, &#x27;address&#x27;: &#x27;127.0.0.1:12347&#x27;&#125;,</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&#x27;runtime_config&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;protocol&#x27;</span>: spu.spu_pb2.SEMI2K,</span><br><span class="line">        <span class="string">&#x27;field&#x27;</span>: spu.spu_pb2.FM128,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">_</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># sf init</span></span><br><span class="line">    <span class="comment"># &lt;&lt;&lt; !!! &gt;&gt;&gt; replace &lt;192.168.0.1:9394&gt; to your ray head</span></span><br><span class="line">    <span class="comment"># two parties secretflow&gt;=0.7.18b3 need to add &lt;sf.init(parties=[&#x27;alice&#x27;, &#x27;bob&#x27;]&gt;</span></span><br><span class="line">    sf.init(parties=[<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;bob&#x27;</span>], address=<span class="string">&#x27;192.168.31.128:9394&#x27;</span>,log_to_driver=<span class="literal">True</span>)</span><br><span class="line">    alice = sf.PYU(<span class="string">&#x27;alice&#x27;</span>)</span><br><span class="line">    bob = sf.PYU(<span class="string">&#x27;bob&#x27;</span>)</span><br><span class="line">    <span class="comment"># carol = sf.PYU(&#x27;carol&#x27;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># &lt;&lt;&lt; !!! &gt;&gt;&gt; replace path to real parties local file path.</span></span><br><span class="line">    input_path = &#123;</span><br><span class="line">        alice: <span class="string">&#x27;./psi_1.csv&#x27;</span>,</span><br><span class="line">        bob: <span class="string">&#x27;./psi_2.csv&#x27;</span>,</span><br><span class="line">        <span class="comment"># if run with `ECDH_PSI_3PC`, add carol</span></span><br><span class="line">        <span class="comment"># carol: &#x27;/data/psi_3.csv&#x27;,</span></span><br><span class="line">    &#125;</span><br><span class="line">    output_path = &#123;</span><br><span class="line">        alice: <span class="string">&#x27;./psi_output.csv&#x27;</span>,</span><br><span class="line">        bob: <span class="string">&#x27;./psi_output.csv&#x27;</span>,</span><br><span class="line">        <span class="comment"># if run with `ECDH_PSI_3PC`, add carol</span></span><br><span class="line">        <span class="comment"># carol: &#x27;/data/psi_output.csv&#x27;,</span></span><br><span class="line">    &#125;</span><br><span class="line">    select_keys = &#123;</span><br><span class="line">        alice: [<span class="string">&#x27;id&#x27;</span>],</span><br><span class="line">        bob: [<span class="string">&#x27;id&#x27;</span>],</span><br><span class="line">        <span class="comment"># if run with `ECDH_PSI_3PC`, add carol</span></span><br><span class="line">        <span class="comment"># carol: [&#x27;id&#x27;],</span></span><br><span class="line">    &#125;</span><br><span class="line">    spu = sf.SPU(cluster_def)</span><br><span class="line">    <span class="comment"># spu = sf.SPU(sf.utils.testing.cluster_def([&#x27;alice&#x27;, &#x27;bob&#x27;]))</span></span><br><span class="line">    <span class="comment"># prepare data</span></span><br><span class="line">    start = time.time()</span><br><span class="line"></span><br><span class="line">    reports = spu.psi_csv(</span><br><span class="line">        key=select_keys,</span><br><span class="line">        input_path=input_path,</span><br><span class="line">        output_path=output_path,</span><br><span class="line">        receiver=<span class="string">&#x27;alice&#x27;</span>,  <span class="comment"># if `broadcast_result=False`, only receiver can get output file.</span></span><br><span class="line">        <span class="comment"># all the possible protocols: ECDH_PSI_2PC KKRT_PSI_2PC BC22_PSI_2PC ECDH_PSI_3PC</span></span><br><span class="line">        protocol=<span class="string">&#x27;ECDH_PSI_2PC&#x27;</span>,<span class="comment"># psi protocol</span></span><br><span class="line">        precheck_input=<span class="literal">False</span>,  <span class="comment"># will cost ext time if set True</span></span><br><span class="line">        sort=<span class="literal">False</span>,  <span class="comment"># will cost ext time if set True</span></span><br><span class="line">        broadcast_result=<span class="literal">False</span>,  <span class="comment"># will cost ext time if set True</span></span><br><span class="line">    )</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;psi reports: <span class="subst">&#123;reports&#125;</span>&quot;</span>)</span><br><span class="line">    logging.info(<span class="string">f&quot;cost time: <span class="subst">&#123;time.time() - start&#125;</span>&quot;</span>) <span class="comment"># units： second</span></span><br><span class="line"></span><br><span class="line">    sf.shutdown()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(main)</span><br></pre></td></tr></table></figure><h2 id="SKY-PSI测试"><a href="#SKY-PSI测试" class="headerlink" title="SKY-PSI测试"></a>SKY-PSI测试</h2><p>./bin/PSI_test -r 0 -ss 20 -rs 20 -w 621 -h 20 -hash 10  &amp; ./bin/PSI_test -r 1 -ss 20 -rs 20 -w 621 -h 20 -hash 10</p><p>./bin/PSI_test -r 0 -ss 22 -rs 22 -w 627 -h 22 -hash 10  &amp; ./bin/PSI_test -r 1 -ss 22 -rs 22 -w 627 -h 22 -hash 10</p><p>./bin/PSI_test -r 0 -ss 23 -rs 23 -w 630 -h 23 -hash 10  &amp; ./bin/PSI_test -r 1 -ss 23 -rs 23 -w 630 -h 23 -hash 10</p><p>./bin/PSI_test -r 0 -ss 24 -rs 24 -w 633 -h 24 -hash 11  &amp; ./bin/PSI_test -r 1 -ss 24 -rs 24 -w 633 -h 24 -hash 11</p><p>./bin/PSI_test -r 0 -ss 25 -rs 25 -w 636 -h 25 -hash 11  &amp; ./bin/PSI_test -r 1 -ss 25 -rs 25 -w 636 -h 25 -hash 11</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">alleysira@ubuntu:~/SKY-PSI$ cmake .</span><br><span class="line">alleysira@ubuntu:~/SKY-PSI$ make</span><br><span class="line">alleysira@ubuntu:~/SKY-PSI$ ./bin/PSI_test -r 0 -ss 20 -rs 20 -w 621 -h 20 -<span class="built_in">hash</span> 10 -ip 127.0.0.1  -ck 0 -gm 0 &amp; ./bin/PSI_test -r 1 -ss 20 -rs 20 -w 621 -h 20 -<span class="built_in">hash</span> 10 -ip 127.0.0.1 -ck 0 -gm 0</span><br><span class="line">alleysira@ubuntu:~/SKY-PSI$ ./bin/PSI_test -r 0 -ss 20 -rs 20 -w 621 -h 20 -<span class="built_in">hash</span> 10 -ip 127.0.0.1  -ck 0 -gm 0 &amp; ./bin/PSI_test -r 1 -ss 20 -rs 20 -w 621 -h 20 -<span class="built_in">hash</span> 10 -ip 127.0.0.1 -ck 0 -gm 0</span><br><span class="line">[1] 4988</span><br><span class="line">Receiver matrix sent and transposed <span class="built_in">hash</span> input computed</span><br><span class="line">Label                                     Time (ms)  diff (ms)</span><br><span class="line">__________________________________</span><br><span class="line">Sender base OT finished                       155.1    155.071  ******</span><br><span class="line">Sender <span class="built_in">set</span> transformed                        645.4    490.352  *******</span><br><span class="line">Sender transposed <span class="built_in">hash</span> input computed        6863.1   6217.686  **********</span><br><span class="line">Sender <span class="built_in">hash</span> outputs computed and sent        8659.7   1796.587  *********</span><br><span class="line">Receiver intersection computed,Intersection size:500000</span><br><span class="line">Label                                                       Time (ms)  diff (ms)</span><br><span class="line">__________________________________</span><br><span class="line">Receiver base OT finished                                       135.9    135.929  ******</span><br><span class="line">Receiver initialized                                            216.6     80.709  *****</span><br><span class="line">Receiver <span class="built_in">set</span> transformed                                        620.4    403.792  *******</span><br><span class="line">Receiver matrix sent and transposed <span class="built_in">hash</span> input computed        6829.3   6208.850  **********</span><br><span class="line">Receiver intersection computed                                 9250.8   2421.508  *********</span><br><span class="line">Receiver sent communication: 77.631 MB</span><br><span class="line">Receiver received communication: 4.813 MB</span><br><span class="line">Receiver total communication: 82.445 MB</span><br><span class="line">[1]+  Done                    ./bin/PSI_test -r 0 -ss 20 -rs 20 -w 621 -h 20 -<span class="built_in">hash</span> 10 -ip 127.0.0.1 -ck 0 -gm 0</span><br></pre></td></tr></table></figure><p>cm20 支持到$2^{22},2^{23} $</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">alleysira@ubuntu:~/OPRF-PSI-backup$ ./bin/PSI_test -r 0 -ss 22 -rs 22 -w 627 -h 22 -hash 11  &amp; ./bin/PSI_test -r 1 -ss 22 -rs 22 -w 627 -h 22 -hash 11 -ip 127.0.0.1</span><br><span class="line">[2] 5249</span><br><span class="line">Receiver matrix sent and transposed hash input computed</span><br><span class="line">Label                                     Time (ms)  diff (ms)</span><br><span class="line">__________________________________</span><br><span class="line">Sender base OT finished                       688.9    688.936  ******</span><br><span class="line">Sender set transformed                       2053.2   1364.259  *******</span><br><span class="line">Sender transposed hash input computed       28745.7  26692.532  **********</span><br><span class="line">Sender hash outputs computed and sent       38459.4   9713.711  *********</span><br><span class="line">Begin</span><br><span class="line">Receiver intersection computed,Intersection size:532 Proportion of intersection:0.382% correct!</span><br><span class="line">Label                                                       Time (ms)  diff (ms)</span><br><span class="line">__________________________________</span><br><span class="line">Receiver base OT finished                                       690.1    690.110  ******</span><br><span class="line">Receiver initialized                                            874.8    184.698  *****</span><br><span class="line">Receiver set transformed                                       2005.0   1130.157  *******</span><br><span class="line">Receiver matrix sent and transposed hash input computed       28747.9  26742.969  **********</span><br><span class="line">Receiver intersection computed                                41609.8  12861.827  *********</span><br><span class="line">Receiver sent communication: 313.506 MB</span><br><span class="line">Receiver received communication: 10.016 MB</span><br><span class="line">Receiver total communication: 323.522 MB</span><br><span class="line"></span><br><span class="line">alleysira@ubuntu:~/OPRF-PSI-backup$ ./bin/PSI_test -r 0 -ss 23 -rs 23 -w 627 -h 23 -hash 11  &amp; ./bin/PSI_test -r 1 -ss 23 -rs 23 -w 627 -h 23 -hash 11 -ip 127.0.0.1</span><br><span class="line">[1] 5273</span><br><span class="line">Receiver matrix sent and transposed hash input computed</span><br><span class="line">Label                                     Time (ms)  diff (ms)</span><br><span class="line">__________________________________</span><br><span class="line">Sender base OT finished                       150.6    150.579  *****</span><br><span class="line">Sender set transformed                       2884.4   2733.777  *******</span><br><span class="line">Sender transposed hash input computed       67371.3  64486.946  **********</span><br><span class="line">Sender hash outputs computed and sent       90574.5  23203.154  *********</span><br><span class="line">Begin</span><br><span class="line">Receiver intersection computed,Intersection size:536 Proportion of intersection:0.191% correct!</span><br><span class="line">Label                                                       Time (ms)  diff (ms)</span><br><span class="line">__________________________________</span><br><span class="line">Receiver base OT finished                                       148.4    148.435  *****</span><br><span class="line">Receiver initialized                                            517.2    368.812  *****</span><br><span class="line">Receiver set transformed                                       2835.7   2318.477  *******</span><br><span class="line">Receiver matrix sent and transposed hash input computed       67371.8  64536.073  **********</span><br><span class="line">Receiver intersection computed                                97432.1  30060.339  *********</span><br><span class="line">Receiver sent communication: 627.006 MB</span><br><span class="line">Receiver received communication: 20.016 MB</span><br><span class="line">Receiver total communication: 647.022 MB</span><br></pre></td></tr></table></figure><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>4Core/12GB </p><p>hard drive: 30GB，实验过程中硬盘空间不足，可能影响效率</p><p>cm20的元素大小为$2^{128}$，隐语默认为$10^{18}$（已修改为$10^{38}$）</p><p>cm20设置了交集个数为100（已修正为50 0000），隐语交集个数设置为集合大小一半</p><p>分别限制网络带宽为30Mbps 20ms、100Mbps 20ms和LAN进行测试，对secretflow的测试需要限制环回地址lo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ifconfig </span><br><span class="line"></span><br><span class="line"><span class="comment">#100Mbps 20ms</span></span><br><span class="line">sudo tc qdisc add dev lo root handle 1: tbf rate 100mbit burst 256kb latency 800ms                                   </span><br><span class="line">sudo tc qdisc add dev lo parent 1:1 handle 10: netem delay 20msec <span class="built_in">limit</span> 8000 </span><br><span class="line"></span><br><span class="line"><span class="comment">#清除限制</span></span><br><span class="line">sudo tc qdisc del dev lo root</span><br><span class="line"><span class="comment">#查看已有配置</span></span><br><span class="line">sudo tc qdisc show dev lo</span><br></pre></td></tr></table></figure><h3 id="30Mbps-20ms结果"><a href="#30Mbps-20ms结果" class="headerlink" title="30Mbps 20ms结果"></a>30Mbps 20ms结果</h3><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><div class="table-container"><table><thead><tr><th>数量级</th><th>KKRT/s</th><th>ECDH/s</th><th>BC22/s</th><th>SKY-PSI/s</th></tr></thead><tbody><tr><td>百万 1000000 $2^{20}$</td><td>40.00+40.81=40.405</td><td>159.15+161.22=160.185</td><td>58.23+60.14=59.18</td><td>26.47+26.76+26.81=26.68</td></tr><tr><td>千万 10000000</td><td>369.75</td><td>1558.04</td><td>537.13</td></tr></tbody></table></div><h3 id="100Mbps-20ms结果"><a href="#100Mbps-20ms结果" class="headerlink" title="100Mbps 20ms结果"></a>100Mbps 20ms结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(base) jie@jie-virtual-machine:~$ sudo  tc qdisc add dev lo root handle 1: tbf rate 100mbit burst 256kb latency 800ms </span><br><span class="line">(base) jie@jie-virtual-machine:~$ sudo tc qdisc add dev lo parent 1:1 handle 10: netem delay 20msec limit 8000 </span><br><span class="line">(base) jie@jie-virtual-machine:~$ sudo tc qdisc show dev lo</span><br><span class="line">qdisc tbf 1: root refcnt 2 rate 100Mbit burst 256Kb lat 800ms </span><br><span class="line">qdisc netem 10: parent 1:1 limit 8000 delay 20ms</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>数量级</th><th>KKRT/s</th><th>ECDH/s</th><th>BC22/s</th><th>SKY-PSI/s</th></tr></thead><tbody><tr><td>百万 1000000 $2^{20}$</td><td>18.80+18.29=18.545</td><td>151.927</td><td>16.86+16.176=16.518</td><td>10.52+10.51+ 10.57=10.53</td></tr><tr><td>千万 10000000</td><td>138.21+139.47=138.84</td><td>1544.09</td><td>106.89+111.60=109.245</td></tr></tbody></table></div><h3 id="LAN实验结果"><a href="#LAN实验结果" class="headerlink" title="LAN实验结果"></a>LAN实验结果</h3><div class="table-container"><table><thead><tr><th>数量级</th><th>KKRT/s</th><th>ECDH/s</th><th>BC22/s</th><th>SKY-PSI/s</th></tr></thead><tbody><tr><td>百万 1000000 $2^{20}$</td><td>12.85+10.65+12.63+10.19+13.11+9.57+9.82+9.68+9.93=9.84</td><td>137.29+142.37+141.59+147.97+143.38=142.52</td><td>10.33+10.318=10.324</td><td>9.2508+9.002+10.941+9.0912+9.036+9.663+10.935+10.154=9.75</td></tr><tr><td>千万 10000000</td><td>76.24+72.58+74.83+70.75+70.83=73.046</td><td>1374.78</td><td>79.94+78.78+81.13+78.40+78.62=79.374</td></tr></tbody></table></div><p>蚂蚁给出的结果</p><p><img src="/2023/04/08/SecretFlow%E9%9A%90%E8%AF%ADPSI%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%B5%8B%E8%AF%95/7629c228-bc51-4ef7-93e9-9f0c465d025d.png" alt="img"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;SecretFlow隐语PSI实验环境配置与测试&quot;&gt;&lt;a href=&quot;#SecretFlow隐语PSI实验环境配置与测试&quot; class=&quot;headerlink&quot; title=&quot;SecretFlow隐语PSI实验环境配置与测试&quot;&gt;&lt;/a&gt;SecretFlow隐语PSI实验环境配置与测试&lt;/h1&gt;&lt;p&gt;配置SecretFlow 并测试两方PSI的效率&lt;/p&gt;
&lt;p&gt;官方文档 &lt;a href=&quot;https://www.secretflow.org.cn/docs/secretflow/zh_CN/developer/benchmark/psi_benchmark.html#&quot;&gt;隐语PSI Benchmark白皮书 — SecretFlow 文档&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="MPC" scheme="https://alleysira.github.io/categories/MPC/"/>
    
    
    <category term="Crypto" scheme="https://alleysira.github.io/tags/Crypto/"/>
    
    <category term="MPC" scheme="https://alleysira.github.io/tags/MPC/"/>
    
    <category term="PSI" scheme="https://alleysira.github.io/tags/PSI/"/>
    
  </entry>
  
</feed>
