<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Alleysira&#39;s blog</title>
  
  
  <link href="https://alleysira.github.io/atom.xml" rel="self"/>
  
  <link href="https://alleysira.github.io/"/>
  <updated>2023-07-23T10:40:50.028Z</updated>
  <id>https://alleysira.github.io/</id>
  
  <author>
    <name>Alleysira</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ConFuzzius</title>
    <link href="https://alleysira.github.io/2023/07/23/ConFuzzius/"/>
    <id>https://alleysira.github.io/2023/07/23/ConFuzzius/</id>
    <published>2023-07-23T03:09:40.000Z</published>
    <updated>2023-07-23T10:40:50.028Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ConFuzzius-A-Data-Dependency-Aware-Hybrid-Fuzzer-for-Smart-Contracts"><a href="#ConFuzzius-A-Data-Dependency-Aware-Hybrid-Fuzzer-for-Smart-Contracts" class="headerlink" title="ConFuzzius: A Data Dependency-Aware Hybrid Fuzzer for Smart Contracts"></a>ConFuzzius: A Data Dependency-Aware Hybrid Fuzzer for Smart Contracts</h1><p>这篇工作发表于<code>EuroS&amp;P21</code></p><ul><li><p>符号执行的方法存在过拟合，导致假阳率</p></li><li><p>现有的模糊测试方法分析浅层的漏洞比较有效，对于执行时的深层的漏洞分析不够有效，导致较低的代码覆盖率/假阳</p></li><li>传统程序测试中已经证明结合符号执行和模糊测试的可行性</li></ul><p>ConFuzzius是第一个针对智能合约的混合模糊测试器，采用进化的模糊测试方法执行合约的浅层部分，约束求解来生成符合复杂条件的输入，防止进化模糊测试方法探索深层部分。</p><p>ConFuzzius充分利用动态的数据依赖分析来生成更可能导致出现漏洞的交易序列</p><p>实验数据采用精选的128个合约和包含21000真实世界的合约，结果显示比当前最好的工具多检测出了23%的漏洞，代码覆盖率达到了69%，动态数据依赖分析可以加速漏洞检测18%</p><span id="more"></span><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>如果允许一个参与者修改智能合约，合约的信任将不复存在</p><p>智能合约系统中不允许中立的第三方，不能被废止，不可篡改性的代价是智能合约在部署前必须经过大量的测试</p><p>验证智能合约行为的四种方法：</p><ul><li>单元测试：需要人力来覆盖代码的全部部分，仅能去除测试用例中的一小部分bug</li><li>符号执行：抽象分析程序的行为；对于复杂的合约检测速度慢（路径爆炸）</li><li>静态分析：不执行代码，过度近似合约的行为，能够获得整个合约的执行情况；但是存在假阳率，需要手工检查</li><li>模糊测试：通过自动生成测试用例来快速推理合约，比静态分析假阳率低；代码覆盖率低</li></ul><p>模糊测试的挑战：</p><ul><li>输入生成：输入空间可能很大</li><li>状态探索：智能合约是基于状态的应用，执行可能依赖于特定输入序列下可达的状态</li><li>环境依赖：智能合约的运行时环境暴露了和底层区块链相关的额外的输入（时间戳、其他部署的合约），导致合约的执行流程可能依赖于环境信息和交易信息</li></ul><p>作者解决三个挑战的思路是采用符号污点分析来生成五点输入的路径约束。观察到模糊器不处理时，启动约束求解器解决当前的约束问题，将这个解决方案收集在一个变异池中，模糊器可以从中获取来跨越具有挑战性的合约条件。</p><p>现有的混合工具（如Driller）在卡住时停止fuzzer并且切换到conbolic(concrete symbolic)方法来越过复杂条件，之后重启fuzzer，本文的解决方法保持模糊器运行并且只使用约束求解来生成模糊器最终会通过变异池选择的即时数据。</p><p>除了约束求解之外，本文进行路径终止分析来清除变异池中的不相关输入。</p><p>挑战2：为了处理合约的状态性，采用遗传算法的选择和交叉算子。遗传算法包括三个操作：</p><ul><li><p>选择：从中种群选择2个个体</p></li><li><p>交叉：交叉算法将2个个体结合生成2个新的个体，挑战在于如何生成有意义的输入。因此，个体之间的数据依赖性指导我们的选择和交叉算子，只有当它们遵循一个写后读（RAW）数据依赖关系时才接受两个个体。</p></li><li><p>变异</p></li></ul><p>挑战3：为了解决环境依赖的困难问题，对执行环境（即以太坊虚拟机）进行工具化，以模糊环境信息，并将合约的输入建模为一个元组，包含交易和环境数据。</p><p>贡献</p><ul><li>第一个智能合约hybrid模糊器的设计</li><li>利用状态变量间动态数据依赖，在运行时高效的生成输入序列</li><li>ConFuzzius，第一个hybrid模糊器的实现</li><li>对128个经过筛选的智能合约和21K个真实世界的智能合约进行了CONFUZZIUS的评估，并证明了方法不仅可以检测到更多的漏洞（高达23％），而且可以实现比现有符号执行工具和模糊器更高的代码覆盖率（高达69％）</li></ul><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><h3 id="Ethereum-Smart-Contracts"><a href="#Ethereum-Smart-Contracts" class="headerlink" title="Ethereum Smart Contracts"></a>Ethereum Smart Contracts</h3><p>简单介绍智能合约和EVM</p><h3 id="fuzzing"><a href="#fuzzing" class="headerlink" title="fuzzing"></a>fuzzing</h3><p>模糊测试（Fuzzing）或模糊测试是一种自动化的软件测试技术，通过将畸形或意外的数据作为程序的输入，执行程序并监控其效果，来查找程序中的漏洞。</p><h4 id="进化模糊"><a href="#进化模糊" class="headerlink" title="进化模糊"></a>进化模糊</h4><p>指采用遗传算法收敛，测试用例的一代被定义为一个种群，而单个测试用例是一个个体。简而言之，每个一代的个体都根据适应度函数进行评估。在每一代结束时，只有最适应的个体被允许繁殖，遵循达尔文的自然选择或“适者生存”的思想。最终，个体将在收敛于最优解的过程中触发漏洞。</p><p><img src="/2023/07/23/ConFuzzius/image-20230723170403119.png" alt="image-20230723170403119"></p><p>初始种群可以随机选或者启发式采样</p><p>终止条件可以是到达指定时间或者超过最大的代数</p><h4 id="混合模糊"><a href="#混合模糊" class="headerlink" title="混合模糊"></a>混合模糊</h4><p>模糊测试在解决复杂条件时比较困难，导致代码覆盖率低</p><p>流行的解决办法是采用符号执行，理论上可以探索所有路径，但实际上由于程序复杂时路径指数级增长，导致不具备可扩展性；另一个缺陷是和执行环境的交互太少。</p><p>混合测试的想法是各取所长，在模糊器不能继续覆盖代码时，自动切换为符号执行，为没有覆盖的分支条件进行穷举搜索，当符号执行发现了未覆盖的分支条件后，求解并回退为模糊器</p><p>模糊测试和符号执行的交错保证了对程序浅的路径快速的执行和对复杂路径的覆盖</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;ConFuzzius-A-Data-Dependency-Aware-Hybrid-Fuzzer-for-Smart-Contracts&quot;&gt;&lt;a href=&quot;#ConFuzzius-A-Data-Dependency-Aware-Hybrid-Fuzzer-for-Smart-Contracts&quot; class=&quot;headerlink&quot; title=&quot;ConFuzzius: A Data Dependency-Aware Hybrid Fuzzer for Smart Contracts&quot;&gt;&lt;/a&gt;ConFuzzius: A Data Dependency-Aware Hybrid Fuzzer for Smart Contracts&lt;/h1&gt;&lt;p&gt;这篇工作发表于&lt;code&gt;EuroS&amp;amp;P21&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;符号执行的方法存在过拟合，导致假阳率&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;现有的模糊测试方法分析浅层的漏洞比较有效，对于执行时的深层的漏洞分析不够有效，导致较低的代码覆盖率/假阳&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;传统程序测试中已经证明结合符号执行和模糊测试的可行性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ConFuzzius是第一个针对智能合约的混合模糊测试器，采用进化的模糊测试方法执行合约的浅层部分，约束求解来生成符合复杂条件的输入，防止进化模糊测试方法探索深层部分。&lt;/p&gt;
&lt;p&gt;ConFuzzius充分利用动态的数据依赖分析来生成更可能导致出现漏洞的交易序列&lt;/p&gt;
&lt;p&gt;实验数据采用精选的128个合约和包含21000真实世界的合约，结果显示比当前最好的工具多检测出了23%的漏洞，代码覆盖率达到了69%，动态数据依赖分析可以加速漏洞检测18%&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/categories/Blockchain/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="SmartContract" scheme="https://alleysira.github.io/tags/SmartContract/"/>
    
  </entry>
  
  <entry>
    <title>Oyente</title>
    <link href="https://alleysira.github.io/2023/07/18/Oyente/"/>
    <id>https://alleysira.github.io/2023/07/18/Oyente/</id>
    <published>2023-07-18T07:33:15.000Z</published>
    <updated>2023-07-23T10:49:38.382Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Making-Smart-Contracts-Smarter"><a href="#Making-Smart-Contracts-Smarter" class="headerlink" title="Making Smart Contracts Smarter"></a>Making Smart Contracts Smarter</h1><p>这篇工作发表于big4 <code>CCS16</code>，一作是来自NUS的Loi Luu</p><p>本文针对以太坊智能合约的安全问题展开研究，介绍了智能合约运行时的若干安全问题。作为改进，提出了增强以太坊的操作语义的方法，使智能合约更不容易受到攻击。</p><p>对于智能合约开发者，本文提出了Oyente，采用符号执行的方法进行智能合约潜在安全漏洞的查找。实验部分针对19366个合约进行分析，Oyente标记了8833个合约为有风险的。</p><p>同时还讨论了几个案例研究中其他攻击的严重程度，这些案例研究有源代码可用，并在主要的以太坊网络中确认了攻击。</p><span id="more"></span><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>区块链用户通过向智能合约地址发布交易（交易的接受者是合约地址）来调用合约，当交易被确认后，所有参与者在当前区块链的状态下，以交易负载作为输入执行合约代码，通过共识协议对输出和合约的下一个状态达成一致</p><p>过去6个月，约15000个智能合约在以太坊中部署</p><p><img src="/2023/07/18/Oyente/image-20230718160000047.png" alt="image-20230718160000047"></p><h3 id="智能合约的安全问题"><a href="#智能合约的安全问题" class="headerlink" title="智能合约的安全问题"></a>智能合约的安全问题</h3><p>不同于传统的分布式应用，以太坊网络是无授权的</p><p>任意敌手可能能够操纵合约执行（允许矿工选择打包哪些交易，交易的顺序，区块时间戳）</p><p>不像传统的分布式应用可以通过发布补丁来修复错误，智能合约是不可逆转、不可篡改的</p><p>因此，设计安全的智能合约系统和合约部署前的正确性推理都是至关重要的</p><p>作者认为出现安全问题的原因是合约编写者对底层执行语义的假设与智能合约系统的实际语义之间存在语义差距。</p><p>对于时间戳依赖和交易顺序依赖攻击，作者认为他们是第一个提出这个问题的团队；对于其他一些前人已经提出的问题（异常处理和逻辑漏洞），本文分析了这些攻击的影响</p><p>本文的工作强调了<em>智能合约语义中微妙或缺失的抽象，这些抽象导致开发人员产生了<strong>虚假的安全感</strong></em>。我们提出了对以太坊协议的改进，这些改进不需要对现有智能合约进行更改，然而这种更改需要所有客户端更新，实际不太可能部署。因此提出了Oyente进行部署前的漏洞检测。</p><p>Oyente针对以太坊智能合约进行符号验证，直接采用字节码，不需要高层的表达（Solidity，Serpent），因为以太坊本身只存储合约的EVM字节码</p><h3 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h3><ul><li>列出了以太坊智能合约新类型的安全漏洞</li><li>形式化了以太坊智能合约的语义，为列出的漏洞给出了修改建议</li><li>提出了Oyente，一种采用符号执行检测以太坊智能合约漏洞的工具</li><li>在真实的以太坊合约上运行了Oyente，并确认了攻击</li></ul><h2 id="BACKGROUND"><a href="#BACKGROUND" class="headerlink" title="BACKGROUND"></a>BACKGROUND</h2><h3 id="Consensus-Protocol"><a href="#Consensus-Protocol" class="headerlink" title="Consensus Protocol"></a>Consensus Protocol</h3><p>区块链的状态$\sigma$是地址到账户的映射，地址为$\gamma$的账户的状态是$\sigma [\gamma]$</p><p>不同于比特币账户仅持有币，以太坊地址支持智能合约账户，包括币、EVM字节码和永久私有存储</p><p>从概念上，以太坊可以理解为一种基于交易的状态机，$\sigma \mathop{\to}\limits^T  \sigma’ $</p><h3 id="Smart-Contracts-in-Ethereum"><a href="#Smart-Contracts-in-Ethereum" class="headerlink" title="Smart Contracts in Ethereum"></a>Smart Contracts in Ethereum</h3><p>一个智能合约的状态包括：</p><ul><li>私有存储</li><li>余额：ether的数量</li></ul><p>用户通过向合约地址发送交易（以太币+输入）来调用合约</p><p><img src="/2023/07/18/Oyente/image-20230718165841643.png" alt="image-20230718165841643"></p><p>以太坊字节码的每一条指令均有预先定义的gas，当用户发送交易调用合约时，需要向矿工支付gas进行补偿。交易发送这设置gasLimit和gasPrice。如果实际的gas消耗大于gasLimit，仍然会被扣除gasLimit的gas然后不执行。</p><h2 id="SECURITY-BUGS-IN-CONTRACTS"><a href="#SECURITY-BUGS-IN-CONTRACTS" class="headerlink" title="SECURITY BUGS IN CONTRACTS"></a>SECURITY BUGS IN CONTRACTS</h2><h3 id="Transaction-Ordering-Dependence"><a href="#Transaction-Ordering-Dependence" class="headerlink" title="Transaction-Ordering Dependence"></a>Transaction-Ordering Dependence</h3><p>考虑到区块内包含若干交易，如果存在新的区块内包含对同一个合约的两次调用，用户无法得知自己调用时合约的状态，只有打包的矿工可以决定交易的顺序，也就是状态的更新顺序</p><ul><li>考虑两个交易分别由owner和任意参与者发起，交易顺序决定了参与者拿到的ether的数量<ul><li>如果owner恶意，观察到有交易调用合约时，将奖励修改为0，有一定概率会获利</li><li>和miner合谋就更容易获利了</li></ul></li></ul><h3 id="Timestamp-Dependence"><a href="#Timestamp-Dependence" class="headerlink" title="Timestamp Dependence"></a>Timestamp Dependence</h3><p><img src="/2023/07/18/Oyente/image-20230718190624360.png" alt="image-20230718190624360"></p><p>其中的other contract variables like <strong>Last_payout</strong> which contribute to the generation of the random seed are also known.</p><h3 id="Mishandled-Exceptions"><a href="#Mishandled-Exceptions" class="headerlink" title="Mishandled Exceptions"></a>Mishandled Exceptions</h3><p>根据合约调用的方式，被调用合约中的异常可能会传播到调用者，也可能不会传播到调用者。</p><p>比如<code>send</code>后应检查返回值</p><p>国王被替代后会获得补偿，但是如果15行的send失败，会导致当前的国王失去补偿</p><p><img src="/2023/07/18/Oyente/image-20230718191420149.png" alt="image-20230718191420149"></p><p>一般发生在向动态地址发送ether，不知道该支付的gas。</p><h3 id="Deliberately-exceeding-the-call-stack-depth-limit"><a href="#Deliberately-exceeding-the-call-stack-depth-limit" class="headerlink" title="Deliberately exceeding the call-stack depth limit"></a>Deliberately exceeding the call-stack depth limit</h3><p>EVM限制调用栈深度为1024，如果通过<code>call</code>和<code>send</code>调用其他合约，栈深度加一</p><p>恶意敌手可以故意使得15行的send失败，但是无法获利</p><h3 id="Reentrancy-Vulnerability"><a href="#Reentrancy-Vulnerability" class="headerlink" title="Reentrancy Vulnerability"></a>Reentrancy Vulnerability</h3><p><img src="/2023/07/18/Oyente/image-20230718192828640.png" alt="image-20230718192828640"></p><h2 id="TOWARDS-A-BETTER-DESIGN"><a href="#TOWARDS-A-BETTER-DESIGN" class="headerlink" title="TOWARDS A BETTER DESIGN"></a>TOWARDS A BETTER DESIGN</h2><p>轻量化的定义捕捉了以太坊的关键</p><p><img src="/2023/07/18/Oyente/image-20230718193217278.png" alt="image-20230718193217278"></p><h3 id="Operational-Semantics-of-Ethereum"><a href="#Operational-Semantics-of-Ethereum" class="headerlink" title="Operational Semantics of Ethereum"></a>Operational Semantics of Ethereum</h3><p>全局区块链的状态可以定义为$<BC,\sigma>,\sigma$是状态，$\varGamma$是新交易集合</BC,\sigma></p><p><img src="/2023/07/18/Oyente/image-20230718193518629.png" alt="image-20230718193518629" style="zoom:80%;"></p><p>矿工形成和验证区块的操作如图所示。一次只有一个“当选领袖”成功执行Propose规则。领导者广播块B后，其他矿工使用Accept规则</p><p>安全问题：leader可能任意选择时间戳，存在TOD漏洞</p><p>以太坊中交易执行会访问三类空间：</p><ul><li>操作数LIFO的栈</li><li>辅助内存$l$，无限增长的数组</li><li>合约的长期存储$str$，长期存储是持久性的，并且在交易之间保留其值。这使其适合存储需要在多次调用合约之间持久存在的数据。</li></ul><p>定义虚拟机的执行状态 $\mu=<A,\sigma>,A$是调用栈</A,\sigma></p><p><img src="/2023/07/18/Oyente/image-20230718194517649.png" alt="image-20230718194517649" style="zoom:80%;"></p><p>将交易抽象为一个三元组$<id,v,l>$,$id$是调用合约的标识符，$v$是要存储进合约的金额，$l$是输入的参数</id,v,l></p><p><img src="/2023/07/18/Oyente/image-20230719091442282.png" alt="image-20230719091442282"></p><p>交易满足两个语义上的性质：</p><ul><li>原子性：每个交易要么全部失败，要么全部执行。all or nothing</li><li>一致性：交易保证区块链系统从一个有效的状态到另一个有效的状态</li></ul><p>本文将EVM抽象成了ETHERLITE，它是一个带有存储和一些类似以太坊的特性的堆栈机器。EtherLite的指令包括</p><p><img src="/2023/07/18/Oyente/image-20230719092528248.png" alt="image-20230719092528248"></p><p><img src="/2023/07/18/Oyente/image-20230719092723997.png" alt="image-20230719092723997"></p><p>call本质上类似于远程程序执行，第二行是调用栈溢出出现异常的情况；第二个return是正确返回的情况，EXC是返回异常</p><p>观察规则TX-EXCEPTION和EXC，前者仅放弃执行，后者返回0；因此交易不满足原子性</p><p>剩余3个指令：</p><ul><li><code>suicide</code>：将所有ether转移给接收者，终止当前合约；类似于call但不是call</li><li><code>create</code>：创建新的和余额账户，接受3个参数；成功后返回合约的地址，失败返回flag 0;考虑如果合约初始化正在执行，但是没有实际的代码段；初始化失败，导致出现了zombie账户，存入的ether全部锁定，会破坏一致性<ul><li>创建新的地址，分配存储，指定的ether存入该地址</li><li>初始化合约的存储</li><li>代码段存入合约</li></ul></li><li><code>getstate</code>：抽象指令，获得当前区块的时间戳，区块id等</li></ul><h3 id="Recommendations-for-Better-Semantics"><a href="#Recommendations-for-Better-Semantics" class="headerlink" title="Recommendations for Better Semantics"></a>Recommendations for Better Semantics</h3><h4 id="解决TOD——Guarded-Transaactions"><a href="#解决TOD——Guarded-Transaactions" class="headerlink" title="解决TOD——Guarded Transaactions"></a>解决TOD——Guarded Transaactions</h4><p>保证合约的调用结果不依赖于交易顺序</p><p><img src="/2023/07/18/Oyente/image-20230719094721711.png" alt="image-20230719094721711"></p><p>额外增加了保护条件$g$，即异常通过时需要满足$g$，如果$g$不满足，抛弃当前交易，默认为true，满足向后兼容</p><p>例子：在<code>Puzzle</code>合约中，用户发布交易可以指定$g\equiv(reward==R)$</p><p>“保护交易（guarded transactions）”类似于大多数现代处理器支持的“比较和交换（CAS）”指令。CAS是一个标准的多线程同步原语，而“保护事务”为以太坊提供了相同的能力。</p><h4 id="确定性时间戳"><a href="#确定性时间戳" class="headerlink" title="确定性时间戳"></a>确定性时间戳</h4><p>允许合约获取区块时间戳实际上是一个冗余的特征，导致合约容易被敌手利用</p><p>时间戳一般用为以下2个途径：</p><ul><li>作为确定性的随机种子：并不明智，熵太低，容易被操纵；作者给出了2个解决方案<a href="https://github.com/randao/randao">randao/randao: RANDAO: A DAO working as RNG of Ethereum (github.com)</a>和<a href="https://eprint.iacr.org/2015/1015#:~:text=On Bitcoin as a public randomness source Joseph,are broadcast every time new blocks are mined.">On Bitcoin as a public randomness source (iacr.org)</a>（从挖出的区块中提取熵的机制）</li><li>作为分布式网络中的全局时间</li></ul><p>作者建议用区块的编号（索引）作为全局时钟，以太坊约12s产生一个区块</p><p>$timestamp - lastTime &gt; 24 hours\to blockNumber - lastBlock &gt; 7,200$</p><h4 id="更好的异常处理"><a href="#更好的异常处理" class="headerlink" title="更好的异常处理"></a>更好的异常处理</h4><p>任何时候都检查返回值，目前Solidity编译器插入代码段进行异常转发，但是在call和send中不会增加</p><p>因此可以在EVM中增加throw和catch的指令，需要更新客户端</p><h2 id="THE-Oyente-TOOL"><a href="#THE-Oyente-TOOL" class="headerlink" title="THE Oyente TOOL"></a>THE Oyente TOOL</h2><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>之前提出的better design需要所有客户端更新，因此实际部署的可能性不高。因此作者提出了部署前的安全检查工具Oyente，能够实现</p><ul><li>开发者写出更安全的合约</li><li>用户避免调用危险的合约</li></ul><p>符号执行将程序变量的值表示为输入符号值的符号表达式。每个符号路径都有一个路径条件，它是一个公式，通过累积输入符号值必须满足的约束条件来构建。如果路径条件不可满足，则路径是不可行的。否则，路径是可行的。</p><p>静态地对程序进行推理，动态执行需要模拟EVM的运行，比传统的静态污点分析和一般的数据流分析的精度更高</p><p><img src="/2023/07/18/Oyente/image-20230719111941121.png" alt="image-20230719111941121"></p><p>输入包括字节码和以太坊的状态，输出合约是否有漏洞（3类），并输出有问题的符号路径</p><p>CFG作者期望后续可以作为交互式的debugger</p><p>Oyente解释EVM指令集，以准确地映射指令到约束条件，bit级准确度。</p><p>模块化设计：</p><ul><li>CFGBuilder：构造CFG</li><li>Explorer：主要部分，符号化执行合约，输出发送给下一个模块</li><li>CoreAnalysis：采用逻辑匹配漏洞</li><li>Validator：筛选部分假阳</li></ul><h3 id="Implemantation"><a href="#Implemantation" class="headerlink" title="Implemantation"></a>Implemantation</h3><p>python 4000行代码</p><p>采用 <a href="https://github.com/Z3Prover/z3">Z3Prover/z3: The Z3 Theorem Prover (github.com)</a>作为求解器判断可满足性</p><ul><li>CFGBuilder：构建一个主要的控制流图，其中包含所有基本块作为节点，以及一些代表跳转的边，其目标可以通过在相应源节点上进行本地调查来确定。但是，在此阶段无法静态确定某些边，因此它们在后续的符号执行过程中动态构建。</li><li>Explorer：主要部分，从CFG入口开始，核心是一个解释器循环，获取要运行的状态，然后在该状态的上下文中符号执行单个指令。这个循环一直持续，直到没有剩余状态，或者达到用户定义的超时。<ul><li>查询Z3来确定分支条件是否满足，进行条件跳转；</li><li>如果2个分支都满足，采用深度优先的方法都执行</li><li>解释阶段末，产生若干符号路径，Z3用于消除不可达的路径</li></ul></li><li>CoreAnalysis：采用逻辑匹配漏洞，检查是否存在3类漏洞，目前仅分析有明确ehter流的路径<ul><li>TOD：当交易顺序改变后，发送ehter不同；即两条trace的ehter flow不一样</li><li>时间戳依赖漏洞：发送的条件包括时间戳，检测时时间戳不变，给定trace检查是否有时间戳</li><li>异常处理：被调用的合约异常时将0压入调用者的操作符栈，仅每次call后检查合约运行结果是否为0</li><li>重入漏洞：遇到每个call时，获得执行call前路径的条件；检查使用更新变量（例如存储值）的条件后是否依然满足。如果是，认为这是一个漏洞，因为被调用者可以在完成调用之前重新执行调用。</li></ul></li><li>Validator：筛选部分假阳<ul><li>询问Z3检查路径是否可达</li><li>不太完备，还需要手工进行假阳的分析</li></ul></li></ul><h2 id="EVALUATION"><a href="#EVALUATION" class="headerlink" title="EVALUATION"></a>EVALUATION</h2><p>定性和定量分析</p><p>运行了以太坊前145,9999个区块的所有智能合约</p><ul><li>尝试测量安全性漏洞的普遍性</li><li>强调了本方案的设计是由现实世界合约特点驱动的，Oyente足够解决这些问题</li><li>给出了一些研究案例，展示了开发者可能对以太坊微妙的语义存在的误解</li></ul><h3 id="Benchmarks-and-Tool-Robustness"><a href="#Benchmarks-and-Tool-Robustness" class="headerlink" title="Benchmarks and Tool Robustness"></a>Benchmarks and Tool Robustness</h3><p>19366份合约，总价值3068654Ether，3千万美元</p><ul><li>大多数合约没有Ether</li><li>10%有至少1Ether</li><li>最富的合约占所有合约的Ether总数的38.9%</li><li>平均ether为318.5 Ether (合约也有贫富差距)</li></ul><p>选择基于字节码而不是源码，在Amazon EC2，分析时间长达3000h，发现了366213条路径</p><h3 id="定量实验"><a href="#定量实验" class="headerlink" title="定量实验"></a>定量实验</h3><p><img src="/2023/07/18/Oyente/image-20230719154205499.png" alt="image-20230719154205499"></p><p>平均分析一个合约350s, 6mins，每个合约平均路径为19</p><p>发现了8833份合约存在bug，仅175份有源码，手动检查发现6.4%的假阳率</p><p><img src="/2023/07/18/Oyente/image-20230719154323611.png" alt="image-20230719154323611"></p><p><img src="/2023/07/18/Oyente/image-20230719154833676.png" alt="image-20230719154833676"></p><p>exception最多：116有源码，全是真阳性，互相调用比较频繁</p><p>TOD：135份合约，32有源码，9个误报，假阳的例子，存在2个ether发送而且顺序无关，argue后续可以采用更花时间的设计来解决这种问题</p><p><img src="/2023/07/18/Oyente/image-20230719155103653.png" alt="image-20230719155103653"></p><p>时间戳依赖：52个合约 7个有源码，检查时间戳在Ether流的path条件上</p><p>重入漏洞：2份源码，其中一个是TheDao，另一个有重入漏洞但是无法利用</p><h3 id="定性实验"><a href="#定性实验" class="headerlink" title="定性实验"></a>定性实验</h3><p>针对合约思考了可能的攻击事件</p><h1 id="SmartBugs实验"><a href="#SmartBugs实验" class="headerlink" title="SmartBugs实验"></a>SmartBugs实验</h1><p><img src="/2023/07/18/Oyente/image-20230719152819796.png" alt="image-20230719152819796"></p><p>在BecToken.sol 覆盖率很高，但是复杂的合约smartbillion中覆盖率仅20%</p><h1 id="Videos"><a href="#Videos" class="headerlink" title="Videos"></a>Videos</h1><p><a href="https://www.youtube.com/watch?v=EIEB_FKZLEE&amp;pp=ygUeTWFraW5nIFNtYXJ0IENvbnRyYWN0cyBTbWFydGVy">https://www.youtube.com/watch?v=EIEB_FKZLEE&amp;pp=ygUeTWFraW5nIFNtYXJ0IENvbnRyYWN0cyBTbWFydGVy</a></p><p><a href="https://nexisato.github.io/2021/07/16/paper-20210716/">【论文阅读・SmartContract】Making Smart Contracts Smarter | Kaleidoscope—— 万花筒 (nexisato.github.io)</a></p><p>$./smartbugs -t oyente -f samples/*.sol —processes 2 —mem-limit 4g —timeout 600</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Making-Smart-Contracts-Smarter&quot;&gt;&lt;a href=&quot;#Making-Smart-Contracts-Smarter&quot; class=&quot;headerlink&quot; title=&quot;Making Smart Contracts Smarter&quot;&gt;&lt;/a&gt;Making Smart Contracts Smarter&lt;/h1&gt;&lt;p&gt;这篇工作发表于big4 &lt;code&gt;CCS16&lt;/code&gt;，一作是来自NUS的Loi Luu&lt;/p&gt;
&lt;p&gt;本文针对以太坊智能合约的安全问题展开研究，介绍了智能合约运行时的若干安全问题。作为改进，提出了增强以太坊的操作语义的方法，使智能合约更不容易受到攻击。&lt;/p&gt;
&lt;p&gt;对于智能合约开发者，本文提出了Oyente，采用符号执行的方法进行智能合约潜在安全漏洞的查找。实验部分针对19366个合约进行分析，Oyente标记了8833个合约为有风险的。&lt;/p&gt;
&lt;p&gt;同时还讨论了几个案例研究中其他攻击的严重程度，这些案例研究有源代码可用，并在主要的以太坊网络中确认了攻击。&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/categories/Blockchain/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="SmartContract" scheme="https://alleysira.github.io/tags/SmartContract/"/>
    
  </entry>
  
  <entry>
    <title>Securify</title>
    <link href="https://alleysira.github.io/2023/07/10/securify/"/>
    <id>https://alleysira.github.io/2023/07/10/securify/</id>
    <published>2023-07-10T01:56:44.000Z</published>
    <updated>2023-07-23T10:47:07.411Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Securify-Practical-Security-Analysis-of-Smart-Contracts"><a href="#Securify-Practical-Security-Analysis-of-Smart-Contracts" class="headerlink" title="Securify: Practical Security Analysis of Smart Contracts"></a>Securify: Practical Security Analysis of Smart Contracts</h1><p>发表于big4 <code>CCS18</code> 一作是来自ETH的Petar Tsankov，通信作者是IC的Arthur Gervais</p><p>本文对以太坊的智能合约进行安全分析，满足可扩展性、完全自动化并且能够证明特定属性的安全/不安全。</p><p>安全分析分为两步：</p><ul><li>通过符号分析合约的依赖图，从代码中精确地提取出语义信息</li><li>检查是否符合或违反模式（pattern），条件是否满足某个性质</li></ul><p>为了实现可扩展性，所有模式都是用指定的域特定语言（DSL）规定的</p><p>目前已经代码开源，分析了18k个合约，被专家用于安全审计</p><span id="more"></span><h2 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h2><p>合约的广泛应用需要强安全保证，然而设计没有安全漏洞合约非常具有挑战性。</p><p>每几个月都有安全漏洞+每个漏洞都很贵</p><p>关键的挑战：</p><ul><li>合约编程语言的图灵完备性，导致自动验证任意属性是不可判定的。现有解决方法依赖于相对通用的测试和符号执行的方法Oyente和Mythril，存在以下缺陷，导致用户需要检查所有报告中的误报并且担心漏报<ul><li>由于欠近似，可能错过重要的违反行为</li><li>由于对域上特定元素不精确的建模，假阳率</li><li>对现实智能合约的代码覆盖率不高，Oyente只有20%</li></ul></li></ul><p>实际上，许多智能合约的安全属性本质上很难直接进行推理。解决这些挑战的可行途径是针对重要的领域特定属性构建一个自动验证器，目前的工作有仅针对 重入漏洞的 </p><p><img src="/2023/07/10/securify/image-20230710110632238.png" alt="image-20230710110632238"></p><p>本文重要的一个观察结果是 可以从数据流图来检查是否符合或违反模式，原因是现实世界中漏洞倾向于违反许多简单的性质，采用pattern而不是property是因为pattern实质上更适合自动推理</p><p>本文的技术思想是定义两类模式反映给定的安全性质：</p><ul><li>符合模式：即表示符合性质</li><li>违反模式</li></ul><p>现有符号执行的工具存在的问题：</p><ul><li>不报告确定性的违反模式（合并了警告和违反），需要用户手动进行分类，实验结果显示用户手动工作量减少了65.9%</li><li>现有的分析工具无法报告不安全的行为，用户需要手动检查未覆盖的代码</li></ul><p>符号执行的方法对数字性质支持更好（溢出），本方案对审计更复杂合约的支持更好</p><p>主要贡献：</p><ul><li>提出了一种在Datalog中对以太坊合约的依赖关系图进行符号编码的反编译器。</li><li>提出了一组合规和违规的安全模式，捕捉足够的条件来证明和反驳实际安全属性。</li><li>给出了一种端到端的实现，完全自动化合约的分析</li><li>对现有以太坊智能合约进行了广泛评估，证明了Securify可以有效地证明合约的正确性并发现违规行为。</li></ul><h2 id="MOTIVATING-EXAMPLES"><a href="#MOTIVATING-EXAMPLES" class="headerlink" title="MOTIVATING EXAMPLES"></a>MOTIVATING EXAMPLES</h2><p> 2 examples 200 millions worth of USD IN 2017</p><h3 id="Stealing-Ether"><a href="#Stealing-Ether" class="headerlink" title="Stealing Ether"></a>Stealing Ether</h3><p><img src="/2023/07/10/securify/image-20230712145246637.png" alt="image-20230712145246637"></p><p>存在的安全问题：对安全非常重要的变量 <code>owner</code>是所有用户来说都是可写的，应该进行限制</p><p>然而由于address的空间过大，无法轻易判断是否满足该性质</p><p>Securify的检测方法是检查是否存在 <code>owner = _owner</code>的赋值不依赖于<code>caller</code> 指令(返回交易发送者的地址)</p><p>具体实现思路是通过分析合约的依赖推断数据控制流图依赖，在这里，Securify推断赋值<code>owner = _owner</code>不依赖于<code>caller</code>指令，这意味着任何用户都可以访问该赋值。一些符号检查工具执行了对相似性质的不精确检查，导致假阳率和假阴率</p><h3 id="Frozen-Funds"><a href="#Frozen-Funds" class="headerlink" title="Frozen Funds"></a>Frozen Funds</h3><p><img src="/2023/07/10/securify/image-20230712150820192.png" alt="image-20230712150820192"></p><p>攻击：以太坊的智能合约可以用特定的<code>kill</code>指令移除区块链，如果攻击者移除 <code>walletLibrary</code>，存储的资金将被冻结</p><p>安全问题：允许用户存储以太币，但不保证能够取出，因为取回函数依赖于外部库，可以从以下两方面检查是否存在这个问题：</p><ul><li>用户能够存储以太币</li><li>合约没有非零数量以太币转移的指令</li></ul><p>Securify检查两个条件的连接，首先检查是否有<code>stop</code>指令，执行不依赖于转移的以太币为0。假设该<code>stop</code>指令对一些交易是可达的，表明用户可以用正数个ether到达，即存储以太币。其次检查是否对于所有的<code>call</code>指令，从合约中提取的ether数量为0</p><h2 id="THE-SECURIFY-SYSTEM"><a href="#THE-SECURIFY-SYSTEM" class="headerlink" title="THE SECURIFY SYSTEM"></a>THE SECURIFY SYSTEM</h2><p>以判断<code>owner</code>为例，介绍整体流程</p><p><img src="/2023/07/10/securify/image-20230712152705941.png" alt="image-20230712152705941"></p><p>绿色的输入：包括合约的字节码和定义的pattern（采用Domain-Specific Language，DSL编写），输入同样可以是solidity编写的合约</p><h3 id="反编译EVM字节码"><a href="#反编译EVM字节码" class="headerlink" title="反编译EVM字节码"></a>反编译EVM字节码</h3><p>首先转换成无栈的静态单指令(static-single assignment form, SSA)的形式</p><p>识别函数，比如ABI_9DA8 对应的函数为<code>initOwner</code></p><p>执行部分求值来解析内存和存储偏移量、跳转目的地，这些对于精确地静态分析代码都很重要</p><h3 id="推断语义事实"><a href="#推断语义事实" class="headerlink" title="推断语义事实"></a>推断语义事实</h3><p>分析合约推断出数据和控制流依赖</p><p>Securify推导语义事实的方式是通过层次化 Datalog（一种语言） 声明式指定的，并且完全自动化，使用现有的可扩展引擎。</p><p>声明式方法的关键优势是：</p><p>（i）推理规则简洁地捕捉了对不同组件（例如合约存储）的抽象推理</p><p>（ii）更多的事实和推理规则可以轻松地添加</p><p>（iii）推理规则以模块化的方式指定（例如，内存分析独立于合约存储分析）</p><h3 id="检查安全模式"><a href="#检查安全模式" class="headerlink" title="检查安全模式"></a>检查安全模式</h3><p>获得所有语义事实后，SECURIFY检查符合模式和违反模式的集合。所有模式由DSL编写，方便安全专家进行扩展。DSL 是对 Securify 推导的语义事实的逻辑公式片段。其存储偏移量（表示为X）和执行这个指令的标签L都不依赖于任何可能执行合约的调用者指令的结果，则违规模式匹配。否定由 ¬ 表示，合取由 ∧ 表示</p><p><img src="/2023/07/10/securify/image-20230712161430145.png" alt="image-20230712161430145"></p><h3 id="SECURIFY的输出"><a href="#SECURIFY的输出" class="headerlink" title="SECURIFY的输出"></a>SECURIFY的输出</h3><p>对于违规模式的匹配，SECURIFY能够输出导致该模式的指令所在行，如果有源码的话可以对应到solidity的行。对于没有匹配到的性质，将会给出warning</p><h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><ul><li><p>当前版本无法分析出数值性质，比如整数溢出</p></li><li><p>无法支持可达性，假设所有指令都是可达的</p></li><li>并不是所有的违规模式都会被攻击者利用</li></ul><h2 id="SEMANTIC-FACTS"><a href="#SEMANTIC-FACTS" class="headerlink" title="SEMANTIC FACTS"></a>SEMANTIC FACTS</h2><p>本节中，介绍 Securify 使用的控制流和数据流依赖关系的自动推导。在这个过程中推导出的事实被称为语义事实，并且后来用于检查安全属性。首先介绍理解此分析所必需的背景：EVM 指令集和分层 Datalog。然后介绍Securify推导的语义事实和声明式推理规则，这些规则在分层 Datalog 中指定，用于推导这些语义事实。</p><h3 id="Backgroud"><a href="#Backgroud" class="headerlink" title="Backgroud"></a>Backgroud</h3><h4 id="EVM"><a href="#EVM" class="headerlink" title="EVM"></a>EVM</h4><p>EVM指令集支持若干操作码，SECURIFY处理了所有的操作码并给出精简后的相关性较高的指令，包括：</p><ul><li>算术运算符和比较 <code>add</code></li><li>密码学哈希函数 <code>sha3</code></li><li>环境信息 <code>balance</code></li><li>区块信息 <code>number</code> <code>timestamp</code></li><li>内存和存储操作 <code>mload</code> <code>mstore</code> load/store data from the memory/contract storage</li><li>系统操作 如<code>call</code></li><li>控制流指令 如 <code>goto</code></li></ul><h4 id="分层的Datalog"><a href="#分层的Datalog" class="headerlink" title="分层的Datalog"></a>分层的Datalog</h4><p>声明式逻辑语言，编写事实（谓词）和规则来推断事实。</p><h3 id="Facts-and-Inference-Rules"><a href="#Facts-and-Inference-Rules" class="headerlink" title="Facts and Inference Rules"></a>Facts and Inference Rules</h3><p>Securify首先提取了一组基本事实，这些事实对于每个指令都是成立的。这些基本事实构成了Datalog程序的输入，用于推导合约的其他事实。我们使用术语“语义事实”来指代由Datalog程序推导出的事实。在Datalog程序中，合约中出现的所有程序元素，包括指令标签、变量、字段、字符串和整数常量，都被表示为常量。</p><h2 id="SECURITY-PATTERNS"><a href="#SECURITY-PATTERNS" class="headerlink" title="SECURITY PATTERNS"></a>SECURITY PATTERNS</h2><p><img src="/2023/07/10/securify/image-20230712170622099.png" alt="image-20230712170622099"></p><h1 id="Videos"><a href="#Videos" class="headerlink" title="Videos"></a>Videos</h1><ul><li><p>[x] CCS 2018 <a href="https://www.youtube.com/watch?v=7v-bd9maqm8">(1) Securify: Practical Security Analysis of Smart Contracts - YouTube</a></p></li><li><p>[ ] SURI 2018 <a href="https://www.youtube.com/watch?v=YNbj_JElzuc&amp;list=PL95IbaKDuVrLeLaRmDof5o3_FE75tdcZP">(1) Securify: Practical Security Analysis of Smart Contracts | Petar Tsankov - YouTube</a></p></li></ul><p><img src="/2023/07/10/securify/image-20230711225346559.png" alt="image-20230711225346559"></p><p>关键性质是在调用指令后不执行状态的改变，然而智能合约是图灵完备的，无法判定，作者观察出了危险调用和安全调用满足的一些简单的性质</p><p><img src="/2023/07/10/securify/image-20230711225523413.png" alt="image-20230711225523413"></p><p>工具当时可以在线访问，现在已经down了 <a href="http://www.securify.ch/">www.securify.ch</a></p><p>发表会议时已经有了1k+的订阅 许多专家使用</p><p><img src="/2023/07/10/securify/image-20230711230448123.png" alt="image-20230711230448123"></p><p>总体思路</p><ul><li>从EVM字节码出发</li></ul><p><img src="/2023/07/10/securify/image-20230711231815757.png" alt="image-20230711231815757"></p><p><img src="/2023/07/10/securify/image-20230711231850438.png" alt="image-20230711231850438"></p><p><img src="/2023/07/10/securify/image-20230711232107609.png" alt="image-20230711232107609"></p><p><img src="/2023/07/10/securify/image-20230711232308582.png" alt="image-20230711232308582"></p><h1 id="Experiment-on-Smartbugs"><a href="#Experiment-on-Smartbugs" class="headerlink" title="Experiment on Smartbugs"></a>Experiment on Smartbugs</h1><p>根据github <a href="https://github.com/smartbugs/smartbugs">smartbugs/smartbugs: SmartBugs: A Framework to Analyze Ethereum Smart Contracts (github.com)</a>的installation在虚拟机上安装docker</p><p>配置完用户组重启才能生效</p><p>采用securify对samples目录下的10个.sol文件进行分析，2线程 4g内存限制 每个任务最长分析时间为60s，github给出的实验命令是600s，考虑到虚拟机是2core 4g ram，实际测试设置为60s</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$./smartbugs -t securify -f samples/*.sol --processes 2 --mem-limit 4g --timeout 600</span><br></pre></td></tr></table></figure><p><img src="/2023/07/10/securify/image-20230718103340279.png" alt="image-20230718103340279"></p><p>实验结果存储在<code>./results/securify</code>目录下</p><p>目录每个.sol文件分析后包括两个文件，以EtherLotto.sol为例具体来看。</p><ul><li><code>smartbugs.json</code>具体为调用工具时参数的情况</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//smartbugs.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;docker&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;command&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">&quot;detach&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;entrypoint&quot;</span>: <span class="string">&quot;&#x27;/sb/bin/do_solidity.sh&#x27; &#x27;/sb/EtherLotto.sol&#x27; &#x27;/sb/bin&#x27;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;image&quot;</span>: <span class="string">&quot;smartbugs/security:usolc&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;mem_limit&quot;</span>: <span class="string">&quot;4g&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;user&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;volumes&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;/tmp/tmp86tp_iz9&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;bind&quot;</span>: <span class="string">&quot;/sb&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;mode&quot;</span>: <span class="string">&quot;rw&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;filename&quot;</span>: <span class="string">&quot;samples/EtherLotto.sol&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;platform&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;cpu&quot;</span>: <span class="string">&quot;12th Gen Intel(R) Core(TM) i5-12500H&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;python&quot;</span>: <span class="string">&quot;3.10.6.final.0 (64 bit)&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;release&quot;</span>: <span class="string">&quot;5.19.0-45-generic&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;smartbugs&quot;</span>: <span class="string">&quot;2.0.7&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;system&quot;</span>: <span class="string">&quot;Linux&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;#46~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Wed Jun 7 15:06:04 UTC 20&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;result&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;duration&quot;</span>: <span class="number">17.345403909683228</span>,</span><br><span class="line">        <span class="attr">&quot;exit_code&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;logs&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">&quot;output&quot;</span>: <span class="string">&quot;result.tar&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;start&quot;</span>: <span class="number">1689647289.9699748</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;runid&quot;</span>: <span class="string">&quot;20230718_0228&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;solc&quot;</span>: <span class="string">&quot;0.4.26&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;tool&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;bin&quot;</span>: <span class="string">&quot;scripts&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;command&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">&quot;cpu_quota&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">&quot;entrypoint&quot;</span>: <span class="string">&quot;&#x27;$BIN/do_solidity.sh&#x27; &#x27;$FILENAME&#x27; &#x27;$BIN&#x27;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;securify&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;image&quot;</span>: <span class="string">&quot;smartbugs/security:usolc&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;info&quot;</span>: <span class="string">&quot;Securify uses formal verification, also relying on static analysis checks. Securify&#x27;s analysis consists of two steps. First, it symbolically analyzes the contract&#x27;s dependency graph to extract precise semantic information from the code. Then, it checks compliance and violation patterns that capture sufficient conditions for proving if a property holds or not.&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;mem_limit&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">&quot;mode&quot;</span>: <span class="string">&quot;solidity&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Securify&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;origin&quot;</span>: <span class="string">&quot;https://github.com/eth-sri/securify&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;output&quot;</span>: <span class="string">&quot;/results/&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;parser&quot;</span>: <span class="string">&quot;parser.py&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;solc&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;version&quot;</span>: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个文件是<code>result.tar</code>，解压后可以发现</p><ul><li><code>live.json</code>文件，具体内容为模式的定义</li><li><code>results.json</code>文件，给出了匹配的结果，包括violation 和 warning safe 和 conflicts</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//live.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;decompiled&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;finished&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;patternResults&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;DAO&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;completed&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasViolations&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasWarnings&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasSafe&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasConflicts&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;violations&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;warnings&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;safe&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;DAOConstantGas&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;completed&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasViolations&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasWarnings&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasSafe&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasConflicts&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;violations&quot;</span>: [</span><br><span class="line">        <span class="number">226</span>,</span><br><span class="line">        <span class="number">271</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;warnings&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;safe&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;MissingInputValidation&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;completed&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasViolations&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasWarnings&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasSafe&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasConflicts&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;violations&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;warnings&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;safe&quot;</span>: [</span><br><span class="line">        <span class="number">116</span>,</span><br><span class="line">        <span class="number">116</span>,</span><br><span class="line">        <span class="number">111</span>,</span><br><span class="line">        <span class="number">116</span>,</span><br><span class="line">        <span class="number">111</span>,</span><br><span class="line">        <span class="number">130</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;TODAmount&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;completed&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasViolations&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasWarnings&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasSafe&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasConflicts&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;violations&quot;</span>: [</span><br><span class="line">        <span class="number">271</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;warnings&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;safe&quot;</span>: [</span><br><span class="line">        <span class="number">226</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;TODReceiver&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;completed&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasViolations&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasWarnings&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasSafe&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasConflicts&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;violations&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;warnings&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;safe&quot;</span>: [</span><br><span class="line">        <span class="number">226</span>,</span><br><span class="line">        <span class="number">271</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;TODTransfer&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;completed&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasViolations&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasWarnings&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasSafe&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasConflicts&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;violations&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;warnings&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;safe&quot;</span>: [</span><br><span class="line">        <span class="number">226</span>,</span><br><span class="line">        <span class="number">271</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;UnhandledException&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;completed&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasViolations&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasWarnings&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasSafe&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasConflicts&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;violations&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;warnings&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;safe&quot;</span>: [</span><br><span class="line">        <span class="number">226</span>,</span><br><span class="line">        <span class="number">271</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;UnrestrictedEtherFlow&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;completed&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasViolations&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasWarnings&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasSafe&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasConflicts&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;violations&quot;</span>: [</span><br><span class="line">        <span class="number">226</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;warnings&quot;</span>: [</span><br><span class="line">        <span class="number">271</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;safe&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//results.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;/sb/EtherLotto.sol:EtherLotto&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;results&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;TODReceiver&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;violations&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;warnings&quot;</span>: [</span><br><span class="line">          <span class="number">48</span>,</span><br><span class="line">          <span class="number">51</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;safe&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;UnhandledException&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;violations&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;warnings&quot;</span>: [</span><br><span class="line">          <span class="number">48</span>,</span><br><span class="line">          <span class="number">51</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;safe&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;TODTransfer&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;violations&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;warnings&quot;</span>: [</span><br><span class="line">          <span class="number">48</span>,</span><br><span class="line">          <span class="number">51</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;safe&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;DAO&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;violations&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;warnings&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;safe&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;TODAmount&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;violations&quot;</span>: [</span><br><span class="line">          <span class="number">51</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;warnings&quot;</span>: [</span><br><span class="line">          <span class="number">48</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;safe&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;MissingInputValidation&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;violations&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;warnings&quot;</span>: [</span><br><span class="line">          <span class="number">20</span>,</span><br><span class="line">          <span class="number">23</span>,</span><br><span class="line">          <span class="number">32</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;safe&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;DAOConstantGas&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;violations&quot;</span>: [</span><br><span class="line">          <span class="number">48</span>,</span><br><span class="line">          <span class="number">51</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;warnings&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;safe&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;UnrestrictedEtherFlow&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;violations&quot;</span>: [</span><br><span class="line">          <span class="number">48</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;warnings&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;safe&quot;</span>: [</span><br><span class="line">          <span class="number">51</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据实验结果，可能是运行的分析时间较短，许多合约分析结果为空（比如Mytoken.sol)</p><p><img src="/2023/07/10/securify/image-20230718105438946.png" alt="image-20230718105438946"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Securify-Practical-Security-Analysis-of-Smart-Contracts&quot;&gt;&lt;a href=&quot;#Securify-Practical-Security-Analysis-of-Smart-Contracts&quot; class=&quot;headerlink&quot; title=&quot;Securify: Practical Security Analysis of Smart Contracts&quot;&gt;&lt;/a&gt;Securify: Practical Security Analysis of Smart Contracts&lt;/h1&gt;&lt;p&gt;发表于big4 &lt;code&gt;CCS18&lt;/code&gt; 一作是来自ETH的Petar Tsankov，通信作者是IC的Arthur Gervais&lt;/p&gt;
&lt;p&gt;本文对以太坊的智能合约进行安全分析，满足可扩展性、完全自动化并且能够证明特定属性的安全/不安全。&lt;/p&gt;
&lt;p&gt;安全分析分为两步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过符号分析合约的依赖图，从代码中精确地提取出语义信息&lt;/li&gt;
&lt;li&gt;检查是否符合或违反模式（pattern），条件是否满足某个性质&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了实现可扩展性，所有模式都是用指定的域特定语言（DSL）规定的&lt;/p&gt;
&lt;p&gt;目前已经代码开源，分析了18k个合约，被专家用于安全审计&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/categories/Blockchain/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="SmartContract" scheme="https://alleysira.github.io/tags/SmartContract/"/>
    
  </entry>
  
  <entry>
    <title>ContractFuzzer</title>
    <link href="https://alleysira.github.io/2023/07/04/ContractFuzzer/"/>
    <id>https://alleysira.github.io/2023/07/04/ContractFuzzer/</id>
    <published>2023-07-04T08:02:37.000Z</published>
    <updated>2023-07-23T10:44:43.382Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ContractFuzzer-Fuzzing-Smart-Contracts-for-Vulnerability-Detection"><a href="#ContractFuzzer-Fuzzing-Smart-Contracts-for-Vulnerability-Detection" class="headerlink" title="ContractFuzzer: Fuzzing Smart Contracts for Vulnerability Detection"></a>ContractFuzzer: Fuzzing Smart Contracts for Vulnerability Detection</h1><p>软工顶会 <code>ASE18</code></p><p>基于智能合约的ABI生成fuzz的输入，针对不同漏洞类型定义了新的测试oracle，利用EVM记录智能合约的运行时行为，分析日志来报告安全漏洞。实验对6991份智能合约标记出了459个漏洞。</p><span id="more"></span><h2 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h2><p>截止 2018.3， 以太坊智能合约和DApps的数量超过2百万，以太坊账户管理的ether超过9800万，约为5800 USD。管理如此多财富的智能合约成为了黑客的攻击目标。</p><p>智能合约容易受攻击的原因：</p><ul><li>智能合约的执行依赖于区块链和其他智能合约，开发者可能忽视合约间的隐含关系</li><li>编程语言和运行时环境比较新颖，开发者对缺陷理解不到位</li><li>智能合约的不可篡改性使得难以在部署后更新，漏洞修复可能需要较长时间</li></ul><p>其他解决方案存在的问题：</p><ul><li>不准确，误报率较高</li><li>符号验证所有的可能路径存在路径爆炸问题，如果只验证部分路径，也可能导致假阴性。</li></ul><p>贡献</p><ul><li>第一个以太坊智能合约fuzzing的框架</li><li>提供了一系列新的测试oracle</li><li>系统的测试了6991个真实的合约</li></ul><h2 id="A-REVIEW-OF-SMART-CONTRACTS"><a href="#A-REVIEW-OF-SMART-CONTRACTS" class="headerlink" title="A REVIEW OF SMART CONTRACTS"></a>A REVIEW OF SMART CONTRACTS</h2><p>区块链的状态 $s$ 是从地址到账户的映射，账户可以由人类和程序拥有。以太坊可以看做是基于交易的状态机，状态由每个交易更新，交易的有效性由共识协议验证。交易实际上是一个账户向另一个账户发送的消息，可以包括二进制数据（输入）和ether</p><p>安全威胁：blockchain level, EVM level, and smart contract level.</p><p>Moreover, even using the <em>block.blockhash()</em> function with <em>block.number</em> as parameters for random number generation is still vulnerable either due the execution mechanism of EVM or due to the transparency of the blockchain.</p><h2 id="DEF1N1NG-TEST1NG-ORACLES-FOR-VULNERAB1L1T1ES-OF-SMART-CONTRACTS"><a href="#DEF1N1NG-TEST1NG-ORACLES-FOR-VULNERAB1L1T1ES-OF-SMART-CONTRACTS" class="headerlink" title="DEF1N1NG TEST1NG ORACLES FOR VULNERAB1L1T1ES OF SMART CONTRACTS"></a>DEF1N1NG TEST1NG ORACLES FOR VULNERAB1L1T1ES OF SMART CONTRACTS</h2><ul><li>Gasless Send：<code>send()</code>是由<code>call()</code>实现的，检查<code>call()</code>的输入为0且gas limit是2300，检查<code>send()</code>是否返回<strong><em>ErrOutOfGas\</em></strong></li><li>Exception Disorder：根调用没有返回异常但是嵌套的调用返回异常，即一场没有正确地传播到根调用</li><li>Reentrancy<ul><li>检查函数调用 A 是否在源自调用 A 的调用链中出现多次</li><li>检查是否有<code>call()</code>调用并且值大于0；是否有足够的gas来执行复杂操作；被<code>call()</code>调用的是工具自身的代理合约</li><li>ContractFuzzer 只有在能够成功对目标合约发起重入攻击时才会标记重入漏洞</li></ul></li><li>Timestamp/Block Number Dependency<ul><li>检查是否调用了TIMESTAMP操作码</li><li>检查是否<code>call()</code>是<code>send()</code>，发送了ether</li><li>检查<code>call()</code>的值是否大于0</li></ul></li><li>DelegateCall<ul><li>检查是否存在deletegatecall的调用</li><li>调用的函数从输入中获取</li></ul></li><li>FreezingEther<ul><li>检查是否能收到ether</li><li>是否使用delegatecall，不存在transfer/send/call/suicide等将ether转移到其他地址的调用</li><li>标记出余额&gt;0，无法采用自身合约转出ether</li></ul></li></ul><h2 id="THE-SMART-CONTRACT-FUZZER"><a href="#THE-SMART-CONTRACT-FUZZER" class="headerlink" title="THE SMART CONTRACT FUZZER"></a>THE SMART CONTRACT FUZZER</h2><p><img src="/2023/07/04/ContractFuzzer/image-20230705150229282.png" alt="image-20230705150229282"></p><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>0-5 共6步</p><p>包括离线EVM检测工具和在线模糊测试工具，EVM进行合约的运行，模糊测试工具提取信息</p><p>采用爬虫将Ehterscan网站的合约的二进制码 ABI 构造参数等爬下来，部署在测试网上</p><p>合约用来作为模糊测试的对象和被其他合约调用</p><p>步骤2 用于测试合约间的交互</p><p>工具将生成符合ABI规范的有效模糊测试输入，以及在步骤3中跨越有效性边界的突变输入。</p><h3 id="Static-Analysis-of-Smart-Contracts"><a href="#Static-Analysis-of-Smart-Contracts" class="headerlink" title="Static Analysis of Smart Contracts"></a>Static Analysis of Smart Contracts</h3><p>extract the signatures of the public functions supported by those contracts.</p><p>该工具基于每个智能合约的 ]SON 格式导出的 ABI，提取 ABI 中声明的所有函数签名，计算函数签名前4字节的哈希值作为function selector并构建key-value(selector-address vector)的映射</p><p>将ABI的JSON解析，提取函数描述和参数的数据类型，address类型必须采用能够提供相应函数的合约的地址</p><p>For a given ABI function of a smart contract under test, how can we effectively determine subset of smart contracts that it can interact with? function selector，call的参数和函数签名的前4个字节对应</p><p>是否正确</p><p><img src="/2023/07/04/ContractFuzzer/image-20230705153449574.png" alt="image-20230705153449574"></p><p>首先反汇编，提取出ABI，提取出函数体，定位函数代码段，如果行以PUSH4开头，当前行加入到selector当中，最后输出Map，搜索Map查询所有的支持selector作为ABI的合约地址放进一个私有的智能合约池中用来进行交互</p><h3 id="Fuzzing-Input-Generation"><a href="#Fuzzing-Input-Generation" class="headerlink" title="Fuzzing Input Generation"></a>Fuzzing Input Generation</h3><p>生成固定长度和非固定长度的输入的算法不同</p><ul><li>固定长度 <em>INT\<M></M></em>, <em>UINT\<M></M></em>, <em>BYTES\<M> 和数组 \<type>[M]</type></M></em><ul><li>首先在有效输入域上随机生成值</li><li>然后我们还构建了另一组种子输入，这些种子输入在基于静态分析的智能合约中经常使用</li><li>两类结合作为候选值</li></ul></li><li>非固定长度的值 <em>bytes string \<type>[]</type></em><ul><li>随机生成一个正整数作为长度，随机从输入域上选</li></ul></li></ul><p>为每个函数都生成候选输入的集合，因此循环执行生成k个实例作为候选集，编码成字节码供调用</p><p>为重入漏洞生成输入需要在两个合约间交互式调用</p><p><img src="/2023/07/04/ContractFuzzer/image-20230705161724227.png" alt="image-20230705161724227"></p><p><em>BountyHunt</em> send ether with a call at line 5 before setting the value of the corresponding bounryAccount to 0 at line 7.</p><h3 id="Instrumenting-EVM-to-Collect-Test-Oracles"><a href="#Instrumenting-EVM-to-Collect-Test-Oracles" class="headerlink" title="Instrumenting EVM to Collect Test Oracles"></a>Instrumenting EVM to Collect Test Oracles</h3><p>需要收集的三类信息：</p><ul><li>call和delegatecall的属性</li><li>调用的操作码</li><li>执行时合约的状态</li></ul><p><img src="/2023/07/04/ContractFuzzer/image-20230705162927210.png" alt="image-20230705162927210"></p><p>为了支持重入漏洞和异常中断漏洞的检测，记录了Call的链</p><p><em>EVM.Call()</em> and <em>EVM.DelegateCall()</em> function 来记录call的信息</p><p><em>interpreter.Run()</em> 来记录opCode</p><h3 id="Vulnerability-Analysis-and-Report"><a href="#Vulnerability-Analysis-and-Report" class="headerlink" title="Vulnerability Analysis and Report"></a>Vulnerability Analysis and Report</h3><p>当初始调用的调用堆栈变为空时，EVM中的检测模块将首先根据收集到的检测信息检查这些子oracle。然后，检测模型将这些子oracle发送到侦听本地主机端口8888的HTTP服务器。服务器将收集子oracle的结果，然后对每个测试oracle的复合条件执行最终检查。</p><h2 id="EXPERIMENT-AND-RESULTS-ANALYSIS"><a href="#EXPERIMENT-AND-RESULTS-ANALYSIS" class="headerlink" title="EXPERIMENT AND RESULTS ANALYSIS"></a>EXPERIMENT AND RESULTS ANALYSIS</h2><p>PC中配置了两个dockers来帮助设置测试客户端和以太坊测试网络。在docker运行测试客户端中，在node.js运行时中使用以太坊javascript API (web3.js库)与testnet docker中的geth客户端进行交互。测试网络docker安装geth客户端1.7.0版本，然后还在该docker中创建了一个以太坊私有区块链，其中一个对等节点作为测试网络。</p><p>当时Etherscan有9960个合约，全部爬下来去掉了无法部署的合约，剩下6991</p><p>contract creation code (bytecode), the ABI interfaces, and the constructor argument of those contracts作为输入</p><p>首先进行静态分析，得到每个ABI的私有的合约池并提取出ABI函数用于生成输入</p><p>对于每个合约采用3类账户进行调用：创建者账户；外部账户；AttackAgent（重入）</p><p>每个账户2种调用模式：带有ehter和无ether的</p><p>对于每个 ABI 函数，如果包含参数，ContractFuzzer 将生成 k 个输入来调用它。否则，我们将简单地对其执行一次调用。结合 3 种账户类型和 call.value() 的 2 种选择，我们将为带参数的函数生成 6<em>k 次调用，为不带参数的函数生成 6 (3\</em>2) 次调用。用一个较大的值初始化 k，以便 ContractFuzzer 可以有广泛的候选调用可供选择。当模糊特定的智能合约时，我们会将为其每个 ABI 函数生成的所有调用合并到智能合约的调用池中。然后ContractFuzzer启动HTTP服务器来收集和分析测试预言机。对于每个智能合约，ContractFuzzer 从其调用池中随机选择调用来执行模糊测试，模拟智能合约函数的不同调用顺序。最后，服务器收集并分析结果以形成报告。经过大约 80 个小时的模糊测试后，我们停止了实验，直到结果逐渐收敛。</p><p>和Oyente verification tool进行实验结果对比</p><p><img src="/2023/07/04/ContractFuzzer/image-20230705164932309.png" alt="image-20230705164932309"></p><p>除了时间戳和区块号依赖有假阳率，其他均没有，手动进行了核查</p><p>误报情况的原因是，对这两种类型的漏洞的测试预言机定义不精确。事实上，在这两种情况的测试预言机定义中，检查了操作码（TIMESTAMP 和 NUMBER）的使用以及测试的 ABI 函数中ether转移调用的使用。还没有检查在读取 TIMESTAMP 和 NUMBER 和使用它们来计算以太币转移的条件之间是否存在数据流定义使用链。但是，记录此类信息可能涉及通过检测所测试的智能合约进行昂贵的数据流跟踪。考虑到实际较高的真阳性率，作者认为ContractFuzzer的解决方案是一种具有成本效益的权衡。</p><p><img src="/2023/07/04/ContractFuzzer/image-20230705165527293.png" alt="image-20230705165527293"></p><p>Oyentle支持4种漏洞检测，调用深度漏洞已经在EIP150 hardfork中修复了，交易顺序依赖攻击contractFuzzer不支持，只比较了时间戳依赖和重入攻击</p><p>对于时间戳依赖漏洞，contractFuzzer假阴（未检测出）的原因：</p><ul><li>时间被硬编码，并将区块时间戳与之进行比较，但是不涉及以太币转移 Table.7</li><li>在有限的测试时间内，某些条件很难触发。例如，一个合约在触发时间戳相关的以太币传输之前需要函数的特定调用模式。我们可以使用不同的函数调用串行执行更广泛的模糊测试来改善这种情况。comprehensive input generation schemes</li></ul><p><img src="/2023/07/04/ContractFuzzer/image-20230705170242332.png" alt="image-20230705170242332"></p><p>对于重入漏洞，contractFuzzer假阴的原因是一些智能合约的漏洞在转移以太之前必须执行复杂的条件检查。然而，这些条件很难由ContracFuzzer触发。</p><p>Oyente假阳的三类：</p><ul><li>uses <em>send()</em> and <em>transfer()</em> operation with a limited gas，被调用者没有足够的gas进行重入</li><li>严格检查caller是否为合约的拥有者</li><li>只能将ehter转给硬编码的地址</li></ul><p>未来研究方向：</p><ul><li>降低假阳率</li><li>增加支持的漏洞类型</li><li>扩展到其他区块链平台</li></ul><h2 id="配置实验环境"><a href="#配置实验环境" class="headerlink" title="配置实验环境"></a>配置实验环境</h2><p>首先下载姜博老师在<a href="https://github.com/gongbell/ContractFuzzer">github.com</a>提供的container，结果居然在百度龟速盘，卒</p><p>容器大小约为3g，考虑到用网络从windows传给虚拟机比较慢，设置了vmware的共享文件夹，不是很好用</p><p>参考<a href="https://blog.csdn.net/wkd_007/article/details/128908085">samba配置</a>，在Ubuntu配置了samba服务器，可以在windows访问，实际传输文件约为80Mbps</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker load&lt;contractfuzzer.tar </span><br><span class="line">$ docker run -i -t contractfuzzer/contractfuzzer:latest</span><br></pre></td></tr></table></figure><p>启动docker后，运行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./run.sh --contracts_dir ./examples/exception_disorder</span><br></pre></td></tr></table></figure><p>大概运行了2h</p><p><img src="/2023/07/04/ContractFuzzer/image-20230718180501857.png" alt="image-20230718180501857"></p><p>查看reporter目录下的文件</p><p><img src="/2023/07/04/ContractFuzzer/image-20230718181052754.png" alt="image-20230718181052754"></p><p><img src="/2023/07/04/ContractFuzzer/image-20230718183538899.png" alt="image-20230718183538899"></p><p><img src="/2023/07/04/ContractFuzzer/image-20230718183428822.png" alt="image-20230718183428822"></p><ol><li><code>contract_fuzzer</code> is one part of ContractFuzzer, which generates contract call messages based on contract’s ABI definition;</li><li><code>contract_tester</code> is one part of ContractFuzzer, which sends the contract call messages to our instrumented Geth client.</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/ContractFuzzer/examples/exception_disorder/fuzzer/reporter <span class="comment"># cat tester_run.log</span></span><br><span class="line">Error: Transaction 0x32f2a2da9954f099f2e37db287c92286a4cd9110f9b18a6f3258deea477b3960 wasn<span class="string">&#x27;t processed in 240 seconds!</span></span><br><span class="line"><span class="string">    at Object.callback (/ContractFuzzer/contract_tester/node_modules/truffle-contract/contract.js:177:35)</span></span><br><span class="line"><span class="string">    at /ContractFuzzer/contract_tester/node_modules/web3/lib/web3/method.js:142:25</span></span><br><span class="line"><span class="string">    at /ContractFuzzer/contract_tester/node_modules/web3/lib/web3/requestmanager.js:89:9</span></span><br><span class="line"><span class="string">    at XMLHttpRequest.request.onreadystatechange (/ContractFuzzer/contract_tester/node_modules/web3/lib/web3/httpprovider.js:128:7)</span></span><br><span class="line"><span class="string">    at XMLHttpRequestEventTarget.dispatchEvent (/ContractFuzzer/contract_tester/node_modules/xhr2/lib/xhr2.js:64:18)</span></span><br><span class="line"><span class="string">    at XMLHttpRequest._setReadyState (/ContractFuzzer/contract_tester/node_modules/xhr2/lib/xhr2.js:354:12)</span></span><br><span class="line"><span class="string">    at XMLHttpRequest._onHttpResponseEnd (/ContractFuzzer/contract_tester/node_modules/xhr2/lib/xhr2.js:509:12)</span></span><br><span class="line"><span class="string">    at IncomingMessage.&lt;anonymous&gt; (/ContractFuzzer/contract_tester/node_modules/xhr2/lib/xhr2.js:469:24)</span></span><br><span class="line"><span class="string">    at IncomingMessage.emit (events.js:185:15)</span></span><br><span class="line"><span class="string">    at IncomingMessage.emit (domain.js:422:20)</span></span><br><span class="line"><span class="string">    at endReadableNT (_stream_readable.js:1106:12)</span></span><br><span class="line"><span class="string">    at process._tickCallback (internal/process/next_tick.js:178:19)</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/gongbell/ContractFuzzer/issues/13">github上的解释</a>是</p><p>“The existing private blockchain has slowed down over time and now the mining speed is too low. truffle-contract is timing out while trying to push the transaction”</p><p>实际更换在windows的wsl上运行docker后不再存在这个问题</p><h2 id="和xls交流后记录"><a href="#和xls交流后记录" class="headerlink" title="和xls交流后记录"></a>和xls交流后记录</h2><ul><li>学习智能合约的开发：<a href="https://github.com/smartcontractkit/full-blockchain-solidity-course-js">https://github.com/smartcontractkit/full-blockchain-solidity-course-js</a></li><li>测试网领取测试币<ul><li>chainlink：<a href="https://faucets.chain.link/sepolia">Get Sepolia Testnet LINK Tokens | Chainlink Faucets</a> 20 test LINK, 0.1测试币</li></ul></li><li><p><img src="/2023/07/04/ContractFuzzer/image-20230722093718219.png" alt="image-20230722093718219"></p><ul><li><a href="https://sepoliafaucet.com/">Sepolia Faucet</a>，每天0.5ETH</li><li><a href="https://goerlifaucet.com/">Goerli Faucet</a>，每天0.02ETH，Goerli需要在主网上充值0.001eth，测试网领取测试币</li></ul></li><li><p>继续学习contractFuzzer的实现，尝试将链部署在Ganache上</p></li><li>以后写合约考虑使用<a href="https://learnblockchain.cn/docs/hardhat/hardhat-network/">Hardhat网络</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;ContractFuzzer-Fuzzing-Smart-Contracts-for-Vulnerability-Detection&quot;&gt;&lt;a href=&quot;#ContractFuzzer-Fuzzing-Smart-Contracts-for-Vulnerability-Detection&quot; class=&quot;headerlink&quot; title=&quot;ContractFuzzer: Fuzzing Smart Contracts for Vulnerability Detection&quot;&gt;&lt;/a&gt;ContractFuzzer: Fuzzing Smart Contracts for Vulnerability Detection&lt;/h1&gt;&lt;p&gt;软工顶会 &lt;code&gt;ASE18&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;基于智能合约的ABI生成fuzz的输入，针对不同漏洞类型定义了新的测试oracle，利用EVM记录智能合约的运行时行为，分析日志来报告安全漏洞。实验对6991份智能合约标记出了459个漏洞。&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/categories/Blockchain/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="SmartContract" scheme="https://alleysira.github.io/tags/SmartContract/"/>
    
  </entry>
  
  <entry>
    <title>blockchain security survey</title>
    <link href="https://alleysira.github.io/2023/06/20/blockchain-security-survey/"/>
    <id>https://alleysira.github.io/2023/06/20/blockchain-security-survey/</id>
    <published>2023-06-20T03:48:28.000Z</published>
    <updated>2023-07-23T10:43:54.051Z</updated>
    
    <content type="html"><![CDATA[<div class="table-container"><table><thead><tr><th style="text-align:center">论文</th><th style="text-align:center">来源</th><th style="text-align:center">内容</th></tr></thead><tbody><tr><td style="text-align:center">区块链安全问题：研究现状与展望</td><td style="text-align:center">自动化学报  2019</td><td style="text-align:center">本文定义了区块链系统设计追求的安全目标, 从机制漏洞、攻击手段和安全措施三方面对区块链各层级的安全问题进行分析, 提出了区块链的平行安全概念框架</td></tr><tr><td style="text-align:center">区块链公链应用的典型安全问题综述</td><td style="text-align:center">软件学报  2022</td><td style="text-align:center">以比特币和以太坊为例, 剖析了针对面向代币交易和应用的区块链系统的各类安全威胁以及应对方法;  接着分析钱包和用户的安全隐患</td></tr><tr><td style="text-align:center">区块链系统攻击与防御技术研究进展</td><td style="text-align:center">软件学报  2020</td><td style="text-align:center">本文从层级分类、攻击关联分析两个维度对区块链已有安全问题的系统架构、攻击原理、防御策略展开研究</td></tr><tr><td style="text-align:center">区块链中攻击方式的研究</td><td style="text-align:center">计算机学报  2021</td><td style="text-align:center">分析区块链攻击方式，提出了对攻击方式的分类方法，体现了不同攻击方式间的差异性和关联性，归纳攻击的特点并给出了预防措施和检测方法</td></tr><tr><td style="text-align:center">智能合约漏洞检测研究综述</td><td style="text-align:center">计算机科学与探索  2022</td><td style="text-align:center">通过对常见漏洞的分析，漏洞检测方法和工具的国内外现状调研并分析优缺点，复现部分工具进行实验，以检测速度、准确率以及支持的漏洞数量为标准，展示漏洞检测工具的性能</td></tr><tr><td style="text-align:center">区块链的网络安全：威胁与对策</td><td style="text-align:center">信息安全学报  2018</td><td style="text-align:center">本文针对区块链数据的完整性、匿名性与隐私保护的安全需求, 系统分析了区块链的安全攻击, 综述了安全保护技术研究进展</td></tr><tr><td style="text-align:center">智能合约漏洞及检测技术研究综述</td><td style="text-align:center">网络安全技术与应用 2022</td><td style="text-align:center">详细介绍了智能合约的14种典型安全漏洞，总结了漏洞防范的方法；针对漏洞检测技术进行分类，介绍检测工具解决的问题，实现原理，比较检测技术和工具的优劣</td></tr><tr><td style="text-align:center">区块链安全能力测评与分析报告</td><td style="text-align:center">中国信通院  2021</td><td style="text-align:center">综合分析区块链基础设施安全能力测评情况，总结了安全隐患，对2021-2023年区块链基础设施安全新方向提出展望</td></tr><tr><td style="text-align:center">网络安全国家标准研究项目研究报告</td><td style="text-align:center">北航  伍前红 2018</td><td style="text-align:center">国内外区块链发展现状和相关政策；区块链安全需求以及面临的主要威胁；区块链应用典型案例；区块链安全参考架构；区块链安全标准化建议</td></tr><tr><td style="text-align:center">区块链的安全威胁与取证</td><td style="text-align:center">付章杰-南京信息工程大学</td><td style="text-align:center">本报告介绍了区块链取证的背景，区块链取证的研究现状与存在的技术挑战，研究内容主要包括通用感知和精准取证</td></tr></tbody></table></div><span id="more"></span><h1 id="智能合约漏洞检测研究综述-李雷孝-计算机科学与探索"><a href="#智能合约漏洞检测研究综述-李雷孝-计算机科学与探索" class="headerlink" title="智能合约漏洞检测研究综述-李雷孝-计算机科学与探索"></a>智能合约漏洞检测研究综述-李雷孝-计算机科学与探索</h1><p>介绍了重入攻击漏洞、整数溢出以及访问控制漏洞的分析</p><p>给出了形式化验证、符号执行、机器学习等方法和工具的现状以及优缺点</p><p>复现了部分工具，给出了检测速度、准确率、漏洞数量等性能对比</p><h2 id="区块链和智能合约"><a href="#区块链和智能合约" class="headerlink" title="区块链和智能合约"></a>区块链和智能合约</h2><p>安全问题出现的原因主要有:</p><ul><li><p>智能合约一旦部署不可修改</p></li><li><p>合约执行后不可逆</p></li><li><p>编程语言自身问题或程序员的逻辑问题</p></li></ul><p>智能合约的设计准则：</p><ul><li>可观察性</li><li>客观可核查</li><li>相对性</li><li>可执行性</li></ul><p>智能合约一般采用高级语言Solidity编写，智能合约应用采用EVM字节码编码后存储在区块链上</p><h2 id="智能合约的漏洞"><a href="#智能合约的漏洞" class="headerlink" title="智能合约的漏洞"></a>智能合约的漏洞</h2><p><img src="/2023/06/20/blockchain-security-survey/image-20230620164027253.png" alt="image-20230620164027253"></p><ul><li><p>重入漏洞：<code>fallback</code>函数在调用结束前让攻击者有机会再执行被调用的函数，类似于递归调用</p><ul><li><code>fallback</code>在合约调用没有匹配到函数签名，或者调用没有带任何数据时被自动调用。</li></ul></li><li><p>整数溢出：以太坊提供了SafeMath库，会提前检测整数溢出</p><ul><li>乘法</li><li>加法</li><li>减法</li></ul></li><li><p>访问控制漏洞：合约中函数的权限设置不合理，如未定义类型的函数默认为public</p></li><li>交易顺序依赖攻击：算出PoW的矿工可以选择打包哪些交易，攻击者可以观察交易池中存在哪些可能对自己不利的交易，攻击者可以创建包含更高gas的交易，使得自己被优先打包，核心问题是矿工根据gas交易来选择打包的交易</li><li>对可预测变量的依赖：以太坊的随机数通过区块的某些属性来生成，攻击者可能能够预测到随机数的生成</li><li>tx-origin滥用：<code>tx-origin</code>作为一个全局变量，能够回溯整个调用栈被返回租出发起交易的合约地址，当合约使用该变量进行验证或授权，可能能够绕过某些判断语句</li><li>DoS：可能导致合约被锁定，用户的加密货币无法取回</li><li>动态数组双重访问攻击：不同变量可能存储在同一个位置，可能导致变量被覆盖，目前没有有效的工具<ul><li>绕过</li><li>提权</li></ul></li></ul><h2 id="智能合约漏洞检测方法"><a href="#智能合约漏洞检测方法" class="headerlink" title="智能合约漏洞检测方法"></a>智能合约漏洞检测方法</h2><p>不可篡改性：上链前</p><h3 id="形式化验证"><a href="#形式化验证" class="headerlink" title="形式化验证"></a>形式化验证</h3><ul><li>BAN逻辑</li><li>模型检验</li><li>密码学原语代数属性的形式化方法</li><li><p>基于定理证明</p></li><li><p>形式化验证包括</p><ul><li>模型检验：列举出所有可能的状态主义检验</li><li>演绎验证</li></ul></li><li>形式化验证的工具：<ul><li>ZEUS. KALRA S, GOEL S, DHAWAN M, et al. ZEUS: analyzing safety of smart contracts[C]//Proceedings of the 25th Annual Network and Distributed System Security Symposium, San Diego, Feb 18-21, 2018: 1-15.<ul><li>无法检测重入攻击和跨功能的分析策略</li></ul></li><li>Isabelle/HOL：针对EVM 字节码进行检测</li></ul></li></ul><h3 id="符号执行的审计方法"><a href="#符号执行的审计方法" class="headerlink" title="符号执行的审计方法"></a>符号执行的审计方法</h3><p>将代码中的变量符号化符号化程序输入，符号执行能够为所有的执行路径维护一组约束，执行之后，约束求解<br>器将用于求解约束并确定该执行的输入，最后利用约束求解器得到新的测试输入，检测符号值是否可以产生漏洞。</p><p><img src="/2023/06/20/blockchain-security-survey/image-20230620173459648.png" alt="image-20230620173459648"></p><p>步骤：符号化、逐条解释、更新状态搜集路径约束，完成所有路径的探索（安全问题）</p><ul><li><p>Oyente 第一个用于以太坊上的漏洞检测支持重入漏洞、交易顺序依赖以及伪随机等安全漏洞的检测，但是该工具对于自杀合约和<code>tx-origin</code> 的滥用问题并不能做到有效的检测</p></li><li><p>Mythril <a href="https://pypi.org/project/mythril/">mythril · PyPI</a><a href="https://pypi.org/project/mythril/">mythril · PyPI</a></p></li><li>MythX <a href="https://mythx.io/">MythX: Smart contract security service for Ethereum</a></li></ul><h3 id="利用模糊测试的审计方法"><a href="#利用模糊测试的审计方法" class="headerlink" title="利用模糊测试的审计方法"></a>利用模糊测试的审计方法</h3><p>提供非预期输入监视异常结果来发现软件漏洞。</p><p>核心思想是将自动或半自动生成的随机数输入程序并检测到程序的异常。</p><p>工具：</p><ul><li>ContractFuzzer 分析日志进行分析检测  JIANG B, LIU Y, CHAN W K. ContractFuzzer: fuzzing smart contracts for vulnerability detection[C]//Proceedings of the 33rd ACM/IEEE International Conference on Automated Software Engineering, Montpellier, Sep 3-7, 2018. New York: ACM, 2018: 259-269.</li><li>SoliAudit 机器学习和模糊测试结合  LIAO J W, TSAI T T, HE C K, et al. SoliAudit: smart contract<br>vulnerability assessment based on machine learning and fuzz testing[C]//Proceedings of the 6th International Conference on Internet of Things: Systems, Management and Security, Granada, Oct 22-25, 2019. Piscataway: IEEE, 2019: 458-465.</li><li>GasFuzzer 检测交易中有较高gas 消耗异常的工具</li></ul><h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><p>多将代码转换为控制流图，利用CFG进行切片，对切片矩阵建立了机器学习的决策模型</p><p>准确率较高，研究丰富</p><h3 id="其他方法的漏洞检测技术"><a href="#其他方法的漏洞检测技术" class="headerlink" title="其他方法的漏洞检测技术"></a>其他方法的漏洞检测技术</h3><p>以太坊中，透明公开的智能合约占了总交易量和总交易金额的2/3 左右，但是有大约77.3%的智能合约是不透明非开源的</p><ul><li><p>Erays 采用逆向工程进行漏洞检测，难以实现高自动化，更适合于手动分析并且高度依赖专家经验 ZHOU Y, KUMAR D, BAKSHI S, et al. Erays: reverse engineering Ethereum’s opaque smart contracts[C]//Proceedings of the 27th USENIX Security Symposium, Baltimore, Aug 15-17, 2018. Berkeley: USENIX Association, 2018: 1371-1385.</p></li><li><p>Dc-Hunter 计算待检测合约和已知合约的相似性</p></li><li>Slither 将智能合约转化为中间表示SlithIR  FEIST J, GREICO G, GROCE A. Slither: a static analysis<br>framework for smart contracts[C]//Proceedings of the 2nd International Workshop on Emerging Trends in Software Engineering for Blockchain, Montreal, May 27, 2019. Piscataway: IEEE, 2019: 8-15.</li><li>EASYFLOW  GAO J B, LIU H, LIU C, et al. EASYFLOW: keep Ethereum away from overflow[C]//Proceedings of the 41st International Conference on Software Engineering: Companion Proceedings, Montreal, May 25-31, 2019. Piscataway: IEEE, 2019: 23-26.</li><li>SmartCheck  TIKHOMIROV S, VOSKRESENSKAYA E, IVANITSKIY I, et al. SmartCheck: static analysis of ethereum smart contracts [C]//Proceedings of the 1st IEEE/ACM International Workshop on Emerging Trends in Software Engineering for Blockchain, Gothenburg, May 27-Jun 3, 2018. New York:ACM, 2018: 9-16.</li></ul><h3 id="各类方案存在的问题"><a href="#各类方案存在的问题" class="headerlink" title="各类方案存在的问题"></a>各类方案存在的问题</h3><ul><li>形式化验证：数学推导和证明门槛高，自动化程度低</li><li>符号执行：涉及到路径遍历和约束问题，耗时</li><li>模糊测试：随机种子难以设计</li><li>机器学习方法：检测结果最好，依赖于开源的智能合约；需要对每种漏洞进行建模，降低了通用性</li><li>特征匹配：依赖开源代码，误报率高</li></ul><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p>450个智能合约</p><p>对VaaS、Oyente、ContractFuzzer、DR-GCN、Slither进行了对比，主要测试可重入和可预测变量的依赖两种类型漏洞进行检测</p><p><img src="/2023/06/20/blockchain-security-survey/image-20230620193254180.png" alt="image-20230620193254180"></p><p>实验结果显示机器学习的准确率最高，效率较高，但是支持的漏洞少，通用性差</p><p>Vaas 是商用级别的漏洞检测工具</p><h2 id="未来研究方向"><a href="#未来研究方向" class="headerlink" title="未来研究方向"></a>未来研究方向</h2><ul><li>符号执行的路径优化</li><li>提高自动化程度：深度学习</li><li>提高漏洞类型覆盖率：目前众多漏洞检测工具个体支持检测的漏洞类型最多不超过10 种，但现有常见的漏洞类型多达 20 多种。机器学习实现通用模型</li><li>准确率和效率：解决假阳等问题</li><li>智能合约开源程度较低</li><li>机器学习方法构建通用模型</li><li>跨平台的漏洞检测工具</li><li>缺乏统一的评价指标</li></ul><h1 id="区块链安全问题-研究现状与展望-袁勇-自动化学报"><a href="#区块链安全问题-研究现状与展望-袁勇-自动化学报" class="headerlink" title="区块链安全问题: 研究现状与展望-袁勇-自动化学报"></a>区块链安全问题: 研究现状与展望-袁勇-自动化学报</h1><p>定义了区块链系统设计追求的安全目标, 从机制漏洞、攻击手段和安全措施三方面对区块链各层级的安全问题进行全面分析, 提出了区块链的平行安全概念框架, 并总结未来区块链安全问题的研究重点.</p><h2 id="区块链的安全目标"><a href="#区块链的安全目标" class="headerlink" title="区块链的安全目标"></a>区块链的安全目标</h2><p><img src="/2023/06/20/blockchain-security-survey/image-20230620200830216.png" alt="image-20230620200830216" style="zoom:67%;"></p><ul><li><p>实现保密性需要设计三类机制</p></li><li><p>共识安全部分主要参考了backbone，需要阅读这篇</p></li><li><p>强一致性不会出现分叉，确认快，前向安全</p></li><li><p>隐私保护</p><ul><li>身份隐私保护身份信息、物理地址、IP和链上的公私钥不关联</li><li>交易隐私保护：交易本身对非授权节点匿名，交易之间的关联被切断</li></ul></li><li><p>智能合约安全</p><ul><li>编写安全<ul><li>设计没问题</li><li>代码安全</li></ul></li><li>运行安全：合约执行出现漏洞或被攻击后，不会对节点和本地设备造成影响，不会影响调用合约的其他合约异常<ul><li>模块化：智能合约的高内聚低耦合</li><li>隔离运行：运行在虚拟化等隔离环境中</li></ul></li></ul></li></ul><h2 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h2><p>数据层、网络层、共识层、激励层、合约层和应用层六层</p><p><img src="/2023/06/20/blockchain-security-survey/image-20230620203308163.png" alt="image-20230620203308163"></p><ul><li>数据层：<ul><li>量子计算</li><li>密钥管理：区块链应用中的主流密钥管理方法包括本地存储、离线存储、托管钱包和门限钱包. <ul><li>密钥保护秘密分享[CCS11]</li></ul></li><li>交易联系：环签名、零知识证明、zk-SNARK</li><li>代码漏洞：数字签名的延展性</li></ul></li><li>网络层<ul><li>P2P: 缺乏身份认证、节点实际上身份不对等</li><li>网络拓扑：日蚀攻击</li><li>隐私：数据与IP地址的关联性；Tor；<ul><li>混币：去中心化和中心化混币</li></ul></li></ul></li><li>共识层：共识机制在安全性建模时需要考虑网络时序性、节点数量拓展、在线离线切换、算力或权益的动态分布、共识难度变更、区块链增长速率等多变量因素. 由于共识机制下层的网络环境复杂, 新的共识机制不断涌现, 传统的可证明安全框架无法完全适用于区块链. 共识机制的安全性面临建模困难、安全性证明不完备的问题.<ul><li>又提到了backbone</li><li>目前对共识机制的可证明安全研究集中在PoW和PoS中</li><li>假设不可靠：依赖诚实节点拥有的算力和权益大多数</li><li>一致性：弱一致性共识算法可能存在分叉<ul><li>受网络影响严重，同步性缺失时无法保持强一致性</li></ul></li><li>分片：周期性节点轮换、跨片交易的原子性</li><li>Dust Attack: 造成网络拥堵、大量交易排队验证；可能泄露账户关联性</li><li>区块链初始化困难问题：创世区块的安全生成<ul><li>依赖第三方</li><li>由现有的、成熟的区块链过渡到新区块的创世区块</li></ul></li></ul></li><li>激励层：激励层还需要策略性行为检测和动态的奖励机制优化，主要解决经济学的 激励不相容问题<ul><li>无利害关系攻击Nothing at Stake: 利益最大化的矿工会同时在分叉上进行挖矿</li><li>区块奖励归零0，仅依赖交易费是否安全</li></ul></li><li>合约层：<ul><li>外部数据调用问题：Oracle作为可信实体，实际上无法保证一致性和真实性</li><li>形式化验证和程序分析工具不完善</li></ul></li></ul><h1 id="区块链公链应用的典型安全问题综述-魏松杰-软件学报"><a href="#区块链公链应用的典型安全问题综述-魏松杰-软件学报" class="headerlink" title="区块链公链应用的典型安全问题综述-魏松杰-软件学报"></a>区块链公链应用的典型安全问题综述-魏松杰-软件学报</h1><p>本文首先介绍了区块链技术, 回顾其面临的安全风险; 其次以比特币和以太坊两个典型系统为例, 剖析了针对面向代币交易和应用的区块链系统的各类安全威胁以及应对方法; 接着分析了钱包交易所等区块链周边设施和区块链用户的安全隐患; 最后对文中安全问题进行了分类总结, 提出可行技术线路和防御方法, 展望当前区块链安全的研究热点和发展趋势.</p><h2 id="区块链1-0-比特币的安全问题"><a href="#区块链1-0-比特币的安全问题" class="headerlink" title="区块链1.0 比特币的安全问题"></a>区块链1.0 比特币的安全问题</h2><p>重放攻击往往出现在存在硬分叉的区块链中,一条链上的交易数据在另一条链上也有极大可能也是合法的. 攻击者只需抓取一条链上的交易数据, 再复制到另一条链上广播, 即可发动重放攻击</p><p>空快攻击的防御思路：区块链设计者可以设计共识, 使矿工的收益与块中的交易数目挂钩, 打包的块中的交易越多, 矿工的奖励就越高; 使矿工的挖矿难度与块中的交易数目挂钩, 根据打包的块中的交易数目略微减少矿工的挖矿难度,使得包含交易多的块更容易被挖出, 从而激励矿工们打包更多的交易.</p><p>长程攻击（PoS）：</p><ul><li>变节攻击：利用其他地址里的权利, 例如B 的地址, 哪怕在攻击者进行攻击时B地<br>址内的权益已经清空了, 只要B的地址内在攻击者需要的历史时刻下有大量的权益, 攻击者在获得该地址的私钥后, 就可以利用自己和B 的权益进行变节攻击</li></ul><p>比特币等典型区块链中每个节点拥有两个节点表, NEW TABLE 存储了节点知晓但还未连接过的其他节点IP; TRIED TABLE 存储了曾经连接过但现在可能没有建立连接的其他节点IP. 攻击者需要利用傀儡节点IP或无效IP 填满两个节点表, 才能达到隔离节点的目的</p><h2 id="区块链2-0-以太坊的安全问题"><a href="#区块链2-0-以太坊的安全问题" class="headerlink" title="区块链2.0 以太坊的安全问题"></a>区块链2.0 以太坊的安全问题</h2><p>Gas 是以太坊为了防止恶意用户部署无限循环运行的合约, 而要求用户为所部署合约的每一步支付的费用, 智能合约的逻辑越复杂, 花费的 Gas 就越多. Gas价格是指花费每个Gas 所需要的以太币的数量, 可由用户自行调整</p><p>GHOST 协议, 以权重最高的子树作为合法主链</p><p><img src="/2023/06/20/blockchain-security-survey/image-20230622161248631.png" alt="image-20230622161248631"></p><p>交易顺序依赖攻击：降低实际开销成本</p><h2 id="区块链周边安全问题"><a href="#区块链周边安全问题" class="headerlink" title="区块链周边安全问题"></a>区块链周边安全问题</h2><ul><li>钱包<ul><li>在线钱包（热钱包）外界通过互联网访问私钥存储的地方</li><li>冷钱包：非联网状态，能够避免黑客攻击。硬件设备设计的缺陷可能存在==导致漏洞</li></ul></li><li>矿池：<ul><li>远程管理机制</li><li>恶意挖矿策略<ul><li>自私挖矿：诚实节点为了获得超额的挖矿奖励，可能转入恶意矿池进行挖矿</li><li>跳池攻击：根据算力大小给矿池内参与挖矿的矿工结算收益, 结算模式有很多, 例如Proportional 模式、PPS 模式、PPLNS 模式等；<ul><li>在Proportional 模式下, 从矿池挖到上个区块到挖到当前区块的时<br>间被称为一个挖矿周期, 每个矿工的区块奖励与一个挖矿周期内其有效工作量证明(share) 所占全部有效工作量的百分比成正比. 因此矿工们收益最高的策略是当当前挖矿周期长度到达一个阀值后, 跳槽到另一个才发现新区块、挖矿周期较短的矿池重新开始挖矿</li><li>可以采用更优的收益结算模式，如PPS模式或者PPLNS模式</li><li>PPS: 矿工的收益=矿池用于奖励矿工的总币量×某个矿工提供的算力/当前网络难度.</li><li>PPLNS: 矿工的收益=矿池用于奖励矿工的总币量×出块时该名矿工提交的有效工作量证明在总有效提交中占比.</li></ul></li><li>扣块攻击：恶意矿工在挖到新区块后不向矿池提交, 而是直接丢弃该区块, 从而减少矿池收入的攻击.</li></ul></li></ul></li></ul><h2 id="用户的安全问题"><a href="#用户的安全问题" class="headerlink" title="用户的安全问题"></a>用户的安全问题</h2><ul><li>社会工程学</li><li>中间人攻击</li><li>撞库攻击</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>大多数攻击针对的是区块链的共识层，设计漏洞较少、安全性较高的共识算法</p><p>针对PoW的攻击比较多</p><p>研究问题与最新进展</p><ul><li>数据层<ul><li>量子计算</li><li>隐私保护：多方零知识证明</li></ul></li><li>网络层<ul><li>针对区块链网络的异常检测系统</li></ul></li><li>共识层<ul><li>避免双花攻击：跨链的双花攻击 doi: 10.1109/TPS-ISA48467.2019.00014</li><li>其他类型的双花攻击</li></ul></li><li>激励层<ul><li>设计新的矿池收益结算模式，避免跳池攻击</li><li>扣快攻击的解决策略</li></ul></li><li>合约层<ul><li>智能合约漏洞检测<ul><li>机器学习</li><li>智能合约代码修复，修复字节码</li></ul></li></ul></li><li>应用层<ul><li>分析查找非法交易相关地址</li></ul></li></ul><p>当前智能合约安全的研究重点主要为智能合约漏洞检测与修复. 现有的漏洞检测方案可以针对智能合约中的简单漏洞进行检测并提供审计报告, 部分降低了智能合约开发者出错的可能和人工审计成本. 但由于智能合约版本更新换代较快, 各个平台采用的智能合约底层框架不尽相同, 现有方案很难为所有平台所有版本的智能合约提供漏洞检测服务, 因此设计一种通用性强的智能合约漏洞检测工具是未来研究方向之一. </p><p>除了漏洞检测, 未来还可以通过研究标准化的智能合约编写工具以及智能合约漏洞自动修复工具来减少智能合约的安全风险. 另外, 站在智能合约设计者的角度, 为预防在复杂合约的编程过程中可能出现的安全漏洞以及因此而带来的风险, 设计一种“图灵完备”的安全脚本智能合约语言也是可以考虑的方案之一.</p><p>跨链场景下的攻击模型和防御方案</p><h1 id="区块链安全标准体系研究-伍前红"><a href="#区块链安全标准体系研究-伍前红" class="headerlink" title="区块链安全标准体系研究-伍前红"></a>区块链安全标准体系研究-伍前红</h1><p>智能合约就其本质而言，也是一种共识的概念。值得注意的是上述的共识机制、共识算法，都是针对已经发生的交易，进行记录并同步到所有节点。而智能合约究其目的，是确保未发生的交易，在条件满足后能自动触发并生成新的交易，并且这些未来的新交易能保证在各节点上记录的一致性。从这个意义上讲，智能合约是对未来交易的共识。具体而言，智能合约的技术包括合约的签署和分发，合约条件的触发以及最终的记录入链等。</p><p>主要讲解区块链的政策，在金融、医疗、物流等方面的实际应用</p><p>智能合约的安全漏洞</p><ul><li>整数溢出类</li><li>拒绝服务类：合约无法响应</li><li>竞争条件：重入、交易顺序依赖</li><li>底层函数误用</li><li>权限验证错误类：tx.origin</li><li>算法缺陷：伪随机数利用不够随机</li><li>用户错误使用：授权错误</li><li>可见性声明：未正确声明合约的接口，public和private等</li><li>段地址攻击、无限制增发和销毁</li></ul><p><img src="/2023/06/20/blockchain-security-survey/image-20230623103830841.png" alt="image-20230623103830841"></p><h1 id="区块链安全能力测评与分析报告2021-中国信通院"><a href="#区块链安全能力测评与分析报告2021-中国信通院" class="headerlink" title="区块链安全能力测评与分析报告2021-中国信通院"></a>区块链安全能力测评与分析报告2021-中国信通院</h1><p><img src="/2023/06/20/blockchain-security-survey/image-20230623121621506.png" alt="image-20230623121621506"></p><p><img src="/2023/06/20/blockchain-security-survey/image-20230623121657709.png" alt="image-20230623121657709"></p><p><img src="/2023/06/20/blockchain-security-survey/image-20230623121834821.png" alt="image-20230623121834821"></p><p><img src="/2023/06/20/blockchain-security-survey/image-20230623122149405.png" alt="image-20230623122149405"></p><p><img src="/2023/06/20/blockchain-security-survey/image-20230623122135523.png" alt="image-20230623122135523"></p><h1 id="智能合约漏洞及检测技术研究综述-网络安全技术与应用"><a href="#智能合约漏洞及检测技术研究综述-网络安全技术与应用" class="headerlink" title="智能合约漏洞及检测技术研究综述-网络安全技术与应用"></a>智能合约漏洞及检测技术研究综述-网络安全技术与应用</h1><ul><li>短地址漏洞：短地址漏洞通常指的是用户在交易所提取代币时，输入一个短地址，但交易所对用户所输入的地址长度没有检查其是否合法而引起的交易异常事件。以太坊虚拟机没有严格检查地址位数的机制，且具有自动补齐缺失位数的机制，这使短地址攻击漏洞更容易发生。为防范此漏洞，交易所需要做好校验用户输入地址长度工作，有效阻止恶意的短地址，减少经济损失</li><li>以太币冻结漏洞：合约需要设置接受和转出以太币的功能</li><li>时间戳依赖漏洞：更改可靠的时间戳来源</li><li><code>delegatecall()</code>函数可以任意执行其他智能合约的中的代码</li><li>可利用外部的随机数据源取代使用区块变量开发而成的PRG</li><li>存储变量重复命名</li><li>严格balance比较漏洞</li></ul><p><img src="/2023/06/20/blockchain-security-survey/image-20230623170930876.png" alt="image-20230623170930876"></p><ul><li>模糊测试是将自动或半自动生成的具有随机性的数据作为输入，运行将其作为输入数据的程序并持续监控，以检测程序异常情况。</li><li>符号执行是将输入数据变为符号值，程序的输出值是输入符号值的一个函数。</li><li>形式化验证通过形式化语言把合约中的概念、判断、推理转化成智能合约模型，可以消除自然语言的歧义性、不通用性，进而采用形式化工具对智能合约建模、分析和验证，进行一致性测试，最后自动生成验证过的合约代码，形成智能合约生产的可信全生命周期。</li><li>智能合约漏洞分析中，使用污点分析技术能够将来自程序外部的输入数据标记为污点数据，通过跟踪与污点数据相关的信息流向，可以判断污点数据及其相关数据是否会影响关键程序实现的功能完整性，进一步检测出合约程序漏洞。</li><li>程序分析技术<ul><li>静态分析</li><li>动态分析：运行时方法实现</li></ul></li></ul><p>漏洞检测的主流技术仍为模糊测试、符号执行以及形式化验证。但同时也存在一些问题，现有的检测技术难以形成全面、体系的智能合约检测框架；检测技术优势较为单一，无法兼顾多种检测技术优势；对运行中的智能合约，未实现灵活、有效的合约维护、升级机制。对漏洞检测技术的研究，有利于推动智能合约安全性研究，保障区块链上智能合约的安全，进而降低了合约参与者的经济风险。</p><h1 id="区块链的网络安全-威胁与对策-信息安全学报"><a href="#区块链的网络安全-威胁与对策-信息安全学报" class="headerlink" title="区块链的网络安全: 威胁与对策-信息安全学报"></a>区块链的网络安全: 威胁与对策-信息安全学报</h1><p>本文针对区块链数据的完整性、匿名性与隐私保护的安全需求, 系统分析了区块链的安全攻击, 综述了安全保护技术研究进展, 尤其对区块链密码学安全防护技术进行了对比分析。</p>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;论文&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;来源&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;内容&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;区块链安全问题：研究现状与展望&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;自动化学报  2019&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;本文定义了区块链系统设计追求的安全目标, 从机制漏洞、攻击手段和安全措施三方面对区块链各层级的安全问题进行分析, 提出了区块链的平行安全概念框架&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;区块链公链应用的典型安全问题综述&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;软件学报  2022&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;以比特币和以太坊为例, 剖析了针对面向代币交易和应用的区块链系统的各类安全威胁以及应对方法;  接着分析钱包和用户的安全隐患&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;区块链系统攻击与防御技术研究进展&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;软件学报  2020&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;本文从层级分类、攻击关联分析两个维度对区块链已有安全问题的系统架构、攻击原理、防御策略展开研究&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;区块链中攻击方式的研究&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;计算机学报  2021&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;分析区块链攻击方式，提出了对攻击方式的分类方法，体现了不同攻击方式间的差异性和关联性，归纳攻击的特点并给出了预防措施和检测方法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;智能合约漏洞检测研究综述&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;计算机科学与探索  2022&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;通过对常见漏洞的分析，漏洞检测方法和工具的国内外现状调研并分析优缺点，复现部分工具进行实验，以检测速度、准确率以及支持的漏洞数量为标准，展示漏洞检测工具的性能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;区块链的网络安全：威胁与对策&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;信息安全学报  2018&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;本文针对区块链数据的完整性、匿名性与隐私保护的安全需求, 系统分析了区块链的安全攻击, 综述了安全保护技术研究进展&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;智能合约漏洞及检测技术研究综述&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;网络安全技术与应用 2022&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;详细介绍了智能合约的14种典型安全漏洞，总结了漏洞防范的方法；针对漏洞检测技术进行分类，介绍检测工具解决的问题，实现原理，比较检测技术和工具的优劣&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;区块链安全能力测评与分析报告&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;中国信通院  2021&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;综合分析区块链基础设施安全能力测评情况，总结了安全隐患，对2021-2023年区块链基础设施安全新方向提出展望&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;网络安全国家标准研究项目研究报告&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;北航  伍前红 2018&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;国内外区块链发展现状和相关政策；区块链安全需求以及面临的主要威胁；区块链应用典型案例；区块链安全参考架构；区块链安全标准化建议&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;区块链的安全威胁与取证&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;付章杰-南京信息工程大学&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;本报告介绍了区块链取证的背景，区块链取证的研究现状与存在的技术挑战，研究内容主要包括通用感知和精准取证&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/categories/Blockchain/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="SmartContract" scheme="https://alleysira.github.io/tags/SmartContract/"/>
    
  </entry>
  
  <entry>
    <title>Sharding_Blockchain_Consensus</title>
    <link href="https://alleysira.github.io/2023/05/31/Sharding-Blockchain-Consensus-lyj/"/>
    <id>https://alleysira.github.io/2023/05/31/Sharding-Blockchain-Consensus-lyj/</id>
    <published>2023-05-31T08:23:34.000Z</published>
    <updated>2023-07-23T10:47:12.730Z</updated>
    
    <content type="html"><![CDATA[<p>云南创新研究院研讨会 刘懿中老师分片共识研究分享</p><span id="more"></span><h1 id="分片区块链共识机制研究"><a href="#分片区块链共识机制研究" class="headerlink" title="分片区块链共识机制研究"></a>分片区块链共识机制研究</h1><h2 id="区块链共识机制"><a href="#区块链共识机制" class="headerlink" title="区块链共识机制"></a>区块链共识机制</h2><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531163125372.png" alt="image-20230531163125372"></p><p>1982年提出了拜占庭将军问题</p><p>FLP提出异步环境下没有确定性一致算法</p><p>2016年ELASTICO是首个分片共识，结合数据库领域的分片技术</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531163950433.png" alt="image-20230531163950433"></p><p>分片的基本流程</p><ul><li>选出块者<ul><li>随机出块</li></ul></li><li>生成区块并广播</li><li>节点验证更新区块链</li></ul><p>一致性consistency：指诚实节点输出的交易互为前缀</p><ul><li>强一致性：PBFT</li><li>弱一致性：PoW PoS</li></ul><p>活性liveness：交易一定会被处理</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531164356367.png" alt="image-20230531164356367"></p><p>性能+安全性都取决于共识机制</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531164845023.png" alt="image-20230531164845023"></p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531164926354.png" alt="image-20230531164926354"></p><p>经典的分布式一致算法能够容忍宕机错误（crash）</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531165205097.png" alt="image-20230531165205097"></p><p>现在研究工作集中于异步网络环境下，信工所路远老师 清华段斯斯老师等均有相关研究工作</p><p>异步DKG，如何在动态环境下更新委员会，实现动态门限签名</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531165353683.png" alt="image-20230531165353683"></p><p>PoW的能防止女巫攻击</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531165444310.png" alt="image-20230531165444310"></p><p>PoW和PoS的安全性已经足够好了，但是性能比较低，设计混合共识的动机</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531165609984.png" alt="image-20230531165609984"></p><p>先用PoW和PoS选委员会，委员会内跑PBFT等</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531165938027.png" alt="image-20230531165938027"></p><p>多个委员会，每个委员会并行处理交易，分片登场了</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531170048237.png" alt="image-20230531170048237"></p><h2 id="分片区块链技术"><a href="#分片区块链技术" class="headerlink" title="分片区块链技术"></a>分片区块链技术</h2><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531170221192.png" alt="image-20230531170221192"></p><p>如果在安全性上妥协，可以提高可扩展性</p><p>分片的思想就是将节点划分到不同的子集，每个分片负责维护本分片区块链</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531170346117.png" alt="image-20230531170346117"></p><p>共识节点分片，交易分片</p><ul><li><p>计算分片：分片内只验证分片内的交易</p></li><li><p>存储分片：片内节点只存片内的区块链</p></li><li>通信分片：大多数情况不需要和分片外节点通信</li></ul><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531170603682.png" alt="image-20230531170603682"></p><p>时期epoch是为了防止节点的腐化攻击设置的，进行重新配置</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531170753693.png" alt="image-20230531170753693"></p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531171408957.png" alt="image-20230531171408957"></p><p>完整的分片区块链系统</p><ul><li>节点选择<ul><li>permissionless：PoW/PoS</li><li>permissioned：CA</li></ul></li><li>随机数生成与节点分配：节点划分为不同分片过程中一般需要随机化分配（不随机的方案需要考虑敌手控制的节点低于某个阈值）<ul><li>VRF 门限签名 VSS TEE</li></ul></li><li>分片内共识：都可以<ul><li>PBFT PoW</li><li>有的交易需要跨片协同交易</li></ul></li><li>跨片交易处理</li><li>分片重配置：应对敌手corruption</li><li>激励机制：有一些博弈论的结论</li></ul><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531171805722.png" alt="image-20230531171805722"></p><p>公平性是节点选中的概率相同，鲁棒性指一定能选出来</p><p>委员会中心化问题后续可以再了解了解</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531171935276.png" alt="image-20230531171935276"></p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531172038191.png" alt="image-20230531172038191"></p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531172228946.png" alt="image-20230531172228946"></p><p>BLS签名不管签名的 $t$ 个人是谁，签名是unique，需要DKG，实际上DKG</p><p>随机数生成复杂度一般是$O(n^2)$，因此需要先选一部分节点来做</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531173107903.png" alt="image-20230531173107903"></p><p>利用概率来考虑如何进行节点分配</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531173338979.png" alt="image-20230531173338979"></p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531173458813.png" alt="image-20230531173458813"></p><p>一致性的定义基于backbone protocol </p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531173630844.png" alt="image-20230531173630844"></p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531173726776.png" alt="image-20230531173726776"></p><p>2 phase commitment</p><ul><li>准备阶段 两个分片运行片内共识，确认交易可用性，锁定输入（防止双花，直到第二轮片内共识结束）</li><li>承诺阶段 </li></ul><p>多输入输出拆分后不需要跨片吗，没理解</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531174150817.png" alt="image-20230531174150817"></p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531174655816.png" alt="image-20230531174655816"></p><p>替换的方法：</p><ul><li>随机</li><li>时间规则（rapid chain）</li><li>有界布谷鸟</li></ul><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531174810883.png" alt="image-20230531174810883"></p><p>基于博弈论的思想，分片+博弈+reputation的研究很少，有研究价值</p><p>以上研究内容发表在computer science review，中科院Q1的综述</p><h2 id="Fleetchain"><a href="#Fleetchain" class="headerlink" title="Fleetchain"></a>Fleetchain</h2><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531175230991.png" alt="image-20230531175230991"></p><p>分片内签名可以聚合$O(n^2)\to O(n)$，是否可以在分片内签名聚合</p><p>片间复杂度同样降低$O(m^2)\to O(m)$</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531175429371.png" alt="image-20230531175429371"></p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531175438271.png" alt="image-20230531175438271"></p><p>共识协议的安全性一般依赖于数字签名的安全性</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531175529500.png" alt="image-20230531175529500"></p><p>将hotstuff每轮换leader改成stable leader</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531175600846.png" alt="image-20230531175600846"></p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531175612448.png" alt="image-20230531175612448"></p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531175639194.png" alt="image-20230531175639194"></p><p>两部分都是线性复杂度</p><h2 id="跨片交易处理"><a href="#跨片交易处理" class="headerlink" title="跨片交易处理"></a>跨片交易处理</h2><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531175713097.png" alt="image-20230531175713097"></p><p>交易输入地址可能是共有的，众筹服务器！</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531175835847.png" alt="image-20230531175835847"></p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531175944598.png" alt="image-20230531175944598"></p><p>由用户将每个分片给的证明再转发</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531180116957.png" alt="image-20230531180116957"></p><p>分片直接互相广播，用户无感知</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531180154281.png" alt="image-20230531180154281"></p><p>1个交易2个BFT，如果2次BFT处理1k个交易，输入merkle树根，输出树的路径证明</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531180335584.png" alt="image-20230531180335584"></p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531180437719.png" alt="image-20230531180437719"></p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531180507265.png" alt="image-20230531180507265"></p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531180613883.png" alt="image-20230531180613883"></p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531180625949.png" alt="image-20230531180625949"></p><h2 id="跨片视图转换"><a href="#跨片视图转换" class="headerlink" title="跨片视图转换"></a>跨片视图转换</h2><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531180651927.png" alt="image-20230531180651927"></p><p>不同分片的领导者片间可能作恶，片内诚实</p><p>比如片间不发送证明，领导者censor</p><p>思想是本分片监控其他分片领导者是否作恶，作恶则运行BFT给出作恶的证明，发送给作恶分片进行视图转换</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531180923215.png" alt="image-20230531180923215"></p><ul><li>记得扒一下老师的工作</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;云南创新研究院研讨会 刘懿中老师分片共识研究分享&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/categories/Blockchain/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="Consensus" scheme="https://alleysira.github.io/tags/Consensus/"/>
    
    <category term="Sharding" scheme="https://alleysira.github.io/tags/Sharding/"/>
    
  </entry>
  
  <entry>
    <title>FSS</title>
    <link href="https://alleysira.github.io/2023/05/06/FSS/"/>
    <id>https://alleysira.github.io/2023/05/06/FSS/</id>
    <published>2023-05-06T06:53:58.000Z</published>
    <updated>2023-06-06T09:50:06.382Z</updated>
    
    <content type="html"><![CDATA[<p>Elette Boyle’s lecture on FSS from <a href="[The 12th BIU Winter School on Cryptography | BIU Cyber Center](https://cyber.biu.ac.il/event/the-12th-biu-winter-school-on-cryptography/">12th BIU Winter School</a>)</p><span id="more"></span><h1 id="Function-Secret-Sharing"><a href="#Function-Secret-Sharing" class="headerlink" title="Function Secret Sharing"></a>Function Secret Sharing</h1><p><img src="/2023/05/06/FSS/image-20230506145622804.png" alt="image-20230506145622804"></p><p>简单介绍加性秘密分享</p><p>考虑分享一个秘密的函数，份额通信量非常小（compact）</p><p>FSS is compressing the truth table of additive secret sharing </p><p>3Hours：</p><ul><li>定义和性质</li><li>构造</li><li>扩展和应用</li></ul><h2 id="definition"><a href="#definition" class="headerlink" title="definition"></a>definition</h2><ul><li>$Gen(1^\lambda,f)\to(f_0,f_1)$ some times $k_0,k_1$</li><li><p>$Eval(b,k_b,x)\to y_b$, $x$ is the public input,$y_b$ is the output share </p><p>satisfying</p></li><li><p>secrecy (semantic security): $\forall f,f’ \in \mathcal{F}, \{k_b \in f\} \approx \{ k_b \in f’\}$</p><ul><li>statistically close</li><li>relaxed bond: relaxed on hardness problem</li><li>simulation security</li></ul></li><li><p>reconstruction: $y_0+y_1=f(x)$</p><ul><li>other forms are acceptable</li></ul></li><li><p>FSS For All functions(truth table)</p><ul><li>using additive secret sharing but the share size is  $O(2^n),where \ input\ len\ is\ nbits$</li></ul></li><li><p>Linear functions over ring $R$</p><ul><li>using  coefficients additive secret sharing</li></ul></li><li><p>polynomials</p><ul><li>also using  coefficients additive secret sharing</li></ul></li></ul><p>Notes: <em>secret</em> linear combination of <em>public</em> function of x and All the constructions above are information-secure </p><p>for some classes of functions can only get computational security</p><ul><li>Point functions<ul><li>$f_{\alpha,\beta}(x)=\alpha $ only when $x=\alpha$, else eval 0</li></ul></li></ul><h3 id="Sample-Application"><a href="#Sample-Application" class="headerlink" title="Sample Application"></a>Sample Application</h3><p>similar to PIR</p><p><img src="/2023/05/06/FSS/image-20230506154438168.png" alt="image-20230506154438168"></p><p> <img src="/2023/05/06/FSS/image-20230506154931929.png" alt="image-20230506154931929"></p><p>2服务器 计算安全的PIR的结果和FSS结果不谋而合 （<strong>corollary</strong>）</p><p>AES is unbreakable, means lightweight crypto</p><p>FSS for points Functions \to 2- server PIR</p><p><img src="/2023/05/06/FSS/image-20230506155829634.png" alt="image-20230506155829634"></p><p>正确显然成立，黑色框是0的秘密分享，$y_A\  y_B$求和后只剩下$val[i]$</p><p> FSS for Point Functions ⇒ Private Increment satisifying p</p><p>Q: garble circuits as a weak case of FSS</p><p>A: yes, reconstruction is not additive, former applications won’t go directly </p><p>Q: how to complete private read and write an the same time</p><p>A: Not possible. reading needs server to store same data, writing needs server to hold shared data, changing sever numbers may </p><p>Q: point functions can’t be described as low degree <strong>polynomial</strong> having FSS for low degree polynomials and FSS for distributed point function</p><h2 id="Construction"><a href="#Construction" class="headerlink" title="Construction"></a>Construction</h2><h3 id="point-functions"><a href="#point-functions" class="headerlink" title="point functions"></a>point functions</h3><p>DPF的第一个构造来自于[CG99]对PIR的构造，$n$是函数输入的bits</p><p><img src="/2023/05/06/FSS/image-20230606164441993.png" alt="image-20230606164441993"></p><h3 id="comparison-functions"><a href="#comparison-functions" class="headerlink" title="comparison functions"></a>comparison functions</h3>]]></content>
    
    
    <summary type="html">&lt;p&gt;Elette Boyle’s lecture on FSS from &lt;a href=&quot;[The 12th BIU Winter School on Cryptography | BIU Cyber Center](https://cyber.biu.ac.il/event/the-12th-biu-winter-school-on-cryptography/&quot;&gt;12th BIU Winter School&lt;/a&gt;)&lt;/p&gt;</summary>
    
    
    
    <category term="Crypto" scheme="https://alleysira.github.io/categories/Crypto/"/>
    
    
    <category term="Crypto" scheme="https://alleysira.github.io/tags/Crypto/"/>
    
  </entry>
  
  <entry>
    <title>Rabin81</title>
    <link href="https://alleysira.github.io/2023/04/14/Rabin81/"/>
    <id>https://alleysira.github.io/2023/04/14/Rabin81/</id>
    <published>2023-04-14T08:37:35.000Z</published>
    <updated>2023-07-23T10:46:47.907Z</updated>
    
    <content type="html"><![CDATA[<p>Michael O. Rabin. How to exchange secrets with oblivious transfer. Technical Report TR-81, Aiken Computation Lab, Harvard University, 1981.</p><span id="more"></span><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Alice和Bob分别拥有一个对方想要解密的加密文件，密钥为1 bit秘密$SA\ SB$，因此两人想要交换$SA\ SB$</p><p>但是存在问题，如果密钥错误，文件会损坏不能再解密。因此Alice和Bob都想要保证能够正确解密文件</p><p>如果Bob给了Alice错误的密钥$S\neq SB$，交换得到了正确的$SA$，这是Alice不希望发生的情况</p><p>如果Bob发送一条消息， <strong>My secret is S, signed Bob.</strong> Alice可以收到$S$后不发给Bob $SA$，这是Bob不希望发生的情况，Alice也可以耍赖 <strong>“I gave Bob the password SA and he has not used it; I am willing to reveal it again right now.”</strong> 尽管Bob最终能够得到$SA$，Alice已经占据了时间优势</p><p>进行归纳，协议的流程总是分为$Alcie \to^{I_i} Bob, Bob \to^{J_i} Alice $，总会存在一个$k$满足Bob可以从$\{I_1,\dots,I_k\}$中得知$SA$，而Alice不能从$\{J_1,\dots,J_{k-1}\}$中得知$SB$，因此需要设计一种协议保证：</p><p>当Bob得知$SA$时，Alice一定可以得知$SB$</p><p>假设：当Bob发送$SA$去读文件时，Alice能够知道这一情况；反之亦然</p><h1 id="Exchange-of-Secrets-Protocol"><a href="#Exchange-of-Secrets-Protocol" class="headerlink" title="Exchange of Secrets Protocol"></a>Exchange of Secrets Protocol</h1><p>假设Alice和Bob目前分别有了公钥$K_A,K_B$可以进行公钥加密与签名。为了简洁，后续的流程中省略了签名</p><ul><li><p>Alice选择两个大素数$p,q$并计算一次性密钥$n_A=pq$，发送给Bob</p></li><li><p>类似地，Bob选择两个大素数$p_1,q_1$并计算一次性密钥$n_B=p_1q_1$，发送给Alice</p></li><li><p>Bob随机选$x\leq n_A$，计算$c \equiv x^2 \bmod n_A$，发送$c$给Alice</p></li><li><p>Alice已知$p,q$，计算出$x_1^2\equiv c \bmod n_A$，发送$x_1$给Bob</p><ul><li>可能会有四个解$\pm x,\pm y$</li><li>Bob可能作弊，发送自己无法求根的$c$，可能会允许R分解$n$，可以通过添加零知识证明来防御 [GMR85]</li></ul></li><li><p>Bob计算$gcd(x-x_1,n_A)=d$，有$Pr(d=p\ or\ q)=1/2$</p><ul><li>如果$x_1\neq \pm x,x_1^2 -x^2\equiv 0 \bmod n_A,(x_1-x)(x_1+x)\equiv0 \bmod n_A$</li><li>即得知 $p,q$，所以概率$Pr(d=p\ or\ q)=1/2$</li></ul></li><li><p>Bob同样执行 $3-4$ 步，定义</p></li><li><script type="math/tex; mode=display">v_B=\begin{cases}0 & if\ gcd(x-x_1,n_A)=p\ or \ q\\1 & otherwise\end{cases}</script></li><li><p>Bob发送$\varepsilon_B=S_B\oplus v_B$</p></li><li><p>同样地，Alice发送$\varepsilon_A=S_A\oplus v_A$</p></li><li><p>Alice将秘密$S_A$放在消息$m_A$中，采用公钥加密$E_{n_A}(m_A)=C$并发送给Bob</p><ul><li>提供$m_A$的一小段前缀来区分4个根</li><li>公钥加密算法采用依赖整数分解的算法即可</li></ul></li><li><p>Bob将秘密$S_B$放在消息$m_B$中，采用公钥加密$E_{n_B}(m_B)=C’$并发送给Bob</p></li></ul><h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p>定理：任何参与方都不能获得秘密的概率为$1/4$</p><p>证明：如果任何参与方在协议正常结束前终止交互，另一方也会停止，两方都无法获得对方的秘密。</p><p>不妨设Alice已经发给了Bob$E_{n_A}(m_A)$，Bob成功解密并对比得到$SA$，当Bob尝试使用$SA$进行文件解密时，根据假设，Alice能够得知$v_B=0$，因此Alice能够计算出$S_B=\varepsilon_B \oplus v_B$；Bob发送$E_{n_B}(m_B)$的情况同理；</p><p>因此任何参与方都不能获得秘密的概率为两方都不能计算出$p,q,p_1,q_1$的概率，即$(1/2)^2=1/4$</p><h2 id="Remark"><a href="#Remark" class="headerlink" title="Remark"></a>Remark</h2><ul><li><p>协议不能迭代执行，考虑当Alice已经知道$SB$，但是直到第二轮结束才查询文件，Bob可能不知道第二轮的$v_A=0$是否成立</p></li><li><p>可以通过修改OT子协议实现正确率</p><ul><li>收到$n_A$后，Bob随机选$x,y\leq n_A$，发送$x^2,y^2 \bmod n_A$，收到解$x_1,y_1$后不知道$p,q$的概率为$1/4$</li><li>协议总的失败率为$(1/4)^2=1/16$</li><li>但是这种方法存在一个上限，如果$Pr[v_B=0]\to0$，则Alice很可能认为Bob知道p，q，即$Pr[\varepsilon_B=S_B]\to 1$</li></ul></li></ul><h1 id="Future-work"><a href="#Future-work" class="headerlink" title="Future work"></a>Future work</h1><ul><li>OT子协议在没有假设的前提下也是有效的，是否能找到其他应用场景</li><li>对EOS协议的假设能否变弱、</li><li>能否构造永远能终止的EOS，或者有人能证明非零的不终止概率是必要的？</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Michael O. Rabin. How to exchange secrets with oblivious transfer. Technical Report TR-81, Aiken Computation Lab, Harvard University, 1981.&lt;/p&gt;</summary>
    
    
    
    <category term="MPC" scheme="https://alleysira.github.io/categories/MPC/"/>
    
    
    <category term="MPC" scheme="https://alleysira.github.io/tags/MPC/"/>
    
    <category term="OT" scheme="https://alleysira.github.io/tags/OT/"/>
    
  </entry>
  
  <entry>
    <title>SV21</title>
    <link href="https://alleysira.github.io/2023/04/13/SV21/"/>
    <id>https://alleysira.github.io/2023/04/13/SV21/</id>
    <published>2023-04-13T10:46:04.000Z</published>
    <updated>2023-07-23T10:47:19.180Z</updated>
    
    <content type="html"><![CDATA[<p>[SV21 ISIT]Private Data Access in Blockchain Systems Employing Coded Sharding</p><p>面向编码分片的区块链（PolyShard），数据采用RS码编码后保存，采用PIR保护余额查询</p><span id="more"></span><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>区块链的共识主要包含两方面：</p><ul><li>谁拥有出块的权利</li><li>谁对链的视图将被所有人认可</li></ul><p>在比特币中分别为PoW和最长链原则</p><p>区块链系统的三个性能指标：</p><ul><li>security threshold：区块链系统能容忍的恶意节点数量，取决于共识算法</li><li>吞吐量：每个时间单元的交易量，区块大小固定时，可以根据验证通过的区块数量衡量</li><li>存储效率：每个节点存储完整区块链数据的比例</li></ul><p>比特币和以太坊采用完整复制的思想，导致存储效率为最低值1</p><p>水平扩展（horizontal scaling）：随着网络规模线性地增加吞吐量、降低存储效率</p><p>编码分片（coded sharding）被认为是解决不可能三角的方案之一</p><p>区块链的分片是指将将网络划分为小的子网，每个子网掌握不相交的交易集合和不相交的账户</p><p>编码的分片中，区块链是一个编码的块形成的链，是对跨分片的块进行编码得到的</p><h1 id="Privacy-in-Blockchain"><a href="#Privacy-in-Blockchain" class="headerlink" title="Privacy in Blockchain"></a>Privacy in Blockchain</h1><p>假名（pseudonym）：公钥</p><p>钱包：与发送方和接收方相关联的一对假名</p><p>交易的隐私包含：</p><ul><li>被记录到区块里的过程</li><li>上链后从区块里读：如果客户端下载了完整的账本，敌手无法发现与客户端相关的账户<ul><li>但是随着区块链规模增加，会影响客户端的存储</li><li>采用SPV，只需要存储区块头，但是只能验证支付，无法验证</li></ul></li></ul><p>目前保护<em>余额查询</em> 这一过程隐私的方法：</p><ul><li>钱包假名机制是暂时的，即可以更换公钥</li><li>公钥无法追踪到用户身份</li></ul><p>It is not difficult to realize that transaction-privacy based on ephemeral nature of wallets is an illusion. （好有哲理）</p><p>因此有了中心化的混币机构（可能作恶，可能滥用财产，容易受到去匿名攻击）</p><p>如果采用PIR，可以实现余额查询的隐私保护</p><h2 id="Private-Information-Retrieval"><a href="#Private-Information-Retrieval" class="headerlink" title="Private Information Retrieval"></a>Private Information Retrieval</h2><p>$n$个服务器，每个服务器都有完整的$k$个比特的字符串$(x_1,x_2,\dots,x_k)$，获取$x_i$，但是任何服务器都不知道哪个比特被查询了</p><p>评价PIR的标准之一是rate，是指取回的符号/下载的符号，类似有效率</p><h2 id="Contribution"><a href="#Contribution" class="headerlink" title="Contribution"></a>Contribution</h2><ul><li>形式化了使用PIR在编码分片区块链上进行交易隐私保护</li><li>构造了从RS码存储的数据中进行查询的PIR</li><li>容忍最多$n-k$半诚实服务器合谋</li></ul><h1 id="Transaction-Privacy-with-Coded-Sharding"><a href="#Transaction-Privacy-with-Coded-Sharding" class="headerlink" title="Transaction Privacy with Coded Sharding"></a>Transaction Privacy with Coded Sharding</h1><h2 id="Private-Data-Access-System-model"><a href="#Private-Data-Access-System-model" class="headerlink" title="Private Data Access: System model"></a>Private Data Access: System model</h2><p>节点个数为$n$，分片个数为$k$，每个分片内账户总数为$m$</p><p>同步网络，网络可以是动态的，但是假设网络规模永远为$n$个节点</p><p>主要考虑$T$个epoch，$B_j(t)$表示第$j$个分片内的区块，$j\in[k],t\in[T]$，假设没有跨片交易，$X_j(t)$为$B_j(t)$包含的交易</p><p>$X_j(t)=(X_j^{send}(t),X_j^{receive}(t))$</p><p>$X_j^{send}(t),X_j^{receive}(t)$每个元素都属于$\mathbb{F}_q^m$，即$(1\times m)$向量，$q$的值取决于单个交易的最大单元</p><p>账户$p$向账户$q$发送b个单位密码货币，记为</p><script type="math/tex; mode=display">X_j^{send}(t,p)=-b,X_j^{receive}(t,q)=b</script><p>$X_j^{send}(t,p)$是$X_j^{send}$的第$p$个分量</p><p>只考虑线性码，第$i$个节点在epoch $t$存储$Y_i(t)$的是$\{X_j(t),j\in[k]\}$的线性组合</p><script type="math/tex; mode=display">Y_i(t)=\sum^k_{j=1}g_{ij}X_j(t),i\in[n]</script><p>$g_i=[g_{i1},\dots,g_{ik}]^T$是第$i$个节点的生成向量，$X_j(t)$为$1\times 2m$向量，考虑$T$个epoch后节点$i$的内容$Z_i(T)$</p><script type="math/tex; mode=display">Z_i =\left[\begin{matrix}Y_i(1)\\Y_i(2)\\\vdots\\Y_i(T)\end{matrix}\right]= \left[\begin{matrix}X_1(1) &\dots & X_k(1) \\X_1(2) &\dots  &X_k(2)  \\\vdots  &\ddots  &\vdots \\X_1(T) & \dots & X_k(T) \end{matrix}\right]\left[\begin{matrix}g_{i1}\mathbb{1}_{2m}  \\g_{i2}\mathbb{1}_{2m} \\\vdots  \\g_{ik}\mathbb{1}_{2m}  \end{matrix}\right]=U \cdot(g_i \otimes\mathbb{1}_{2m})\\</script><p>$\mathbb{1}_{2m}$是$2m\times1$维的全1向量，$U:(T\times 2km)$包含了$T$个epoch内所有分片，涉及总用户$km$的交易历史</p><p>考虑$j$个分片内的用户$p$，会想知道自己付的钱是否被打包，即$X_j(t),U(t,2(j-1)m)$</p><p>每一行为一个epoch，出块$k$个，第$j$个块的范围为$[2(j-1)m,2mj]$，则$p$对应的send位置为$2(j-1)m+p$;</p><p>同理，可以查询receive位置$2(j-1)m+p+m=2j+p-m$</p><p>如果服务器对send位置和receiver位置（即p）不知情（oblivious），能够防御恶意服务器将假名和用户的真实网络地址联系起来</p><p>统计账户可以记作$\sum_{t=1}^T U(t,2(j-1)m+p)+U(t,2j-m+p)$</p><p>服务器可以分为：</p><ul><li>curious-but-honest：想要猜出$p$，但是会正确响应</li><li>stragglers：拖延很久争取时间猜出$p$，之后正确响应</li><li>malicious：尝试猜出$p$，可能返回错误结果</li></ul><p>当用户$p$想要读取$X_j(t,p)=U(t,2(j-1)m+p)$时，生成$n$个随机的$1\times 2m$向量$\{q_i(j,p)\in\mathbb{F}_q^{2m}|i=1,2,\dots,n \}$，向第$i$个节点发送$(t,q_i(j,p))$</p><p>每个节点返回$\mathcal{A}(Y_i(t),q_i(j,p)):=a_i=q_i(j,p)^TY_i(t)$，扩张n倍</p><p>收到所有$a_i$后，计算$\hat{X}_j(t,p)=\sum^n_{i=1} a_i$</p><p>协议需要满足：</p><ul><li>正确性：$\hat{X}_j(t,p)=X_j(t,p)$对所有$j,p$均成立</li><li>隐私性：信息论安全 对在$\{1,\dots,2m\}$均匀随机的$P$和curious-but-honest的服务器集合$\mathcal{D}$，满足 $I(P:\cup_{i\in\mathcal{D}}q_i(j,p))=0$</li></ul><h2 id="Overiew-of-Reed-Solomon-Codes"><a href="#Overiew-of-Reed-Solomon-Codes" class="headerlink" title="Overiew of Reed-Solomon Codes"></a>Overiew of Reed-Solomon Codes</h2><p>假设采用广义RS码 (generalized Reed-Solomon code, GRS) 对区块进行编码</p><h3 id="复习信息论"><a href="#复习信息论" class="headerlink" title="复习信息论"></a>复习信息论</h3><p>$(n,k)$ 线性码：n是码长，k是线性空间维数</p><p><img src="/2023/04/13/SV21/image-20230415101504909.png" alt="image-20230415101504909" style="zoom:50%;"></p><p>生成矩阵：$G:k\times n$，每一行是生成向量</p><p>校验矩阵：$H: (n-k)\times n$，每一行是一个n元线性方程组的系数，$n-k$ 行确定了一个n维线性空间</p><p>若c为码字，有$Hc^T=0$</p><p><img src="/2023/04/13/SV21/image-20230415101709876.png" alt="image-20230415101709876" style="zoom:50%;"></p><p><img src="/2023/04/13/SV21/image-20230415102007666.png" alt="image-20230415102007666" style="zoom:50%;"></p><p>$C_{GRS}$是MDS码，最小距离$n-k+1$</p><p><img src="/2023/04/13/SV21/image-20230415103611131.png" alt="image-20230415103611131" style="zoom: 67%;"></p><p>$H_{(n-k)\times A},A\leq n-k$ 列满秩，说明$H$内 存在$A\times A$可逆矩阵</p><h2 id="Private-Data-Access-with-Curious-but-honest-Servers"><a href="#Private-Data-Access-with-Curious-but-honest-Servers" class="headerlink" title="Private Data Access with Curious-but-honest Servers"></a>Private Data Access with Curious-but-honest Servers</h2><p>如果敌手是malicious，可以通过固定查询检测出，所有回复$q^TY_1(t)\dots q^TY_n(t)$是一个码字，则$q^TY_1(t)\in \mathbb{F}_q$</p><p>因此从敌手的角度来说保持curious but honest是更加明智的选择</p><p>假设curious but honest服务器的数量 $d\leq n-k$</p><h3 id="PIR-protocol"><a href="#PIR-protocol" class="headerlink" title="PIR protocol"></a>PIR protocol</h3><p>构造查询向量的思想：混合</p><ul><li>$\mathcal{C}_{GRS}$的奇偶校验向量（思想来自于[TIT18]）</li><li>半随机向量(q)</li><li>生成矩阵的逆矩阵的行向量</li></ul><p>最终用户$p$构造的查询向量为$\{q_i(j,p)\in \mathbb{F}^{2m}_q|i=1,\dots,n\}$</p><p>分别向每个服务器$i$发送查询$q_i(j,p),t$</p><p>收到回复$\mathcal{A}(Y_i(t),q_i(j,p))=a_i=q_i(j,p)^TY_i(t)$后，客户端计算$X_j(t,p)=\sum^n_{i=1} a_i$</p><p>以下给出查询向量$q_i(j,p)$的构造方式：</p><p>分别记GRS码的校验矩阵和生成矩阵为：</p><script type="math/tex; mode=display">H_{GRS}=\left [\begin{matrix}h_1^T\\h_2^T\\\vdots \\h^T_{n-k}\end{matrix}\right ]_{(n-k) \times n} G_{GRS}=\left [\begin{matrix}G_1 \  G_2\end{matrix}\right ]_{k \times n}</script><p>其中$G_1:k\times k,G_2:k\times(n-k)$，$G_1$是$G_{GRS}$可逆的子矩阵，$h^T_l=[h_{l1},h_{l2},\dots,h_{ln}],1\leq l\leq(n-k)$</p><p>$G_1^{-1}=[\tilde\phi_1,\dots,\tilde\phi_k],\tilde\phi_i:k\times 1,\phi_j^T=[\tilde\phi_j \ 0]_{1\times n}$，即$\tilde\phi_j$后面补$n-k$ 个$0$</p><p>假设curious but honest服务器的数量为$d$</p><p>均匀随机选择$d$个向量$r_1,\dots,r_d \in \mathbb{F}^{2m}_q$，计算$r_{d+1}=(\sum^d_{i=1} r_i)+e_p$，其中$e_p=[0\ 0\ \dots\ 1_p\ \dots\ 0]_{2m \times 1}$</p><script type="math/tex; mode=display">R_p=[r_1 \  r_2\  \dots \ r_{d+1}]_{2m \times (d+1)}\\\Psi_j=\left [\begin{matrix}h_1^T + \phi_j^T\\h_2^T+\phi_j^T \\\vdots\\h_d^T+\phi_j^T\\\phi_j^T\end{matrix}\right ]_{(1+d)\times n}\\Q=R_p\Psi _j:2m\times n</script><p>此时矩阵$Q$的每一列分别为$q_i(j,p)$，令$\varphi_{i}=\phi^T_{ji},i\in[n]$</p><script type="math/tex; mode=display">q_1(j,p)=\left[\begin{matrix}\sum^{d}_{k=1} r_{k,1}(h_{k,1}+\varphi_1 )+r_{d+1,1}\varphi_{1}\\\sum^{d}_{k=1} r_{k,2}(h_{k,1}+\varphi_1 )+r_{d+1,2}\varphi_{1}\\\vdots \\\sum^{d}_{k=1} r_{k,2m}(h_{k,1}+\varphi_1 )+r_{d+1,2m}\varphi_{1}\end{matrix}\right ]\\q_i(j,p)=\left[\begin{matrix}\sum^{d}_{k=1} r_{k,1}(h_{k,i}+\varphi_i )+r_{d+1,1}\varphi_{i}\\\sum^{d}_{k=1} r_{k,2}(h_{k,i}+\varphi_i )+r_{d+1,2}\varphi_{i}\\\vdots \\\sum^{d}_{k=1} r_{k,2m}(h_{k,i}+\varphi_i )+r_{d+1,2m}\varphi_{i}\end{matrix}\right ],i\in[n]</script><p>接下来证明这种构造满足正确性和隐私性</p><h3 id="Privacy"><a href="#Privacy" class="headerlink" title="Privacy"></a>Privacy</h3><p>设作恶的服务器为$d\leq n-k,\mathcal{D}={i_1,\dots,i_d}$，则发送给所有作恶节点的查询向量组成$2m\times d$的矩阵$Q_D$</p><p>对$R=[r_1 \ r_2 \cdots \ r_d ]_{2m\times d},E_p=[e_p \ \cdots \  e_p]_{2m\times d},rank-one,\Phi=[h_1 \ h_2 \ \cdots \ h_d]_{d\times d}$</p><script type="math/tex; mode=display">\Delta_D=\left[\begin{matrix}\hat\phi_{j1} \\& \hat\phi_{j2} \\& & \ddots\\& & & \hat\phi_{jd}\end{matrix}\right ]_{d\times d}</script><p>有$Q_D=R_p \cdot\Psi_{j,D}=R\Phi+ E_p\Delta _D$</p><h3 id="Correctness"><a href="#Correctness" class="headerlink" title="Correctness"></a>Correctness</h3><p>根据$a_i=q_i(j,p)^TY_i(t),Y_i(t)=\sum^k_{j=1}g_{ij}X_j(t),i\in[n]$</p><script type="math/tex; mode=display">\begin{align}X_j(t,p) &=\sum^n_{i=1} a_i \\& = \sum_{i=1}^n q_i(j,p)^TY_i(t) \\& = (\sum_{l=1}^dr_l^T\sum^n_{i=1}(h_{l_i}+\phi_{ji})Y_i(t))+r_{d+1}\sum^n_{i=1}\phi_{ji}Y_i(t)\end{align}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;[SV21 ISIT]Private Data Access in Blockchain Systems Employing Coded Sharding&lt;/p&gt;
&lt;p&gt;面向编码分片的区块链（PolyShard），数据采用RS码编码后保存，采用PIR保护余额查询&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/categories/Blockchain/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="PIR" scheme="https://alleysira.github.io/tags/PIR/"/>
    
  </entry>
  
  <entry>
    <title>SecretFlow隐语PSI实验环境配置与测试</title>
    <link href="https://alleysira.github.io/2023/04/08/SecretFlow%E9%9A%90%E8%AF%ADPSI%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%B5%8B%E8%AF%95/"/>
    <id>https://alleysira.github.io/2023/04/08/SecretFlow%E9%9A%90%E8%AF%ADPSI%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%B5%8B%E8%AF%95/</id>
    <published>2023-04-08T14:03:51.000Z</published>
    <updated>2023-07-23T10:47:04.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SecretFlow隐语PSI实验环境配置与测试"><a href="#SecretFlow隐语PSI实验环境配置与测试" class="headerlink" title="SecretFlow隐语PSI实验环境配置与测试"></a>SecretFlow隐语PSI实验环境配置与测试</h1><p>配置SecretFlow 并测试两方PSI的效率</p><p>官方文档 <a href="https://www.secretflow.org.cn/docs/secretflow/zh_CN/developer/benchmark/psi_benchmark.html#">隐语PSI Benchmark白皮书 — SecretFlow 文档</a></p><span id="more"></span><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><p>配置conda</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install wget</span><br><span class="line">wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh</span><br><span class="line">bash Miniconda3-latest-Linux-x86_64.sh</span><br><span class="line"><span class="comment"># choose miniconda3 location</span></span><br><span class="line">~/.miniconda3</span><br><span class="line">Do you wish the installer to initialize Miniconda3 by running conda init? [yes|no]</span><br><span class="line">[no] &gt;&gt;&gt; yes</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"></span><br><span class="line">conda --version</span><br></pre></td></tr></table></figure><p>新建conda环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conda create -n sf-benchmark python=3.8</span><br><span class="line">conda activate sf-benchmark</span><br><span class="line">pip install -U secretflow</span><br><span class="line">mkdir sf-benchmark</span><br><span class="line">cd sf-benchmark</span><br></pre></td></tr></table></figure><p>生成.csv集合数据脚本，调用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 gene_psi.py 1000000</span><br></pre></td></tr></table></figure><p>脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python3 gene_psi.py</span></span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> sample</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_with_N_digits</span>(<span class="params">n</span>):</span></span><br><span class="line">    range_start = <span class="number">10</span> ** (n - <span class="number">1</span>)</span><br><span class="line">    range_end = (<span class="number">10</span>**n) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> randint(range_start, range_end)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">row_list = []</span><br><span class="line">len1 = <span class="number">10</span>**<span class="number">2</span></span><br><span class="line">len2 = <span class="number">10</span></span><br><span class="line">len3 = <span class="number">10</span></span><br><span class="line">len4 = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &gt; <span class="number">1</span>:</span><br><span class="line">    len1 = <span class="built_in">int</span>(sys.argv[<span class="number">1</span>])</span><br><span class="line">    len2 = <span class="built_in">int</span>(len1 / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &gt; <span class="number">2</span>:</span><br><span class="line">    len3 = <span class="built_in">int</span>(sys.argv[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">len4 = <span class="built_in">int</span>(len3 / <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(len1, len2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(len1):</span><br><span class="line">    data_list = [random_with_N_digits(<span class="number">38</span>)] <span class="comment"># should use 10^38 equals 2^128</span></span><br><span class="line">    row_list.append(data_list)</span><br><span class="line"></span><br><span class="line">row_list2 = sample(row_list, len2)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(len2, len1):</span><br><span class="line">    data_list = [random_with_N_digits(<span class="number">38</span>)]</span><br><span class="line">    row_list2.append(data_list)</span><br><span class="line"></span><br><span class="line">row_list3 = sample(row_list, len4)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(len4, len3):</span><br><span class="line">    data_list = [random_with_N_digits(<span class="number">38</span>)]</span><br><span class="line">    row_list3.append(data_list)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(row_list2))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(row_list3))</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;psi_1.csv&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    writer = csv.writer(file)</span><br><span class="line">    writer.writerow([<span class="string">&quot;id&quot;</span>])</span><br><span class="line">    writer.writerows(row_list)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;psi_2.csv&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    writer = csv.writer(file)</span><br><span class="line">    writer.writerow([<span class="string">&quot;id&quot;</span>])</span><br><span class="line">    writer.writerows(row_list2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;psi_3.csv&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    writer = csv.writer(file)</span><br><span class="line">    writer.writerow([<span class="string">&quot;id&quot;</span>])</span><br><span class="line">    writer.writerows(row_list3)</span><br></pre></td></tr></table></figure><h2 id="测试安装是否成功"><a href="#测试安装是否成功" class="headerlink" title="测试安装是否成功"></a>测试安装是否成功</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python3 foot.py</span></span><br><span class="line"><span class="keyword">import</span> secretflow <span class="keyword">as</span> sf</span><br><span class="line">sf.init([<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;carol&#x27;</span>], address=<span class="string">&#x27;local&#x27;</span>)</span><br><span class="line">dev = sf.PYU(<span class="string">&#x27;alice&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"></span><br><span class="line">data, target = load_iris(return_X_y=<span class="literal">True</span>, as_frame=<span class="literal">True</span>)</span><br><span class="line">data[<span class="string">&#x27;uid&#x27;</span>] = np.arange(<span class="built_in">len</span>(data)).astype(<span class="string">&#x27;str&#x27;</span>)</span><br><span class="line">data[<span class="string">&#x27;month&#x27;</span>] = [<span class="string">&#x27;Jan&#x27;</span>] * (<span class="number">2</span>^<span class="number">20</span>) + [<span class="string">&#x27;Feb&#x27;</span>] * (<span class="number">2</span>^<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># generate data, notice the content ./data</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.makedirs(<span class="string">&#x27;./data&#x27;</span>, exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">da, db, dc = data.sample(frac=<span class="number">0.9</span>), data.sample(frac=<span class="number">0.8</span>), data.sample(frac=<span class="number">0.7</span>)</span><br><span class="line"></span><br><span class="line">da.to_csv(<span class="string">&#x27;data/alice.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br><span class="line">db.to_csv(<span class="string">&#x27;data/bob.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br><span class="line">dc.to_csv(<span class="string">&#x27;data/carol.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">alice, bob = sf.PYU(<span class="string">&#x27;alice&#x27;</span>), sf.PYU(<span class="string">&#x27;bob&#x27;</span>)</span><br><span class="line">spu = sf.SPU(sf.utils.testing.cluster_def([<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;bob&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">input_path = &#123;alice: <span class="string">&#x27;data/alice.csv&#x27;</span>, bob: <span class="string">&#x27;data/bob.csv&#x27;</span>&#125;</span><br><span class="line">output_path = &#123;alice: <span class="string">&#x27;data/alice_psi.csv&#x27;</span>, bob: <span class="string">&#x27;data/bob_psi.csv&#x27;</span>&#125;</span><br><span class="line">spu.psi_csv(<span class="string">&#x27;uid&#x27;</span>, input_path, output_path, <span class="string">&#x27;alice&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = da.join(db.set_index(<span class="string">&#x27;uid&#x27;</span>), on=<span class="string">&#x27;uid&#x27;</span>, how=<span class="string">&#x27;inner&#x27;</span>, rsuffix=<span class="string">&#x27;_bob&#x27;</span>, sort=<span class="literal">True</span>)</span><br><span class="line">expected = df[da.columns].astype(&#123;<span class="string">&#x27;uid&#x27;</span>: <span class="string">&#x27;int64&#x27;</span>&#125;).reset_index(drop=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">da_psi = pd.read_csv(<span class="string">&#x27;data/alice_psi.csv&#x27;</span>)</span><br><span class="line">db_psi = pd.read_csv(<span class="string">&#x27;data/bob_psi.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pd.testing.assert_frame_equal(da_psi, expected)</span><br><span class="line">pd.testing.assert_frame_equal(db_psi, expected)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(da_psi)</span><br></pre></td></tr></table></figure><h2 id="实际实验测试脚本"><a href="#实际实验测试脚本" class="headerlink" title="实际实验测试脚本"></a>实际实验测试脚本</h2><p>启动节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RAY_DISABLE_REMOTE_CODE=<span class="literal">true</span> </span><br><span class="line">ray start --head --node-ip-address=<span class="string">&quot;192.168.31.128&quot;</span> --port=<span class="string">&quot;9394&quot;</span> --resources=<span class="string">&#x27;&#123;&quot;alice&quot;: 2&#125;&#x27;</span> --include-dashboard=False   </span><br><span class="line">ray start --address=<span class="string">&quot;192.168.31.128:9394&quot;</span> --resources=<span class="string">&#x27;&#123;&quot;bob&quot;: 2&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>通过更换reports的protocol参数进行3个两方PSI协议的测试，脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python3 benchmark.py</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> absl <span class="keyword">import</span> app</span><br><span class="line"><span class="keyword">import</span> spu</span><br><span class="line"><span class="keyword">import</span> secretflow <span class="keyword">as</span> sf</span><br><span class="line"></span><br><span class="line"><span class="comment"># init log</span></span><br><span class="line">logging.basicConfig(stream=sys.stdout, level=logging.INFO)</span><br><span class="line"></span><br><span class="line"><span class="comment"># SPU settings</span></span><br><span class="line">cluster_def = &#123;</span><br><span class="line">    <span class="string">&#x27;nodes&#x27;</span>: [</span><br><span class="line">        <span class="comment"># listen_address and address should have the same port</span></span><br><span class="line">        <span class="comment"># &lt;&lt;&lt; !!! &gt;&gt;&gt; replace &lt;192.168.0.1:12945&gt; to alice node&#x27;s local ip &amp; free port</span></span><br><span class="line">        <span class="comment"># 192.168.31.128 is my own ip address </span></span><br><span class="line">        &#123;<span class="string">&#x27;party&#x27;</span>: <span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;local:0&#x27;</span>, <span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;192.168.31.128:12345&#x27;</span>, <span class="string">&#x27;listen_address&#x27;</span>: <span class="string">&#x27;0.0.0.0:12345&#x27;</span>&#125;,</span><br><span class="line">        <span class="comment"># &lt;&lt;&lt; !!! &gt;&gt;&gt; replace &lt;192.168.0.2:12946&gt; to bob node&#x27;s local ip &amp; free port</span></span><br><span class="line">        &#123;<span class="string">&#x27;party&#x27;</span>: <span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;local:1&#x27;</span>, <span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;192.168.31.128:12333&#x27;</span>, <span class="string">&#x27;listen_address&#x27;</span>: <span class="string">&#x27;0.0.0.0:12333&#x27;</span>&#125;,</span><br><span class="line">        <span class="comment"># &lt;&lt;&lt; !!! &gt;&gt;&gt; if you need 3pc test, please add node here, for example, add carol as rank 2</span></span><br><span class="line">        <span class="comment"># &#123;&#x27;party&#x27;: &#x27;carol&#x27;, &#x27;id&#x27;: &#x27;local:2&#x27;, &#x27;address&#x27;: &#x27;127.0.0.1:12347&#x27;&#125;,</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&#x27;runtime_config&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;protocol&#x27;</span>: spu.spu_pb2.SEMI2K,</span><br><span class="line">        <span class="string">&#x27;field&#x27;</span>: spu.spu_pb2.FM128,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">_</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># sf init</span></span><br><span class="line">    <span class="comment"># &lt;&lt;&lt; !!! &gt;&gt;&gt; replace &lt;192.168.0.1:9394&gt; to your ray head</span></span><br><span class="line">    <span class="comment"># two parties secretflow&gt;=0.7.18b3 need to add &lt;sf.init(parties=[&#x27;alice&#x27;, &#x27;bob&#x27;]&gt;</span></span><br><span class="line">    sf.init(parties=[<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;bob&#x27;</span>], address=<span class="string">&#x27;192.168.31.128:9394&#x27;</span>,log_to_driver=<span class="literal">True</span>)</span><br><span class="line">    alice = sf.PYU(<span class="string">&#x27;alice&#x27;</span>)</span><br><span class="line">    bob = sf.PYU(<span class="string">&#x27;bob&#x27;</span>)</span><br><span class="line">    <span class="comment"># carol = sf.PYU(&#x27;carol&#x27;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># &lt;&lt;&lt; !!! &gt;&gt;&gt; replace path to real parties local file path.</span></span><br><span class="line">    input_path = &#123;</span><br><span class="line">        alice: <span class="string">&#x27;./psi_1.csv&#x27;</span>,</span><br><span class="line">        bob: <span class="string">&#x27;./psi_2.csv&#x27;</span>,</span><br><span class="line">        <span class="comment"># if run with `ECDH_PSI_3PC`, add carol</span></span><br><span class="line">        <span class="comment"># carol: &#x27;/data/psi_3.csv&#x27;,</span></span><br><span class="line">    &#125;</span><br><span class="line">    output_path = &#123;</span><br><span class="line">        alice: <span class="string">&#x27;./psi_output.csv&#x27;</span>,</span><br><span class="line">        bob: <span class="string">&#x27;./psi_output.csv&#x27;</span>,</span><br><span class="line">        <span class="comment"># if run with `ECDH_PSI_3PC`, add carol</span></span><br><span class="line">        <span class="comment"># carol: &#x27;/data/psi_output.csv&#x27;,</span></span><br><span class="line">    &#125;</span><br><span class="line">    select_keys = &#123;</span><br><span class="line">        alice: [<span class="string">&#x27;id&#x27;</span>],</span><br><span class="line">        bob: [<span class="string">&#x27;id&#x27;</span>],</span><br><span class="line">        <span class="comment"># if run with `ECDH_PSI_3PC`, add carol</span></span><br><span class="line">        <span class="comment"># carol: [&#x27;id&#x27;],</span></span><br><span class="line">    &#125;</span><br><span class="line">    spu = sf.SPU(cluster_def)</span><br><span class="line">    <span class="comment"># spu = sf.SPU(sf.utils.testing.cluster_def([&#x27;alice&#x27;, &#x27;bob&#x27;]))</span></span><br><span class="line">    <span class="comment"># prepare data</span></span><br><span class="line">    start = time.time()</span><br><span class="line"></span><br><span class="line">    reports = spu.psi_csv(</span><br><span class="line">        key=select_keys,</span><br><span class="line">        input_path=input_path,</span><br><span class="line">        output_path=output_path,</span><br><span class="line">        receiver=<span class="string">&#x27;alice&#x27;</span>,  <span class="comment"># if `broadcast_result=False`, only receiver can get output file.</span></span><br><span class="line">        <span class="comment"># all the possible protocols: ECDH_PSI_2PC KKRT_PSI_2PC BC22_PSI_2PC ECDH_PSI_3PC</span></span><br><span class="line">        protocol=<span class="string">&#x27;ECDH_PSI_2PC&#x27;</span>,<span class="comment"># psi protocol</span></span><br><span class="line">        precheck_input=<span class="literal">False</span>,  <span class="comment"># will cost ext time if set True</span></span><br><span class="line">        sort=<span class="literal">False</span>,  <span class="comment"># will cost ext time if set True</span></span><br><span class="line">        broadcast_result=<span class="literal">False</span>,  <span class="comment"># will cost ext time if set True</span></span><br><span class="line">    )</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;psi reports: <span class="subst">&#123;reports&#125;</span>&quot;</span>)</span><br><span class="line">    logging.info(<span class="string">f&quot;cost time: <span class="subst">&#123;time.time() - start&#125;</span>&quot;</span>) <span class="comment"># units： second</span></span><br><span class="line"></span><br><span class="line">    sf.shutdown()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(main)</span><br></pre></td></tr></table></figure><h2 id="SKY-PSI测试"><a href="#SKY-PSI测试" class="headerlink" title="SKY-PSI测试"></a>SKY-PSI测试</h2><p>./bin/PSI_test -r 0 -ss 20 -rs 20 -w 621 -h 20 -hash 10  &amp; ./bin/PSI_test -r 1 -ss 20 -rs 20 -w 621 -h 20 -hash 10</p><p>./bin/PSI_test -r 0 -ss 22 -rs 22 -w 627 -h 22 -hash 10  &amp; ./bin/PSI_test -r 1 -ss 22 -rs 22 -w 627 -h 22 -hash 10</p><p>./bin/PSI_test -r 0 -ss 23 -rs 23 -w 630 -h 23 -hash 10  &amp; ./bin/PSI_test -r 1 -ss 23 -rs 23 -w 630 -h 23 -hash 10</p><p>./bin/PSI_test -r 0 -ss 24 -rs 24 -w 633 -h 24 -hash 11  &amp; ./bin/PSI_test -r 1 -ss 24 -rs 24 -w 633 -h 24 -hash 11</p><p>./bin/PSI_test -r 0 -ss 25 -rs 25 -w 636 -h 25 -hash 11  &amp; ./bin/PSI_test -r 1 -ss 25 -rs 25 -w 636 -h 25 -hash 11</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">alleysira@ubuntu:~/SKY-PSI$ cmake .</span><br><span class="line">alleysira@ubuntu:~/SKY-PSI$ make</span><br><span class="line">alleysira@ubuntu:~/SKY-PSI$ ./bin/PSI_test -r 0 -ss 20 -rs 20 -w 621 -h 20 -<span class="built_in">hash</span> 10 -ip 127.0.0.1  -ck 0 -gm 0 &amp; ./bin/PSI_test -r 1 -ss 20 -rs 20 -w 621 -h 20 -<span class="built_in">hash</span> 10 -ip 127.0.0.1 -ck 0 -gm 0</span><br><span class="line">alleysira@ubuntu:~/SKY-PSI$ ./bin/PSI_test -r 0 -ss 20 -rs 20 -w 621 -h 20 -<span class="built_in">hash</span> 10 -ip 127.0.0.1  -ck 0 -gm 0 &amp; ./bin/PSI_test -r 1 -ss 20 -rs 20 -w 621 -h 20 -<span class="built_in">hash</span> 10 -ip 127.0.0.1 -ck 0 -gm 0</span><br><span class="line">[1] 4988</span><br><span class="line">Receiver matrix sent and transposed <span class="built_in">hash</span> input computed</span><br><span class="line">Label                                     Time (ms)  diff (ms)</span><br><span class="line">__________________________________</span><br><span class="line">Sender base OT finished                       155.1    155.071  ******</span><br><span class="line">Sender <span class="built_in">set</span> transformed                        645.4    490.352  *******</span><br><span class="line">Sender transposed <span class="built_in">hash</span> input computed        6863.1   6217.686  **********</span><br><span class="line">Sender <span class="built_in">hash</span> outputs computed and sent        8659.7   1796.587  *********</span><br><span class="line">Receiver intersection computed,Intersection size:500000</span><br><span class="line">Label                                                       Time (ms)  diff (ms)</span><br><span class="line">__________________________________</span><br><span class="line">Receiver base OT finished                                       135.9    135.929  ******</span><br><span class="line">Receiver initialized                                            216.6     80.709  *****</span><br><span class="line">Receiver <span class="built_in">set</span> transformed                                        620.4    403.792  *******</span><br><span class="line">Receiver matrix sent and transposed <span class="built_in">hash</span> input computed        6829.3   6208.850  **********</span><br><span class="line">Receiver intersection computed                                 9250.8   2421.508  *********</span><br><span class="line">Receiver sent communication: 77.631 MB</span><br><span class="line">Receiver received communication: 4.813 MB</span><br><span class="line">Receiver total communication: 82.445 MB</span><br><span class="line">[1]+  Done                    ./bin/PSI_test -r 0 -ss 20 -rs 20 -w 621 -h 20 -<span class="built_in">hash</span> 10 -ip 127.0.0.1 -ck 0 -gm 0</span><br></pre></td></tr></table></figure><p>cm20 支持到$2^{22},2^{23} $</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">alleysira@ubuntu:~/OPRF-PSI-backup$ ./bin/PSI_test -r 0 -ss 22 -rs 22 -w 627 -h 22 -hash 11  &amp; ./bin/PSI_test -r 1 -ss 22 -rs 22 -w 627 -h 22 -hash 11 -ip 127.0.0.1</span><br><span class="line">[2] 5249</span><br><span class="line">Receiver matrix sent and transposed hash input computed</span><br><span class="line">Label                                     Time (ms)  diff (ms)</span><br><span class="line">__________________________________</span><br><span class="line">Sender base OT finished                       688.9    688.936  ******</span><br><span class="line">Sender set transformed                       2053.2   1364.259  *******</span><br><span class="line">Sender transposed hash input computed       28745.7  26692.532  **********</span><br><span class="line">Sender hash outputs computed and sent       38459.4   9713.711  *********</span><br><span class="line">Begin</span><br><span class="line">Receiver intersection computed,Intersection size:532 Proportion of intersection:0.382% correct!</span><br><span class="line">Label                                                       Time (ms)  diff (ms)</span><br><span class="line">__________________________________</span><br><span class="line">Receiver base OT finished                                       690.1    690.110  ******</span><br><span class="line">Receiver initialized                                            874.8    184.698  *****</span><br><span class="line">Receiver set transformed                                       2005.0   1130.157  *******</span><br><span class="line">Receiver matrix sent and transposed hash input computed       28747.9  26742.969  **********</span><br><span class="line">Receiver intersection computed                                41609.8  12861.827  *********</span><br><span class="line">Receiver sent communication: 313.506 MB</span><br><span class="line">Receiver received communication: 10.016 MB</span><br><span class="line">Receiver total communication: 323.522 MB</span><br><span class="line"></span><br><span class="line">alleysira@ubuntu:~/OPRF-PSI-backup$ ./bin/PSI_test -r 0 -ss 23 -rs 23 -w 627 -h 23 -hash 11  &amp; ./bin/PSI_test -r 1 -ss 23 -rs 23 -w 627 -h 23 -hash 11 -ip 127.0.0.1</span><br><span class="line">[1] 5273</span><br><span class="line">Receiver matrix sent and transposed hash input computed</span><br><span class="line">Label                                     Time (ms)  diff (ms)</span><br><span class="line">__________________________________</span><br><span class="line">Sender base OT finished                       150.6    150.579  *****</span><br><span class="line">Sender set transformed                       2884.4   2733.777  *******</span><br><span class="line">Sender transposed hash input computed       67371.3  64486.946  **********</span><br><span class="line">Sender hash outputs computed and sent       90574.5  23203.154  *********</span><br><span class="line">Begin</span><br><span class="line">Receiver intersection computed,Intersection size:536 Proportion of intersection:0.191% correct!</span><br><span class="line">Label                                                       Time (ms)  diff (ms)</span><br><span class="line">__________________________________</span><br><span class="line">Receiver base OT finished                                       148.4    148.435  *****</span><br><span class="line">Receiver initialized                                            517.2    368.812  *****</span><br><span class="line">Receiver set transformed                                       2835.7   2318.477  *******</span><br><span class="line">Receiver matrix sent and transposed hash input computed       67371.8  64536.073  **********</span><br><span class="line">Receiver intersection computed                                97432.1  30060.339  *********</span><br><span class="line">Receiver sent communication: 627.006 MB</span><br><span class="line">Receiver received communication: 20.016 MB</span><br><span class="line">Receiver total communication: 647.022 MB</span><br></pre></td></tr></table></figure><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>4Core/12GB </p><p>hard drive: 30GB，实验过程中硬盘空间不足，可能影响效率</p><p>cm20的元素大小为$2^{128}$，隐语默认为$10^{18}$（已修改为$10^{38}$）</p><p>cm20设置了交集个数为100（已修正为50 0000），隐语交集个数设置为集合大小一半</p><p>分别限制网络带宽为30Mbps 20ms、100Mbps 20ms和LAN进行测试，对secretflow的测试需要限制环回地址lo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ifconfig </span><br><span class="line"></span><br><span class="line"><span class="comment">#100Mbps 20ms</span></span><br><span class="line">sudo tc qdisc add dev lo root handle 1: tbf rate 100mbit burst 256kb latency 800ms                                   </span><br><span class="line">sudo tc qdisc add dev lo parent 1:1 handle 10: netem delay 20msec <span class="built_in">limit</span> 8000 </span><br><span class="line"></span><br><span class="line"><span class="comment">#清除限制</span></span><br><span class="line">sudo tc qdisc del dev lo root</span><br><span class="line"><span class="comment">#查看已有配置</span></span><br><span class="line">sudo tc qdisc show dev lo</span><br></pre></td></tr></table></figure><h3 id="30Mbps-20ms结果"><a href="#30Mbps-20ms结果" class="headerlink" title="30Mbps 20ms结果"></a>30Mbps 20ms结果</h3><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><div class="table-container"><table><thead><tr><th>数量级</th><th>KKRT/s</th><th>ECDH/s</th><th>BC22/s</th><th>SKY-PSI/s</th></tr></thead><tbody><tr><td>百万 1000000 $2^{20}$</td><td>40.00+40.81=40.405</td><td>159.15+161.22=160.185</td><td>58.23+60.14=59.18</td><td>26.47+26.76+26.81=26.68</td></tr><tr><td>千万 10000000</td><td>369.75</td><td>1558.04</td><td>537.13</td></tr></tbody></table></div><h3 id="100Mbps-20ms结果"><a href="#100Mbps-20ms结果" class="headerlink" title="100Mbps 20ms结果"></a>100Mbps 20ms结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(base) jie@jie-virtual-machine:~$ sudo  tc qdisc add dev lo root handle 1: tbf rate 100mbit burst 256kb latency 800ms </span><br><span class="line">(base) jie@jie-virtual-machine:~$ sudo tc qdisc add dev lo parent 1:1 handle 10: netem delay 20msec limit 8000 </span><br><span class="line">(base) jie@jie-virtual-machine:~$ sudo tc qdisc show dev lo</span><br><span class="line">qdisc tbf 1: root refcnt 2 rate 100Mbit burst 256Kb lat 800ms </span><br><span class="line">qdisc netem 10: parent 1:1 limit 8000 delay 20ms</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>数量级</th><th>KKRT/s</th><th>ECDH/s</th><th>BC22/s</th><th>SKY-PSI/s</th></tr></thead><tbody><tr><td>百万 1000000 $2^{20}$</td><td>18.80+18.29=18.545</td><td>151.927</td><td>16.86+16.176=16.518</td><td>10.52+10.51+ 10.57=10.53</td></tr><tr><td>千万 10000000</td><td>138.21+139.47=138.84</td><td>1544.09</td><td>106.89+111.60=109.245</td></tr></tbody></table></div><h3 id="LAN实验结果"><a href="#LAN实验结果" class="headerlink" title="LAN实验结果"></a>LAN实验结果</h3><div class="table-container"><table><thead><tr><th>数量级</th><th>KKRT/s</th><th>ECDH/s</th><th>BC22/s</th><th>SKY-PSI/s</th></tr></thead><tbody><tr><td>百万 1000000 $2^{20}$</td><td>12.85+10.65+12.63+10.19+13.11+9.57+9.82+9.68+9.93=9.84</td><td>137.29+142.37+141.59+147.97+143.38=142.52</td><td>10.33+10.318=10.324</td><td>9.2508+9.002+10.941+9.0912+9.036+9.663+10.935+10.154=9.75</td></tr><tr><td>千万 10000000</td><td>76.24+72.58+74.83+70.75+70.83=73.046</td><td>1374.78</td><td>79.94+78.78+81.13+78.40+78.62=79.374</td></tr></tbody></table></div><p>蚂蚁给出的结果</p><p><img src="/2023/04/08/SecretFlow%E9%9A%90%E8%AF%ADPSI%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%B5%8B%E8%AF%95/7629c228-bc51-4ef7-93e9-9f0c465d025d.png" alt="img"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;SecretFlow隐语PSI实验环境配置与测试&quot;&gt;&lt;a href=&quot;#SecretFlow隐语PSI实验环境配置与测试&quot; class=&quot;headerlink&quot; title=&quot;SecretFlow隐语PSI实验环境配置与测试&quot;&gt;&lt;/a&gt;SecretFlow隐语PSI实验环境配置与测试&lt;/h1&gt;&lt;p&gt;配置SecretFlow 并测试两方PSI的效率&lt;/p&gt;
&lt;p&gt;官方文档 &lt;a href=&quot;https://www.secretflow.org.cn/docs/secretflow/zh_CN/developer/benchmark/psi_benchmark.html#&quot;&gt;隐语PSI Benchmark白皮书 — SecretFlow 文档&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="MPC" scheme="https://alleysira.github.io/categories/MPC/"/>
    
    
    <category term="Crypto" scheme="https://alleysira.github.io/tags/Crypto/"/>
    
    <category term="MPC" scheme="https://alleysira.github.io/tags/MPC/"/>
    
    <category term="PSI" scheme="https://alleysira.github.io/tags/PSI/"/>
    
  </entry>
  
  <entry>
    <title>Intro_to_lattices</title>
    <link href="https://alleysira.github.io/2023/04/07/Intro-to-lattices/"/>
    <id>https://alleysira.github.io/2023/04/07/Intro-to-lattices/</id>
    <published>2023-04-07T10:29:49.000Z</published>
    <updated>2023-07-23T10:45:58.183Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1re411W7vA/?spm_id_from=333.999.0.0&amp;vd_source=fbfceeec0a697a64e4aba2132714eb9d">2012年BIU密码学冬令营-01-Introduction to Lattices</a></p><span id="more"></span><h1 id="2012-BIU-Introduction-to-Lattices"><a href="#2012-BIU-Introduction-to-Lattices" class="headerlink" title="2012 BIU Introduction to Lattices"></a>2012 BIU Introduction to Lattices</h1><p><img src="/2023/04/07/Intro-to-lattices/image-20230407183351420.png" alt="image-20230407183351420"></p><p>基底不唯一</p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407183444805.png" alt="image-20230407183444805"></p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407183505019.png" alt="image-20230407183505019"></p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407183846399.png" alt="image-20230407183846399"></p><p>格密码的安全是worst-case的困难问题</p><p>传统密码学是average-case的困难问题</p><p>格可以实现FHE</p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407184005734.png" alt="image-20230407184005734"></p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407184353209.png" alt="image-20230407184353209"></p><p>安全证明可以给出关于如何选择安全参数的提示</p><p>average-case的困难问题，比如如何选择N？</p><ul><li>大质数$p,q$如何选择</li><li>$p-1,q-1$的素因子应该足够大</li><li>$p+1,q+1$的素因子应该足够大</li><li>实际上现在已经不太重要了</li></ul><p>格不存在这样的问题</p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407185137186.png" alt="image-20230407185137186"></p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407185310415.png" alt="image-20230407185310415"></p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407185523538.png" alt="image-20230407185523538"></p><p>如果1%被破解了，所有格上的困难问题都被破解了，不需要考虑参数的选取</p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407190027295.png" alt="image-20230407190027295"></p><p>现在格密码的效率和RSA接近</p><ul><li>LWE SIS</li><li>RLWE RSIS 特定代数结构，效率非常高，密钥长度KB级别，接近哈希函数的效率</li></ul><p><img src="/2023/04/07/Intro-to-lattices/image-20230407190336753.png" alt="image-20230407190336753"></p><p>两个定义，实际上等价 列就是基底 </p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407190559981.png" alt="image-20230407190559981"></p><p> 等价基底</p><p>如何寻找等价基底，能在基底上做什么</p><ul><li>列变换 $v_i\leftrightarrow v_j$</li><li>取负值 $v_i\gets -v_i$</li><li>$v_i\gets v_i +kv_j,k\in Z$</li></ul><p>相当于右乘 幺模矩阵(unimodular 行列式值为1)，对乘法封闭</p><p>两个格等价的条件</p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407191804198.png" alt="image-20230407191804198"></p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407192045351.png" alt="image-20230407192045351"></p><p>格的一些特征</p><p>一维空间的周期函数$f:\R \to \R$</p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407192624915.png" alt="image-20230407192624915"></p><p>考虑高维空间，类似于循环群，只需要存储陪集</p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407193047743.png" alt="image-20230407193047743"></p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407193204421.png" alt="image-20230407193204421"></p><p>格的基本区域</p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407193341145.png" alt="image-20230407193341145"></p><p>给定基，可以定义基本平行多面体 就是一个基本区域，恰好包含陪集中的每一个元素</p><p>基本空间的等价定义：基本空间内不存在两个等价的空间点，仅包含所有不等价陪集内的点集</p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407193441619.png" alt="image-20230407193441619"></p><p>寻找空间点的一个表示，实际上是在做模 基本平行多面体</p><p>存储的实际是点和格的相关性，当点在格上，模P(B)后得到原点</p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407194218433.png" alt="image-20230407194218433"></p><p>实际上平行多面体的形状无重要，可以用任意多面体标识格，不是所有基本区域都是平行的</p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407194446752.png" alt="image-20230407194446752"></p><p>基本区域的面积必须相同，对平行多面体也成立，可以把平行多面体内的点映射到另一个平行多面体中 </p><p>格的行列式定义为基生成的平行多面体的体积$|det(B)|$</p><p>格的行列式表示了格点的稀疏程度，密度</p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407202440541.png" alt="image-20230407202440541"></p><p>连续极小，最短向量(集合)</p><p>一般距离是欧几里得范数</p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407202709347.png" alt="image-20230407202709347"></p><p>一般指关心$\lambda_1 $</p><p>$\lambda_n $是线性空间的基</p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407202958269.png" alt="image-20230407202958269"></p><p>注意$\tilde{v_2}$并不是格点</p><p>正交基也是基本区域</p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407204323284.png" alt="image-20230407204323284"></p><p>从正交向量集到规范化正交集，是线性代数层面的基而不是格的基</p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407204527658.png" alt="image-20230407204527658"></p><p>QR分解</p><p>可以证明施密特正交区域是基本区域 </p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407204950666.png" alt="image-20230407204950666"></p><p>证明引理1：三角形行列式等于主对角线上元素的乘积</p><p>证明引理2：对最后一列的系数取非0，其他所有项系数取0，则 $\lambda_1\geq \tilde{v_n}$；同理当倒数第二列系数为非0，其他所有列系数为0，$\lambda_1\geq \tilde{v_{n-1}}$ ，永远存在非0系数，实际得到了$\lambda_1$的下界</p><h2 id="Minkowski‘s-theorem"><a href="#Minkowski‘s-theorem" class="headerlink" title="Minkowski‘s theorem"></a>Minkowski‘s theorem</h2><p>袋鼠的面积大于格的行列式</p><p><img src="/2023/04/07/Intro-to-lattices/image-20230409144553627.png" alt="image-20230409144553627"></p><p>S必须是关于0点对称的凸集合，存在一个非0格点，因为0永远在S中</p><p><img src="/2023/04/07/Intro-to-lattices/image-20230409144706671.png" alt="image-20230409144706671"></p><p>证明：将S缩小一半，体积缩小$2^n$，$z_1-z_2\in \Lambda $</p><p>由于$\pm2z_1,\pm2z_2 \in S,2z_1-2z_2$的中点 $z_1-z_2\in S$</p><p><img src="/2023/04/07/Intro-to-lattices/image-20230409145627491.png" alt="image-20230409145627491"></p><p>说明了格中至少有短向量</p><p>等价推论：任意行列式为1的格，必然包含长度不超过$\sqrt{n}$的短向量</p><p>考虑半径为$\sqrt{n}$的球，球的体积大于$2^n$</p><p>现在格中找短向量的方法都是数学方法，基于格的密码学方案假设是不知道如何高效求得格的短向量</p><p>Blichfeld定理是存在性定理，没有给出如何求</p><h2 id="计算困难问题"><a href="#计算困难问题" class="headerlink" title="计算困难问题"></a>计算困难问题</h2><h3 id="简单问题"><a href="#简单问题" class="headerlink" title="简单问题"></a>简单问题</h3><p>给定格基$B$和向量$v$，检查$v$是否在$L(B)$</p><p>解法：高斯消元检查系数是否为整数</p><p>给定格基 $B_1 B_2$，判断$L(B_1)=L(B_2)$</p><p>解法：根据之前的定理，$B_1 = B_2\times U$，$U$是幺模矩阵</p><p>另一个解法：取基$B_1$中任意一个向量，检查是否属于另一个基；如果所有基向量均在$L(B_2)$，再检查$B_2$中所有向量是否在$L(B_1)$</p><p>结论是代数问题很简单，但是几何问题很困难</p><p><img src="/2023/04/07/Intro-to-lattices/image-20230409160126271.png" alt="image-20230409160126271"></p><h3 id="困难问题"><a href="#困难问题" class="headerlink" title="困难问题"></a>困难问题</h3><h4 id="最短向量问题，SVP"><a href="#最短向量问题，SVP" class="headerlink" title="最短向量问题，SVP"></a>最短向量问题，SVP</h4><p>给定基，求最短向量</p><p>密码学常用的是近似最短向量问题，求得最短向量的$\gamma$倍的向量</p><p><img src="/2023/04/07/Intro-to-lattices/image-20230409160404955.png" alt="image-20230409160404955"></p><p>变种：给出近似最短向量的长度即可（类似判定小问题</p><h4 id="最短独立向量问题，SIVP"><a href="#最短独立向量问题，SIVP" class="headerlink" title="最短独立向量问题，SIVP"></a>最短独立向量问题，SIVP</h4><p><img src="/2023/04/07/Intro-to-lattices/image-20230409160855151.png" alt="image-20230409160855151"></p><h4 id="最近向量问题，CVP"><a href="#最近向量问题，CVP" class="headerlink" title="最近向量问题，CVP"></a>最近向量问题，CVP</h4><p><img src="/2023/04/07/Intro-to-lattices/image-20230409160843986.png" alt="image-20230409160843986"></p><p>SVP不比CVP更困难，CVP解决能解决SVP</p><p><img src="/2023/04/07/Intro-to-lattices/image-20230409164706784.png" alt="image-20230409164706784"></p><p><img src="/2023/04/07/Intro-to-lattices/image-20230409171842664.png" alt="image-20230409171842664"></p><p>LLL是多项式时间算法，输出短向量，近似因子接近$2^n$，当$n$接近500，输出向量不够理想</p><p><img src="/2023/04/07/Intro-to-lattices/image-20230409173133959.png" alt="image-20230409173133959"></p><p><img src="/2023/04/07/Intro-to-lattices/image-20230409173530831.png" alt="image-20230409173530831"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1re411W7vA/?spm_id_from=333.999.0.0&amp;amp;vd_source=fbfceeec0a697a64e4aba2132714eb9d&quot;&gt;2012年BIU密码学冬令营-01-Introduction to Lattices&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Crypto" scheme="https://alleysira.github.io/categories/Crypto/"/>
    
    
    <category term="Crypto" scheme="https://alleysira.github.io/tags/Crypto/"/>
    
    <category term="Lattices" scheme="https://alleysira.github.io/tags/Lattices/"/>
    
  </entry>
  
  <entry>
    <title>Tech_chall_in_bc</title>
    <link href="https://alleysira.github.io/2023/03/15/Tech-chall-in-bc/"/>
    <id>https://alleysira.github.io/2023/03/15/Tech-chall-in-bc/</id>
    <published>2023-03-15T06:02:08.000Z</published>
    <updated>2023-07-23T10:47:22.552Z</updated>
    
    <content type="html"><![CDATA[<p>陈婧，Algorand Inc</p><span id="more"></span><p><img src="/2023/03/15/Tech-chall-in-bc/image-20230315140644953.png" alt="image-20230315140644953"></p><h1 id="Algorand"><a href="#Algorand" class="headerlink" title="Algorand"></a>Algorand</h1><p>不存在分叉，高效</p><p>不采用PoW：用户友好，参与门槛低</p><p>没有软分叉：即时确认</p><p>有了拜占庭协议为什么还需要研究共识：用户数量过高（10亿），效率低</p><p><img src="/2023/03/15/Tech-chall-in-bc/image-20230315141211609.png" alt="image-20230315141211609"></p><p><img src="/2023/03/15/Tech-chall-in-bc/image-20230315141320970.png" alt="image-20230315141320970"></p><p>如此设计不需要用户之间的通信，敌手不知道去攻击哪个节点</p><p>​    Algorand设置了分叉的概率为$10^{-18}$</p><h1 id="Technical-Challenges-in-Blockchains"><a href="#Technical-Challenges-in-Blockchains" class="headerlink" title="Technical Challenges in Blockchains"></a>Technical Challenges in Blockchains</h1><h2 id="Smart-contract"><a href="#Smart-contract" class="headerlink" title="Smart contract"></a>Smart contract</h2><p><img src="/2023/03/15/Tech-chall-in-bc/image-20230315142240113.png" alt="image-20230315142240113"></p><p>智能合约执行和共识执行解耦</p><p><img src="/2023/03/15/Tech-chall-in-bc/image-20230315142455033.png" alt="image-20230315142455033"></p><p>Algorand将复杂的计算放在链下，提供了一定的并行度</p><p><img src="/2023/03/15/Tech-chall-in-bc/image-20230315143455593.png" alt="image-20230315143455593"></p><p>应用中可能不需要递归，攻击者反而容易使用</p><h2 id="Interoperability"><a href="#Interoperability" class="headerlink" title="Interoperability"></a>Interoperability</h2><p>跨链问题，可能最终演变为类似操作系统的现状</p><p>目前的解决方案有</p><ul><li>转换token</li><li>burn-and-mint</li></ul><h2 id="Ecnomics-amp-Finance"><a href="#Ecnomics-amp-Finance" class="headerlink" title="Ecnomics &amp; Finance"></a>Ecnomics &amp; Finance</h2><ul><li>如何设计交易费</li><li>管理token</li><li><p>区块链上新的博弈模型</p></li><li><p>知识不对称：小白可能学习到专业的交易技巧/策略</p></li></ul><h2 id="Privacy-amp-Post-Quantum-Scurity"><a href="#Privacy-amp-Post-Quantum-Scurity" class="headerlink" title="Privacy &amp; Post-Quantum Scurity"></a>Privacy &amp; Post-Quantum Scurity</h2><p>工业界最关心的事是量子算法的可扩展性和效率</p><p><img src="/2023/03/15/Tech-chall-in-bc/image-20230315145047758.png" alt="image-20230315145047758"></p><p>链上可能接受的是对证明的验证，生成还是</p><p><img src="/2023/03/15/Tech-chall-in-bc/image-20230315145123162.png" alt="image-20230315145123162"></p><p><img src="/2023/03/15/Tech-chall-in-bc/image-20230315145507512.png" alt="image-20230315145507512"></p><h2 id="Scalability"><a href="#Scalability" class="headerlink" title="Scalability"></a>Scalability</h2><p><img src="/2023/03/15/Tech-chall-in-bc/image-20230315145743501.png" alt="image-20230315145743501"></p><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p>链下合约的安全性：如何进行授权</p><p>跨链的信任：共识决定了不同链的安全性保证不同，</p><p>被遗忘权：实现编辑权；存加密后的数据；物理网络上结合法律法规进行设计（可编辑区块链技术地位卑微）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;陈婧，Algorand Inc&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/categories/Blockchain/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>bc_eco_sys</title>
    <link href="https://alleysira.github.io/2023/03/14/bc-eco-sys/"/>
    <id>https://alleysira.github.io/2023/03/14/bc-eco-sys/</id>
    <published>2023-03-14T08:30:15.000Z</published>
    <updated>2023-07-23T10:42:51.908Z</updated>
    
    <content type="html"><![CDATA[<p>随手记录见到的区块链应用案例</p><span id="more"></span><h1 id="政策"><a href="#政策" class="headerlink" title="政策"></a>政策</h1><ul><li>2021年十部委发文 <a href="http://www.gov.cn/zhengce/zhengceku/2021-10/08/content_5641404.htm"><strong>关于进一步防范和处置虚拟货币交易炒作风险的通知</strong></a></li></ul><h1 id="区块链行业资料"><a href="#区块链行业资料" class="headerlink" title="区块链行业资料"></a>区块链行业资料</h1><ul><li>信通院主导的<a href="http://www.trustedblockchain.cn/#/result/result/index/0">可信区块链推进计划 (trustedblockchain.cn)</a></li><li>信通院白皮书<a href="http://www.caict.ac.cn/kxyj/qwfb/bps/202212/t20221229_413462.htm">中国信通院-科研能力-权威发布-白皮书 (caict.ac.cn)</a></li><li>MEVboost提供了以太坊的四类实体的交易区块的可视化<a href="https://mevboost.pics/">mevboost.pics | MEV-Boost Dashboard</a></li></ul><h1 id="国内的区块链应用"><a href="#国内的区块链应用" class="headerlink" title="国内的区块链应用"></a>国内的区块链应用</h1><ul><li>中国移动的<a href="http://explorer.zhongyi.bsnbase.com/#/browserEos?activeTab=browserEos">中移链浏览器 (bsnbase.com)</a></li><li>中国联通的联通链Baas平台<a href="https://gec.10010.com/p/product/1002639">中国联通政企在线门户 (10010.com)</a></li><li>浙江冷链食品溯源码<a href="http://www.cixi.gov.cn/art/2021/1/5/art_1229036208_59040664.html">购买冷链食品可扫一扫“浙冷链”溯源码 (cixi.gov.cn)</a></li></ul><h1 id="顶级会议"><a href="#顶级会议" class="headerlink" title="顶级会议"></a>顶级会议</h1><ul><li>ACM Advances in Financial Technologies, ACT</li><li>Financial Cryptography and Data Security, FC, CCF C</li></ul><p>南开大学汪定老师的<a href="http://wangdingg.weebly.com/miscellanea.html">博客</a>有总结</p><p>新加坡科技设计大学的<a href="http://jianying.space/">Jianying Zhou</a>对顶会的会议影响因子进行了定义和排名</p><p><img src="/2023/03/14/bc-eco-sys/image-20230723153728097.png" alt="image-20230723153728097"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;随手记录见到的区块链应用案例&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/categories/Blockchain/"/>
    
    
    <category term="Blockchian" scheme="https://alleysira.github.io/tags/Blockchian/"/>
    
  </entry>
  
  <entry>
    <title>scheme_design</title>
    <link href="https://alleysira.github.io/2023/03/10/scheme-design/"/>
    <id>https://alleysira.github.io/2023/03/10/scheme-design/</id>
    <published>2023-03-10T02:59:58.000Z</published>
    <updated>2023-07-23T10:46:54.303Z</updated>
    
    <content type="html"><![CDATA[<p>梳理思路，设计方案</p><span id="more"></span><h1 id="模型定义"><a href="#模型定义" class="headerlink" title="模型定义"></a>模型定义</h1><ul><li>定义方案需要满足的性质<ul><li>安全性<ul><li>链增长</li><li>链质量</li><li>公共前缀</li></ul></li></ul></li><li>定义编辑操作的正确性：不被通过的编辑请求是恶意的，即投票通过的编辑是合法的；具体表现包括<ul><li>不修改金融数据</li><li>[LMW23]定义的编辑正确性：An honest block modified by the adversary without the approval of the committee is malicious.</li></ul></li><li><p>腐化模型：t-温和敌手：是指敌手腐化一个节点需要一定的时间来完成. 敌手发布对目标节点的腐化指令, 经过t时间后, 目标节点被腐化, 受到敌手的控制, 成为恶意节点. 在实施腐化的t 时间内, 节点仍然属于诚实节点. 温和敌手是区块链协议分析中经常采用的腐化模型.</p></li><li><p>敌手模型：$n=2f+1$</p><ul><li><p>[JCH22]的方案要求门限值$t&gt;n/4$</p></li><li><p>[LMW23]如何确定委员会大小n，如何选举第一个委员会的成员（pow）</p></li></ul></li></ul><ul><li><p>网络模型：同步网络，存在已知的最大时延$\delta$</p></li><li><p>追责性：</p><ul><li><p>节点$P_i$发起编辑请求，所有节点收到后投票发送给委员会：</p><ul><li>投票不通过<ul><li>不执行，追责发起编辑的人以及投赞成票的人</li></ul></li><li>投票通过<ul><li>执行编辑之后，其他区块验证编辑不符合格式，追责编辑节点（领导者）</li></ul></li><li>记录发起编辑申请，扣除保证金</li></ul></li><li><p>惩罚投票阶段发送虚假份额的节点</p></li></ul></li></ul><ul><li><p>公平性：</p><ul><li><p>任何节点$P_i$可以通过发起编辑申请，缴纳保证金请求编辑，公平参与性</p></li><li><p>编辑权由编辑者掌握</p><ul><li>编辑者的选择依赖于委员会选择，委员会内可验证随机函数最小值（√）</li><li>投票就是密钥份额，超过门限直接执行（√）</li><li>恢复密钥阶段<ul><li>每个节点都有份额（√）</li><li>委员会成员有份额</li></ul></li><li>委员会选择的方法：相对简单的Pow<ul><li>节点为什么要加入委员会，设计激励制度，执行编辑操作，获得手续费</li></ul></li></ul></li></ul></li></ul><ul><li><p>为什么要设计委员会</p><ul><li>委员会成员进行变色龙哈希函数的密钥生成（√）</li><li>收集编辑请求，同意之后发出编辑的交易（√）</li><li>委员会内选举领导者，执行编辑（√）</li><li>委员会的大小，先定死</li></ul></li><li><p>委员会内投票还是所有节点参与投票</p><ul><li>委员会内投票：需要考虑委员会成员的安全性</li><li>所有节点投票，投票周期长，更加公平，超过门限就可以（√）<ul><li>门限是否设置为50%，保证安全性但是可能没有这么多节点在线</li></ul></li></ul></li></ul><h1 id="协议流程"><a href="#协议流程" class="headerlink" title="协议流程"></a>协议流程</h1><h2 id="选择委员会"><a href="#选择委员会" class="headerlink" title="选择委员会"></a>选择委员会</h2><p>委员会大小$t$</p><p>计算PoW $H(ini_ran|PK|IP|nonce)\leq 2^{-D}$，D是困难系数</p><p>委员会内领导者选举采用VRF</p><h2 id="分布式密钥生成"><a href="#分布式密钥生成" class="headerlink" title="分布式密钥生成"></a>分布式密钥生成</h2><p>暂定使用JCH22的方案</p><p><img src="/2023/03/10/scheme-design/image-20230316153823400.png" alt="image-20230316153823400"></p><h2 id="收集编辑请求"><a href="#收集编辑请求" class="headerlink" title="收集编辑请求"></a>收集编辑请求</h2><p>任何节点$P_i$想要修改区块$B_j$内的第$k$个交易，正常发起交易（上链后才能编辑），支付交易费和保证金</p><p>委员会节点打包交易发现有编辑交易后，在委员会内部发送编辑请求$req=(height,last_hash’,addr_{tx},tx,m_root,seq)$</p><p>委员会节点向所有全节点广播编辑请求，同意编辑的全节点向委员会返回$(ID(P_i),sig(P_i,seq),seq)$</p><p>委员会收集投票总数sum，$sum&gt;0.5n$且$sum&gt;t$则恢复密钥，执行编辑</p><h2 id="执行编辑"><a href="#执行编辑" class="headerlink" title="执行编辑"></a>执行编辑</h2><p>领导者生成区块$B_j$编辑后的区块$B^\star_j$，头部修改为$(prev_hash,last_hash’,acc)$，acc是更新后RSA累加器的值</p><h2 id="节点验证编辑并更新本地链"><a href="#节点验证编辑并更新本地链" class="headerlink" title="节点验证编辑并更新本地链"></a>节点验证编辑并更新本地链</h2><p>验证出块者是否在委员会内，是否为领导者</p><p>检查是否为合法区块</p><h2 id="委员会更新"><a href="#委员会更新" class="headerlink" title="委员会更新"></a>委员会更新</h2><p>更新，类似于定期执行$(t,n)\to(t’,n’)$秘密分享</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul><li>(已完成)JCH22在收集编辑请求过程中存在重放攻击，增加序列号</li><li>[未实现]委员会内的领导者隐藏身份，直到出块时在区块头增加出块者的身份</li><li>委员会的epoch设置为敌手腐化委员会成员需要的时间即可</li><li>为什么不使用公开可验证的秘密分享：采用公钥加密和零知识证明，导致效率更低；安全性上不参与秘密重构的人理应无权投诉。</li></ul><h2 id="论文问题"><a href="#论文问题" class="headerlink" title="论文问题"></a>论文问题</h2><ul><li>形式化撰写困难问题</li></ul><h2 id="后续可以研究的问题"><a href="#后续可以研究的问题" class="headerlink" title="后续可以研究的问题"></a>后续可以研究的问题</h2><ul><li>安全性<ul><li>保护领导者身份，委员会的环签名，如何追踪领导者作恶</li><li>密钥过期问题<ul><li>如果不更新<script type="math/tex">s</script>，存在曾经的密钥份额也可以恢复现在的秘密的情况(需要获得上一轮至少t个份额)</li><li>定期更新s，重新进行dkg即可</li><li>投票结果是否放在链上</li></ul></li><li>领导者作恶无法生成有效的编辑区块</li></ul></li></ul><h2 id="可参考的架构图"><a href="#可参考的架构图" class="headerlink" title="可参考的架构图"></a>可参考的架构图</h2><p><img src="/2023/03/10/scheme-design/image-20230404102733511.png" alt="image-20230404102733511"></p><p><img src="/2023/03/10/scheme-design/image-20230331115108870.png" alt="image-20230331115108870"></p><p><img src="/2023/03/10/scheme-design/image-20230331115138133.png" alt="image-20230331115138133"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;梳理思路，设计方案&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/categories/Blockchain/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>BIU</title>
    <link href="https://alleysira.github.io/2023/03/09/BIU/"/>
    <id>https://alleysira.github.io/2023/03/09/BIU/</id>
    <published>2023-03-09T08:43:56.000Z</published>
    <updated>2023-05-06T06:52:56.942Z</updated>
    
    <content type="html"><![CDATA[<p>13th BIU winter school</p><span id="more"></span><h1 id="What-are-Blockchains-and-What-are-They-For-Dan-Boneh"><a href="#What-are-Blockchains-and-What-are-They-For-Dan-Boneh" class="headerlink" title="What are Blockchains and What are They For? - Dan Boneh"></a>What are Blockchains and What are They For? - Dan Boneh</h1><p><img src="/2023/03/09/BIU/image-20230309164910424.png" alt="image-20230309164910424"></p><p>如果有可信方，不需要区块链技术</p><p><img src="/2023/03/09/BIU/image-20230309165047176.png" alt="image-20230309165047176"></p><p><img src="/2023/03/09/BIU/image-20230309165442867.png" alt="image-20230309165442867"></p><p>比特币的创新：实际的公开可写的数据结构</p><p><img src="/2023/03/09/BIU/image-20230309165717210.png" alt="image-20230309165717210"></p><p>以太坊的创新：可编程的环境，应用可以互相调用</p><p><img src="/2023/03/09/BIU/image-20230309165846240.png" alt="image-20230309165846240"></p><p>区块链通过复制的方法实现只能写的功能</p><ul><li>persistence: 只能写，不能删除</li><li>liveness: 诚实节点可以添加新的交易<ul><li>抗审查</li></ul></li></ul><p><img src="/2023/03/09/BIU/image-20230309170207472.png" alt="image-20230309170207472"></p><p><img src="/2023/03/09/BIU/image-20230309170459366.png" alt="image-20230309170459366"></p><p>和web2的区别是真正的状态存储在链上，而不是数据库</p><p><img src="/2023/03/09/BIU/image-20230309170529887.png" alt="image-20230309170529887"></p><p>资产由DAPP管理，和现实的金融机构不同，具有透明性</p><p><img src="/2023/03/09/BIU/image-20230309170646811.png" alt="image-20230309170646811"></p><h2 id="2-application-areas"><a href="#2-application-areas" class="headerlink" title="2 application areas"></a>2 application areas</h2><h3 id="DeFi"><a href="#DeFi" class="headerlink" title="DeFi"></a>DeFi</h3><p>任何人都可以建立金融基础设施</p><p>应用之间可以交互，只要满足ERC-20标准 6个函数</p><p><img src="/2023/03/09/BIU/image-20230309170833011.png" alt="image-20230309170833011"></p><p>为什么需要DeFi</p><ul><li>垮境手续费</li><li>经济可能不稳定</li><li>经济状况不好时不适合使用银行</li></ul><p><img src="/2023/03/09/BIU/image-20230309171413201.png" alt="image-20230309171413201"></p><p>Time will tell</p><p><img src="/2023/03/09/BIU/image-20230309171601629.png" alt="image-20230309171601629"></p><h3 id="DAOs"><a href="#DAOs" class="headerlink" title="DAOs"></a>DAOs</h3><ul><li>运行在特定地址的的DAPP</li><li>任何人可以给DAO捐钱</li><li>任何人可以发起请求<ul><li>投票（链上投票，链下可以用snapshot.org，如果通过再上链）<ul><li>如何链下投票，安全地把结果转移到链上是个问题</li></ul></li><li>同意，执行</li></ul></li></ul><p><img src="/2023/03/09/BIU/image-20230309171903673.png" alt="image-20230309171903673"></p><p>甚至有全日制员工，自己的博物馆，工资被program支付</p><p><img src="/2023/03/09/BIU/image-20230309172134135.png" alt="image-20230309172134135"></p><p>gitcoin 写开源代码，给开源者打钱</p><p>直接民主，direct governance，导致了参与度非常低</p><p><img src="/2023/03/09/BIU/image-20230309172510515.png" alt="image-20230309172510515"></p><p><img src="/2023/03/09/BIU/image-20230309172614155.png" alt="image-20230309172614155"></p><p>liquid democracy，也就是代理民主</p><p>政治学家可以进行民主实验，而不用建立一个新的国家</p><p><img src="/2023/03/09/BIU/image-20230309172916272.png" alt="image-20230309172916272"></p><p>2021年 Constitution DAO 但是输了</p><p>如何建立一个有secret treasury的DAO</p><p><img src="/2023/03/09/BIU/image-20230309173401581.png" alt="image-20230309173401581"></p><p>一个dapp，管理DAO的集合</p><p>问题是不知道DAO为什么要投资呢</p><p><img src="/2023/03/09/BIU/image-20230309173805546.png" alt="image-20230309173805546"></p><p><img src="/2023/03/09/BIU/image-20230309174355621.png" alt="image-20230309174355621"></p><p><img src="/2023/03/09/BIU/image-20230309174520582.png" alt="image-20230309174520582"></p><p>跨链</p><p>现实生活中有审计员，区块链可能需要对付款能力的零知识证明</p><p><img src="/2023/03/09/BIU/image-20230309174609532.png" alt="image-20230309174609532"></p><h1 id="An-Overview-of-PoW-and-PoS-Consensus-Valeria-Nikoaenko"><a href="#An-Overview-of-PoW-and-PoS-Consensus-Valeria-Nikoaenko" class="headerlink" title="An Overview of PoW and PoS Consensus - Valeria Nikoaenko"></a>An Overview of PoW and PoS Consensus - Valeria Nikoaenko</h1><p><img src="/2023/03/09/BIU/image-20230310160737648.png" alt="image-20230310160737648"></p><h2 id="Definiation-of-blockchian"><a href="#Definiation-of-blockchian" class="headerlink" title="Definiation of blockchian"></a>Definiation of blockchian</h2><p><img src="/2023/03/09/BIU/image-20230310160836195.png" alt="image-20230310160836195"></p><p>consensus不需要协商整个账本的历史，只需要协商最新的区块并达成一致</p><p>safety:</p><p>liveness: means not consoring, malicious </p><p><img src="/2023/03/09/BIU/image-20230310161343926.png" alt="image-20230310161343926"></p><p>实际像是key-value对，每个区块是对币的重新分配</p><p>D是一个状态</p><p><img src="/2023/03/09/BIU/image-20230310161621599.png" alt="image-20230310161621599"></p><p>节点负责打包交易出块</p><p>client作为用户，发送交易，身份可以重合</p><p><img src="/2023/03/09/BIU/image-20230310161742706.png" alt="image-20230310161742706"></p><p><img src="/2023/03/09/BIU/image-20230310161856858.png" alt="image-20230310161856858"></p><p>选举领导者的过程简化了共识的过程（选项更少）</p><p>假设了理想情况下节点对交易的内容是客观的，但实际上节点会有意见</p><h2 id="PoW-vs-PoS"><a href="#PoW-vs-PoS" class="headerlink" title="PoW vs PoS"></a>PoW vs PoS</h2><p>共识机制consensus 包含两部分</p><ul><li>选举出块者</li><li>每个参与者决定是否接收区块</li></ul><p><img src="/2023/03/09/BIU/image-20230310162245983.png" alt="image-20230310162245983"></p><p><img src="/2023/03/09/BIU/image-20230310162331356.png" alt="image-20230310162331356"></p><p>工作量证明增加了成为出块者的门槛，系统更容易选择如何出块</p><p>虽然很浪费资源，但是没有挖金矿浪费资源</p><p>比特币和以太坊占了时长的80%</p><p><img src="/2023/03/09/BIU/image-20230310163425990.png" alt="image-20230310163425990"></p><p>考虑设计密码系统的成本时，可以参考，计算$2^{76}$次哈希的成本约为$150,000$刀</p><p><img src="/2023/03/09/BIU/image-20230310163902166.png" alt="image-20230310163902166"></p><p>如何设计更好地PoW</p><p><img src="/2023/03/09/BIU/image-20230310164124610.png" alt="image-20230310164124610"></p><ul><li>proof-of-useful-work：解决实际问题</li></ul><p>减少PoW使用的频率：PoW选举领导者，每个任期多次出块</p><p><img src="/2023/03/09/BIU/image-20230310164757487.png" alt="image-20230310164757487"></p><p>挖矿的收益和投入之间成比例</p><p>在PoS中矿工的收入和存的钱相关，任期结束后归还，提供了惩罚的方法；和Pow的区别是：在PoW系统中如果想要退出，已经购买的硬件成本无法像PoS一样回收</p><p><img src="/2023/03/09/BIU/image-20230310165126602.png" alt="image-20230310165126602" style="zoom: 80% ;"></p><p><img src="/2023/03/09/BIU/image-20230310165135320.png" alt="image-20230310165135320"></p><p><img src="/2023/03/09/BIU/image-20230310165601334.png" alt="image-20230310165601334"></p><p>在代理PoS中，借出权益也会获得收益</p><p><img src="/2023/03/09/BIU/image-20230310165926265.png" alt="image-20230310165926265"></p><p>非常成功，全球用电量降低了0.2%，ASIC用户可能转向其他Pow的区块链或者零知识证明的</p><p>An application-specific integrated circuit (ASIC) is <strong>an integrated circuit chip designed for a specific purpose</strong>. An ASIC miner is a computerized device that uses ASICs for the sole purpose of “mining” digital currency. Generally, each ASIC miner is constructed to mine a specific digital currency.</p><h2 id="Longest-chain-vs-BFT"><a href="#Longest-chain-vs-BFT" class="headerlink" title="Longest chain vs BFT"></a>Longest chain vs BFT</h2><p><img src="/2023/03/09/BIU/image-20230310170815540.png" alt="image-20230310170815540"></p><p>BFT是为了设计可靠的分布式系统提出的，但是需要预先知道验证者的规模</p><p><img src="/2023/03/09/BIU/image-20230310171044295.png" alt="image-20230310171044295"></p><p><img src="/2023/03/09/BIU/image-20230310171510394.png" alt="image-20230310171510394"></p><p>推荐的学习资料</p><p><img src="/2023/03/09/BIU/image-20230310171756494.png" alt="image-20230310171756494"></p><p><img src="/2023/03/09/BIU/image-20230310171915851.png" alt="image-20230310171915851"></p><p><img src="/2023/03/09/BIU/image-20230312125824805.png" alt="image-20230312125824805"></p><p><img src="/2023/03/09/BIU/image-20230312130251382.png" alt="image-20230312130251382"></p><p><img src="/2023/03/09/BIU/image-20230312130536483.png" alt="image-20230312130536483"></p><p>Latest message-driven greedy heaviest observed sub-tree</p><p>未被选择的区块内的交易重新回到交易池等待被打包</p><p>最长链方案存在的问题：</p><ul><li><p>双花攻击，确认结果是概率的，等待时间越长，确认的正确概率越高</p></li><li><p>对用户不友好，可能需要等待1h-1day</p></li><li><p>在分片下不安全，可能会出现冲突的链</p></li></ul><p><img src="/2023/03/09/BIU/image-20230312132622028.png" alt="image-20230312132622028" style="zoom:67%;"></p><p><img src="/2023/03/09/BIU/image-20230312132644507.png" alt="image-20230312132644507"></p><p><img src="/2023/03/09/BIU/image-20230312132802166.png" alt="image-20230312132802166"></p><p>Responsiveness指网络越快，完成协议越快</p><p>Hotstuff的创新点在于：</p><ul><li><p>将消息重新发回Leader，让Leader再广播，避免了$n^2$的复杂度</p></li><li><p>支持并行</p></li></ul><p><img src="/2023/03/09/BIU/image-20230312132902496.png" alt="image-20230312132902496"></p><p><img src="/2023/03/09/BIU/image-20230312133156905.png" alt="image-20230312133156905"></p><p><img src="/2023/03/09/BIU/image-20230312133251103.png" alt="image-20230312133251103"></p><p>保证了3个区块后就一定会被确认</p><p><img src="/2023/03/09/BIU/image-20230312133301876.png" alt="image-20230312133301876"></p><p>当验证者的数量增加到大于100时，效率会非常低，延迟会很高</p><p>混合的协议</p><p><img src="/2023/03/09/BIU/image-20230312133530407.png" alt="image-20230312133530407"></p><p><img src="/2023/03/09/BIU/image-20230312133629192.png" alt="image-20230312133629192"></p><p><img src="/2023/03/09/BIU/image-20230312133722087.png" alt="image-20230312133722087"></p><p><img src="/2023/03/09/BIU/image-20230312134123486.png" alt="image-20230312134123486"></p><h1 id="An-Overview-of-the-Ethereum-Excecution-Layer-Dan-Boneh"><a href="#An-Overview-of-the-Ethereum-Excecution-Layer-Dan-Boneh" class="headerlink" title="An Overview of the Ethereum Excecution Layer - Dan Boneh"></a>An Overview of the Ethereum Excecution Layer - Dan Boneh</h1><p><img src="/2023/03/09/BIU/image-20230312134233883.png" alt="image-20230312134233883"></p><p>先上一节crash course</p><p><img src="/2023/03/09/BIU/image-20230312134449575.png" alt="image-20230312134449575"></p><p>状态转移函数，什么是world state</p><p><img src="/2023/03/09/BIU/image-20230312134542647.png" alt="image-20230312134542647"></p><p><img src="/2023/03/09/BIU/image-20230312134658166.png" alt="image-20230312134658166"></p><p><img src="/2023/03/09/BIU/image-20230312134732323.png" alt="image-20230312134732323"></p><p><img src="/2023/03/09/BIU/image-20230312134945076.png" alt="image-20230312134945076"></p><p>这次讲座主要介绍execution_layer</p><h2 id="The-Ethereum-Compute-Layer-The-EVM"><a href="#The-Ethereum-Compute-Layer-The-EVM" class="headerlink" title="The Ethereum Compute Layer: The EVM"></a>The Ethereum Compute Layer: The EVM</h2><p>从顶向下进行介绍</p><p><img src="/2023/03/09/BIU/image-20230312135134997.png" alt="image-20230312135134997"></p><p>状态空间很大，$2^{32}$</p><p>人类的代码站在了同一个层次</p><p><img src="/2023/03/09/BIU/image-20230312140316880.png" alt="image-20230312140316880"></p><p>线性计算复杂度</p><p><img src="/2023/03/09/BIU/image-20230312140547577.png" alt="image-20230312140547577"></p><p>四种类型的交易，contract也可以给contract转钱</p><p><img src="/2023/03/09/BIU/image-20230312140928114.png" alt="image-20230312140928114"></p><p>交易的内容</p><p>来自contract的交易不会被签名</p><p>目的地址为0时相当于建立新的账户，输出hash(your address，your notes)</p><p>如何在链上存储secret key？</p><p>nonce机制是为了防御重放攻击，但仍然可能存在跨链重放，设计了chain_id字段</p><p>如果同一个nonce被使用多次，只有其中一个交易会被接受，其他会被拒绝 </p><p><img src="/2023/03/09/BIU/image-20230312141920486.png" alt="image-20230312141920486"></p><p>提交的代码占的空间越少越好</p><p><img src="/2023/03/09/BIU/image-20230312142831254.png" alt="image-20230312142831254"></p><p><img src="/2023/03/09/BIU/image-20230312143543518.png" alt="image-20230312143543518"></p><p><img src="/2023/03/09/BIU/image-20230312143649117.png" alt="image-20230312143649117"></p><p>archival 存储了所有的历史</p><p>log message for：记录了合约做了什么，如果发起了一个换钱交易，log可能记录了将多少转换为多少</p><p><img src="/2023/03/09/BIU/image-20230312144409662.png" alt="image-20230312144409662"></p><p><img src="/2023/03/09/BIU/image-20230312145244476.png" alt="image-20230312145244476"></p><p><img src="/2023/03/09/BIU/image-20230312145313760.png" alt="image-20230312145313760"></p><p>存在<a href="[What Is a Front-Running Attack? (halborn.com">front running attack</a>](<a href="https://www.halborn.com/blog/post/what-is-a-front-running-attack">https://www.halborn.com/blog/post/what-is-a-front-running-attack</a>)) </p><p>Front-running attacks take advantage of this process of adding transactions to blocks based on transaction fees. An attacker has the ability to ensure that their transaction is processed before any other transaction by including a higher transaction fee with it. This is called a front-running attack.</p><p><img src="/2023/03/09/BIU/image-20230312150136506.png" alt="image-20230312150136506"></p><p><img src="/2023/03/09/BIU/image-20230312150231761.png" alt="image-20230312150231761"></p><p><img src="/2023/03/09/BIU/image-20230312150338122.png" alt="image-20230312150338122"></p><p>nameLookup函数是为其他智能合约设计的，brain of the contract</p><p>如果把秘密放在链上</p><p>为什么使用name而不是直接使用地址：</p><ul><li>name的代价是付出成本，convenience costs money</li><li>某种意义上将name可能更安全，address可能存在typo</li></ul><p>目前存在系统中的小bug：由于交易的目的地址可以是虚假的地址，造成了不存在的地址却拥有账户余额的情况，如果智能合约的编写假设了余额为0，可能产生bug</p><p><img src="/2023/03/09/BIU/image-20230312173809451.png" alt="image-20230312173809451"></p><p>一般数据存在链下，链上存储承诺</p><p><img src="/2023/03/09/BIU/image-20230312174155419.png" alt="image-20230312174155419"></p><p>log是执行层产生的，但是执行层不能读</p><p><img src="/2023/03/09/BIU/image-20230312174542018.png" alt="image-20230312174542018"></p><p><img src="/2023/03/09/BIU/image-20230312180142873.png" alt="image-20230312180142873"></p><p><img src="/2023/03/09/BIU/image-20230312180429548.png" alt="image-20230312180429548"></p><p><img src="/2023/03/09/BIU/image-20230312180621134.png" alt="image-20230312180621134"></p><p><img src="/2023/03/09/BIU/image-20230312180445905.png" alt="image-20230312180445905"></p><h1 id="CeFi-Versus-DeFi-Arthur-Gervais"><a href="#CeFi-Versus-DeFi-Arthur-Gervais" class="headerlink" title="CeFi Versus DeFi - Arthur Gervais"></a>CeFi Versus DeFi - Arthur Gervais</h1><p><img src="/2023/03/09/BIU/image-20230313151729740.png" alt="image-20230313151729740"></p><p>Defi存在于application logic state层 ，将逻辑编码在应用程序中</p><p>设计的composability使得应用之间能够进行交互</p><p>标准保证了composability</p><p>arbitrage：套利</p><p> What Is a Bear Raid?</p><p>A bear raid is an illegal practice of colluding to push a stock’s price lower through concerted <a href="https://www.investopedia.com/terms/s/shortselling.asp">short selling</a>, while spreading negative rumors about the shorted company. A bear raid is sometimes undertaken by unscrupulous short sellers who want to make a quick buck from their short positions, leveraging social media platforms and online message boards.<img src="/2023/03/09/BIU/image-20230313153521850.png" alt="image-20230313153521850"></p><p>what is stable coin like USDC？A stablecoin is a <strong>digital currency that is pegged to a “stable” reserve asset</strong> like the U.S. dollar or gold. Stablecoins are designed to reduce volatility relative to unpegged cryptocurrencies like Bitcoin.</p><p>由于比特币缺乏接受外界输出的能力，需要使用Oracle和现实世界交互.<strong>区块链外信息写入区块链内的机制，一般被称为预言机 (oracle mechanism)</strong> <a href="[什么是区块链预言机（BlockChain Oracle） - 知乎 (zhihu.com">参考</a>](<a href="https://zhuanlan.zhihu.com/p/52369816">https://zhuanlan.zhihu.com/p/52369816</a>))</p><p>Oracle需要了解实时的汇率</p><p><img src="/2023/03/09/BIU/image-20230313155357802.png" alt="image-20230313155357802"></p><p>custodial就是类似于银行的机构，保管大部分资产</p><p>任何参与者不能有优势来审查交易和协议执行</p><p><img src="/2023/03/09/BIU/image-20230313160105543.png" alt="image-20230313160105543"></p><p><img src="/2023/03/09/BIU/image-20230313160224017.png" alt="image-20230313160224017"></p><p> <img src="/2023/03/09/BIU/image-20230313160417991.png" alt="image-20230313160417991"><img src="/2023/03/09/BIU/image-20230313160353603.png" alt="image-20230313160353603"></p><p>FAFT gives examples but not standards.</p><p>如果有节点能独自审查交易，可能会要求KYC/AML</p><p><img src="/2023/03/09/BIU/image-20230313161156286.png" alt="image-20230313161156286"></p><p>稳定币可以冻结一些地址，减少攻击带来的危害 2周前发生过</p><p>usdt可以销毁 </p><p><img src="/2023/03/09/BIU/image-20230313162127044.png" alt="image-20230313162127044"></p><p><img src="/2023/03/09/BIU/image-20230313162307038.png" alt="image-20230313162307038"></p><p>limit order book</p><p><img src="/2023/03/09/BIU/image-20230313162621936.png" alt="image-20230313162621936"></p><p>买卖订单可以分为市价订单（market order）和限价订单（limit order），市价订单是指当交易者想要尽可能快速地执行目标交易指令，从而以市场最优价格发出的订单指令；限价订单则区别于最优价格，交易者会在订单中指定买入的最高价格或者卖出的最低价格，以及对应的订单规模，等待市场价格变动后到达自己的目标价位，再进行撮合成交。这些限价订单被交易所整合到一起并挂出，就是我们所介绍的限价订单簿。因此，限价订单簿（limit order book, LOB），顾名思义，也就是市场上限价订单的集合簿。</p><p><img src="/2023/03/09/BIU/image-20230313163116934.png" alt="image-20230313163116934"></p><p><a href="https://zhuanlan.zhihu.com/p/446271796">什么是Uniswap? 史上最全新手导读 - 知乎 (zhihu.com)</a></p><p><img src="/2023/03/09/BIU/image-20230313164051858.png" alt="image-20230313164051858"></p><p><img src="/2023/03/09/BIU/image-20230313164734783.png" alt="image-20230313164734783"></p><p>如何免费发送交易，using relayer，如果失败了不需要付款</p><p><img src="/2023/03/09/BIU/image-20230313165108420.png" alt="image-20230313165108420"> </p><p><img src="/2023/03/09/BIU/image-20230313165455850.png" alt="image-20230313165455850"></p><p>在Defi中抵押的价值通常比借的数额更多</p><p>杠杆是导致借贷流行的重要因素</p><p><img src="/2023/03/09/BIU/image-20230313165808193.png" alt="image-20230313165808193"></p><p><img src="/2023/03/09/BIU/image-20230313170926997.png" alt="image-20230313170926997"></p><p><img src="/2023/03/09/BIU/image-20230313172802145.png" alt="image-20230313172802145"></p><p>主要用来交换担保或者套利</p><p><img src="/2023/03/09/BIU/image-20230313172947491.png" alt="image-20230313172947491"></p><p>可能会被拿来进行投票（虚假的权益），makerDAO，已经修复无法进行投票 ；</p><p>可能会被用来套现</p><p><img src="/2023/03/09/BIU/image-20230313173247208.png" alt="image-20230313173247208"></p><p>rational矿工实际可以在打包交易时本地运行程序来检查自己能否复现套现的操作，为自己谋利</p><p><img src="/2023/03/09/BIU/image-20230313174329437.png" alt="image-20230313174329437"></p><p><img src="/2023/03/09/BIU/image-20230313174417558.png" alt="image-20230313174417558"></p><p><img src="/2023/03/09/BIU/image-20230313174436585.png" alt="image-20230313174436585"></p><p><img src="/2023/03/09/BIU/image-20230313174516002.png" alt="image-20230313174516002"></p><p><img src="/2023/03/09/BIU/image-20230313174545417.png" alt="image-20230313174545417"></p><p><img src="/2023/03/09/BIU/image-20230313174634381.png" alt="image-20230313174634381"></p><p><img src="/2023/03/09/BIU/image-20230313174653896.png" alt="image-20230313174653896"></p><p><img src="/2023/03/09/BIU/image-20230313175230630.png" alt="image-20230313175230630"></p><p><img src="/2023/03/09/BIU/image-20230313175347680.png" alt="image-20230313175347680"> </p><p><img src="/2023/03/09/BIU/image-20230313175538566.png" alt="image-20230313175538566"></p><p><img src="/2023/03/09/BIU/image-20230313175555758.png" alt="image-20230313175555758"></p><p>如果钱包的私钥泄露，可能存在跨链的安全性问题</p><p><img src="/2023/03/09/BIU/image-20230313175832184.png" alt="image-20230313175832184"></p><p><img src="/2023/03/09/BIU/image-20230313175946183.png" alt="image-20230313175946183"></p><p>GameStop </p><p><img src="/2023/03/09/BIU/image-20230313180205737.png" alt="image-20230313180205737"></p><p><img src="/2023/03/09/BIU/image-20230313180313425.png" alt="image-20230313180313425"></p><h1 id="Hard-Problems-in-Blockchains-Valeria-Nikolaenko"><a href="#Hard-Problems-in-Blockchains-Valeria-Nikolaenko" class="headerlink" title="Hard Problems in Blockchains - Valeria Nikolaenko"></a>Hard Problems in Blockchains - Valeria Nikolaenko</h1><p><img src="/2023/03/09/BIU/image-20230314091825196.png" alt="image-20230314091825196"></p><h2 id="Long-Range-Attack"><a href="#Long-Range-Attack" class="headerlink" title="Long-Range Attack"></a>Long-Range Attack</h2><p>虽然讲的是困难问题，实际上区块链系统运行的很好，更加高效节约能源（不要被吓到233）</p><p><img src="/2023/03/09/BIU/image-20230314092026596.png" alt="image-20230314092026596"></p><p>出块时锁定了自己的权益，如果作恶会被惩罚</p><p><img src="/2023/03/09/BIU/image-20230314092155928.png" alt="image-20230314092155928"></p><p><img src="/2023/03/09/BIU/image-20230314092213092.png" alt="image-20230314092213092"> </p><p>考虑验证者的生命周期，当不再持有财产后没有保存旧的密钥的动机</p><p><img src="/2023/03/09/BIU/image-20230314092852032.png" alt="image-20230314092852032"></p><p>PoS中敌手很容易做到分叉，PoW中不适用</p><p>当以前的私钥泄露后，敌手可能轻易伪造一条和当前链长度相同的分叉</p><p><img src="/2023/03/09/BIU/image-20230314092917720.png" alt="image-20230314092917720"></p><p><img src="/2023/03/09/BIU/image-20230314093141414.png" alt="image-20230314093141414"></p><p>当验证者密钥最少的时候最容易受到敌手攻击</p><p><img src="/2023/03/09/BIU/image-20230314093304538.png" alt="image-20230314093304538"> </p><p>将主链的区块哈希硬编码在中心化组织，比如github</p><ul><li>如果不中心化，检查点的哈希可能不一样，如何协商/选择</li><li>可以把检查点写在PoW区块链上（目前最实际的做法）<ul><li>如果安全性依赖PoW的链，PoS也没有那么节约电力 </li></ul></li></ul><p><img src="/2023/03/09/BIU/image-20230314094015158.png" alt="image-20230314094015158"></p><p>如果不验证轮换密钥，更加容易攻击。考虑在$t_4$攻击两个节点很困难，但是等价于在$t_2$攻击相同的两个节点</p><p>核心思想是激励验证者更新密钥</p><p><img src="/2023/03/09/BIU/image-20230314094506538.png" alt="image-20230314094506538"></p><p><img src="/2023/03/09/BIU/image-20230314094848617.png" alt="image-20230314094848617"></p><p>公钥不变，更新私钥，但是会泄露部分信息，私钥会变得越来越弱</p><p>假设相信他们会忘记旧的密钥</p><p>如果验证者知道未来可能通过出售私钥获利，无法假设验证者是诚实的，因此无法解决实际问题</p><p><img src="/2023/03/09/BIU/image-20230314095334330.png" alt="image-20230314095334330"></p><p>以太坊建议的解决方案 ，问题是实际上验证者和客户端不会一直查看链的状态</p><p><img src="/2023/03/09/BIU/image-20230314095519060.png" alt="image-20230314095519060"></p><p>开始介绍自己发的文章，引入了第二层共识</p><p><img src="/2023/03/09/BIU/image-20230314095757652.png" alt="image-20230314095757652"></p><p>如果区块链生成区块的速度很快，用户发起的交易的last_block字段很可能落后于当前区块，可以考虑设置此字段为更长的时间间隔，比如epoch</p><p><img src="/2023/03/09/BIU/image-20230314095924108.png" alt="image-20230314095924108"></p><p><img src="/2023/03/09/BIU/image-20230314100013866.png" alt="image-20230314100013866"></p><p><img src="/2023/03/09/BIU/image-20230314100050437.png" alt="image-20230314100050437"></p><p><img src="/2023/03/09/BIU/image-20230314100343805.png" alt="image-20230314100343805"></p><p>第二层共识需要用户在线，实际的场景可能没有这么多用户在线，考虑代理或降低交易费</p><p>验证者可能会更加倾向于打包一些交易，不再客观 </p><p>假设所有用户知道当前正确的链是哪一条，预防了敌手不知道在哪条冲突的链投票的情况</p><p>存在潜在中心化的问题：用户的对链上信息的了解可能来自某些中心化机构，比如交易所；本方案要求用户对比各个信息源的</p><p>方案类似于要求用户参与链的安全性</p><p><img src="/2023/03/09/BIU/image-20230314103006306.png" alt="image-20230314103006306"></p><h2 id="Proposer-Election-in-PoS"><a href="#Proposer-Election-in-PoS" class="headerlink" title="Proposer Election in PoS"></a>Proposer Election in PoS</h2><p><img src="/2023/03/09/BIU/image-20230314103452297.png" alt="image-20230314103452297"></p><p>如果T的值很大，攻击者很容易引诱leader或者进行Dos攻击</p><p><img src="/2023/03/09/BIU/image-20230314105318786.png" alt="image-20230314105318786"></p><p>循环选择显然不满足不可预测性和无偏性</p><p><img src="/2023/03/09/BIU/image-20230314105713753.png" alt="image-20230314105713753"></p><p>使用RB的问题在于出现了循环依赖关系，一般的解决方案是当前轮固定proposer的schedule</p><p>以太坊采用的drb</p><p><img src="/2023/03/09/BIU/image-20230314110033912.png" alt="image-20230314110033912"></p><p>节点可以选择提交$v_i$或者保存，但是VDF保证了无法预先计算随机数的值，不具备提前进行判断的优势</p><p>问题是目前的实践部分，VDF的理论构造很好，但是实际的构造基于class group，很多人不看好；</p><p>以太坊的构造是对同一个函数的多次计算并给出证明，未来很可能会出现可用的</p><p>为了保证VDF无法被加速，需要在ASIC进行验证（很贵）</p><p><img src="/2023/03/09/BIU/image-20230314111602084.png" alt="image-20230314111602084"></p><p>ethereum</p><p><img src="/2023/03/09/BIU/image-20230314111615701.png" alt="image-20230314111615701"></p><p><img src="/2023/03/09/BIU/image-20230314113106896.png" alt="image-20230314113106896"></p><h2 id="Post-quantum-blockchains"><a href="#Post-quantum-blockchains" class="headerlink" title="Post-quantum blockchains"></a>Post-quantum blockchains</h2><p><img src="/2023/03/09/BIU/image-20230314144442669.png" alt="image-20230314144442669"></p><p><img src="/2023/03/09/BIU/image-20230314144521529.png" alt="image-20230314144521529"></p><p>PoW机制也存在问题，量子矿工能在$T$时间搜索$T^2$的空间，可能传统矿工挖矿的动机会消失</p><p>hash函数的困难性依然得到保证</p><p><img src="/2023/03/09/BIU/image-20230314144857476.png" alt="image-20230314144857476"></p><p><img src="/2023/03/09/BIU/image-20230314144932739.png" alt="image-20230314144932739"></p><p>后量子签名的大小显著增加</p><p><img src="/2023/03/09/BIU/image-20230314145205986.png" alt="image-20230314145205986"></p><p><img src="/2023/03/09/BIU/image-20230314145215000.png" alt="image-20230314145215000"></p><p><img src="/2023/03/09/BIU/image-20230314145249133.png" alt="image-20230314145249133"></p><p><img src="/2023/03/09/BIU/image-20230314145409065.png" alt="image-20230314145409065"></p><p>可以采用零知识证明证明自己拥有seed来宣称所有权</p><p><img src="/2023/03/09/BIU/image-20230314150230758.png" alt="image-20230314150230758"></p><p><img src="/2023/03/09/BIU/image-20230314150248652.png" alt="image-20230314150248652"></p><p><img src="/2023/03/09/BIU/image-20230314150316944.png" alt="image-20230314150316944"></p><h1 id="The-Risk-of-Censorship-and-De-anonymization-Arthur-Gervais"><a href="#The-Risk-of-Censorship-and-De-anonymization-Arthur-Gervais" class="headerlink" title="The Risk of Censorship and De-anonymization - Arthur Gervais"></a>The Risk of Censorship and De-anonymization - Arthur Gervais</h1><p>define censorship:</p><ul><li>某个矿工忽略某个交易，属于censor吗</li><li>许多矿工故意不传播某个交易，属于对该交易censor</li><li>如果网络发生了分片，可能是一种censor</li></ul><p><img src="/2023/03/09/BIU/image-20230329095555113.png" alt="image-20230329095555113"></p><p><img src="/2023/03/09/BIU/image-20230329095714528.png" alt="image-20230329095714528"></p><p><img src="/2023/03/09/BIU/image-20230329103715524.png" alt="image-20230329103715524"></p><p><img src="/2023/03/09/BIU/image-20230329103750638.png" alt="image-20230329103750638"></p><p>Q：为什么tornado cash只实现输入1eth拿出1eth而不支持1.1eth进1.1出</p><p>A：如果进入的输入不固定为1,10,100，敌手容易观察出身份</p><p>Q：who pays for the gas？</p><p>A：存在一个第三方，需要混币的人向第三方发送证明，第三方负责给mixer支付gas，然后从需要混币的人从池子中拿回的钱里取一部分做补偿</p><ul><li>或许可以拿存的钱来挖矿，类似于银行</li></ul><p>mixer的用户足够多时，才能够保护用户的隐私。同时还需要浏览器，ip地址可能泄露隐私的保护。</p><p><img src="/2023/03/09/BIU/image-20230329105756930.png" alt="image-20230329105756930"></p><p>相当一部分来自TC自己，说明可能经过多次混币</p><p><img src="/2023/03/09/BIU/image-20230329105847587.png" alt="image-20230329105847587"></p><p>制裁之后TC的存款量减少为以前的20%</p><p>多次混币</p><p><img src="/2023/03/09/BIU/image-20230410101127788.png" alt="image-20230410101127788"></p><p><img src="/2023/03/09/BIU/image-20230329110006218.png" alt="image-20230329110006218"></p><p>但是从矿池角度来看，制裁之后包含TC交易的矿池几乎没有了</p><p><img src="/2023/03/09/BIU/image-20230329110214688.png" alt="image-20230329110214688"></p><p><img src="/2023/03/09/BIU/image-20230329110825537.png" alt="image-20230329110825537"></p><p>以太坊目前有四类实体</p><ul><li>searchers 逐利，可能在套利/清算，将交易发给builder</li><li>builder负责将交易打包为有序的区块，发给relayer</li><li>relayer选择出价最高的交易交给validator出块</li></ul><p>究竟谁在参与censor？</p><p><img src="/2023/03/09/BIU/image-20230329111257477.png" alt="image-20230329111257477"></p><p>图中的绿色区块是包含TC交易的区块，即认为是没有被审查过的</p><p>该网站提供了以太坊的四类实体的交易区块的可视化<a href="https://mevboost.pics/">mevboost.pics | MEV-Boost Dashboard</a></p><p>Maximal Extractable Value (MEV) is a method for miners or validators to increase their profits by changing the order of transactions before approving a new block on the network. MEV refers to profits that can be made by extracting value from Ethereum users by reordering, inserting, or censoring transactions within blocks being produced. It is one of Ethereum’s biggest issues, with more than $689 million extracted from users of the network year-to-date.</p><p>TC交易被ban掉的这一现象可能就是一种censorship</p><p><img src="/2023/03/09/BIU/image-20230329112311713.png" alt="image-20230329112311713"></p><p>blender.io不是智能合约，由第三方实体提供混币服务，当OFAC开始后，服务几乎停止了（相对于智能合约，代码开源，更难容易关停）</p><p><img src="/2023/03/09/BIU/image-20230329112322049.png" alt="image-20230329112322049"></p><p>Q：security implications of censorship?</p><p><img src="/2023/03/09/BIU/image-20230329113530464.png" alt="image-20230329113530464"></p><p>如何判断交易确认延迟：引入挖矿矿池之外的节点spy node</p><p><img src="/2023/03/09/BIU/image-20230329113645178.png" alt="image-20230329113645178"></p><p>实验结果显示censor 交易确认时间出现了变化15.8s-29.3s</p><p>但是实验无法区分是sanction导致了变化还是ethereum的proposer builder(M PBS)区分导致的</p><p><img src="/2023/03/09/BIU/image-20230329113942951.png" alt="image-20230329113942951"> </p><p>接下来考虑DOS的部分，核心思想是让节点执行工作却不付gas ，前提条件是发起交易比验证更廉价</p><p><img src="/2023/03/09/BIU/image-20230329114409396.png" alt="image-20230329114409396"></p><p>如何设计攻击：交易前面都是复杂的逻辑，但是最后是TC，由于节点想要监管，并不会将交易包含在区块内，类似于让validator打白工了</p><p><img src="/2023/03/09/BIU/image-20230329115047150.png" alt="image-20230329115047150"></p><p>存在问题：如何得知哪个validator在执行交易</p><p>已经解决：查看每个块的coinbase交易，可以区分执行censoring和不censoring的miner</p><p>后续可以设计更加精巧的攻击方案：如果可能得知下一个validator会censor再攻击</p><p><img src="/2023/03/09/BIU/image-20230329141242534.png" alt="image-20230329141242534"></p><p><img src="/2023/03/09/BIU/image-20230329141353038.png" alt="image-20230329141353038"></p><p>通过这个问题，提出了Censor可能引入被Dos攻击这一问题</p><p><img src="/2023/03/09/BIU/image-20230329165410233.png" alt="image-20230329165410233"></p><p>Q：如果所有的validator开始审查，是否可以通过硬分叉来实现先拿到fee再执行</p><p>A：可能存在的</p><h1 id="What-Are-Snarks-and-What-Are-They-Good-for-Dan-Boneh"><a href="#What-Are-Snarks-and-What-Are-They-Good-for-Dan-Boneh" class="headerlink" title="What Are Snarks and What Are They Good for? - Dan Boneh"></a>What Are Snarks and What Are They Good for? - Dan Boneh</h1><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p><img src="/2023/03/09/BIU/image-20230329170654067.png" alt="image-20230329170654067"></p><p>40年发展，第一行是提供snark的公司，第二行是使用snark的公司，第三行是研究snark硬件加速的</p><p><img src="/2023/03/09/BIU/image-20230329170940528.png" alt="image-20230329170940528"></p><p>ZNARK发展快速的原因</p><p><img src="/2023/03/09/BIU/image-20230329171633196.png" alt="image-20230329171633196"></p><p>what is layer1 blockchain</p><p>Layer 1 refers to a base network, such as Bitcoin, BNB Chain, or Ethereum, and its underlying infrastructure. Layer-1 blockchains can validate and finalize transactions without the need for another network. Making improvements to the scalability of layer-1 networks is difficult, as we’ve seen with Bitcoin. As a solution, developers create layer-2 protocols that rely on the layer-1 network for security and consensus. Bitcoin’s Lightning Network is one example of a layer-2 protocol. It allows users to make transactions freely before recording them into the main chain.</p><p>讨论两类区块链：</p><ul><li>外包计算的：没有隐私，不需要ZK，但是链上存储非常昂贵，交易需要快速被验证<ul><li>跨链：对旧链资产进行证明，B链证明</li><li>如何实现资产的跨链？在旧链上lock资产，新链得知存在被locked的资产</li></ul></li><li>需要保护隐私的链<ul><li>证明加密的交易有效</li><li>证明交易是可偿还的，证明资产</li></ul></li></ul><p>研究的目的：证明更短，验证更快，生成证明更快</p><p><img src="/2023/03/09/BIU/image-20230329173006577.png" alt="image-20230329173006577"></p><p><img src="/2023/03/09/BIU/image-20230329173516102.png" alt="image-20230329173516102"></p><p>区块链驱动了SNARKS的发展，许多其他的与区块链无关的应用收益</p><p><img src="/2023/03/09/BIU/image-20230329173756175.png" alt="image-20230329173756175"></p><p><img src="/2023/03/09/BIU/image-20230329173820719.png" alt="image-20230329173820719"></p><p><a href="https://a16zcrypto.com/content/article/zero-knowledge-canon/">Zero Knowledge Canon, part 1 &amp; 2 - a16z crypto</a></p><h2 id="what-is-SNARK"><a href="#what-is-SNARK" class="headerlink" title="what is SNARK?"></a>what is SNARK?</h2><p><img src="/2023/03/09/BIU/image-20230329174411327.png" alt="image-20230329174411327"></p><p>算术电路，n元多项式的评估方法</p><p><img src="/2023/03/09/BIU/image-20230329174551593.png" alt="image-20230329174551593"></p><p>pp is prover parameter，vp is verifier parameter.</p><p><img src="/2023/03/09/BIU/image-20230329174843720.png" alt="image-20230329174843720"></p><p>next</p><p><img src="/2023/03/09/BIU/image-20230330154239398.png" alt="image-20230330154239398"></p><p>NARK is trivial </p><p>NARK with succint</p><p>任何比trivial NARK更好的方法都很有意义，比如当证明的长度为sub-linear</p><p><img src="/2023/03/09/BIU/image-20230330155356530.png" alt="image-20230330155356530"></p><p>目前有的SNARK证明的长度和验证的时间都是常数</p><p>比较有趣的地方：验证者甚至不能完全读入C就要做出验证？实际上VP是C的一个总结</p><p><img src="/2023/03/09/BIU/image-20230330155833321.png" alt="image-20230330155833321"></p><p>这次讲座主要讲SNARK，存在从SNARK到zk-SNARK的通用构造，因此困难的部分在构造SNARK</p><p><img src="/2023/03/09/BIU/image-20230330160047589.png" alt="image-20230330160047589"></p><p>zero-knowledge可能不公开witness</p><p><img src="/2023/03/09/BIU/image-20230330160155218.png" alt="image-20230330160155218"></p><p><img src="/2023/03/09/BIU/image-20230330160333294.png" alt="image-20230330160333294"></p><p> 现实中使用snark并不需要写算术电路，已经有了domain-specific的语言，建议学习</p><p>采用dsl写好后编辑器编译为SNARK友好的形式：circuit/EVM</p><p>给定输入x和witness产生证明的过程可能需要很多的计算</p><p>但是输出很可能是简单的几百个字节，DB建议打印在T恤上</p><p>问题是谁来执行高昂的运算？现在有专门的公司</p><p><img src="/2023/03/09/BIU/image-20230330161158370.png" alt="image-20230330161158370"></p><p>未来可能会有证明市场，证明者选算力提供者来产生证明，臭打游戏的显卡空闲时也可以用来产生证明</p><p><img src="/2023/03/09/BIU/image-20230330161724731.png" alt="image-20230330161724731"></p><p>存在树形的递归证明，prover3不证明交易，证明prover1和prover2</p><p>non-interactive表现在verifier的验证阶段</p><p>think：who gets paid？</p><p>为什么不能哪个节点先响应就把证明任务交给哪个节点？如果这样设计，永远都是硬件最强的节点进行证明，存在中心化的风险，因此市场需要<strong>指派</strong>由哪个节点来证明，这里需要设计界复杂的机制，可能会有密码的应用</p><p>为什么要去中心化？出于对效率的考虑而不是安全的考虑，现有的算力是分布式的现状</p><p>如果witness是保密的，可以采用秘密分享，分拆后的份额分别进行证明</p><p>证明的交易之前可能存在一致性的问题，tx1的输出可能会影响tx3</p><h2 id="applications-of-SNARKs-Tornado"><a href="#applications-of-SNARKs-Tornado" class="headerlink" title="applications of SNARKs-Tornado"></a>applications of SNARKs-Tornado</h2><p><img src="/2023/03/09/BIU/image-20230330163311245.png" alt="image-20230330163311245"></p><p>只有名字里没写zk的Tornado使用了零知识证明（乐</p><p>Q：目前zkRollup在实际的full contract中运行，效率如何</p><p>A：硬件问题，是可以并行的，需要更多GPU即可</p><p>DAI是稳定币，1000dai约为1000刀乐</p><p><img src="/2023/03/09/BIU/image-20230330164309241.png" alt="image-20230330164309241"></p><p>看起来人畜无害（benign）</p><p>coin merkle tree存了当前存储的所有coin，链上存储过于昂贵，链上只存merkle root</p><p>nullifier </p><p><img src="/2023/03/09/BIU/image-20230330164728293.png" alt="image-20230330164728293"></p><p>当Alice想要存100DAI时，给出<code>MerkleProof(4)</code>和<code>C_4</code>，发送的证明必须和当前的<code>next</code>字段值相同</p><p><img src="/2023/03/09/BIU/image-20230330164853379.png" alt="image-20230330164853379"></p><p>合约检查证明，计算更新后的<code>merkle_root</code>，更新状态</p><p>Alice保存hash的原像即可作为取钱的凭证</p><p><img src="/2023/03/09/BIU/image-20230330165249850.png" alt="image-20230330165249850"></p><p>存在的问题：observer知道谁存在哪个叶节点</p><p><img src="/2023/03/09/BIU/image-20230330165742310.png" alt="image-20230330165742310"></p><p>当Bob要取钱时证明自己有nf，不泄露存的是哪个币</p><p><img src="/2023/03/09/BIU/image-20230330165928639.png" alt="image-20230330165928639"></p><p>(i)在10年前是不可能高效证明的，但是由于zkSNARK的发展，现在浏览器的JavaScript几秒内就能够完成</p><p><img src="/2023/03/09/BIU/image-20230330170212615.png" alt="image-20230330170212615"></p><p>A作为输入但是没有使用：在假设敌手不能扩展的情况下，用来防御重放攻击</p><p>一般的论文会证明soundness，但是实际上不可延展性非常重要</p><p><img src="/2023/03/09/BIU/image-20230330170623789.png" alt="image-20230330170623789"></p><p><img src="/2023/03/09/BIU/image-20230330170934504.png" alt="image-20230330170934504"></p><p><img src="/2023/03/09/BIU/image-20230330171004406.png" alt="image-20230330171004406"></p><p>取完钱后需要新加上nf</p><p><img src="/2023/03/09/BIU/image-20230330173051993.png" alt="image-20230330173051993"></p><p><img src="/2023/03/09/BIU/image-20230330173334189.png" alt="image-20230330173334189"></p><p><img src="/2023/03/09/BIU/image-20230330173416547.png" alt="image-20230330173416547"></p><p>设计的很好，然后被别人拿来洗钱了</p><p>吃一堑长一智：支付系统中完全的匿名化问题多多</p><p><img src="/2023/03/09/BIU/image-20230330173819854.png" alt="image-20230330173819854"></p><p>如何设计</p><p><img src="/2023/03/09/BIU/image-20230330174951441.png" alt="image-20230330174951441"></p><p>显然不可以，攻击者可以使用proxy</p><p>Tornado的匿名性可以通过存储的时间来增强，存的时间越长越不容易被链接起来</p><p><img src="/2023/03/09/BIU/image-20230330180629504.png" alt="image-20230330180629504"></p><h1 id="Permissionless-Consensus-I-Rafael-Pass"><a href="#Permissionless-Consensus-I-Rafael-Pass" class="headerlink" title="Permissionless Consensus I - Rafael Pass"></a>Permissionless Consensus I - Rafael Pass</h1><p><img src="/2023/03/09/BIU/image-20230419161535218.png" alt="image-20230419161535218"></p><p><img src="/2023/03/09/BIU/image-20230419161808584.png" alt="image-20230419161808584"></p><p>future self-consistency sometimes are neglected</p><p>$\Delta$ should be polynomial，比特币假设为10s（非常悲观的取值），实际可能2s已经到达了99%的网络节点</p><p><img src="/2023/03/09/BIU/image-20230419162759632.png" alt="image-20230419162759632"></p><p><img src="/2023/03/09/BIU/image-20230419163838156.png" alt="image-20230419163838156"></p><p>传统的许可链，参与者很少（10），参与者的数量固定，身份已知</p><p>协议执行期间节点不会掉线</p><p>节点之前存在认证信道/PKI </p><p><img src="/2023/03/09/BIU/image-20230419164236072.png" alt="image-20230419164236072"></p><p>实际上认证信道和PKI的区别分长达</p><p><img src="/2023/03/09/BIU/image-20230419165548671.png" alt="image-20230419165548671"></p><p>为什么加一个节点就能保证consistency and liveness</p><p><img src="/2023/03/09/BIU/image-20230419170618762.png" alt="image-20230419170618762"></p><p><img src="/2023/03/09/BIU/image-20230419171411032.png" alt="image-20230419171411032"></p><p>economic robostness指因为节点可能随时离开或加入网络，需要设计激励机制</p><p><img src="/2023/03/09/BIU/image-20230419171626796.png" alt="image-20230419171626796"></p><p><img src="/2023/03/09/BIU/image-20230419171805125.png" alt="image-20230419171805125"></p><p><img src="/2023/03/09/BIU/image-20230419172036888.png" alt="image-20230419172036888"></p><p><img src="/2023/03/09/BIU/image-20230419172355148.png" alt="image-20230419172355148"></p><p>敌手能够伪装为good guy的代价太低了</p><p><img src="/2023/03/09/BIU/image-20230419172503929.png" alt="image-20230419172503929"></p><p>不再依赖于诚实节点的占比，依赖于计算能力</p><p><img src="/2023/03/09/BIU/image-20230419173713048.png" alt="image-20230419173713048"></p><p>考虑一个人恶意</p><p><img src="/2023/03/09/BIU/image-20230419174143595.png" alt="image-20230419174143595"></p><p><img src="/2023/03/09/BIU/image-20230419184223312.png" alt="image-20230419184223312"></p><p><img src="/2023/03/09/BIU/image-20230419184829074.png" alt="image-20230419184829074"></p><p>诚实节点遵循最长链原则</p><p><img src="/2023/03/09/BIU/image-20230419184955890.png" alt="image-20230419184955890"></p><p><img src="/2023/03/09/BIU/image-20230419185118029.png" alt="image-20230419185118029"></p><p><img src="/2023/03/09/BIU/image-20230419185135769.png" alt="image-20230419185135769"></p><p><img src="/2023/03/09/BIU/image-20230419185358888.png" alt="image-20230419185358888"></p><p><img src="/2023/03/09/BIU/image-20230419185502328.png" alt="image-20230419185502328"></p><p>chain quality: get paid for their work</p><p><img src="/2023/03/09/BIU/image-20230419185700177.png" alt="image-20230419185700177"></p><p><img src="/2023/03/09/BIU/image-20230419185806657.png" alt="image-20230419185806657"></p><p>如果有了一个区块链系统，如何得到consensus？</p><ul><li>去掉最后k个区块，实现consistency</li><li>chain is going… even bad guys are censoring</li></ul><p><img src="/2023/03/09/BIU/image-20230419190147884.png" alt="image-20230419190147884"></p><p>看上去chain quality不是最优的：诚实节点比例为1-p，但是得到的链质量为$(1-p/(1-p))$</p><p>实际上这已经是最优的</p><p>敌手可以获得比恶意算力更多的收益：自私挖矿</p><p><img src="/2023/03/09/BIU/image-20230419190705377.png" alt="image-20230419190705377"></p><p>比特币看起来是一个半同步的网络假设，没有用到$\Delta$，但是挖矿的难度$d$隐含了这一条件</p><p>如果网络中的最大时延超过10mins，协议不再安全</p><h1 id="Decentralized-Exchanges-Sandwich-Arbitrage-Arthur-Gervais"><a href="#Decentralized-Exchanges-Sandwich-Arbitrage-Arthur-Gervais" class="headerlink" title="Decentralized Exchanges, Sandwich, Arbitrage - Arthur Gervais"></a>Decentralized Exchanges, Sandwich, Arbitrage - Arthur Gervais</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;13th BIU winter school&lt;/p&gt;</summary>
    
    
    
    <category term="Crypto" scheme="https://alleysira.github.io/categories/Crypto/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>Dumbo</title>
    <link href="https://alleysira.github.io/2023/03/09/Dumbo/"/>
    <id>https://alleysira.github.io/2023/03/09/Dumbo/</id>
    <published>2023-03-09T02:08:27.000Z</published>
    <updated>2023-07-23T10:44:54.222Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1ns4y1Y7yo/?share_source=copy_web&amp;vd_source=4487439a1220fa77bb4a6f0079c98794">区块链异步共识——超速小飞象共识协议</a></p><span id="more"></span><h1 id="超速小飞象共识协议"><a href="#超速小飞象共识协议" class="headerlink" title="超速小飞象共识协议"></a>超速小飞象共识协议</h1><h2 id="健壮的区块链系统需要异步共识"><a href="#健壮的区块链系统需要异步共识" class="headerlink" title="健壮的区块链系统需要异步共识"></a>健壮的区块链系统需要异步共识</h2><ul><li><p>公共账本</p><ul><li><p>保证可以正确写入</p></li><li><p>保证可以正确读取</p></li></ul></li><li><p>智能合约</p><ul><li><p>正确执行</p></li><li><p>条件执行</p></li></ul></li></ul><h3 id="拜占庭共识"><a href="#拜占庭共识" class="headerlink" title="拜占庭共识"></a>拜占庭共识</h3><p>有效性规定了输出具有一定意义：输出是诚实节点的输出</p><p><img src="/2023/03/09/Dumbo/image-20230309100604319.png" alt="image-20230309100604319"></p><h3 id="区块链共识"><a href="#区块链共识" class="headerlink" title="区块链共识"></a>区块链共识</h3><p>BFA是一次性共识，区块链需要的是持续运行的共识协议</p><p><img src="/2023/03/09/Dumbo/image-20230309100647097.png" alt="image-20230309100647097"></p><p><img src="/2023/03/09/Dumbo/image-20230309101037056.png" alt="image-20230309101037056"></p><p>交换机出错6分钟，认为Raft的不够科学</p><p><img src="/2023/03/09/Dumbo/image-20230309101059583.png" alt="image-20230309101059583"></p><p>最终同步网络模型：已知分片有限，不知道什么时候可以恢复</p><p>异步网络模型：刻画了TCP的模型</p><p><img src="/2023/03/09/Dumbo/image-20230309101203507.png" alt="image-20230309101203507"></p><p><img src="/2023/03/09/Dumbo/image-20230309101417682.png" alt="image-20230309101417682"></p><p><img src="/2023/03/09/Dumbo/image-20230309101536669.png" alt="image-20230309101536669"></p><p><img src="/2023/03/09/Dumbo/image-20230309101705780.png" alt="image-20230309101705780"></p><h2 id="性能瓶颈"><a href="#性能瓶颈" class="headerlink" title="性能瓶颈"></a>性能瓶颈</h2><p>确定性算法无法解决异步共识问题</p><p><img src="/2023/03/09/Dumbo/image-20230309101801067.png" alt="image-20230309101801067"></p><p><img src="/2023/03/09/Dumbo/image-20230309101835990.png" alt="image-20230309101835990"></p><p><img src="/2023/03/09/Dumbo/image-20230309101945208.png" alt="image-20230309101945208"></p><p>蜜罐100个节点需要10分钟进行共识</p><p>小飞象主要在轮复杂度进行了优化</p><p><img src="/2023/03/09/Dumbo/image-20230309102125976.png" alt="image-20230309102125976"></p><p>P2P网络中如何实现广播通信：RBC协议，最终获得相同的消息或者都不获得消息</p><p>ABA:对0/1实现共识，保证输出一定来自于至少一个诚实节点，随机化算法，并行的多个实例的停机时间影响效率</p><p>RBC结束了就投票0，未结束投票1</p><p><img src="/2023/03/09/Dumbo/image-20230309102321412.png" alt="image-20230309102321412"></p><p><img src="/2023/03/09/Dumbo/image-20230309102450800.png" alt="image-20230309102450800"></p><p><img src="/2023/03/09/Dumbo/image-20230309102527408.png" alt="image-20230309102527408"></p><p>1个MVBA替换n个ABA，实际只需要2-3个ABA</p><p>思想是实现MVBA的输出是RBC是否完成的投票</p><p><img src="/2023/03/09/Dumbo/image-20230309102708864.png" alt="image-20230309102708864"></p><p><img src="/2023/03/09/Dumbo/image-20230309102814021.png" alt="image-20230309102814021"></p><p><img src="/2023/03/09/Dumbo/image-20230309102836473.png" alt="image-20230309102836473"></p><h2 id="超速小飞象"><a href="#超速小飞象" class="headerlink" title="超速小飞象"></a>超速小飞象</h2><p>解决提到的两个问题</p><p><img src="/2023/03/09/Dumbo/image-20230309102944264.png" alt="image-20230309102944264"></p><p><img src="/2023/03/09/Dumbo/image-20230309103021991.png" alt="image-20230309103021991"></p><p>Totality要求一个节点收到消息，其他节点也必须要收到</p><p>PB 即发送者收到足够多的签名时即可保证f+1个诚实节点收到相同的广播消息</p><p><img src="/2023/03/09/Dumbo/image-20230309103254589.png" alt="image-20230309103254589"></p><p><img src="/2023/03/09/Dumbo/image-20230309103358760.png" alt="image-20230309103358760"></p><p><img src="/2023/03/09/Dumbo/image-20230309103431821.png" alt="image-20230309103431821"></p><p>MVBA是导致延迟的主要原因</p><p><img src="/2023/03/09/Dumbo/image-20230309103519817.png" alt="image-20230309103519817"></p><p><img src="/2023/03/09/Dumbo/image-20230309103557798.png" alt="image-20230309103557798"></p><p><img src="/2023/03/09/Dumbo/image-20230309103645643.png" alt="image-20230309103645643"></p><p><img src="/2023/03/09/Dumbo/image-20230309103720267.png" alt="image-20230309103720267"></p><p><img src="/2023/03/09/Dumbo/image-20230309103800950.png" alt="image-20230309103800950"></p><p><img src="/2023/03/09/Dumbo/image-20230309103946281.png" alt="image-20230309103946281"></p><p><img src="/2023/03/09/Dumbo/image-20230309104051895.png" alt="image-20230309104051895"></p><p><img src="/2023/03/09/Dumbo/image-20230309104129598.png" alt="image-20230309104129598"></p><p><img src="/2023/03/09/Dumbo/image-20230309104210694.png" alt="image-20230309104210694"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1ns4y1Y7yo/?share_source=copy_web&amp;amp;vd_source=4487439a1220fa77bb4a6f0079c98794&quot;&gt;区块链异步共识——超速小飞象共识协议&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/categories/Blockchain/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="Consensus" scheme="https://alleysira.github.io/tags/Consensus/"/>
    
  </entry>
  
  <entry>
    <title>LXY+22</title>
    <link href="https://alleysira.github.io/2023/03/07/LXY-22/"/>
    <id>https://alleysira.github.io/2023/03/07/LXY-22/</id>
    <published>2023-03-07T03:35:13.000Z</published>
    <updated>2023-07-23T10:46:28.096Z</updated>
    
    <content type="html"><![CDATA[<p>Li X Y, Xu J, Yin L Y, et al. Escaping from consensus: Instantly redactable blockchain protocols in permissionless setting[J]. IEEE Transactions on Dependable and Secure Computing, 2022.</p><span id="more"></span><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="主要工作"><a href="#主要工作" class="headerlink" title="主要工作"></a>主要工作</h2><ul><li>基于[DMT19]的思想进行改进，将投票机制和共识机制解耦，从而提高编辑的确认速度，实现即时编辑<ul><li>即节点对是否编辑的投票不再记录在区块上而是直接发送给委员会</li><li>由于安全性不依赖于共识，对恶意敌手的要求从小于1/3，降低为1/2</li><li>实现编辑性的方法是类似于[DMT19]，在区块头保存被编辑区块的$merkle_root$，验证区块的有效性时首先检查前一个区块的哈希，如果不满足则检查编辑策略和旧状态是否满足条件<ul><li>实际工程实现可以在新节点和旧节点之间可以保持一样的区块结构，新节点分别保存原区块链和修改</li><li>所有编辑请求和投票都可以用现有的插入OP RETURN等脚本码来实现</li><li>目前编辑功能只局限于修改非金融字段，提出可以像Reparo一样，在更新UTXO的情况下修改金融数据</li></ul></li></ul></li><li>给出了形式化的可编辑区块链理想模型和基于模拟的安全证明<ul><li>现有方案一般仅分析编辑带来的影响</li><li>证明了满足链质量、链增长和可编辑共同前缀</li></ul></li><li>提供了方案在PoS和PoW区块链中的具体构造<ul><li>实验使用c语言针对采用PoS的Cardano Settlement Layer进行实现</li></ul></li></ul><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><ul><li>利用$Cmt$随机选举委员会，保证委员会超过一定比例的委员一定诚实，恶意敌手无法生成足够投票</li><li>用户想要修改区块$B_j$就生成候选区块$B_j^\star$并广播</li><li>委员对候选区块投票</li></ul><h3 id="委员会选举实现方法"><a href="#委员会选举实现方法" class="headerlink" title="委员会选举实现方法"></a>委员会选举实现方法</h3><p>分析在PoS中实现的$Cmt$算法，使用VRF进行选择（包括Algorand、Cardano、Internet Computer和Polkadot在内的许多L1区块链都在共识机制中使用了VRF来随机选择出块节点）</p><p>$hash$的输出表明了$P_i$有多少投票，每个权益为$s_i$的用户相当于有$s_i$个子用户，每个子用户被选中的概率是$p=\frac{T}{S}$,T是当前委员会投票阶段的权益的和，S是区块链系统权益的和</p><p>$s_i$中$q$个子用户被选中的概率服从二项分布$B(p;q,s_i)=C_{s_i}^q p^q(1-p)^{s_i-q}$</p><p>将区间[0,1)分为连续的区间</p><script type="math/tex; mode=display">I^c=[\sum^c_{q=0}B(p;q,s_i),\sum_{q=0}^{c+1} B(p;q,s_i)),c\in\{1,\dots,s_i\}</script><p>如果$\frac{hash}{2^{hashlen} }$落在$I_c$，证明$c$个用户为$P_i$投票</p><p><img src="/2023/03/07/LXY-22/image-20230309113111623.png" alt="image-20230309113111623"></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li><p>一般将每个出块者任期称为一个epoch，每个epoch由多个slot/round组成，每次生成一个区块</p></li><li><p>本文的slot是怎么定义的没有明确给出</p></li><li><p>共识和投票的区别</p><ul><li>共识是输入状态，得到0,1</li><li>投票是将已经有的0,1进行收集</li></ul></li></ul><p><a href="https://blog.csdn.net/A33280000f/article/details/120683353?spm=1001.2014.3001.5502">参考师兄的博客</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Li X Y, Xu J, Yin L Y, et al. Escaping from consensus: Instantly redactable blockchain protocols in permissionless setting[J]. IEEE Transactions on Dependable and Secure Computing, 2022.&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/categories/Blockchain/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="Redactable Blockchain" scheme="https://alleysira.github.io/tags/Redactable-Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>LMW23</title>
    <link href="https://alleysira.github.io/2023/03/01/LMW23/"/>
    <id>https://alleysira.github.io/2023/03/01/LMW23/</id>
    <published>2023-03-01T09:49:14.000Z</published>
    <updated>2023-07-23T10:46:23.938Z</updated>
    
    <content type="html"><![CDATA[<p>Li J, Ma H, Wang J, et al. Wolverine: A Scalable and Transaction-Consistent Redactable Permissionless Blockchain[J]. IEEE Transactions on Information Forensics and Security, 2023.</p><span id="more"></span><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>区块链中有两种链接关系：hash链接和签名链接</p><ul><li>哈希链接存在于不同区块的区块头之间</li><li>签名链接存在于不同区块的区块体的交易之间，签名链接是满足了之前交易的challenge script的见证</li></ul><p><img src="/2023/03/01/LMW23/image-20230302095926899.png" alt="image-20230302095926899" style="zoom:67%;"></p><p>考虑删除区块$B_2$内的交易$tx^1_2$，可能导致四条交易链接失效$tx^0_0\gets tx^1_2,tx_0^1\gets tx^1_2,tx^1_2\gets tx_3^1 ,tx^1_2\gets tx_3^2 $</p><p>其中交易$tx^0_0\gets tx^1_2,tx_0^1\gets tx^1_2$可能被双花</p><p>交易$tx^1_2\gets tx_3^1 ,tx^1_2\gets tx_3^2$可能会失效</p><h2 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work"></a>Related work</h2><p>[DMT19]为了实现追责，扩展了区块头增加了$old_merkle_root$字段，Reparo相当于将这个字段单独存储在数据库中而不修改区块结构，存在投票周期长和$n=3f+1$；这两篇文章都考虑+了交易的一致性问题，因此将编辑操作限制在非金融字段，不适用于UTXO</p><h2 id="Preliminary"><a href="#Preliminary" class="headerlink" title="Preliminary"></a>Preliminary</h2><h3 id="DRB"><a href="#DRB" class="headerlink" title="DRB"></a>DRB</h3><p>对于参与者$\{P_1,\dots,P_n\}$，$(t,n)$去中心化随机信标包含如下算法：</p><ul><li>$Setup(1^\lambda)\to pp$</li><li>$CmteGen(pp,t,n)\to(cpk,sk_1,\dots,sk_n)$:交互式协议，输出委员会的公钥和参与方对应的私钥</li><li>$PartialRand(cpk,sk_i,st_{l-1})\to s_i$：输入$l-1$轮状态$st_{l-1}$，计算部分值$\sigma_{l,i}$和对应的证明$\pi_{l,i}$，并且$s_i=(i,\sigma_{l,i},\pi_{l,i})$</li><li>$CombRand(cpk,st_{l-1},\varepsilon)\to (\sigma_l,\pi_l)$：输入$\varepsilon=\{s_i\}_{i\in I},|I|\geq t+1$</li><li>$VerifyRand(cpk,st_{l-1},\sigma_l,\pi_l)\to d\in\{0,1\}$</li><li>$UpdState(cpk,st_{l-1},\sigma_l,\pi_l)\to st_l$：输入上一轮的状态，输出更新后的当前轮的状态</li></ul><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><h2 id="System-model"><a href="#System-model" class="headerlink" title="System model"></a>System model</h2><p>考虑在$N$个节点的p2p网络中，存在监管委员会$R$人数$n\ll N$</p><p>假设委员会大多数诚实，委员会成员之间共享变色龙哈希函数密钥</p><ul><li><p>区块链节点首先通过抗女巫攻击的方式生成身份（$pk，sk$）</p></li><li><p>执行去中心化自举协议协商委员会的大小（开销很大但是只执行一次）</p></li><li>网络中任何人都可以将编辑指令放进区块中来发起编辑请求</li><li>委员会成员根据编辑策略验证编辑指令</li><li>如果满足策略，委员会成员投票并作为交易广播</li><li>矿工检查投票并且将有效投票打包进下一个区块</li><li>来自不同委员会成员的投票超过$n/2$之后，每个参与者本地组合份额恢复变色龙哈希函数私钥，执行编辑</li><li>每轮epoch重新选举委员会，重新分发陷门密钥</li></ul><h2 id="Network-and-Threat-model"><a href="#Network-and-Threat-model" class="headerlink" title="Network and Threat model"></a>Network and Threat model</h2><p>同步网络，公有链广泛采用的假设，诚实节点之间的信道延迟至多为$\delta$</p><p>存在同步广播信道（区块链本身）</p><p>考虑PPT的拜占庭敌手，任意时刻腐化的敌手数量满足$\rho &lt; 1/2$，被腐化的敌手可以任意偏离协议，发送错误的消息或者保持沉默</p><p>假设敌手slowly adaptive，敌手可以在每一轮开始或中间选择腐化的集合，但是直到该轮结束腐化才能生效</p><h1 id="NITCH"><a href="#NITCH" class="headerlink" title="NITCH"></a>NITCH</h1><p>给出非交互式变色龙哈希函数的构造和在RO下的安全证明</p><ul><li>部分更新算法$Partial\ Adapt(sk_i,vk_i,m,m’)\to s_i=(i,c_i,\pi_i)$，输出更新后的份额$c_i$和对应的证明</li><li>部分验证算法$Partial \ Verify(pk,vk_i,s_i,m,m’)\to 0/1$ </li><li>$Combine(VK,(h,m,r),m’,\varepsilon) \to r’$，其中$\varepsilon=\{s_{i_1},\dots,s_{i_{ |I| } } \}$输出新的随机数或者空<ul><li>奇怪的是恢复密钥采用的不是原始的私钥份额，而是执行部分更新算法后份额</li></ul></li></ul><p>verification keys的作用</p><h2 id="Instantiation"><a href="#Instantiation" class="headerlink" title="Instantiation"></a>Instantiation</h2><ul><li><p>系统模型阶段</p><ul><li>每个节点建议自己的身份并广播</li><li>协商出大小为$n$的委员会</li><li><p>任何人可以发起RI并广播到区块中</p><ul><li><p>如何发布RI</p><ul><li>存储在区块中的话，相当于需要发起一笔交易</li><li>如果不存在区块，需要一个单独的数据结构存储RI，因此节点本地有</li></ul></li><li><p>如果编辑交易和普通交易不可区分，不需要考虑</p></li><li>如果出块者在打包交易时发现了编辑交易，为什么要打包进编辑交易呢<ul><li>设计激励机制</li></ul></li></ul></li></ul></li><li><p>DKG采用如下方案，只需要一轮通信，但无法保证均匀，用到了RO假设</p><ul><li><img src="/2023/03/01/LMW23/image-20230303170611136.png" alt="image-20230303170611136"></li><li>Non-interactive and information-theoretic secure verifiable secret sharing</li><li>此处第二个生成元的作用：公开可验证常数项的正确性，每个份额的正确性只有拿到份额的人可以验证</li><li>$sk=\sum a_{i,0},sk_j=\sum s_{i,j}=\sum f_i(j),pk=g_2^{\sum a_{i,0}},vk_j=g_1^{\sum s_{i,j} }=g_1^{sk_j},i\in QUAL$</li><li>私钥份额$sk_j$即所有参与者多项式在$j$处的求值</li><li>此处的$l_i^I(0)=\prod\frac{x}{x-x’} \bmod q$<ul><li>参考一篇博客 <a href="https://medium.com/nethermind-eth/a-tour-of-verifiable-secret-sharing-schemes-and-distributed-key-generation-protocols-3c814e0d47e1">https://medium.com/nethermind-eth/a-tour-of-verifiable-secret-sharing-schemes-and-distributed-key-generation-protocols-3c814e0d47e1</a></li><li>DKG使用私钥而不泄露私钥是非常重要的</li></ul></li></ul></li></ul><p>利用NITCH构造DRB</p><p><img src="/2023/03/01/LMW23/image-20230304145041604.png" alt="image-20230304145041604"></p><h1 id="Construction"><a href="#Construction" class="headerlink" title="Construction"></a>Construction</h1><h2 id="Shadow-Transaction-stx"><a href="#Shadow-Transaction-stx" class="headerlink" title="Shadow Transaction(stx)"></a>Shadow Transaction(stx)</h2><ul><li>目的：实现交易级的修改</li><li>将可修改的、能够插入任意数据的字段称为admissible fields $AF(tx,out.script,tx.wit)$</li><li>实际就是复制原来的交易，将AF字段设置为对应的变色龙哈希的值</li><li>带来两个性质<ul><li>可编辑性：交易的AF字段可以被委员会编辑</li><li>不可篡改性：交易的stable fields无法修改（H是抗碰撞的）</li></ul></li></ul><p><img src="/2023/03/01/LMW23/image-20230304153332166.png" alt="image-20230304153332166"></p><h2 id="The-redactable-blockchain-Protocol"><a href="#The-redactable-blockchain-Protocol" class="headerlink" title="The redactable blockchain Protocol"></a>The redactable blockchain Protocol</h2><ul><li>Update local chain：每轮开始选择最长链进行本地更新</li><li>从链去掉末尾k个区块后，收集所有编辑请求<ul><li>将请求加入到RIP(research instruction pool)</li><li>对编辑请求投票，更新RIP中的$(RI,\phi)\to (RI,\{vote\})$</li></ul></li><li>收集投票：更新$(RI,shares\cup s_i)$</li><li>编辑交易：如果$len(shares)&gt;n/2$，执行$NITCH.Combine$算法</li><li>扩展链：产生新区块并广播</li><li>编辑结束之后，其他用户可以提出新的编辑请求</li></ul><h2 id="Committee-Evolution"><a href="#Committee-Evolution" class="headerlink" title="Committee Evolution"></a>Committee Evolution</h2><h3 id="随机数生成"><a href="#随机数生成" class="headerlink" title="随机数生成"></a>随机数生成</h3><p>$R^e$执行DRB为下一轮生成随机数串$\tau^{e+1}$，当前轮结束后揭示$\tau^{e+1}$</p><h3 id="下一轮委员会选举"><a href="#下一轮委员会选举" class="headerlink" title="下一轮委员会选举"></a>下一轮委员会选举</h3><p>下一轮$e+1$开始时，每个参与者本地选择公钥和地址$(PK,IP)$作为身份</p><ul><li>引进IP为了防止女巫攻击</li></ul><p>能够发现PoW的解的参与者作为下一轮委员会的成员（公平性）</p><p>经过$\Delta$时间后，停止选举（如何保证委员会人数正确）</p><h3 id="分布式密钥再分享"><a href="#分布式密钥再分享" class="headerlink" title="分布式密钥再分享"></a>分布式密钥再分享</h3><ul><li><p>处理阶段</p><ul><li>每个$R^e$中的参与者$P_i^e$随机选择多项式$f_i(x)=sk_i^e+\sum_{j=1}^{t^{e+1} } a_{i,j}x^j$（注意此时用的是下一轮的$t$）</li><li>$P_i^e$广播$A_{i,k}=g_1^{a_{i,k}},k=0,\dots,t$</li><li>$P_i^e$计算份额$s_{i,j}=f_i(j),j=1,\dots,n^{e+1}$，发送$f_i(j)\to j$</li></ul></li><li><p>验证阶段：验证发送的秘密份额是否正确，实现对委员会参与者的追责</p><ul><li>参与者$P_j^{e+1}$计算</li><li><script type="math/tex; mode=display">g_1^{ s_{i,j} } \mathop{=}\limits^{?} \prod_{k=0}^{t^{e+1} } (A_{i,j})^{j^k}</script></li><li><p>如果不成立，广播对参与者$P_i^e$的投诉</p></li></ul></li><li><p>投诉阶段（抱怨2333）</p><ul><li>如果每个参与者收到超过$t^{e+1}$个投票就失去委员会资格，$P_i^e$收到投诉时需要重新发送$s_{i,j}$的份额，如果新的份额依然不通过则失去资格</li></ul></li><li><p>恢复阶段 </p><ul><li>计算公共验证密钥</li><li><script type="math/tex; mode=display">\mathrm{vk}_j=\prod_{i \in U} \prod_{k=0}^{t^{(e+1)}} A_{i, k}^{\ell_i^U(0) \cdot j^k}, j \in \mathcal{R}^{(e+1)}</script></li></ul></li><li><p>每个参与者本地计算私钥份额</p><ul><li><script type="math/tex; mode=display">\mathrm{sk}_j=\sum_{i\in U} (\ell^U_i(0)\cdot s_{i,j})</script></li></ul></li></ul><h1 id="目的-amp-收获"><a href="#目的-amp-收获" class="headerlink" title="目的&amp;收获"></a>目的&amp;收获</h1><ul><li>学习如何构造非交互式的门限变色龙哈希<ul><li>显然还是需要交互的</li></ul></li><li>刷新委员会和密钥份额的区别<ul><li>抗女巫攻击的身份生成方案</li></ul></li><li>shadow transaction如何实现交易一致性</li><li>实现多项式插值的算法的加速</li><li>学习 decentralized bootstrapping protocol</li><li>记得学习<a href="https://missing-semester-cn.github.io/2020/">https://missing-semester-cn.github.io/2020/</a></li><li><p>本方案要求本地存储两个数据库</p><ul><li>redaction instruction pool：储存当前的编辑请求，超过门限就恢复秘密执行编辑<ul><li>如何保证这个数据库的同步性，可能有敌手宣称已经超过1/2</li></ul></li><li>check value revocation list：存储区块最新的$r’$<ul><li>为了保证这个字段的一致性，区块头增加了$h=HASH(CVRL)$</li></ul></li></ul></li><li><p>方案的轮数是如何定义的</p></li><li><p>无法实现对区块的删除</p></li><li><p>具体出块者是谁</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Li J, Ma H, Wang J, et al. Wolverine: A Scalable and Transaction-Consistent Redactable Permissionless Blockchain[J]. IEEE Transactions on Information Forensics and Security, 2023.&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/categories/Blockchain/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="Redactable Blockchain" scheme="https://alleysira.github.io/tags/Redactable-Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>ZZL22</title>
    <link href="https://alleysira.github.io/2023/03/01/ZZL22/"/>
    <id>https://alleysira.github.io/2023/03/01/ZZL22/</id>
    <published>2023-03-01T07:15:59.000Z</published>
    <updated>2023-03-06T09:22:52.986Z</updated>
    
    <content type="html"><![CDATA[<p>赵晓琦,张正昊,李勇.可编辑且可追责的区块链方案[J].信息安全学报,2022,7(5):19-28</p><span id="more"></span><h1 id="方案构造"><a href="#方案构造" class="headerlink" title="方案构造"></a>方案构造</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>存在Leader将陷门作为秘密，进行可验证的秘密分享，附带证明。</p><p>链中用户对编辑请求进行投票，利用公钥和Leader的随机数进行哈希并排序选择具有编辑权的用户。</p><p>用户向leader发送密钥并附带证明，编辑者收到t个份额后恢复密钥并进行编辑。</p><p>用户可对编辑后的区块进行验证，对相关方追责。</p><h2 id="秘密分享阶段"><a href="#秘密分享阶段" class="headerlink" title="秘密分享阶段"></a>秘密分享阶段</h2><ul><li>Share：Dealer计算<ul><li>计算$Y_i=(y_i)^{f(i)},i\in [n],C_j=g^{a_j},j\in\{0,t-1\}$<ul><li>这里为什么不能用g，用公钥类似于公钥加密</li></ul></li><li>承诺$c=H(g^{f(i)},y^{f(i)}_i,g^{w_i},y^{w_i}_i)$</li><li>应答$r_i\equiv w_i-f(i)c \bmod q$</li><li>证明$\pi=(c,r_1,\dots,r_n)$</li><li>广播$(Y_1,\dots,Y_n,C_0,\dots,C_{t-1},\pi)$</li></ul></li><li><p>Verify：用户计算</p><ul><li>$g^{w_i}\mathop{=}\limits^{?}g^{r_i}(\prod_{j=0}^{t-1} (C_j)^{i^j})^c$</li><li>$y_i^{w_i}\mathop{=}\limits^{?}y_i^{r_i}(\prod_{j=0}^{t-1} (C_j)^{i^j})^c$</li></ul></li><li><p>Dec：用户计算</p><ul><li>计算$s_i=Y_i^{x_i^{-1}},c_2=H(h^{t_i}|s_i^{t_i})$</li><li>证明$\pi_i=(c_2,t_i-x_ic_2)$（用于对编辑的追责，可能使用虚假的公钥）</li></ul></li></ul><h2 id="投票阶段"><a href="#投票阶段" class="headerlink" title="投票阶段"></a>投票阶段</h2><p>用户对编辑请求投票，需要保证修改的不是金融数据，同意则生成一个随机数加密发给Leader</p><h2 id="寻找编辑者阶段"><a href="#寻找编辑者阶段" class="headerlink" title="寻找编辑者阶段"></a>寻找编辑者阶段</h2><p>$hash_i=H(upk_i,r_{sum})$，用户计算并广播$hash_i$，其中$r_{sum}$相当于是参与者都提供了部分随机性，排序后选择最小的公钥对应的编辑者即可</p><h2 id="编辑阶段"><a href="#编辑阶段" class="headerlink" title="编辑阶段"></a>编辑阶段</h2><p>恢复秘密生成新的随机数即可</p><h2 id="验证追责阶段"><a href="#验证追责阶段" class="headerlink" title="验证追责阶段"></a>验证追责阶段</h2><ul><li>检查$r_{sum}$正确性</li><li>判断编辑权用户的公钥是不是最小的哈希值的输入<ul><li>还要考虑Leader的公钥与随机数的哈希值是否小于最小哈希，如果不满足说明Dealer可能作恶</li></ul></li><li>计算变色龙哈希值成立</li><li><strong>验证子密钥是否正确，即$\pi_i$</strong></li></ul><h1 id="追责性"><a href="#追责性" class="headerlink" title="追责性"></a>追责性</h1><p>定义：编辑后的内容广播到区块链中，用户可验证是否可被接受，出现错误时可以向相关责任方进行追责</p><p>分别考虑验证追责阶段的四个条件：</p><ul><li>Leader可能更改随机数的和来内定编辑者，计算和可以追责到leader</li><li>如果用户的公钥不是最小哈希值，可以追责到编辑者</li><li>如果哈希值不同，用户发送的子密钥正确，追责编辑者</li><li>子密钥错误，追责子密钥拥有者</li></ul><p>如果编辑发布后经公共验证不被接受，追责所有相关者</p><h1 id="目的-amp-收获"><a href="#目的-amp-收获" class="headerlink" title="目的&amp;收获"></a>目的&amp;收获</h1><ul><li>了解可追责的定义，学习可追责的方案设计思路，追责部分详细分析如何追责的思路和方法</li><li>寻找编辑者阶段的设计，每个人生成随机数，Dealer求和再下发和，将随机数的和以及公钥作为哈希输入，对结果排序</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;赵晓琦,张正昊,李勇.可编辑且可追责的区块链方案[J].信息安全学报,2022,7(5):19-28&lt;/p&gt;</summary>
    
    
    
    <category term="Crypto" scheme="https://alleysira.github.io/categories/Crypto/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="Redactable Blockchain" scheme="https://alleysira.github.io/tags/Redactable-Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>JCH22</title>
    <link href="https://alleysira.github.io/2023/02/27/JCH22/"/>
    <id>https://alleysira.github.io/2023/02/27/JCH22/</id>
    <published>2023-02-27T03:18:09.000Z</published>
    <updated>2023-07-23T10:48:40.909Z</updated>
    
    <content type="html"><![CDATA[<p>Jia M, Chen J, He K, et al. Redactable Blockchain From Decentralized Chameleon Hash Functions[J]. IEEE Transactions on Information Forensics and Security, 2022, 17: 2771-2783.</p><span id="more"></span><h1 id="去中心化变色龙哈希函数的构造"><a href="#去中心化变色龙哈希函数的构造" class="headerlink" title="去中心化变色龙哈希函数的构造"></a>去中心化变色龙哈希函数的构造</h1><p>包含五个算法：</p><ul><li><p>$Key\ generation$ 密钥生成算法：需要$t$个参与者$\{P_1,\dots,P_t\}$在线合作共同生成密钥，$g$是循环群生成元，参与者$P_i$ 如下执行</p><ul><li><p>随机生成$t-1$阶多项式：$f_i(x)=\sum_{j=0}^{t-1}a_{i,j}x^j$，秘密为常数项$f_i(0)$</p></li><li><p>给参与者$P_j$发送$f_i(ID(P_j)),(g^{f_i(ID(P_1))},\dots,g^{f_i(ID(P_t))}),g^{f_i(0)}$，类似于拉格朗日插值法，把秘密放在了幂指数上</p><ul><li>$f_i(x)$是否有必要放在幂指数上？如果不放在指数上任何参与者都可以拿到输出私钥的值了</li><li>$f_i(ID(P_j))$的意义在于构建系统的私钥，由于私钥是$s_i=\sum^t_{j=1}f_j(ID(P_i))$，需要其他人的多项式在自己身份处的取值</li></ul></li><li><p>参与者$P_i$收到参与者$P_j$发送的$f_j(ID(P_i)),(g^{f_j(ID(P_1))},\dots,g^{f_j(ID(P_t))}),g^{f_j(0)}$后，计算拉格朗日插值判断是否正确，即计算是否成立</p><ul><li><script type="math/tex; mode=display">f_j(0)=\sum_{k=1}^tf_j(ID(P_k))\prod^t_{l=1,l\neq k}\frac{ID(P_l)}{ID(P_l)-ID(P_k)}</script></li></ul></li><li><p>输出公钥$g^s=\prod_{j=1}^t f_j(0),s=\sum^t_{j=1}a_{j,0}$，相当于$t$个参与者每个人私钥的和，但任何参与者都无法计算出公钥的$s$；输出私钥$s_i=\sum^t_{j=1}f_j(ID(P_i))$，私钥可以用来恢复公钥</p><ul><li>公私钥生成体现了公平性，$t$个参与者</li><li>考虑敌手$P_j$偷听，尝试恢复$P_i$的私钥$s_i=\sum^t_{k=1}f_i(ID(P_k))$缺一个份额$f_i(ID(P_i)$，以下秘密分享同理，缺少对自己的取值</li></ul></li><li>密钥生成阶段通信复杂度为$O(t^2)$</li></ul></li><li><p>$Hashing$ 哈希算法：输入公钥$g^s$，任意长度消息m，先计算$\mu\gets H(g^s,m)$，$H$是密码学哈希函数，满足$H:\mathbb{G} \times \{0,1\}^{\star} \to \mathbb{G} $，随机选择$e\in \mathbb{Z}_p^*$，输出随机数$r=(g^e,g^{se})$，输出哈希$h=g^e\mu^m$</p><ul><li>此处的$H$选择会影响安全性</li><li>哈希算法里用到了两次m，密码学哈希函数的输入m相当于提供随机性，$\mu^m$保证难以寻找碰撞，m在外面方便计算，实际上并不是想要修改的内容，用的是$header$</li></ul></li><li><p>$Rehashing$算法：给定公钥$g^s$和原始的消息-随机数对$(m,r=g^e,g^{se})$，计算哈希$h\gets g^e\mu^m$并输出</p></li><li><p>$Adaptation$算法：输入私钥份额$s_i$，原始的消息-随机数对$(m,r=g^e,g^{se})$，新的消息$m’\in\{0,1\}^\star$，参与者$P_i,i\in[t]$如下执行：</p><ul><li><p>计算$g^{e’}\gets g^e\mu ^{m-m’}$</p></li><li><p>计算$\eta_i\gets(g^{e’})^{\lambda_i \cdot s_i },\lambda_i=\prod^t_{l=1,l\neq i}\frac{ID(P_l)}{ID(P_l)-ID(P_i)}$，把$\eta_i$发送给参与者$P_j,j\in[t],j\neq i$</p></li><li><p>参与者$P_i$收到$\eta_1,\dots,\eta_{i-1},\eta_{i+1},\dots,\eta_{t}$后，计算$g^{se’}\gets\prod^t_{j=1}\eta_j$，输出更新后的随机数$r’=(g^{e’},g^{se’})$</p></li><li><p>其实就是用$t$个私钥恢复出公钥的指数</p><ul><li><script type="math/tex; mode=display">g^{e'}\to (g^{e'})^s\to(g^{e'})^{\sum f_i(0)}\to(g^{e'})^{\sum \lambda_{i} \cdot s_i} \to \prod (g^{e'})^{\lambda_i \cdot s_i }</script></li></ul></li><li><p>通信复杂度为$O(t^2)$</p></li></ul></li><li><p>$Verification$：输入公钥$g^s$和原始的消息-随机数对$(m,r=g^e,g^{se})$以及修改后的消息-随机数对$(m’,r’=g^{e’},g^{se’})$，如果计算的哈希值$g^e\mu^m=g^{e’}\mu^{m’}$相等且$(g,g^s,g^{e’},g^{se’})$是DH组，输出1，否则输出0</p></li></ul><h2 id="密钥更新阶段"><a href="#密钥更新阶段" class="headerlink" title="密钥更新阶段"></a>密钥更新阶段</h2><p>目的：节点可能动态加入或离开，敌手可能掌握超过$t$个份额，需要在不改变秘密的情况下扩大门限到$t’$</p><p>目前已经有n个节点掌握多项式$F(ID(i),y)$，需要$t$个份额就能恢复秘密</p><ul><li><p>全节点$\{P_i,\dots,P_{2t’}\}$执行$Zero(\{F(ID(P_i),y),t’-1\}^{t})$</p><ul><li><p>随机选择$(t’-1,2t’-1)$阶多项式$R(x,y)$，满足$R(0,0)=0$</p></li><li><p>$\{F(x,ID(i))\}^{2t’} \gets Handout\{F(ID(i),y)\}^t$</p></li><li><p>$\{R(ID(i),y)\}^{2t’}\gets Transform\{R_i(x,ID(i))\}^{2t’},R_i(x,ID(i)$是$t’-1$阶</p></li><li><p>$\{R(x,ID(i))\}^{2t’} \gets Handout\{R(ID(i),y)\}^{2t’}$</p></li><li><p>实现了对份额的更新，新的$t’-1$阶多项式满足$F’(x,ID(P_i))=F(x,ID(P_i))+R(x,ID(i))$</p></li></ul></li><li><p>现在分发给$n’$即可，执行$\{F’(ID(i),y\}^{n’} \gets Handout\{F’(x,ID(i))\}^{2t’}$</p><ul><li>$F’(x,y)=F(x,y)+R(x,y),F’(0,0)=F(0,0)=s$</li><li>更新份额相较于重新生成私钥再分配的区别在于，省去了执行$DCH.KeyGen()$的时间</li></ul></li></ul><h1 id="RSA累加器"><a href="#RSA累加器" class="headerlink" title="RSA累加器"></a>RSA累加器</h1><p>主要参考知乎<a href="https://zhuanlan.zhihu.com/p/158976773">这篇文章</a>理解，本文写的不够清楚</p><ul><li>acc字段存当前RSA累加器的值，RSA累加器把所有区块的$last_hash$编码进去，同一高度的区块acc值一样<ul><li>当区块2内的编辑请求$tx_{req1}$修改$tx1$为$tx1’$后，生成区块3，区块2内的acc值更新</li></ul></li></ul><p><img src="/2023/02/27/JCH22/image-20230227165109508.png" alt="image-20230227165109508"></p><h2 id="一致性检查"><a href="#一致性检查" class="headerlink" title="一致性检查"></a>一致性检查</h2><p>编辑会导致同一区块高度可能存在不同的区块，客户端需要检查是否区块被编辑过</p><ul><li>客户端发送想要查询的区块$header,hash(header)$给任意节点，节点本地查询RSA累加器</li><li>节点收到成员证明或者非成员证明后验证即可</li></ul><h1 id="安全性分析"><a href="#安全性分析" class="headerlink" title="安全性分析"></a>安全性分析</h1><h2 id="Decentralization"><a href="#Decentralization" class="headerlink" title="Decentralization"></a>Decentralization</h2><p>如果敌手试图通过$(m,r=g^e,g^{se})$来恢复$s$实现高效寻找碰撞，考虑到在系统稳定时，密钥作为常数项</p><p>$F(x,0)=s+\sum_{i=1}^{t-1}a_ix^i$被分享给$n$个节点，节点拥有份额$(IP(P_i),F(IP(P_i),0))$，超过$t$个节点同意即可恢复私钥。由于敌手只能控制$t-1$个节点，无法恢复私钥</p><p>在私钥更新阶段，每个节点最多同时掌握$2t-1$阶多项式$F(i,y)$和$t-1$阶$F(x,i)$，节点能够获得$t-1$阶多项式</p><p>敌手最多获得$t-1$份$F(x,0)$和$F’(x,0)$，无法恢复私钥</p><h2 id="Traceability"><a href="#Traceability" class="headerlink" title="Traceability"></a>Traceability</h2><p>考虑到同一高度所有被编辑的区块组成一条编辑链，所有编辑可以被高效审计（RSA累加器的必要性体现在一致性检查）</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li>提到新的创世区块，应该是是自己新建一条链，如何集成到现有的区块链系统中</li><li>最初$t$个掌握变色龙哈希函数私钥的节点怎么选，安全性<ul><li>直接用节点身份的哈希值，属于半中心化信标</li></ul></li><li>在包含修改请求的交易上链后，其他区块链上的节点如何修改$header \to header’$</li><li>修改区块头的结构后，增加的3个字段会带来额外的存储开销</li><li>RSA累加器的必要性在哪里<ul><li>将编辑后的区块加入到RSA累加器中</li><li>每次生成新的区块，节点本地更新RSA累加器的值</li><li>节点验证区块的有效性时想要知道该区块是否被编辑过</li><li>如果不是使用RSA累加器，其他方案如何解决区块的区分问题</li><li>RSA累加器的值能保证同步吗？可能存在某个恶意节点的未即时更新acc，客户端向恶意节点查询本已经被修改过的区块，该恶意节点返回该区块未被编辑。如果不同步，下一次生成区块的acc计算会错误；如果编辑对自己不利，可能在出块时才更新acc<ul><li>[LMW+23]提到了扩展头部的作用是保证类似的本地数据结构的同步</li></ul></li></ul></li><li>初始化的RSA的$N$和$g_1$也需要分布式生成，论文给了参考的算法，没有仔细了解</li><li><p>需要的映射哈希函数，将$x$映射为素数$SH(x)$，这种映射怎么找</p><ul><li>github的RSA accumulator已找到</li></ul></li><li><p>last_hash字段是新产生区块更新后的头部的哈希，如果是对之前区块的编辑，$last_hash$是该区块的头部哈希，不是编辑的区块是否该字段为空？</p></li><li>每次秘密分享都是可验证的，不是公开可验证</li><li>如果将RSA累加器替换为bloom filter？<ul><li>思考可行性：布隆过滤器提供高效的成员证明，非成员证明很可能不出错</li><li>如何保证参与者的bloom filter一致，区块头加上布隆过滤器的哈希值？类似于RSA的acc</li><li><a href="https://zhuanlan.zhihu.com/p/601973839">https://zhuanlan.zhihu.com/p/601973839</a></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Jia M, Chen J, He K, et al. Redactable Blockchain From Decentralized Chameleon Hash Functions[J]. IEEE Transactions on Information Forensics and Security, 2022, 17: 2771-2783.&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/categories/Blockchain/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="Redactable Blockchain" scheme="https://alleysira.github.io/tags/Redactable-Blockchain/"/>
    
  </entry>
  
</feed>
