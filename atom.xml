<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Alleysira&#39;s blog</title>
  
  
  <link href="https://alleysira.github.io/atom.xml" rel="self"/>
  
  <link href="https://alleysira.github.io/"/>
  <updated>2024-01-11T06:04:44.668Z</updated>
  <id>https://alleysira.github.io/</id>
  
  <author>
    <name>Alleysira</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>chainmaker</title>
    <link href="https://alleysira.github.io/2024/01/11/chainmaker/"/>
    <id>https://alleysira.github.io/2024/01/11/chainmaker/</id>
    <published>2024-01-11T06:03:35.000Z</published>
    <updated>2024-01-11T06:04:44.668Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><span id="more"></span><h1 id="长安链部署和配置"><a href="#长安链部署和配置" class="headerlink" title="长安链部署和配置"></a>长安链部署和配置</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装kubectl"><a href="#安装kubectl" class="headerlink" title="安装kubectl"></a>安装kubectl</h3><ul><li><a href="https://kubernetes.io/zh-cn/docs/reference/kubectl/">https://kubernetes.io/zh-cn/docs/reference/kubectl/</a></li><li>在根目录 <code>mkdir .kube</code>，将config文件cp到该目录下</li></ul><h3 id="本地安装长安链2-3-1"><a href="#本地安装长安链2-3-1" class="headerlink" title="本地安装长安链2.3.1"></a>本地安装长安链2.3.1</h3><ul><li><p>官方文档：<a href="https://docs.chainmaker.org.cn/v2.3.1/html/">https://docs.chainmaker.org.cn/v2.3.1/html/</a></p></li><li><p>安装go</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">wget https://golang.google.cn/dl/go1.18.10.linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">sudo rm -rf /usr/<span class="built_in">local</span>/go </span><br><span class="line">sudo tar -C /usr/<span class="built_in">local</span> -xzf go1.16.13.linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">vi /etc/profile</span><br><span class="line"><span class="comment"># 加入配置</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/go/bin</span><br><span class="line"><span class="comment"># 配置生效</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 换源</span></span><br><span class="line">go env GO11MODULE=on</span><br><span class="line">go env -w GOPROXY=https://goproxy.cn</span><br></pre></td></tr></table></figure></li><li><p>安装7.3版本以上的gcc</p></li><li><p>安装7zip </p><ul><li><pre><code class="lang-bash">sudo apt-get install p7zip-full p7zip-rar</code></pre></li></ul></li><li><p>安装docker，参考<a href="https://docs.docker.com/engine/install/ubuntu/#install-using-the-repository">https://docs.docker.com/engine/install/ubuntu/#install-using-the-repository</a></p></li><li>下载gitlab的pre仓库<ul><li><a href="https://gitlab.distribute-compute.cn/chenzhu/pre">https://gitlab.distribute-compute.cn/chenzhu/pre</a></li></ul></li><li>安装完毕后测试智能合约是否能部署</li></ul><h2 id="部署到云"><a href="#部署到云" class="headerlink" title="部署到云"></a>部署到云</h2><ul><li>修改改k8sconfg/4.yml和Makefile里面的版本/命名空间</li><li><p>build docker </p><ul><li><code>make docker-solo</code></li></ul></li><li><p>提交docker，这部分需要</p><ul><li><p><code>docker login -u xxx -p xxx xxx.myhuaweicloud.com</code></p></li><li><p><code>make push</code></p></li></ul></li><li><p>进入docker执行命令</p><ul><li><code>kubectl exec docker-name -it /bin/bash -n mj</code></li></ul></li><li><p>停止运行</p><ul><li><code>make configFdown</code></li></ul></li><li>在dockerfile中设置需要打包为docker的文件</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h1 id=&quot;长安链部署和配置&quot;</summary>
      
    
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>sp23_find_spec_blind_spots_via_fuzz_testing</title>
    <link href="https://alleysira.github.io/2024/01/10/sp23-find-spec-blind-spots-via-fuzz-testing/"/>
    <id>https://alleysira.github.io/2024/01/10/sp23-find-spec-blind-spots-via-fuzz-testing/</id>
    <published>2024-01-10T09:22:21.000Z</published>
    <updated>2024-01-11T08:30:13.938Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Ji R, Xu M. Finding Specification Blind Spots via Fuzz Testing[C]//2023 IEEE Symposium on Security and Privacy (SP). IEEE Computer Society, 2023: 2708-2725.</p><span id="more"></span><p>形式化验证能够证明保持验证过的程序和声明的spocifications(SPEC)保持一致，但是如何保证SPEC是完备的 没有逻辑漏洞？本文使用Fuzzing-Assisted Specification Testing来解决这个问题。</p><p>核心思路是利用形式化验证过程序的冗余性和多想想进行交叉检查。 </p><p>具体来讲，在同一个代码库中，SPEC（规范）、实现（CODE）和测试套件都是从同一组业务需求中派生出来的。因此，如果某个意图在CODE和测试用例中被捕捉到，但在SPEC中没有，则这表明SPEC存在盲点。</p><p>FAST以自动化的方式检查SPEC中的不完整性问题：它首先通过变异测试来定位SPEC的缺口gap，即通过检查CODE变体是否符合原始的SPEC来确定是否存在缺口。如果是这样，FAST进一步利用测试套件来推断缺口是由意图引起还是由错误引起的。根据代码库的大小，FAST可以选择以枚举方式还是进化方式生成CODE变体。FAST被应用于两个具有形式验证特性的开源代码库，并且分别帮助确认了它们SPEC中的13个和21个盲点。这凸显了SPEC不完整性在真实应用中的普遍存在。</p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>形式验证通过数学方法检查程序的正确性，为计算系统提供高度保证，即程序的行为完全受限于描述为一组期望属性（规范）的形式建模语言。形式验证在硬件和软件系统中已经被广泛采用。典型的应用场景包括可能导致重大损失和不可逆后果的情况（例如航空领域），或者传统的滚动式程序升级模型不可行的情况，如区块链上的智能合约。</p><p>形式化验证可以分解为两步</p><ul><li>1 设计目标系统的一系列规范 SPEC</li><li>2 证明实际的实现 CODE 和规范 SPEC是否符合，即$SPEC \sqsubseteq CODE$</li></ul><p>目前学术界在2方面进展迅速，但是1被关注较少。这就存在着严重的问题，即使一个程序经过完善的验证工具链进行了彻底的验证，该程序的正确性也仅限于其规范，程序中可能存在着盲点。由于目前形式化验证的成本较高、技术门槛较高，进行SPEC编写的人员一般不是写代码发的，作者想传达的思想是不能盲目的相信形式化验证后的代码，还需要去理解SPEC完备性的重要性</p><p> 硬件领域对SPEC完整性的研究比较多，现有的工作基于mutation testing，即将CODE或者SPEC进行变异，检查变异体是否依然符合旧的内容，因此，任何存活的变异体都会引发一个信号，表明规范可能是不完整的</p><p>因此去可以去研究：</p><ul><li>变异测试 mutation testing 是否能够应用于软件安全</li><li>如果不能，可以采用怎样的改进</li><li>优化后来解决成熟的代码库中是否普遍存在规范不完备的问题</li></ul><p>本文的主要工作是首先确认了采用变异测试能够高效地发现SPEC的漏洞，但是对于复杂的程序，基于变异的测试不够有效</p><p>挑战在于</p><ul><li>当mutant通过了验证，如何证明SPEC之间的gap是故意而为还是错误<ul><li>解决思路：利用形式化验证程序中的冗余性和多样性，即代码 SPEC和测试套件都是从一组需求来的，但是以不同的思维方式进行编程：例如，使用不同的编程语言（甚至是编程范式）实现的，具有不同的演进路径，一般不同且独立的团队进行编写。因此，这三个不太可能出现相同的错误。</li><li>可以通过相互比较来发现错误</li></ul></li><li>如何构造一个更容易通过验证的mutant<ul><li>解决思路：fuzzer的遗传算法，计算每个mutant的fitness，只有高质量的mutant才可能被多次变异，fitness的标准就是验证后触发的错误（这也太trivial了）</li></ul></li></ul><p>FAST无法保证一定没有完备性问题，但可以用于</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Ji R, Xu M. Finding Specification Blind Spots via Fuzz Testing[C]//2023 IEEE Symposium on Security and Privacy (SP). IEEE Computer Society, 2023: 2708-2725.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Detecting Blockchain (E)VM Flaws</title>
    <link href="https://alleysira.github.io/2024/01/10/blocksec-evm-fuzz/"/>
    <id>https://alleysira.github.io/2024/01/10/blocksec-evm-fuzz/</id>
    <published>2024-01-10T07:50:22.000Z</published>
    <updated>2024-01-11T06:56:59.630Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>BlockSec CEO周亚金教授受邀参加香港Web3学者峰会，阐述了EVM虚拟机存在的潜在安全风险以及如何通过差分测试工具解决该类问题。</p><p>参考链接：<a href="https://mp.weixin.qq.com/s/9ujd7AMmWNHWE6Wujfqz2A">url</a></p><span id="more"></span><h1 id="Detecting-Blockchain-E-VM-Flaws"><a href="#Detecting-Blockchain-E-VM-Flaws" class="headerlink" title="Detecting Blockchain (E)VM Flaws"></a>Detecting Blockchain (E)VM Flaws</h1><p>打打广告</p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110161050085.png" alt="image-20240110161050085"></p><p>目前EVM兼容的链有200+</p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110161224346.png" alt="image-20240110161224346"></p><p>虚拟机是智能合约的foundation</p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110161402073.png" alt="image-20240110161402073"></p><p>virtual ROM中存储的是代码，account storge是持久化存储</p><p>evm如果对同一段代码执行结果不一样，就会导致分叉，有两个重要的事件</p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110161551985.png" alt="image-20240110161551985"></p><p>浅拷贝优化导致的错误</p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110161806004.png" alt="image-20240110161806004"></p><p>实现篡改return data</p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110161835490.png" alt="image-20240110161835490"></p><p>CVE2021 Geth及时修复了，但是其他fork geth的项目未能及时采用该patch </p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110162332986.png" alt="image-20240110162332986"></p><p>如何提前发现类似问题：提前开发系统，但是存在着一下问题</p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110162710450.png" alt="image-20240110162710450"></p><p>差分测试：不同种类的实现</p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110162923402.png" alt="image-20240110162923402"></p><p>输入相同，执行的合约相同，理论上输出应该一样</p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110162913739.png" alt="image-20240110162913739"></p><p>test case的prestate也应该相同</p><p>生成测试用例的方法</p><ul><li>用历史真实数据</li><li>基于覆盖率的fuzz（提到blocksec做了很多其他的维度）</li></ul><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110163219770.png" alt="image-20240110163219770"></p><p>基于种子交易mutate，生成不正常的交易</p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110163332043.png" alt="image-20240110163332043"></p><p>现有的evm存在定制，neo作为layer1，基于neo的链可能定制化</p><p>剔除假阳性的方法</p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110163448295.png" alt="image-20240110163448295"></p><p>blocksec目前支持的链的EVM</p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110163543389.png" alt="image-20240110163543389"></p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110155400899.png" alt="image-20240110155400899"></p><p><a href="https://nvd.nist.gov/vuln/detail/CVE-2020-26241">https://nvd.nist.gov/vuln/detail/CVE-2020-26241</a></p><p>目前zkevm的问题比较多</p><p>eos的问题：新的合约账户可能和已被销毁的合约账户连接起来</p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110155916090.png" alt="image-20240110155916090"></p><p>aurora预编译合约计算gas错误，远远小于实际的gas消耗，导致dos</p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110160130852.png" alt="image-20240110160130852"></p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110160609580.png" alt="image-20240110160609580"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;BlockSec CEO周亚金教授受邀参加香港Web3学者峰会，阐述了EVM虚拟机存在的潜在安全风险以及如何通过差分测试工具解决该类问题。&lt;/p&gt;
&lt;p&gt;参考链接：&lt;a href=&quot;https://mp.weixin.qq.com/s/9ujd7AMmWNHWE6Wujfqz2A&quot;&gt;url&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="EVM" scheme="https://alleysira.github.io/tags/EVM/"/>
    
  </entry>
  
  <entry>
    <title>TOSEM23</title>
    <link href="https://alleysira.github.io/2023/11/28/TOSEM23/"/>
    <id>https://alleysira.github.io/2023/11/28/TOSEM23/</id>
    <published>2023-11-28T11:38:58.000Z</published>
    <updated>2023-12-14T09:11:50.425Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><em>Yixuan Zhang, Shangtong Cao, Haoyu Wang, Zhenpeng Chen, Xiapu Luo, Dongliang Mu, Yun Ma, Gang Huang, and Xuanzhe Liu. 2023. Characterizing and Detecting WebAssembly Runtime Bugs. ACM Trans. Softw. Eng. Methodol. Just Accepted (September 2023). <a href="https://doi.org/10.1145/3624743">https://doi.org/10.1145/3624743</a></em></p><span id="more"></span><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>首先收集了903个github上wasm bug相关的post，确认了311个真实的bug。基于数据，总结了31类wasm运行时的漏洞并且总结了共同的修复策略。设计了基于pattern的漏洞检测框架来自动检测Wasm中的bug。采用该漏洞检测框架测试了7个WASM运行时，发现了60个漏洞。</p><p>研究对象</p><ul><li>wasmtime</li><li>wasmer</li><li>WAMR</li></ul><p>贡献</p><ul><li>第一篇对Wasm运行时漏洞的系统研究，总结了漏洞的种类和对应的修复措施</li><li>开发了基于模式的漏洞检测框架，对真实世界的wasm运行时进行了检测，能够发现错误</li><li>脚本 数据集和漏洞检测工具已经开源（<a href="https://github.com/bnmcxlzd/TOSEM2023_Complementary_materials）">https://github.com/bnmcxlzd/TOSEM2023_Complementary_materials）</a></li></ul><h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><h2 id="wasm-binary"><a href="#wasm-binary" class="headerlink" title="wasm binary"></a>wasm binary</h2><p>wasm是一种底层的类似汇编的语言，设计目标是高效处理和紧凑表示。对应的二进制文件是.wasm。</p><p>Wasm标准定义了概念性的堆栈虚拟机，用于执行pop和push，并将结果留在堆栈上。</p><h2 id="wat-format"><a href="#wat-format" class="headerlink" title="wat format"></a>wat format</h2><p>.wat 是为开发者提供的漂亮的印刷文本格式，能够用于理解语义和wasm模块、进行测试、调试和优化等等。开发者可以使用wabt工具将wasm binary转换成文本格式</p><p>模块module是wasm代码的基本单元，表现为扁平树的形式；本地变量强类型</p><p><img src="/2023/11/28/TOSEM23/image-20231128201211895.png" alt="image-20231128201211895"></p><h2 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h2><p>Frontend compiler（AssemblyScript, Emscripten, Rustc/WASM-Bindgen）能够把高级语言编译为wasm bin，WASM被设计为高级编程语言的可移植编译目标，能够以接近本地执行的速度在多个平台上执行。wasm runtime是硬件和wasm bin之间的中间层</p><p><img src="/2023/11/28/TOSEM23/image-20231128201749638.png" alt="image-20231128201749638"></p><h2 id="wasm-runtime-architecture"><a href="#wasm-runtime-architecture" class="headerlink" title="wasm runtime architecture"></a>wasm runtime architecture</h2><p><img src="/2023/11/28/TOSEM23/image-20231128201825541.png" alt="image-20231128201825541"></p><p>后端编译器：支持提前编译Ahead-of-time compilation (AOT)和传统的即时编译Just-in-Time compilation</p><p>解释器：交互式执行</p><p>运行时环境：负责内存分配，栈的操作，报错</p><p>API：运行wasm运行时被嵌入到高级语言中作为库来使用</p><p>系统接口：支持类似操作系统的功能</p><h1 id="STUDY-DESIGN"><a href="#STUDY-DESIGN" class="headerlink" title="STUDY DESIGN"></a>STUDY DESIGN</h1><h2 id="研究问题"><a href="#研究问题" class="headerlink" title="研究问题"></a>研究问题</h2><p><img src="/2023/11/28/TOSEM23/image-20231129102622855.png" alt="image-20231129102622855"></p><p>漏洞分类的根本原因；是否存在普遍的修复策略；提出的分类方法对漏洞检测的有效性</p><h2 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h2><p>如何说明实验对象的代表性：</p><ul><li>LOC</li><li>star</li><li>支持的编译模式多</li><li>不同的编程语言实现</li></ul><p>数据来源</p><ul><li>github issue<ul><li>从github issue中提取有bug label的issue，最终304个wasmer的issues，167个wasmtime的issues和333个WAMR的issues（未label，全选）</li></ul></li><li>Stack Overlow<ul><li>Stack Overlow问题有标签，可根据标签爬取对应的post</li><li><img src="/2023/11/28/TOSEM23/image-20231129103818825.png" alt="image-20231129103818825"></li></ul></li></ul><h3 id="数据集的refine"><a href="#数据集的refine" class="headerlink" title="数据集的refine"></a>数据集的refine</h3><ul><li><p>筛去了没有确定性回答的issue和post</p></li><li><p>手工去除了install和build相关的错误，文档错误，用户误用等和wasm运行时无关的bug</p></li></ul><p>结果就是只剩下311个issue，SO全部没了（解释是可能github上wasm专家比较少）</p><p><img src="/2023/11/28/TOSEM23/image-20231129104347208.png" alt="image-20231129104347208"></p><h2 id="标记漏洞和修复策略"><a href="#标记漏洞和修复策略" class="headerlink" title="标记漏洞和修复策略"></a>标记漏洞和修复策略</h2><ul><li>pilot labelling 首先随机选了50%的post，论文前两位作者共同分析，进行分类</li><li>可靠性分析：根据之前的分类，两位作者独立标记剩下的40%的post验证之前对漏洞分类的正确性，采用Cohen’s kappa系数；对于出现的分歧与intercessor进行了讨论，新增了2类漏洞和3类修复措施；</li><li>对于剩下的10%，两位作者独立进行了分类，没有发现新的漏洞种类和修复措施，证明了分类的饱和 saturation</li></ul><h1 id="RQ1-TAXONOMY-OF-WASM-RUNTIME-BUGS"><a href="#RQ1-TAXONOMY-OF-WASM-RUNTIME-BUGS" class="headerlink" title="RQ1: TAXONOMY OF WASM RUNTIME BUGS"></a>RQ1: TAXONOMY OF WASM RUNTIME BUGS</h1><p>根据wasm的架构分析了漏洞种类</p><p><img src="/2023/11/28/TOSEM23/image-20231129110601087.png" alt="image-20231129110601087"></p><p>后端编译部分负责将bin编译为本地机器码，需要OS和CPU的支持，占总共bug的38.3%</p><h1 id="RQ3-PATTERN-BASED-BUG-DETECTOR-FOR-WASM-RUNTIMES"><a href="#RQ3-PATTERN-BASED-BUG-DETECTOR-FOR-WASM-RUNTIMES" class="headerlink" title="RQ3:PATTERN-BASED BUG DETECTOR FOR WASM RUNTIMES"></a>RQ3:PATTERN-BASED BUG DETECTOR FOR WASM RUNTIMES</h1><h2 id="Bug-detectors-for-Backend-Compilation"><a href="#Bug-detectors-for-Backend-Compilation" class="headerlink" title="Bug detectors for Backend Compilation"></a>Bug detectors for Backend Compilation</h2><p>No interest</p><h2 id="Bug-detectors-for-WASI-Robustness"><a href="#Bug-detectors-for-WASI-Robustness" class="headerlink" title="Bug detectors for WASI Robustness"></a>Bug detectors for WASI Robustness</h2><ul><li>文件操作错误：测试是否能重命名文件、是否能判断文件不存在、是否能移动文件、计数目录下的文件</li><li>import错误：不支持多个wasi的版本</li><li>输入输出流错误：用c++写程序编译为wasm bin再检查值和类型是否正确</li><li>OS错误：时间的API不一样，利用QuickJS进行测试</li></ul><h2 id="Bug-detectors-for-Runtime-environment"><a href="#Bug-detectors-for-Runtime-environment" class="headerlink" title="Bug detectors for Runtime environment"></a>Bug detectors for Runtime environment</h2><ul><li>module实例化错误：检查是否支持实例化 空 的wasm模块，短时间内大量实例化是否会内存泄漏</li><li><p>module导入错误：部分runtime省略了检查导入对象序号的步骤</p></li><li><p>Calling host functions：调用函数对象是否正确</p></li><li><p>memory issue：检查内存的增长是否是线性的</p></li><li>trap error：设计了带有不可达指令的module来测试运行时是否能正常跳出执行并且报告不可达代码的位置</li><li>入口错误：wasm运行时可能会不允许入口函数或拒绝没有入口函数的module</li><li>未处理异常</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;Yixuan Zhang, Shangtong Cao, Haoyu Wang, Zhenpeng Chen, Xiapu Luo, Dongliang Mu, Yun Ma, Gang Huang, and Xuanzhe Liu. 2023. Characterizing and Detecting WebAssembly Runtime Bugs. ACM Trans. Softw. Eng. Methodol. Just Accepted (September 2023). &lt;a href=&quot;https://doi.org/10.1145/3624743&quot;&gt;https://doi.org/10.1145/3624743&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="Wasm" scheme="https://alleysira.github.io/tags/Wasm/"/>
    
  </entry>
  
  <entry>
    <title>OmniLedger</title>
    <link href="https://alleysira.github.io/2023/11/12/OmniLedger/"/>
    <id>https://alleysira.github.io/2023/11/12/OmniLedger/</id>
    <published>2023-11-12T05:09:50.000Z</published>
    <updated>2023-11-12T14:43:21.478Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Video"><a href="#Video" class="headerlink" title="Video"></a>Video</h1><p>视频链接：<a href="https://www.youtube.com/watch?v=vHVZ2gD8Ie4&amp;ab_channel=AllHackingCons">https://www.youtube.com/watch?v=vHVZ2gD8Ie4&amp;ab_channel=AllHackingCons</a></p><p>github：<a href="https://github.com/dedis/student_18_byzcoin">https://github.com/dedis/student_18_byzcoin</a></p><span id="more"></span><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p><img src="/2023/11/12/OmniLedger/image-20231112132024157.png" alt="image-20231112132024157"></p><p>进行分片时需要考虑的问题：</p><ul><li>验证者如何被分配到不同分片中去</li><li>如何实现跨分片的交易</li></ul><p><img src="/2023/11/12/OmniLedger/image-20231112132216448.png" alt="image-20231112132216448"></p><p>对于第一个问题，显然不能让验证者自己选择进去哪个分片，如果随机选择，需要保证分片大小足够大（失败概率为$10^{-6}$，分片大小在$10^3\to10^4$），符合leopard</p><p><img src="/2023/11/12/OmniLedger/image-20231112132409442.png" alt="image-20231112132409442"></p><p>在SimpleLedger的例子中，每轮有一个可信的random beacon，将验证者分到不同的分片中，且验证者能够验证哪些验证者跟自己在同一个分片</p><p><img src="/2023/11/12/OmniLedger/image-20231112132715120.png" alt="image-20231112132715120" style="zoom:150%;"></p><p>简单的设计，带来了很多问题</p><p><img src="/2023/11/12/OmniLedger/image-20231112133139221.png" alt="image-20231112133139221" style="zoom:150%;"></p><p>安全性方面：</p><ul><li>依赖第三方可信的random beacon</li><li>重配置阶段不支持处理交易</li><li>不支持跨片交易</li></ul><h2 id="OmniLedger"><a href="#OmniLedger" class="headerlink" title="OmniLedger"></a>OmniLedger</h2><p><img src="/2023/11/12/OmniLedger/image-20231112133339611.png" alt="image-20231112133339611" style="zoom:150%;"></p><p>主要有6部分工作，包括DRB 平稳的轮切换等，主要介绍三个</p><h3 id="DRB"><a href="#DRB" class="headerlink" title="DRB"></a>DRB</h3><p><img src="/2023/11/12/OmniLedger/image-20231112133730137.png" alt="image-20231112133730137" style="zoom:150%;"></p><h3 id="原子跨片交易"><a href="#原子跨片交易" class="headerlink" title="原子跨片交易"></a>原子跨片交易</h3><p>参考了数据库领域的工作，2阶段承诺</p><p><img src="/2023/11/12/OmniLedger/image-20231112134014422.png" alt="image-20231112134014422"></p><p>存在问题：2阶段承诺不是时间容忍的，敌手可以abort</p><p><img src="/2023/11/12/OmniLedger/image-20231112134516084.png" alt="image-20231112134516084"></p><p>将分片作为server，client将没有commit的交易输入锁定，等待对应输入分片的证明后解锁</p><h3 id="延迟和吞吐量的trade-off"><a href="#延迟和吞吐量的trade-off" class="headerlink" title="延迟和吞吐量的trade-off"></a>延迟和吞吐量的trade-off</h3><p>增大区块大小可以增加吞吐量，但是发送区块和验证区块的延迟会增加</p><p>Omniledger的思路是牺牲部分安全性来降低延迟</p><p>存在两层验证，一层处理数额较小的输入，安全性为90%，一层处理重要的交易</p><p><img src="/2023/11/12/OmniLedger/image-20231112135746820.png" alt="image-20231112135746820" style="zoom:67%;"></p><h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><p>Go语言编写，<a href="https://github.com/dedis/student_18_byzcoin">https://github.com/dedis/student_18_byzcoin</a></p><p>采用了dedis实验室的代码 <a href="https://github.com/dedis">https://github.com/dedis</a></p><p><img src="/2023/11/12/OmniLedger/image-20231112140022164.png" alt="image-20231112140022164" style="zoom:150%;"></p><p>首先测试scale-out，增加节点数量</p><p><img src="/2023/11/12/OmniLedger/image-20231112141351986.png" alt="image-20231112141351986" style="zoom:150%;"></p><p>1120是分片大小为70，16个分片，考虑敌手比例最多为25%，低于BFT的容错</p><p><img src="/2023/11/12/OmniLedger/image-20231112141855252.png" alt="image-20231112141855252" style="zoom:67%;"></p><p>对于延迟，分别测试了2层验证的耗时</p><p><img src="/2023/11/12/OmniLedger/image-20231112142156625.png" alt="image-20231112142156625" style="zoom:67%;"></p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p><img src="/2023/11/12/OmniLedger/image-20231112142320778.png" alt="image-20231112142320778" style="zoom:67%;"></p><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p>Q: 网络分区的影响</p><p>A: 如果发生网络分区，协议停止，不违反比特币的安全性</p><p>Q: 和Algorand的区别</p><p>A: Algorand没有sharding，可以选择将Algorand作为片内共识算法，Omniledger在Algorand之上，可以得到更好的敌手容忍比例</p><p>Q: 交易如何分配到分片内</p><p>A: Omniledger片内共识是参考比特币的，因此节点本地有UTXO数据库。如果存在跨片交易，依赖于原子承诺的设计，输入分片会commit或者abort</p><p>Q: 表格中安全性仅考虑到了25-30%，失败概率$10^{-6}$，如何实现容忍$10^{-10}$的错误概率</p><p>A: 更大的分片大小，trade-off</p><p>Q: 因为目前矿池集中的算力超过了25%，可能达到30% 40% 45%，作者认为可能会如何</p><p>A: 片内如果用比特币的共识能容忍50%的敌手</p><p>Q: 最坏情况下的性能，如所有交易都是跨片交易</p><p>A: 当所有交易都是跨片交易，不再是线性增长的。采用单个共识算法的效率会比sharding更好</p><p>Q: 敌手能否让所有交易都成为跨片交易？</p><p>A: 交易是由client发起的，不是由敌手选择的，因为交易有手续费，跨片交易的手续费比普通交易更高，如果跨3个片交易费可能是片内交易的三倍</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Video&quot;&gt;&lt;a href=&quot;#Video&quot; class=&quot;headerlink&quot; title=&quot;Video&quot;&gt;&lt;/a&gt;Video&lt;/h1&gt;&lt;p&gt;视频链接：&lt;a href=&quot;https://www.youtube.com/watch?v=vHVZ2gD8Ie4&amp;amp;ab_channel=AllHackingCons&quot;&gt;https://www.youtube.com/watch?v=vHVZ2gD8Ie4&amp;amp;ab_channel=AllHackingCons&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;github：&lt;a href=&quot;https://github.com/dedis/student_18_byzcoin&quot;&gt;https://github.com/dedis/student_18_byzcoin&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="Sharding" scheme="https://alleysira.github.io/tags/Sharding/"/>
    
  </entry>
  
  <entry>
    <title>leopard-bft</title>
    <link href="https://alleysira.github.io/2023/10/31/leopard-bft/"/>
    <id>https://alleysira.github.io/2023/10/31/leopard-bft/</id>
    <published>2023-10-31T06:47:05.000Z</published>
    <updated>2023-11-11T14:22:18.328Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Hu K, Guo K, Tang Q, et al. Leopard: Towards High Throughput-Preserving BFT for Large-scale Systems[C]//2022 IEEE 42nd International Conference on Distributed Computing Systems (ICDCS). IEEE, 2022: 157-167.</p><span id="more"></span><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>安装go，将<code>awesomeProject DKG</code> cp到<code>GOROOT</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alleysira@LAPTOP-M4HO8L6S:~/leopard-bft$ sudo cp -r go/src/awesomeProject /usr/local/go/src</span><br><span class="line">alleysira@LAPTOP-M4HO8L6S:~/leopard-bft$ sudo cp -r go/src/DKG /usr/local/go/src</span><br></pre></td></tr></table></figure><p>经典编不过去</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alleysira@LAPTOP-M4HO8L6S:~/leopard-bft/go/src/awesomeProject$ go build main.go</span><br><span class="line"><span class="meta">#</span><span class="bash"> DKG</span></span><br><span class="line">/usr/local/go/src/DKG/bls.go:6:10: fatal error: bls/bls.h: No such file or directory</span><br><span class="line">    6 | #include &lt;bls/bls.h&gt;</span><br><span class="line">      |          ^~~~~~~~~~~</span><br><span class="line">compilation terminated.</span><br></pre></td></tr></table></figure><h3 id="bn"><a href="#bn" class="headerlink" title="bn"></a>bn</h3><p>论文中bls采用了 <a href="https://github.com/dfinity-side-projects/bn，安装">https://github.com/dfinity-side-projects/bn，安装</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">alleysira@LAPTOP-M4HO8L6S:~/bn-master$ make</span><br><span class="line">make -C mcl UPDATE_ASM=1 lib/libmcl.so CFLAGS_USER=-std=c++11 MCL_MAX_BIT_SIZE=384</span><br><span class="line">make[1]: Entering directory &#x27;/home/alleysira/bn-master/mcl&#x27;</span><br><span class="line">g++ -o src/gen src/gen.cpp -g3 -Wall -Wextra -Wformat=2 -Wcast-qual -Wcast-align -Wwrite-strings -Wfloat-equal -Wpointer-arith -m64 -I include -I test -I ../xbyak -I ../cybozulib/include -std=c++11 -fomit-frame-pointer -DNDEBUG -Ofast -march=native -fPIC -DMCL_MAX_BIT_SIZE=384 -DMCL_USE_LLVM=1 -O0</span><br><span class="line">src/gen -old -f src/func.list &gt; src/base64.ll</span><br><span class="line">opt -O3 -o - src/base64.ll -march=x86-64 | llc -O3 -o src/asm/x86-64.s -march=x86-64 -relocation-model=pic  -pre-RA-sched=list-ilp -max-sched-reorder=128</span><br><span class="line">opt: src/base64.ll:16:26: error: expected comma after getelementptr&#x27;s type</span><br><span class="line"><span class="meta">%</span><span class="bash">r5 = getelementptr i64* %r2, i64 %r4</span></span><br><span class="line">                         ^</span><br><span class="line">g++ -c src/asm/x86-64.s -o obj/x86-64.o -g3 -Wall -Wextra -Wformat=2 -Wcast-qual -Wcast-align -Wwrite-strings -Wfloat-equal -Wpointer-arith -m64 -I include -I test -I ../xbyak -I ../cybozulib/include -std=c++11 -fomit-frame-pointer -DNDEBUG -Ofast -march=native -fPIC -DMCL_MAX_BIT_SIZE=384 -DMCL_USE_LLVM=1</span><br><span class="line">src/gen -old -f src/func.list -s bmi2 &gt; src/base64.bmi2.ll</span><br><span class="line">opt -O3 -o - src/base64.bmi2.ll -march=x86-64 | llc -O3 -o src/asm/x86-64.bmi2.s -march=x86-64 -relocation-model=pic  -pre-RA-sched=list-ilp -max-sched-reorder=128 -mattr=bmi2</span><br><span class="line">opt: src/base64.bmi2.ll:16:26: error: expected comma after getelementptr&#x27;s type</span><br><span class="line"><span class="meta">%</span><span class="bash">r5 = getelementptr i64* %r2, i64 %r4</span></span><br><span class="line">                         ^</span><br></pre></td></tr></table></figure><p><code>make clean</code>之后<code>sudo make</code>依然出错，目测是llvm的版本的问题</p><p>github 上相关的issue</p><ul><li><p><a href="https://github.com/dfinity-side-projects/bn/issues/10">https://github.com/dfinity-side-projects/bn/issues/10</a></p></li><li><p><a href="https://github.com/dfinity-side-projects/bn/issues/3">https://github.com/dfinity-side-projects/bn/issues/3</a></p></li></ul><p>opt是llvm的优化器，问题原因是采用的llvm是10.0版本，.ll文件的语法不相同，但是能编译出libbls的两个库和一个libmcl</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">g++ -o src/gen src/gen.cpp -g3 -Wall -Wextra -Wformat=2 -Wcast-qual -Wcast-align -Wwrite-strings -Wfloat-equal -Wpointer-arith -m64 -I include -I test -I ../xbyak -I ../cybozulib/include -std=c++11 -fomit-frame-pointer -DNDEBUG -Ofast -march=native -fPIC -DMCL_MAX_BIT_SIZE=384 -DMCL_USE_LLVM=1 -O0</span><br><span class="line">src/gen -old -f src/func.list &gt; src/base64.ll</span><br><span class="line">opt -O3 -o - src/base64.ll -march=x86-64 | llc -O3 -o src/asm/x86-64.s -march=x86-64 -relocation-model=pic  -pre-RA-sched=list-ilp -max-sched-reorder=128</span><br><span class="line">opt: src/base64.ll:16:26: error: expected comma after getelementptr&#x27;s type</span><br><span class="line"><span class="meta">%</span><span class="bash">r5 = getelementptr i64* %r2, i64 %r4</span></span><br><span class="line">                         ^</span><br><span class="line">g++ -c src/asm/x86-64.s -o obj/x86-64.o -g3 -Wall -Wextra -Wformat=2 -Wcast-qual -Wcast-align -Wwrite-strings -Wfloat-equal -Wpointer-arith -m64 -I include -I test -I ../xbyak -I ../cybozulib/include -std=c++11 -fomit-frame-pointer -DNDEBUG -Ofast -march=native -fPIC -DMCL_MAX_BIT_SIZE=384 -DMCL_USE_LLVM=1</span><br><span class="line">src/gen -old -f src/func.list -s bmi2 &gt; src/base64.bmi2.ll</span><br><span class="line">opt -O3 -o - src/base64.bmi2.ll -march=x86-64 | llc -O3 -o src/asm/x86-64.bmi2.s -march=x86-64 -relocation-model=pic  -pre-RA-sched=list-ilp -max-sched-reorder=128 -mattr=bmi2</span><br><span class="line">opt: src/base64.bmi2.ll:16:26: error: expected comma after getelementptr&#x27;s type</span><br><span class="line"><span class="meta">%</span><span class="bash">r5 = getelementptr i64* %r2, i64 %r4</span></span><br></pre></td></tr></table></figure><p>应该是缺一个mcl库，因为报错编不出来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/tmp/go-build/cgo-gcc-prolog:1354: undefined reference to `mclBn_precomputedMillerLoop&#x27;</span><br><span class="line">/usr/bin/ld: $WORK/b002/_x004.o: in function `_cgo_7ee38b8fbf18_Cfunc_mclBn_precomputedMillerLoop2&#x27;:</span><br><span class="line">/tmp/go-build/cgo-gcc-prolog:1370: undefined reference to `mclBn_precomputedMillerLoop2&#x27;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure><p>尝试把16.04的库直接拿过来用，不行，有一些函数的接口变了，卒</p><p>尝试修改mcl的Makefile文件，跳过对.ll的报错，失败</p><p><img src="/2023/10/31/leopard-bft/image-20231031180355543.png" alt="image-20231031180355543"></p><p>一个逆天bug，/*cgo xxx*/后面不能有空行，必须直接跟着import “C”</p><p>将存放4个库文件的<code>/usr/local/lib</code>加入到LD路径中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=/lib:/usr/lib:/usr/local/lib</span><br></pre></td></tr></table></figure><p>屈服了，下载3.9版本的llvm用cmake build</p><p>如何build的教程 <a href="https://releases.llvm.org/3.9.0/docs/CMake.html">https://releases.llvm.org/3.9.0/docs/CMake.html</a></p><p><img src="/2023/10/31/leopard-bft/image-20231031221526742.png" alt="image-20231031221526742"></p><p><code>make bn</code>没有报错</p><p>库都正确编译了，但是依然有问题，是fp.cpp文件的6个函数存在undefined reference（不应该啊）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">alleysira@LAPTOP-M4HO8L6S:~/leopard-bft/go/src/awesomeProject$ go build main.go</span><br><span class="line"><span class="meta">#</span><span class="bash"> DKG</span></span><br><span class="line">/usr/bin/ld: /usr/local/lib/libbls384.so: undefined reference to `mcl::fp::copyUnitToByteAsLE(unsigned char*, unsigned long const*, unsigned long)&#x27;</span><br><span class="line">/usr/bin/ld: /usr/local/lib/libbls384.so: undefined reference to `mcl::fp::copyAndMask(unsigned long*, void const*, unsigned long, mcl::fp::Op const&amp;, bool)&#x27;</span><br><span class="line">/usr/bin/ld: /usr/local/lib/libbls384.so: undefined reference to `mcl::fp::arrayToStr(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;&amp;, unsigned long const*, unsigned long, int)&#x27;</span><br><span class="line">/usr/bin/ld: /usr/local/lib/libbls384.so: undefined reference to `mcl::fp::hash[abi:cxx11](unsigned long, void const*, unsigned long)&#x27;</span><br><span class="line">/usr/bin/ld: /usr/local/lib/libbls384.so: undefined reference to `mcl::fp::streamToArray(bool*, unsigned long*, unsigned long, std::istream&amp;, int)&#x27;</span><br><span class="line">/usr/bin/ld: /usr/local/lib/libbls384.so: undefined reference to `mcl::fp::Op::init(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;, unsigned long, mcl::fp::Mode, unsigned long)&#x27;</span><br><span class="line">collect2: error: ld returned 1 exit status </span><br></pre></td></tr></table></figure><p>猜测是bn库的版本不对（并不是）</p><p>是因为忘记删除之前<code>\usr\lib\</code>下尝试的新版的mcl编出来的libbslxx.so</p><p>以下是最终能通过build的bls.go</p><p><img src="/2023/10/31/leopard-bft/image-20231031231943209.png" alt="image-20231031231943209"></p><p>把<code>simulateUnderNode\network</code>文件夹cp到<code>GOROOT</code>下即可运行</p><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>4个terminal对应4个节点</p><p><img src="/2023/10/31/leopard-bft/image-20231031233119579.png" alt="image-20231031233119579"></p><p><img src="/2023/10/31/leopard-bft/image-20231031233148849.png" alt="image-20231031233148849"></p><p><img src="/2023/10/31/leopard-bft/image-20231031233209582.png" alt="image-20231031233209582"></p><p><img src="/2023/10/31/leopard-bft/image-20231031233217854.png" alt="image-20231031233217854"></p><p><img src="/2023/10/31/leopard-bft/image-20231031233204879.png" alt="image-20231031233204879"></p><p><img src="/2023/10/31/leopard-bft/image-20231031233312013.png" alt="image-20231031233312013"></p><h1 id="报告笔记"><a href="#报告笔记" class="headerlink" title="报告笔记"></a>报告笔记</h1><p>胡可欣老师详细介绍了工作</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Hotstuff是diem链底层的共识</p><p>半同步网络模型下，已经被证明支持的恶意敌手上界是1/3</p><p>传统的BFT类共识，当节点规模扩大，吞吐量急剧下降</p><ul><li>PBFT &gt;100</li></ul><p><img src="/2023/10/31/leopard-bft/image-20231102141032382.png" alt="image-20231102141032382"></p><p>提升可扩展性的方法</p><ul><li>横向扩展 scale out：共识节点分组，各组对交易并行，分片属于横向方案<ul><li>安全性要求组的大小为600 1000，和想要得到大规模节点的需求之间存在矛盾关系</li></ul></li><li>纵向扩展scale up：给每个节点增加物理资源，存在瓶颈</li></ul><p>发现瓶颈存在于领导者</p><ul><li>错误概率的问题<ul><li>组合</li><li>项目指标安全性要求是单片$10^{-18}$</li></ul></li><li>网络模型<ul><li>半同步 影响活性，一致性与网络模型无关</li><li>Dumbo系列共识是异步</li></ul></li></ul><p>Hotstuff降低了通信复杂度，存在轮数增加的问题；实验结果显示Hotstuff确实提高了性能和规模 </p><h2 id="协议设计"><a href="#协议设计" class="headerlink" title="协议设计"></a>协议设计</h2><ul><li><p>数据传输与共识解耦：先分摊交易，由领导者决定哪些交易当前轮打包</p><ul><li>怎么保证 交易分散没有交集 每个节点都拥有全集，发送时可能 mod 4</li><li>发 Hash(datablock) ，通过调整尺寸来保证复杂度不是n^2</li><li>复杂度是摊销的结果，实际没有降低复杂度</li></ul></li><li><p>纠删码</p><ul><li>法定人数2f+1，一定能收到f+1个好的纠删码片段</li><li>如何判断收到纠删码的完整性：带线性长度的证明</li><li>设计没有考虑proposal可能是交易，实际场景可能存在双花问题</li></ul></li></ul><h2 id="协议实现"><a href="#协议实现" class="headerlink" title="协议实现"></a>协议实现</h2><ul><li><p>实现</p><ul><li>信道 reliable and auth：不是工业界的实现</li><li>execution engine<ul><li>bls需要额外进行DKG</li><li>rate-limiter : 限制数据块分散交易的频率，利用到了半同步</li><li>双通道 go channel（共识优先级高于数据）</li></ul></li></ul></li><li><p>实验</p><ul><li>增加节点数量：600个节点，吞吐量仍然在10w</li><li>增加节点资源：斜率更高</li><li>杭州：一个机器 一个核，1个核能否带多个节点（docker）</li><li>软件所资源目前能使用的资源200个CPU</li><li>具体系统实现用的签名：<ul><li>猎豹采用的是bls门限签名</li><li>Schnorr（复旦大学李强老师）</li><li>ecdsa（pipelined Hotstuff）</li></ul></li><li>规模运行到600时，一笔交易确认已经非常困难了，由于databa</li></ul></li><li><p>安全性</p><ul><li>目前$n=600,Pr_{error}&lt;10^{-6},n=1000,Pr_{error}&lt;10^{-9}$，指标要求的是$10^{-18}$</li></ul></li><li><p>后续工作</p><ul><li>尽快将分片共识的框架搭起来，缺少经验可以学习一下刘老师团队的工作</li><li>明确能否在1个核上运行2个节点</li><li>实现安全性可以考虑gearbox，目前leopard BFT代码里是有一条底层链的实现的</li><li>leopard BFT有后续引用工作：Hu Z, Guan S, Xu W, et al. A Data Flow Framework with High Throughput and Low Latency for Permissioned Blockchains[C]//2023 IEEE 43rd International Conference on Distributed Computing Systems (ICDCS). IEEE, 2023: 1-12.</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Hu K, Guo K, Tang Q, et al. Leopard: Towards High Throughput-Preserving BFT for Large-scale Systems[C]//2022 IEEE 42nd International Conference on Distributed Computing Systems (ICDCS). IEEE, 2022: 157-167.&lt;/p&gt;</summary>
    
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="Consensus" scheme="https://alleysira.github.io/tags/Consensus/"/>
    
    <category term="Sharding" scheme="https://alleysira.github.io/tags/Sharding/"/>
    
  </entry>
  
  <entry>
    <title>Wasm-runtime-bugs-survey</title>
    <link href="https://alleysira.github.io/2023/10/25/Wasm-runtime-bugs-survey/"/>
    <id>https://alleysira.github.io/2023/10/25/Wasm-runtime-bugs-survey/</id>
    <published>2023-10-25T10:54:28.000Z</published>
    <updated>2023-11-28T12:37:30.395Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Wang Y, Zhou Z, Ren Z, et al. A Comprehensive Study of WebAssembly Runtime Bugs[C]//2023 IEEE International Conference on Software Analysis, Evolution and Reengineering (SANER). IEEE, 2023: 355-366.</p><span id="more"></span><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>考虑对漏洞进行分类</p><p>研究对象为4个Wasm</p><ul><li>浏览器采用的Wasm<ul><li><a href="https://v8.dev/">V8</a>：谷歌的开源JS和WAsm引擎，采用c++实现，被用在Chrome和Node.js中 </li><li><a href="https://spidermonkey.dev/">SpiderMonkey</a>：Mozilla的JS和Wasm引擎，采用C++实现，被用在Firefox</li></ul></li><li>独立的Wssm<ul><li><a href="https://wasmer.io/">Wasmer</a>：Rust实现，代码仓库 <a href="https://github.com/wasmerio/wasmer">https://github.com/wasmerio/wasmer</a></li><li><a href="https://github.com/bytecodealliance/wasmtime">Wasmtime</a>：Rust实现</li></ul></li></ul><p>回答6个问题</p><ul><li><p>Wasm运行时漏洞的根本原因的分布：进行了漏洞分类并分析了分布</p></li><li><p>Wasm运行时漏洞的症状：帮助理解漏洞可能导致的结果，辅助如何设计oracle，分为6类</p></li><li><p>根本原因和症状之间的联系</p></li><li>Wasm运行时漏洞的修复时间</li><li>不同运行时漏洞的共同点</li></ul><p>数据集和测试脚本已经<a href="https://github.com/Wang11Yue/WebAssembly_Runtime_Bugs">开源</a> </p><h1 id="Wasm-runtimes"><a href="#Wasm-runtimes" class="headerlink" title="Wasm runtimes"></a>Wasm runtimes</h1><p>wasm运行时负责将二进制wasm指令翻译为本地CPU的机器码，三种方法</p><ul><li>解释执行 解释器</li><li>提前编译为本地执行文件 编译器</li><li>及时编译 编译器 浏览器一般用，因为用户体验较好</li></ul><p><img src="/2023/10/25/Wasm-runtime-bugs-survey/image-20231026101820583.png" alt="image-20231026101820583"></p><h1 id="Methodology"><a href="#Methodology" class="headerlink" title="Methodology"></a>Methodology</h1><ul><li>收集漏洞：首先从closed和fixed中搜集所有已修复漏洞，得到BugSet1<ul><li><a href="https://bugs.chromium.org/p/v8/issues/list?q=&amp;can=1">https://bugs.chromium.org/p/v8/issues/list?q=&amp;can=1</a></li><li><a href="https://bugzilla.mozilla.org/query.cgi?format=advanced">https://bugzilla.mozilla.org/query.cgi?format=advanced</a></li><li><a href="https://github.com/wasmerio/wasmer">https://github.com/wasmerio/wasmer</a></li><li><a href="https://github.com/bytecodealliance/wasmtime">https://github.com/bytecodealliance/wasmtime</a></li></ul></li><li>收集漏洞修复的commit：漏洞提交到修复之前的commit（为了方便，筛掉了采用多个commit修复的情况），筛掉与代码无关的commit得到BugSet2（包含一个commit修复多个漏洞）和BugSet3<ul><li><img src="/2023/10/25/Wasm-runtime-bugs-survey/image-20231026103848029.png" alt="image-20231026103848029"></li></ul></li><li><p>漏洞分类和标记：3位熟悉Wasm的人员对BugSet2中的漏洞手工进行标记，标记出root cause和symptom</p></li><li><p>根本原因：16类</p><ul><li><img src="/2023/10/25/Wasm-runtime-bugs-survey/image-20231026111915194.png" alt="image-20231026111915194"></li></ul></li><li>症状：6类<ul><li><img src="/2023/10/25/Wasm-runtime-bugs-survey/image-20231026111927262.png" alt="image-20231026111927262"></li></ul></li></ul><h1 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h1><ul><li><p>根本原因</p><ul><li>不正确的算法实现是bug出现最多的地方 25.45%</li><li>内存问题占17.7%</li></ul></li><li><p>症状</p><ul><li>最常见的是crash，占比56.86%</li><li>不正确的功能占比22.15%</li></ul></li><li><p>根本原因和症状之间的联系：</p><ul><li>不正确的算法实现、内存、异常处理错误可能导致所有的症状（数量上53.52%）</li><li>79.01%的漏洞导致的结果是崩溃、不正确的功能，但是原因可能各异</li><li><img src="/2023/10/25/Wasm-runtime-bugs-survey/image-20231026113425878.png" alt="image-20231026113425878"></li></ul></li><li><p>修复漏洞花费的时间</p><ul><li>修复时间快于GCC和LLVM</li><li><img src="/2023/10/25/Wasm-runtime-bugs-survey/image-20231026113453636.png" alt="image-20231026113453636"></li></ul></li><li><p>修复涉及到的代码和文件 </p><ul><li><img src="/2023/10/25/Wasm-runtime-bugs-survey/image-20231026113811061.png" alt="image-20231026113811061"></li><li>超过50%的漏洞一个文件就修复了</li><li><img src="/2023/10/25/Wasm-runtime-bugs-survey/image-20231026113504452.png" alt="image-20231026113504452"></li><li>外部API不兼容原因导致的修复文件最多，Bad performance症状涉及到的文件最多，平均4.45</li><li><p><img src="/2023/10/25/Wasm-runtime-bugs-survey/image-20231026114237105.png" alt="image-20231026114237105"></p></li><li><p>修复代码行数的中位数从12-70变化</p></li></ul></li><li><p>不同Wasm运行时之间的共同点：采用斯皮尔曼相关系数进行分析</p><ul><li>取值范围在-1到1之间，-1表示完全负的单调关系，1表示完全正的单调关系，0表示没有单调关系,[0.8-1.0]表示相关性强</li><li><img src="/2023/10/25/Wasm-runtime-bugs-survey/image-20231026114536167.png" alt="image-20231026114536167"></li><li>症状类似，原因相关性不强</li></ul></li></ul><h1 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h1><ul><li>设计漏洞检测工具检测 <ul><li>最常出现的根本原因</li><li>常出现的两个症状</li></ul></li><li>现有的 算法实现 漏洞修复机制需要改进 <ul><li>crash的oracle定义相对简单，可以模糊测试；带有报错，可以辅助和调试</li><li>incorrect functionality难定义，可能采用差分测试</li></ul></li></ul><h1 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h1><ul><li>软件漏洞综述</li><li>Wasm运行时比较多，没有涉及到漏洞检测的</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Wang Y, Zhou Z, Ren Z, et al. A Comprehensive Study of WebAssembly Runtime Bugs[C]//2023 IEEE International Conference on Software Analysis, Evolution and Reengineering (SANER). IEEE, 2023: 355-366.&lt;/p&gt;</summary>
    
    
    
    
    <category term="VM" scheme="https://alleysira.github.io/tags/VM/"/>
    
  </entry>
  
  <entry>
    <title>VM-matters</title>
    <link href="https://alleysira.github.io/2023/10/23/VM-matters/"/>
    <id>https://alleysira.github.io/2023/10/23/VM-matters/</id>
    <published>2023-10-23T08:23:24.000Z</published>
    <updated>2023-10-29T14:43:19.217Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Zheng S, Wang H, Wu L, et al. VM matters: a comparison of WASM VMS and EVMS in the performance of blockchain smart contracts[J]. arXiv preprint arXiv:2012.01032, 2020.</p><span id="more"></span><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Wasm已经被以太坊采用，即eWASM，以期望取代EVM</p><p>以太坊的性能瓶颈</p><ul><li>共识协议</li><li>交易签名</li><li>执行引擎（EVM）</li></ul><p>然而EVM对真实世界的合约来说工具不够完善，开发者开始研究Wasm。Wasm被集成到了所有主流浏览器中。Wasm程序执行效率接近于本地执行，比浏览器Js的实现快2倍</p><p>Ethereum 2.0 roadmap中已经包含了eWASM，潜在的优势</p><ul><li>交易处理更快，提升吞吐量</li><li>支持更多智能合约语言</li><li>目前Geth和Openethereum在实验支持WASM，但是社区活跃似乎在18年，从2022年起代码仓库不再更新<ul><li><a href="https://github.com/ewasm/design">https://github.com/ewasm/design</a></li></ul></li></ul><p>目前没有明确的证据表明WASM能够提高区块链执行的实际效率</p><p>主要工作</p><ul><li><p>本文分析了智能合约执行引擎对区块链执行效率的影响，主要研究两类</p><ul><li><p>EVM engines：Geth和Openethereum</p></li><li><p>WASM engines：11个，3个是区块链定制的（Eos Geth 和 Openethereum）</p></li></ul></li><li><p>分析了字节码内引擎对比和字节码间的引擎对比，即EVM和WASM先自己和自己比，再跨平台比较</p></li><li>设计了一系列的benchmark</li></ul><p>得出了一系列<strong>结论</strong></p><ul><li>基于EVM的链对Wasm的支持<strong>不尽人意</strong><ul><li>Wasm的实现不稳定，客户端的编码规则不一致；支持的编程语言少</li></ul></li><li>对EVM来说，Geth和表现比Openethereum好</li><li>智能合约在Wasm上运行效率差异显著，最大3个数量级</li><li>本地支持的<strong>数据类型</strong>对Wasm合约执行影响显著，如Wasm的数据类型为32/64bit，当执行256的EVM字节码时，带来额外开销</li><li>尽管Standalone WASM的效率比EVM高，但是eWASM VM比EVM慢（所有256bit数据和大多数64bit数据），可能是gas测量和EEI上下文切换带来的开销</li></ul><p>为了研究，会开源benchmark和所有实验结果（因为匿名提交删掉了，github没搜到，但是有很多其他的开源的benchmark）</p><h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><h2 id="Smart-Contract"><a href="#Smart-Contract" class="headerlink" title="Smart Contract"></a>Smart Contract</h2><p>EVM合约字节码的执行是自循环，当程序结束或者出现error或者遇到STOP RETURN语句时终止</p><p>gas用于支付 <em>计算 存储 带宽</em> 的成本</p><h2 id="EVM-WASM-eWASM-字节码"><a href="#EVM-WASM-eWASM-字节码" class="headerlink" title="EVM/WASM/eWASM 字节码"></a>EVM/WASM/eWASM 字节码</h2><ul><li>EVM<ul><li>EVM仅支持256比特的数据，小于该长度的计算都必须转换成256比特的形式EVM才能处理</li><li>EVM不支持浮点数</li></ul></li><li>Wasm：2017年由浏览器厂商提出，在隔离的沙箱中运行<ul><li>可分为解码、验证和执行三个阶段</li><li>数据类型：32bit和64bit的浮点数、整数</li></ul></li><li>eWasm：Wasm的子集<ul><li>通过Wasm执行引擎定义的Ethereum Environment Interface (EEI)和以太坊交互</li><li>限制了浮点数（为了保证和以太坊的一致性）</li><li>定义了 EVM 交叉编译器，实现对EVM字节码的后向兼容性</li></ul></li></ul><p><img src="/2023/10/23/VM-matters/image-20231023192003800.png" alt="image-20231023192003800"></p><h1 id="Study-Design"><a href="#Study-Design" class="headerlink" title="Study Design"></a>Study Design</h1><p>研究四个问题</p><ul><li>目前区块链客户端对Wasm的支持情况</li><li>EVM比较</li><li>Wasm比较</li><li>EVM和Wasm比较</li></ul><p><img src="/2023/10/23/VM-matters/image-20231023192331005.png" alt="image-20231023192331005"></p><p>实验方法</p><ul><li><p>采用0.5.4的solc编译solidity生成EVM字节码</p></li><li><p>利用 <a href="https://github.com/second-state/SOLL">SOLL</a>（最新的release是2年前的）编译soldity生成eWasm的字节码</p></li><li><p>然而eWasm的字节码不能在一般的Wasm上面运行，利用其他引擎支持的语言 Rust 编写等价合约来编译成Wasm字节码</p></li></ul><p>对选择的Wasm的介绍</p><ul><li>Geth WASM - <a href="https://github.com/ewasm/hera">Hera</a>：C++实现，需要EVMC的支持,EVMC是EVM和客户端交互的接口，支持对应的Wasm后端包括<a href="https://github.com/webassembly/wabt">wabt</a> <a href="https://github.com/webassembly/binaryen">Binaryen</a> 和 <a href="https://github.com/WAVM/WAVM">WAVM</a></li><li>Openethereum WASM - <a href="https://github.com/paritytech/wasmi">wasmi</a>：Rust实现，虽然项目凉了，但是Wasm现在依然非常活跃</li><li>EOS VM：虚拟机运行是确定性的，采用软件实现浮点数。采用看门狗 timer来限制执行时间</li><li>其余还有Life SSVM wagon wbt wasm3 WAMR wasmtime</li></ul><p>benchmark</p><p>13个不同种类的测试标准</p><p><img src="/2023/10/23/VM-matters/image-20231023195252543.png" alt="image-20231023195252543"></p><ul><li><p>操作码层面的测试：Simple Operation测试了单一运算的效率</p></li><li><p>以太坊层面的测试：Arithmetic Block Status和Hashing测试</p></li></ul><h1 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h1><ul><li>EVM对比：Openethereum和geth对比<img src="/2023/10/23/VM-matters/image-20231024172501663.png" alt="image-20231024172501663"></li><li>WASM对比 <img src="/2023/10/23/VM-matters/image-20231024172615876.png" alt="image-20231024172615876"></li><li>eWasm和EVM字节码对比 <img src="/2023/10/23/VM-matters/image-20231024172751695.png" alt="image-20231024172751695"></li><li>Wasm带来的额外开销占比 <img src="/2023/10/23/VM-matters/image-20231024173251526.png" alt="image-20231024173251526"></li></ul><h1 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a>Limitation</h1><ul><li><p>benchmark的局限性</p><ul><li>目前只支持单一的操作、算术运算和哈希，不支持对KV存储的操作，因为Wasm目前不支持长期存储。</li><li>没有交易 和其他合约交互的测试</li></ul></li><li><p>目前的思路是设计benchmark来近似测量操作码执行的效率，更精确的方法应该是直接测量记录操作码的运行时间</p></li><li>Wasm VM仍然在频繁更新，本论文的结果可能不能反映目前的VM的实际性能</li></ul><h2 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h2><p>第一篇对Wasm和EVM执行效率进行对比的论文，目前有一些对Wasm的研究和区块链系统性能测量的研究</p><ul><li>Wasm字节码分析<ul><li>有工作<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Marius Musch, Christian Wressnegger, Martin Johns, and Konrad Rieck. 2019.New Kid on the Web: A Study on the Prevalence of WebAssembly in the Wild. In International Conference on Detection of Intrusions and Malware, and VulnerabilityAssessment. Springer, 23–42.">[1]</span></a></sup>分析了Alexa上使用WAsm的合约，发现仅1/600的合约使用Wasm</li><li>有工作发现<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Jan Rüth, Torsten Zimmermann, KonradWolsing, and Oliver Hohlfeld. 2018. Digginginto browser-based crypto mining. In Proceedings of the Internet MeasurementConference 2018. 70–76.">[2]</span></a></sup>Wasm被用于PoW，可能导致cryptojacking</li><li>工作<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Weikang Bian, Wei Meng, and Mingxue Zhang. 2020. MineThrottle: Defendinga gainst WASM In-Browser Cryptojacking. In Proceedings of The Web Conference3 112–3118.">[3]</span></a></sup> 提出了防御cryptojacking的方法</li></ul></li><li>区块链性能测量<ul><li>BlockBench <sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Tien Tuan Anh Dinh, Ji Wang, Gang Chen, Rui Liu, Beng Chin Ooi, and Kian-Lee Tan. 2017. Blockbench: A framework for analyzing private blockchains. InProceedings of the 2017 ACM International Conference on Management of Data.1085–1100.">[4]</span></a></sup>测量区块链私链的性能，分析了Ethereum, Parity and Hyperledger，发现区块链系统的瓶颈在于共识协议</li><li>工作<sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Sara Rouhani and Ralph Deters. 2017. Performance analysis of ethereum transactionsin private blockchain. In 2017 8th IEEE International Conference on Software Engineering and Service Science (ICSESS). IEEE, 70–74.">[5]</span></a></sup>分析了Geth和Parity上交易的效率，发现Parity更快</li></ul></li></ul><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Marius Musch, Christian Wressnegger, Martin Johns, and Konrad Rieck. 2019.New Kid on the Web: A Study on the Prevalence of WebAssembly in the Wild. In International Conference on Detection of Intrusions and Malware, and VulnerabilityAssessment. Springer, 23–42.<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Jan Rüth, Torsten Zimmermann, KonradWolsing, and Oliver Hohlfeld. 2018. Digginginto browser-based crypto mining. In Proceedings of the Internet MeasurementConference 2018. 70–76.<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Weikang Bian, Wei Meng, and Mingxue Zhang. 2020. MineThrottle: Defendinga gainst WASM In-Browser Cryptojacking. In Proceedings of The Web Conference3 112–3118.<a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Tien Tuan Anh Dinh, Ji Wang, Gang Chen, Rui Liu, Beng Chin Ooi, and Kian-Lee Tan. 2017. Blockbench: A framework for analyzing private blockchains. InProceedings of the 2017 ACM International Conference on Management of Data.1085–1100.<a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Sara Rouhani and Ralph Deters. 2017. Performance analysis of ethereum transactionsin private blockchain. In 2017 8th IEEE International Conference on Software Engineering and Service Science (ICSESS). IEEE, 70–74.<a href="#fnref:5" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;Zheng S, Wang H, Wu L, et al. VM matters: a comparison of WASM VMS and EVMS in the performance of blockchain smart contracts[J]. arXiv preprint arXiv:2012.01032, 2020.&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/categories/Blockchain/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="VM" scheme="https://alleysira.github.io/tags/VM/"/>
    
  </entry>
  
  <entry>
    <title>smart-contract-audit</title>
    <link href="https://alleysira.github.io/2023/10/19/smart-contract-audit/"/>
    <id>https://alleysira.github.io/2023/10/19/smart-contract-audit/</id>
    <published>2023-10-19T07:14:55.000Z</published>
    <updated>2023-10-23T12:43:50.567Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>收集、分析智能合约审计报告</p><span id="more"></span><h1 id="审计报告"><a href="#审计报告" class="headerlink" title="审计报告"></a>审计报告</h1><h2 id="调研结果"><a href="#调研结果" class="headerlink" title="调研结果"></a>调研结果</h2><p>收集了来自42家公司的2382份pdf格式的审计报告，主要针对的是智能合约</p><p>总结了审计报告的主要内容并以MetaTransaction的审计报告为例介绍了各个模块</p><h2 id="审计报告主要内容"><a href="#审计报告主要内容" class="headerlink" title="审计报告主要内容"></a>审计报告主要内容</h2><p>以审计公司 <a href="https://abdk.consulting/">ABDK.consulting</a> 对 <a href="[0x | Powerful APIs to build financial apps on crypto rails](https://0x.org/">0x</a>) 项目的 MetaTransaction审计报告为例，介绍审计报告一般包含的主要内容</p><h3 id="审计方法"><a href="#审计方法" class="headerlink" title="审计方法"></a>审计方法</h3><p>介绍审计过程中采用的方法或审计的流程</p><p>该审计报告主要进行了四个方面的分析</p><ul><li>常规代码检查：检查代码风格是否清楚、一致，具体检查缩进、变量命名、缺失注释等问题</li><li>实体使用分析：分析代码中的实体（例如变量、函数、类等）的使用情况和模式。了解代码中的实体是如何被引用、使用和修改的，以及它们在不同上下文中的行为和依赖关系</li><li>访问控制分析：对于能够被外部访问的实体，检查访问控制是否恰当</li><li>代码逻辑分析：分析特定函数的正确性和效率，检查代码的行为是否符合预期、算法是否正确</li></ul><p><img src="/2023/10/19/smart-contract-audit/image-20231008154504134.png" alt="image-20231008154504134" style="zoom:67%;"></p><h3 id="审计对象"><a href="#审计对象" class="headerlink" title="审计对象"></a>审计对象</h3><p>一般会给出被审计项目的基本介绍、代码、项目结构等信息</p><p>源代码：<a href="https://github.com/0xProject/protocol/compare/development...feat/MetaTransactionV2">Comparing development…feat/MetaTransactionV2 · 0xProject/protocol (github.com)</a> 以及 <a href="https://github.com/0xProject/protocol/pull/665/commits/6e926af41cd93ebd8686163f5ac34759b4ff1446">feat: Multiplex + MetaTransaction integration and MetaTransaction Multi-Fee Support [RFQ-795] [LIT-870] by patrick-dowell · Pull Request #665 · 0xProject/protocol (github.com)</a></p><p>审计对象的项目结构</p><p><img src="/2023/10/19/smart-contract-audit/image-20231008152113943.png" alt="image-20231008152113943"></p><h3 id="审计结果"><a href="#审计结果" class="headerlink" title="审计结果"></a>审计结果</h3><p>主要包括发现的漏洞类型、数量以及漏洞的修复情况</p><p>根据危害等级，一般将漏洞等级分为：</p><ul><li>Critical：严重</li><li>Major：高危</li><li>Moderate：中危</li><li>Minor：低危</li></ul><p>本报告发现了1个严重漏洞、1个高危漏洞、1个中危漏洞、17个低危漏洞，其中5个已经修复，仍有15个低危漏洞尚未被修复</p><p><img src="/2023/10/19/smart-contract-audit/image-20231008152655355.png" alt="image-20231008152655355" style="zoom:67%;"></p><h3 id="漏洞详细信息"><a href="#漏洞详细信息" class="headerlink" title="漏洞详细信息"></a>漏洞详细信息</h3><p>审计报告一般会对发现的漏洞进行描述，包括漏洞的分类、漏洞的危害、漏洞在合约中的位置、如何触发漏洞、以及如何修复漏洞</p><p>以发现的严重漏洞CVF-1为例，审计报告中介绍了该漏洞的具体信息</p><ul><li>漏洞分类为 缺陷</li><li>两个modifier <code>refundsAttachedEth</code> 和<code>doesNotReduceEthBalance</code>可能产生冲突</li><li>漏洞位置：该漏洞出现在<code>MetaTransactionsFeatureV2.sol</code>合约中</li><li>建议的修复措施：将<code>refundsAttachedEth</code>和<code>doesNotReduceEthBalance</code>合并作为交易退款的标识符</li><li>0x项目的解决方法：删除<code>refundsAttachedEth()</code>，将<code>executeMetatransaction</code>设置为<code>notpayable</code></li></ul><p><img src="/2023/10/19/smart-contract-audit/image-20231008153109744.png" alt="image-20231008153109744"></p><h2 id="审计报告来源"><a href="#审计报告来源" class="headerlink" title="审计报告来源"></a>审计报告来源</h2><p>共计42家审计公司公开发布的审计报告，具体名单如下</p><div class="table-container"><table><thead><tr><th style="text-align:center">审计公司</th><th style="text-align:center">链接</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://www.abdk.consulting/">ABDK Consulting</a></td><td style="text-align:center"><a href="https://github.com/abdk-consulting/audits">Link</a></td></tr><tr><td style="text-align:center"><a href="https://www.arbitraryexecution.com/blog/">Arbitrary Execution</a></td><td style="text-align:center"><a href="https://github.com/arbitraryexecution/publications">Link</a></td></tr><tr><td style="text-align:center"><a href="https://arcadiamgroup.com/">Arcadia Group</a></td><td style="text-align:center"><a href="https://www.arcadia.agency/auditReports">Link</a></td></tr><tr><td style="text-align:center"><a href="https://www.blockchainlabs.nz/home">BlockchainLabs</a></td><td style="text-align:center"><a href="https://github.com/BlockchainLabsNZ/audits">Link</a></td></tr><tr><td style="text-align:center"><a href="https://blocksecteam.com">BlockSec</a></td><td style="text-align:center"><a href="https://github.com/blocksecteam/audit-reports">Link</a></td></tr><tr><td style="text-align:center"><a href="https://chainsafe.io/">Chain Safe</a></td><td style="text-align:center"><a href="https://github.com/ChainSafe/audits">Link</a></td></tr><tr><td style="text-align:center"><a href="https://chainsulting.de/">Chainsulting</a></td><td style="text-align:center"><a href="https://github.com/chainsulting/Smart-Contract-Security-Audits">Link</a></td></tr><tr><td style="text-align:center"><a href="https://cystack.net/">Cystack</a></td><td style="text-align:center"><a href="https://github.com/cystack/security-audit-reports">Link</a></td></tr><tr><td style="text-align:center"><a href="https://credshields.com/index.html">CredShields</a></td><td style="text-align:center"><a href="https://github.com/Credshields/Audit-Reports">Link</a></td></tr><tr><td style="text-align:center"><a href="https://www.coinspect.com/">Coinspect</a></td><td style="text-align:center"><a href="https://github.com/coinspect/publications">Link</a></td></tr><tr><td style="text-align:center"><a href="https://www.cyfrin.io/">Cyfrin</a></td><td style="text-align:center"><a href="https://github.com/ChainAccelOrg/cyfrin-audit-reports">Link</a></td></tr><tr><td style="text-align:center"><a href="https://decurity.io/">Decurity</a></td><td style="text-align:center"><a href="https://github.com/Decurity/audits">Link</a></td></tr><tr><td style="text-align:center"><a href="https://www.dedaub.com/">Dedaub</a></td><td style="text-align:center"><a href="https://github.com/Dedaub/audits">Link</a></td></tr><tr><td style="text-align:center"><a href="https://distributedlab.com/">Distributed Lab</a></td><td style="text-align:center"><a href="https://github.com/dl-solidity-library/audits">Link</a></td></tr><tr><td style="text-align:center"><a href="https://github.com/g0-group">G0 Group</a></td><td style="text-align:center"><a href="https://github.com/g0-group/Audits">Link</a></td></tr><tr><td style="text-align:center"><a href="https://guardianaudits.com/">GuardianAudits</a></td><td style="text-align:center"><a href="https://github.com/GuardianAudits/Audits">Link</a></td></tr><tr><td style="text-align:center"><a href="https://lab.guardianaudits.com/">Guardian Solidity Lab</a></td><td style="text-align:center"><a href="https://github.com/GuardianAudits/SolidityLabAudits/tree/main">Link</a></td></tr><tr><td style="text-align:center"><a href="https://hexens.io/">Hexens</a></td><td style="text-align:center"><a href="https://github.com/Hexens/Smart-Contract-Review-Public-Reports">Link</a></td></tr><tr><td style="text-align:center"><a href="https://www.immunebytes.com/">Immunebytes</a></td><td style="text-align:center"><a href="https://github.com/ImmuneBytes/Smart-Contract-Audit-Reports/">Link</a></td></tr><tr><td style="text-align:center"><a href="https://informal.systems/">InformalSystems</a></td><td style="text-align:center"><a href="https://github.com/informalsystems/audits">Link</a></td></tr><tr><td style="text-align:center"><a href="https://www.kalos.xyz/">Kalos</a></td><td style="text-align:center"><a href="https://github.com/kalos-xyz/Publications">Link</a></td></tr><tr><td style="text-align:center"><a href="https://mixbytes.io/">MixBytes</a></td><td style="text-align:center"><a href="https://github.com/mixbytes/audits_public">Link</a></td></tr><tr><td style="text-align:center"><a href="https://www.numencyber.com/">Numen</a></td><td style="text-align:center"><a href="https://github.com/numencyber/Public_Report">Link</a></td></tr><tr><td style="text-align:center"><a href="https://www.oaksecurity.io/">Oak Security</a></td><td style="text-align:center"><a href="https://github.com/oak-security/audit-reports">Link</a></td></tr><tr><td style="text-align:center"><a href="https://oxor.io">Oxorio</a></td><td style="text-align:center"><a href="https://github.com/oxor-io/public_audits">Link</a></td></tr><tr><td style="text-align:center"><a href="https://github.com/peppersec">PepperSec</a></td><td style="text-align:center"><a href="https://github.com/peppersec/public-audit-reports">Link</a></td></tr><tr><td style="text-align:center"><a href="https://pessimistic.io/">Pessemistic</a></td><td style="text-align:center"><a href="https://github.com/pessimistic-io/audits">Link</a></td></tr><tr><td style="text-align:center"><a href="https://redteam.pl/">REDTEAM.PL</a></td><td style="text-align:center"><a href="https://github.com/redteampl/public_reports">Link</a></td></tr><tr><td style="text-align:center"><a href="https://runtimeverification.com/">Runtime Verification</a></td><td style="text-align:center"><a href="https://github.com/runtimeverification/publications#smart-contracts-security-audit-and-formal-verification">Link</a></td></tr><tr><td style="text-align:center"><a href="https://www.sec3.dev/">Sec3</a></td><td style="text-align:center"><a href="https://github.com/sec3-service/reports">Link</a></td></tr><tr><td style="text-align:center"><a href="https://audit.shellboxes.com/">ShellBoxes</a></td><td style="text-align:center"><a href="https://github.com/shellboxes/public-audit-reports">Link</a></td></tr><tr><td style="text-align:center"><a href="https://www.sherlock.xyz/">Sherlock</a></td><td style="text-align:center"><a href="https://github.com/sherlock-protocol/sherlock-reports">Link</a></td></tr><tr><td style="text-align:center"><a href="https://sigmaprime.io/">Sigma Prime</a></td><td style="text-align:center"><a href="https://github.com/sigp/public-audits">Link</a></td></tr><tr><td style="text-align:center"><a href="https://smcauditors.com/index.html">SMC Auditors</a></td><td style="text-align:center"><a href="https://github.com/smcauditors/smart-contract-audits">Link</a></td></tr><tr><td style="text-align:center"><a href="https://solidified.io/">Solidified</a></td><td style="text-align:center"><a href="https://github.com/solidified-platform/audits">Link</a></td></tr><tr><td style="text-align:center"><a href="https://spearbit.com/">Spearbit</a></td><td style="text-align:center"><a href="https://github.com/spearbit/portfolio">Link</a></td></tr><tr><td style="text-align:center"><a href="https://statemind.io/">Statemind</a></td><td style="text-align:center"><a href="https://github.com/statemindio/public-audits">Link</a></td></tr><tr><td style="text-align:center"><a href="https://www.truscova.com/index.php">Truscova</a></td><td style="text-align:center"><a href="https://github.com/Truscova/Reports">Link</a></td></tr><tr><td style="text-align:center"><a href="https://www.verichains.io/">Verichains</a></td><td style="text-align:center"><a href="https://github.com/verichains/public-audit-reports">Link</a></td></tr><tr><td style="text-align:center"><a href="https://yacademy.dev/">yAcademy</a></td><td style="text-align:center"><a href="https://github.com/yacademy/audits">Link</a></td></tr><tr><td style="text-align:center"><a href="https://yaudit.dev/">yAudit</a></td><td style="text-align:center"><a href="https://github.com/yAudit/reports">Link</a></td></tr><tr><td style="text-align:center"><a href="https://www.zellic.io/">Zellic</a></td><td style="text-align:center"><a href="https://github.com/Zellic/publications">Link</a></td></tr><tr><td style="text-align:center"><a href="https://www.zokyo.io/">Zokyo</a></td><td style="text-align:center"><a href="https://github.com/zokyo-sec/audit-reports">Link</a></td></tr></tbody></table></div><h1 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h1><ul><li><p>Etherscan目前认证了60家智能合约审计公司</p><ul><li><a href="https://etherscan.io/directory/Smart_Contracts/Smart_Contracts_Audit_And_Security">https://etherscan.io/directory/Smart_Contracts/Smart_Contracts_Audit_And_Security</a></li></ul></li><li><p>中山大学郑子彬老师的团队花费了44个人月，分析了1322份开源的审计报告</p><ul><li><a href="https://arxiv.org/abs/2305.08456">https://arxiv.org/abs/2305.08456</a></li><li>开源工具DappScan <ul><li><a href="https://github.com/InPlusLab/DAppSCAN">https://github.com/InPlusLab/DAppSCAN</a></li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;收集、分析智能合约审计报告&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/categories/Blockchain/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="SmartContract" scheme="https://alleysira.github.io/tags/SmartContract/"/>
    
  </entry>
  
  <entry>
    <title>EVM_security</title>
    <link href="https://alleysira.github.io/2023/10/12/EVM-security/"/>
    <id>https://alleysira.github.io/2023/10/12/EVM-security/</id>
    <published>2023-10-12T13:46:08.000Z</published>
    <updated>2023-11-29T13:16:50.051Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>调研区块链虚拟机安全</p><span id="more"></span><h1 id="EVM的不同实现"><a href="#EVM的不同实现" class="headerlink" title="EVM的不同实现"></a>EVM的不同实现</h1><ul><li>EVM官方实现：<a href="https://ethereum.org/en/developers/docs/evm/">Ethereum Virtual Machine (EVM) | ethereum.org</a><ul><li><a href="https://github.com/ethereum/py-evm">Py-EVM</a> - <em>Python</em></li><li><a href="https://github.com/ethereum/evmone">evmone</a> - <em>C++</em></li><li><a href="https://github.com/ethereumjs/ethereumjs-vm">ethereumjs-vm</a> - <em>JavaScript</em></li><li><a href="https://github.com/microsoft/eevm">eEVM</a> - <em>C++</em>，微软开发</li><li><a href="https://github.com/bluealloy/revm\-">https://github.com/bluealloy/revm\-</a> <em>Rust</em></li></ul></li><li><a href="https://github.com/rust-blockchain/evm">SputnikVM</a>：- <em>rust</em></li><li><a href="https://github.com/ethereum/pyethereum">pyethereum</a>：- <em>py</em>，2023.3已被弃用</li></ul><h1 id="其他VM"><a href="#其他VM" class="headerlink" title="其他VM"></a>其他VM</h1><ul><li><a href="https://github.com/neo-project/neo-vm">NEO VM</a>：采用C#实现，Neo链目前的市值排行66，NEO支持多种常用的编程语言，如C#、Java和Python等编写智能合约</li><li><a href="https://github.com/solana-labs/solana">Solana Virtual Machine</a>：Solana链（市值第7）上的虚拟机，rust实现.<ul><li>智能合约语言可以是Rust, C, and C++，翻译成BPF字节码执行；支持交易并行</li><li><a href="https://github.com/neonlabsorg/neon-evm">Neon</a>用于solana和EVM对齐</li></ul></li><li><a href="https://github.com/input-output-hk/cardano-node">Cardano</a>：token ADA，目前市值排行8，采用Haskell语言实现，以<a href="https://github.com/runtimeverification/evm-semantics">KEVM</a>,EVM的形式化验证版本为基础<ul><li>其中Milkomeda C1是Cardano对应的EVM侧链</li></ul></li><li><a href="https://gitlab.com/tezos/tezos">Tezos</a>：目前的市值排行52，项目采用的语言是OCaml，合约采用的编程语言是Archetype, LIGO, 和SmartPy，翻译为底层语言<a href="https://opentezos.com/michelson/">Michelson</a>后在VM上执行<ul><li>虚拟机的设计未详细介绍，参考资料<a href="https://forklog.com/sp/dev-on-tezos/en/tezos-introduction/#:~:text=Tezos&#39;s VM works with byte,with fast access to data">What Smart Contracts are and How They Work</a></li><li>github镜像：<a href="https://github.com/tezos/tezos-mirror">tezos/tezos-mirror: Github test mirror of the Octez software</a></li></ul></li></ul><h2 id="WASM"><a href="#WASM" class="headerlink" title="WASM"></a>WASM</h2><ul><li><a href="https://github.com/EOSIO/eos-vm">EOSIO, EOS-VM</a>：第一个DpoS的链，C++实现，目前的市值排行57，采用WebAssembly（WASM）作为底层引擎，通过即时编译技术将智能合约字节码转换为本地机器码；同样支持多种编程语言，包括C++、Rust、Python等编写智能合约</li><li><a href="https://github.com/near/nearcore">Near</a>：采用Rust实现，Wasm作为执行引擎，市值排行43</li><li>国内的迅雷公司的<a href="https://github.com/xunleichain/tc-wasm/tree/master">迅雷链</a>：采用Wasm作为VM，目前提供<a href="https://blockchain.xunlei.com/">数字藏品</a></li><li><a href="https://tron.network/">Tron</a>：市值10声称要支持WASM，但是根据<a href="https://tron.network/static/doc/white_paper_v_2_0.pdf">官方白皮书</a>的介绍，目前采用的实现是以太坊的fork</li><li><a href="https://github.com/ewasm/hera">Hera</a>：Geth采用的Wasm，需要EVMC的支持</li><li><a href="https://github.com/vshymanskyy/awesome-wasm-tools">awesome-wasm-tools</a>：Wasm静态分析、动态分析和相关论文的仓库</li></ul><p>学习资料</p><ul><li>fuzzinglab<ul><li>开源工具集 <a href="https://fuzzinglabs.com/blockchain-security-fuzzing/">FuzzingLabs</a></li><li>medium Fuzz testing in webassembly vms <a href="https://medium.com/wasmer/fuzz-testing-in-webassembly-vms-3a301f982e5a">https://medium.com/wasmer/fuzz-testing-in-webassembly-vms-3a301f982e5a</a></li><li>学习教程 <a href="https://fuzzinglabs.com/journey-fuzzing-webassembly-wasm-vm/">https://fuzzinglabs.com/journey-fuzzing-webassembly-wasm-vm/</a></li></ul></li><li>中科大CSS实验室 <a href="https://csslab-ustc.github.io/index.html">https://csslab-ustc.github.io/index.html</a><ul><li>在py虚拟机 wasm虚拟机方面有很多工作</li></ul></li></ul><h2 id="MOVE-VM"><a href="#MOVE-VM" class="headerlink" title="MOVE VM"></a>MOVE VM</h2><ul><li>github的awesome库：<a href="https://github.com/MystenLabs/awesome-move#papers">https://github.com/MystenLabs/awesome-move#papers</a></li><li><a href="https://github.com/diem/diem">MoveVM</a>：Facebook旗下的区块链项目Diem（ Libra ）采用的虚拟机，rust实现</li><li><a href="https://github.com/MystenLabs/sui">Sui</a>：Mysten Labs于2022年3月发起的layer1 PoS公链，目前市值排行91，同样采用Move作为运行时</li></ul><h1 id="以太坊客户端"><a href="#以太坊客户端" class="headerlink" title="以太坊客户端"></a>以太坊客户端</h1><p>根据以太坊主网的<a href="https://www.ethernodes.org/">统计数据</a>显示，geth是使用最广泛的客户端</p><p><img src="/2023/10/12/EVM-security/image-20231012160435832.png" alt="image-20231012160435832"></p><ul><li><a href="https://github.com/ethereum/go-ethereum">Geth</a>：占比50.0%，采用go语言实现，最常用的客户端<ul><li>支持Mainnet, Sepolia, Goerli</li></ul></li><li><a href="https://github.com/NethermindEth/nethermind">Nethermind</a>：占比29.3%，采用C#实现<ul><li>支持Mainnet, Sepolia, Goerli, and more</li></ul></li><li><a href="https://github.com/ledgerwatch/erigon">Erigon</a>：占比11.12%，采用go语言实现，作为Openethereum的后继者<ul><li>Mainnet, Sepolia, Goerli, and more</li></ul></li><li><a href="https://github.com/hyperledger/besu">besu</a>：占比9%，Java实现，Hyperledger 项目的一部分，是一个企业级以太坊客户端<ul><li>Mainnet, Sepolia, Goerli, and more</li></ul></li><li><a href="https://github.com/paradigmxyz/reth">reth</a>：占比0.5%，Rust实现<ul><li>Mainnet, Sepolia, Goerli, and more</li></ul></li><li><p><a href="https://github.com/openethereum/openethereum">Openethereum</a>：采用Rust实现，曾经仅次于geth， August 4, 2021已被弃用</p></li><li><p><a href="https://github.com/etclabscore/core-geth">Coregeth</a>：Go实现，Geth的下游发行版</p></li></ul><h1 id="EVM兼容的区块链"><a href="#EVM兼容的区块链" class="headerlink" title="EVM兼容的区块链"></a>EVM兼容的区块链</h1><p>所有兼容EVM的区块链可见 <a href="https://www.coincarp.com/zh/chainlist/">EVM公链列表CoinCarp</a></p><ul><li><a href="https://www.bnbchain.world/en">Binance Smart Chain</a>：token BNB，市值排行第4，由币安交易所推出<ul><li>客户端<a href="https://github.com/bnb-chain/bsc">bsc</a>基于geth fork开发，EVM类似于geth</li></ul></li><li><a href="https://fantom.foundation/">Fantom</a>：token FTM，市值排行63<ul><li>客户端opera采用go实现，利用了EVM的实现<a href="https://github.com/Fantom-foundation/go-opera">go-opera</a></li></ul></li><li><a href="https://polygon.technology/">Polygon</a>：token MATIC，市值排行13<ul><li>虚拟机是zkEVM，声称与EVM等价 <a href="https://polygon.technology/polygon-zkevm">Polygon zkEVM | Scaling for the Ethereum Virtual Machine</a></li><li><a href="https://github.com/maticnetwork/bor">Bor</a>，EVM实现是geth的fork</li></ul></li><li><a href="https://www.avax.network/">Avalanche</a>：token AVAX，市值排行22</li></ul><h1 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h1><ul><li><p><a href="https://github.com/ethereum/tests">EVMtest</a> 以太坊项目官方对客户端会进行单元测试，</p></li><li><p><a href="https://github.com/ooibc88/blockbench">Blockbench</a> 区块链测试用例 </p></li><li><p><a href="https://github.com/ziyadedher/evm-bench">EVM性能对比和压力测试</a> </p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>可能的研究方向<ul><li>虚拟机：目前学术论文的研究对象主要是EVM的官方实现（geth/aleth/js-evm/openethereum）和EVM兼容的链（FISCO-BCOS-evm），逐渐开始有向其他公有链项目采用的VM进行延伸（Neo）的工作。后续工作可以考虑对其他EVM兼容的区块链上的EVM实现（如SputnikVM）进行差分模糊测试和对其他非EVM的知名公有链的虚拟机（EOS-VM/Solana/Cardano）安全性进行研究</li><li>客户端：现有的对以太坊客户端的测试主要以Geth为主。但是从以太坊官方的统计数据来看，除了Geth之外，Nethermind、Eriqon、besu同样占有较大的比例，对以上客户端内的EVM实现进行差分模糊测试也是具有一定研究意义的</li></ul></li><li>目前探索的方向：学习EVMfuzzer和NeoDiff，扩展到EVM compatible的链上</li></ul><h1 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h1><ul><li>6年前其他人总结的EVM相关的资料：<a href="https://github.com/pirapira/awesome-ethereum-virtual-machine">pirapira/awesome-ethereum-virtual-machine: Ethereum Virtual Machine Awesome List (github.com)</a></li><li><a href="https://github.com/kareniel/awesome-evm-security">https://github.com/kareniel/awesome-evm-security</a></li><li>WASM对应的VM：<a href="https://github.com/appcypher/awesome-wasm-runtimes">appcypher/awesome-wasm-runtimes: A list of webassemby runtimes (github.com)</a></li><li>Move语言相关资料：<a href="https://github.com/MystenLabs/awesome-move#move-powered-blockchains">MystenLabs/awesome-move: Code and content from the Move community. (github.com)</a></li><li>CCS23放出的Accepted Poster <a href="https://www.sigsac.org/ccs/CCS2023/program.html">https://www.sigsac.org/ccs/CCS2023/program.html</a><ul><li>Poster:A Privacy-Preserving Smart Contract Vulnerability Detection Framework for Permissioned Blockchain<br>Wensheng Tian (Nanhu Laboratory - CN)<br>Lei Zhang (Nanhu Laboratory - CN)<br>Shuangxi Chen (Jiaxing Vocational and Technical College - CN)<br>Hu Wang (Zhejiang Big Data Development Administration - CN)<br>Xiao Luo (Zhejiang University - CN)</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;调研区块链虚拟机安全&lt;/p&gt;</summary>
    
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>BlockScope</title>
    <link href="https://alleysira.github.io/2023/09/26/BlockScope/"/>
    <id>https://alleysira.github.io/2023/09/26/BlockScope/</id>
    <published>2023-09-26T10:17:51.000Z</published>
    <updated>2024-01-07T04:38:22.261Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="BlockScope-Detecting-and-Investigating-Propagated-Vulnerabilities-in-Forked-Blockchain-Projects"><a href="#BlockScope-Detecting-and-Investigating-Propagated-Vulnerabilities-in-Forked-Blockchain-Projects" class="headerlink" title="BlockScope: Detecting and Investigating Propagated Vulnerabilities in Forked Blockchain Projects"></a>BlockScope: Detecting and Investigating Propagated Vulnerabilities in Forked Blockchain Projects</h1><p>Yi X, Fang Y, Wu D, et al. BlockScope: Detecting and Investigating Propagated Vulnerabilities in Forked Blockchain Projects[C].Network and Distributed System Security (NDSS) Symposium 2023<br>27 February - 3 March 2023, San Diego, CA, USA.</p><span id="more"></span><p>NDSS23的<a href="https://www.ndss-symposium.org/ndss-paper/blockscope-detecting-and-investigating-propagated-vulnerabilities-in-forked-blockchain-projects/">工作</a></p><p>许多区块链重用或者fork了比特币/以太坊等经典区块链的代码，不难理解，当fork或频繁fetch时可能将原来链上存在的漏洞传播到当前链上。本文设计了BlockScope，能够在输入现有的BC/Ethereum安全补丁后，检测出多个cloned漏洞</p><p>BlockScope采用基于相似度的代码匹配机制，设计了一种新的计算代码相似度的方法来覆盖所有syntax-wide变量的克隆</p><p>BlockScope能够自动抽取补丁的上下文，找到潜在的相关代码进行对比</p><p>和现有工作ReDebug相比，能在精度接近的情况下实现1.8倍的recall（确定更多可能执行的路径或者函数调用）</p><p>分别在13/16个forked区块链上发现了101个漏洞</p><ul><li>40个被接受或修复</li><li>66被知情，等待中</li><li>4个被拒绝</li></ul><p>总结出了3类从源到分叉的链的漏洞传播规律</p><p>仅开源了具体的漏洞报告 <a href="https://github.com/VPRLab/BlkVulnReport">VPRLab/BlkVulnReport: A Summary of Vulnerabilities Found in the BlockScope NDSS’23 Paper (github.com)</a>，没有源代码</p><h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>因为开源，所以可以fork或重用eth和Bitcoin的代码</p><p>漏洞传播可能的途径</p><ul><li>最初分叉</li><li>update commits</li></ul><p>创新点</p><ul><li>相似度检查而不是精确的hash对比，相似度计算方法改进，更好处理增删和重排序<ul><li>更接近Soundness：大幅降低假阴率，略微提高假阳率</li></ul></li><li>抽取并利用补丁代码的语境定位可能相关的代码段<ul><li>提高执行效率和精度</li></ul></li></ul><p>数据集采用了38个补丁</p><ul><li>32个是比特币的代码仓库中来的（CVE只有4个</li><li>6个Ethereum的CVE</li></ul><p>分别测试了11+6个fork链的C/Go的代码，准确率和recall率为91.8%</p><p>发现漏洞后试图总结传播规律</p><ul><li>最初fork时传播</li><li>fetch时传播</li><li>被非显式的commit感染</li></ul><p>大多数分叉链修补的时间延迟约为200天 </p><p>提供的具体漏洞CVE和PR：<a href="https://github.com/VPRLab/BlkVulnReport">VPRLab/BlkVulnReport: A Summary of Vulnerabilities Found in the BlockScope NDSS’23 Paper (github.com)</a></p><p>wu老师的主页总结了学术界和工业界安全相关会议的ddl <a href="https://daoyuan14.github.io/">Daoyuan Wu’s HomePage (daoyuan14.github.io)</a></p><h1 id="design-choices-and-system-overview"><a href="#design-choices-and-system-overview" class="headerlink" title="design choices and system overview"></a>design choices and system overview</h1><ul><li>基于补丁的代码检测</li><li>不针对特定编程语言，不采用类似程序分析的抽象</li><li>创新点<ul><li>利用补丁代码上下文，仅定位相关的代码（不用分析全程序，精度更高）</li><li>采用基于代码相似度的代码匹配机制，支持3类代码克隆</li></ul></li></ul><h1 id="问题与思考"><a href="#问题与思考" class="headerlink" title="问题与思考"></a>问题与思考</h1><ul><li>什么是similariry based code match</li><li>recall：分析结果中确定可达分支的能力</li><li>extract之前需要normalizing and tokenizing</li></ul><p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;BlockScope-Detecting-and-Investigating-Propagated-Vulnerabilities-in-Forked-Blockchain-Projects&quot;&gt;&lt;a href=&quot;#BlockScope-Detecting-and-Investigating-Propagated-Vulnerabilities-in-Forked-Blockchain-Projects&quot; class=&quot;headerlink&quot; title=&quot;BlockScope: Detecting and Investigating Propagated Vulnerabilities in Forked Blockchain Projects&quot;&gt;&lt;/a&gt;BlockScope: Detecting and Investigating Propagated Vulnerabilities in Forked Blockchain Projects&lt;/h1&gt;&lt;p&gt;Yi X, Fang Y, Wu D, et al. BlockScope: Detecting and Investigating Propagated Vulnerabilities in Forked Blockchain Projects[C].Network and Distributed System Security (NDSS) Symposium 2023&lt;br&gt;27 February - 3 March 2023, San Diego, CA, USA.&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/categories/Blockchain/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="SmartContract" scheme="https://alleysira.github.io/tags/SmartContract/"/>
    
  </entry>
  
  <entry>
    <title>NeoDiff</title>
    <link href="https://alleysira.github.io/2023/09/25/NeoDiff/"/>
    <id>https://alleysira.github.io/2023/09/25/NeoDiff/</id>
    <published>2023-09-25T07:55:11.000Z</published>
    <updated>2023-11-28T11:40:35.726Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Uncovering-Smart-Contract-VM-Bugs-Via-Differential-Fuzzing"><a href="#Uncovering-Smart-Contract-VM-Bugs-Via-Differential-Fuzzing" class="headerlink" title="Uncovering Smart Contract VM Bugs Via Differential Fuzzing"></a>Uncovering Smart Contract VM Bugs Via Differential Fuzzing</h1><p>Maier D, Fäßler F, Seifert J P. Uncovering Smart Contract VM Bugs Via Differential Fuzzing[C]//Reversing and Offensive-oriented Trends Symposium. 2021: 11-22.</p><span id="more"></span><p>基于覆盖和状态对智能合约虚拟机的行为进行模糊测试，提出了NeoDiff——第一个反馈导向的智能合约虚拟机的模糊测试框架</p><ul><li><p>除了对EVM进行模糊测试，NeoDiff发现了若干Neo区块链上的重要漏洞</p></li><li><p>通过高层的语义变异器，发现了Python编写的Neo智能合约和传统CPython编写的合约的不一致</p></li><li>发现了C#的Neo虚拟机中的内存损坏问题</li></ul><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>智能合约虚拟机类似于传统安全研究范畴内的操作系统，执行合约的虚拟机定义了如何进行交互的接口，没有文件系统、套接字和线程，而是直接访问区块链，因此出现了新的安全问题</p><p>智能合约虚拟机需要保证执行结果的一致性</p><p>2500行代码实现了NeoDiff</p><p>反馈部分不仅考虑了覆盖率，还考虑了虚拟机传回的状态传播</p><p>尽管对以太坊的两个虚拟机的测试仅返回了假阳的结果（可能是因为严格的手工测试），额外发现了很多其他生态系统中的漏洞，如Neo</p><p>Neo是一个被研究较少的区块链，2021年日均交易量达1.5亿美元。项目地址：<a href="https://neo.org/">Neo 智能经济</a></p><p><a href="https://www.investopedia.com/tech/china-neo-cryptocurrency/">NEO (NEO) Definition (investopedia.com)</a></p><p><img src="/2023/09/25/NeoDiff/image-20230925160606443.png" alt="image-20230925160606443"></p><p>在Neo上NeoDiff发现了VM的不一致性、主链上的内存损坏，因为Neo提供了利用python等传统编程语言写智能合约的选项，因此可以利用python的语义进行模糊测试</p><p>和传统模糊测试不同的是，差分模糊测试想要实现的是输出或状态的不一致，NeoDiff支持对不同编程语言实现的系统进行模糊测试（neo-python VM 客户端和Neo VM C# 共识节点)，</p><p>发现了CPython and neo-boa Python和智能合约上的语义差别</p><p>贡献如下：</p><ul><li><p>开发并开源了NeoDiff，对智能合约虚拟机定制的模糊测试工具</p><ul><li><a href="https://github.com/fgsect/NeoDiff">fgsect/NeoDiff: Differential fuzzing for Smart Contract VMs (github.com)</a></li></ul></li><li><p>实现了NeoDiff的后端，来模糊测试openethereum against the geth Ethereum VM和<br>Neo VM against neo-python.</p></li><li>测试了CPython和Python实现的合约的语义，发现了语义的差距和对应的安全后果</li><li>讨论了如何利用智能合约虚拟机中的不一致性进行攻击（如攻击区块链网络上的应用</li><li>NeoDiff帮助发现并修复了Neo智能合约生态系统中的重要bug</li></ul><h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><p>2020年FC有一篇讨论NEo的BFT方案的论文，Neo采用PoS，参与共识的节点数量较少；目前支持8种编程语言编写合约（Python, Go, JavaScript, Java and C#  /C C++ to be done)；Neo的编译器调用对应语言的官方编译器，将IR转换成AVM 码，即虚拟机的字节码。</p><p>参与共识的节点运行C#编写的Neo VM构成区块链网络的核心部分，为了调用区块链，用户需要使用客户端程序，提供了SDK供开发者在NEO区块链上编写应用程序和合约交互；SDK需要能够理解所有交易并本地执行合约</p><ul><li><p>资产：Neo区块链原生的资产是代币Neo和部署、执行合约需要的GAS；NeoGas随时间生成并根据拥有的Neo成比例地分配给钱包；每个节点本地 都能执行字节码形式的合约，消耗的gas和opcode以及syscall相关联。共识算法是基于PBFT的DelegatedBFT</p></li><li><p>虚拟机：负责执行上传的合约，每个参与者都必须有VM来执行合约，和传统的VM不同，Neo VM不提供硬件和文件系统访问，直接和区块链的数据交互。本地执行合约允许客户端从合约存储中直接读取数据，而不用通过缓慢的API进行查或相信中心化的节点</p></li><li><p>C#虚拟机：执行引擎是核心部分，包括函数和调用栈。执行合约时创建一个对应的上下文。上下文中包括代码和两个栈每个合约在隔离的上下文中执行，合约可以使用两个栈</p><ul><li>altstack：临时数据存储</li><li>执行栈：存储结果</li><li>每次调用生成新的调用栈</li><li><p>架构如图<img src="/2023/09/25/NeoDiff/image-20230925171307210.png" alt="image-20230925171307210"></p></li><li><p>持久存储：大多数数据（例如区块链的交易和合约的永久K-V存储）均可以通过syscall操作码访问；区块链本身仅存储交易，包括了调用合约的交易；为了得到当前存储的状态，所有交易都必须被重放（重新执行），存储可能存了认证消息或代币的余额。可以给予另一个合约访问存储的对象的权利</p><ul><li>实现中的漏洞或不恰当的授权可能导致存储相关的问题，如delagatecall<ul><li>Johannes Krupp and Christian Rossow. 2018. teether: Gnawing at Ethereum to<br>Automatically Exploit Smart Contracts. Proceedings of the 27th USENIX Security<br>Symposium (2018), 1317–1333.</li></ul></li></ul></li></ul></li></ul><h1 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work"></a>Related work</h1><p>在智能合约概念出现之前，差分模糊测试被用于测试编译器和代码库</p><ul><li>CSmith：自动生成C程序，寻找不同编译器和优化层级带来的程序行为的差异 2011</li><li>Diffuzz：通过差分模糊测试进行侧信道分析</li><li>NEZHA：对二进制代码库进行差分模糊测试，除了代码覆盖率之外，采用了多种反馈</li><li>HyDiff：和NEZHA类似，关注覆盖率的同时，额外利用了静态分析和符号执行，采用了一系列的启发式推理改善对变异输出的</li><li>EVMFuzzer：生成合约并提供给以太坊虚拟机发现不一致性，在solidity层面对合约进行变异</li></ul><p>提到了EVMFuzzer，世界线收束</p><h1 id="NEODIFF"><a href="#NEODIFF" class="headerlink" title="NEODIFF"></a>NEODIFF</h1><p>对同一个虚拟机的多个可选实现进行差分模糊测试</p><p><img src="/2023/09/25/NeoDiff/image-20230925185409445.png" alt="image-20230925185409445"></p><h2 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h2><p>反馈导向，可以采用不同量级的反馈机制来对不同编程语言实现的VM进行测试</p><p>和EVMFuzz相比，NeoDiff更底层，生成有效的操作码序列而不是修改AST再转化为合约，会枚举所有可能的操作码序列，然而solidity编译器可能不会生成无意义的操作码（假设VM之前很少接受这种高级语言不会生成的序列的测试）</p><ul><li>Diff generator：采用基于反馈的变异器生成VM执行的字节码<ul><li>拼接、添加高覆盖率的片段、随机翻转字节，能够生成高级编程语言无法生成的操作码序列</li></ul></li><li>mutator：可以针对特定目标定制不同变异器；默认NeoDiff循环采用下列的变异器，直到达到最小的合约长度；由于可能生成全新的合约，不容易陷入局部最优解；会将成功执行的字节码序列保留下来；方便定义其他特定链的变异器<ul><li>随机1字节</li><li>全拼接：添加<del>部分</del>第二个随机合约的代码，倾向于能够覆盖新分支的测试用例</li><li>部分拼接：添加部分第二个随机合约的代码，倾向于能够覆盖新分支的测试用例<ul><li><img src="/2023/09/25/NeoDiff/image-20230925193912440.png" alt="image-20230925193912440"></li></ul></li><li>字节插入：一个字节插入到当前合约的随机位置</li><li>特殊操作：特殊的字节码，比如ETH的PUSHBYTES</li></ul></li><li>Diff Analyzer：需要修改EVM的实现来生成trace，trace的内容包括执行的操作码的列表，对应的类型hash $\tau$和状态hash $\sigma$，分析器通过比较$\sigma$来发现不同，通过$\tau$判断是否到达了新的状态<ul><li>假设当中间的$\sigma$不同时，认为出现了分叉</li><li>出现不一致时，导致问题产生的操作码和对应的$\tau$存储在结果中</li><li>分叉之前正确的操作码和对应的$\tau$会前向传播到minimizer</li><li>minimizer试图寻找到能导致特定$\tau$的最短字节序列并且存储到$\tau$ map中去<ul><li>$\tau$ map随着模糊测试的进行不断增长，后续可以用于变异的反馈</li></ul></li><li><img src="/2023/09/25/NeoDiff/image-20230925200033512.png" alt="image-20230925200033512"></li></ul></li></ul><h2 id="state-hash"><a href="#state-hash" class="headerlink" title="state-hash"></a>state-hash</h2><p>为了标识不同的执行，利用了状态哈希$\sigma$，取当前执行中的状态的子集，由研究者定义对于diff重要的信息，将该信息包括在哈希中</p><ul><li>对于基于栈的虚拟机而言，包括对栈的概率性采样；</li><li>如果有寄存器应该包括寄存器的值</li><li>如果有额外的内存，需要考虑内存</li></ul><p>执行速度和精度之前需要进行trade-off，可能的话对每个操作码都更新$\sigma$，利用它来检测不一致性</p><h2 id="Type-Hash"><a href="#Type-Hash" class="headerlink" title="Type-Hash"></a>Type-Hash</h2><p>思路：利用type-hash来作为一种轻量级的覆盖率的表示</p><p>也包含了状态信息，但是没有和之前的状态连接起来，仅标识当前操作码的状态</p><p>由于Neo VM支持多种类型（整数、字节数组等），以太坊仅支持256比特的整数作为类型，设立了虚类型方便执行</p><p>NeoDiff支持在传统的代码覆盖率下进行测试，如果采用了类型哈希，可以用来对差异进行排序和分类</p><p>类型哈希 $\tau $ 利用栈顶的2个类型，前缀为当前的操作码，执行加法命令，栈顶元素是整型1和字节数组2，对应的类型哈希 𝜏 为ADD_12</p><p>问题：类型哈希变化一定意味着覆盖率的变化吗？实验结果：86%的情况下，发现新的类型哈希 𝜏 同样标识到达了新的代码覆盖率。结果表明类型哈希能够表示所有的覆盖率变化，NeoDiff同样支持采用实际的覆盖率作为类型哈希</p><p><img src="/2023/09/25/NeoDiff/image-20231006192746686.png" alt="image-20231006192746686"></p><h2 id="Minimization"><a href="#Minimization" class="headerlink" title="Minimization"></a>Minimization</h2><p>利用测试用例再次执行VM，对于每个字节检查是否包含了之前的 𝜏 ，一旦发现了所有的类型哈希，认为当前长度是最短的</p><p>根据操作码导致的类型哈希来进行分类</p><h1 id="Eval"><a href="#Eval" class="headerlink" title="Eval"></a>Eval</h1><p>工具已经开源，后续有空测试一下</p><p><a href="https://github.com/fgsect/NeoDiff">fgsect/NeoDiff: Differential fuzzing for Smart Contract VMs (github.com)</a></p><ul><li>C# VM and neo-python VM<ul><li>测试了4个变异策略<ul><li>random：字节全随机</li><li>mut1p：将特定值压入栈，利用覆盖率反馈的概率较低</li><li>mut20p：基于反馈的变异，概率是20倍</li><li>coverage：默认变异策略，初始是随机的</li><li><img src="/2023/09/25/NeoDiff/image-20230928082042644.png" alt="image-20230928082042644"></li><li>然而当运行深度增加，随机策略丧失了多样性</li></ul></li></ul></li><li>geth vs. openethereum<ul><li>发现了6个不同，均是配置信息，未能在现有的区块链上复现</li><li><img src="/2023/09/25/NeoDiff/image-20230928084441953.png" alt="image-20230928084441953"></li></ul></li><li>cpy vs. Neo py：额外设计了py的语义变异器，不基于状态，能够产生有效的python脚本能够作为Neo智能合约运行<ul><li><img src="/2023/09/25/NeoDiff/image-20231006200937631.png" alt="image-20231006200937631"></li></ul></li></ul><h1 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h1><h2 id="合约虚拟机差异的安全影响"><a href="#合约虚拟机差异的安全影响" class="headerlink" title="合约虚拟机差异的安全影响"></a>合约虚拟机差异的安全影响</h2><ul><li>链上差异：可能导致算力分叉，大多数算力采用的实现将成为主流，可能导致链分叉</li><li>区块链应用差异：钱包和Dapp本地执行结果和主网不一致，导致出现本地分叉</li><li>合约语义差异：python写的合约和solidity写的合约行为不一致，恶意的开发者可能设计后门</li></ul><h2 id="对Neo-VM差异的PoC"><a href="#对Neo-VM差异的PoC" class="headerlink" title="对Neo VM差异的PoC"></a>对Neo VM差异的PoC</h2><p>给了比较详细的PoC和脚本</p><h2 id="Ethereum-VM-Differences"><a href="#Ethereum-VM-Differences" class="headerlink" title="Ethereum VM Differences"></a>Ethereum VM Differences</h2><p><img src="/2023/09/25/NeoDiff/image-20231006202931015.png" alt="image-20231006202931015"></p><p>表明进行差分模糊测试时应该在空白的链上，采用相同的初始设置</p><p>或者手动删除这些假阳性</p><h2 id="语言语义的差异"><a href="#语言语义的差异" class="headerlink" title="语言语义的差异"></a>语言语义的差异</h2><ul><li>语义差异：<ul><li>编译时报错：neo-boa不支持range()和float</li></ul></li><li>字符串连接：<ul><li>+：neo-python编译成VMOP.ADD，整数加法<ul><li>‘xxx’+’!!!’=’xxx!!!’, not ‘yyy’</li></ul></li></ul></li><li>字符串乘法<ul><li>’x’<em>21 和 ’x’</em>20</li></ul></li><li>潜在的漏洞：Neo VM会进行类型转换，之前的安全机制如给key加前缀可能不再安全<ul><li><img src="/2023/09/25/NeoDiff/image-20231006204246703.png" alt="image-20231006204246703"></li></ul></li></ul><h2 id="Neo-VM的差异和漏洞"><a href="#Neo-VM的差异和漏洞" class="headerlink" title="Neo VM的差异和漏洞"></a>Neo VM的差异和漏洞</h2><ul><li>类型转换</li><li>执行引擎的差异</li><li>数学操作的不一致</li><li>VM崩溃</li></ul><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>仓库地址：<a href="https://github.com/fgsect/NeoDiff">https://github.com/fgsect/NeoDiff</a></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git submodule init</span><br><span class="line">git submodule update <span class="comment">## take some time</span></span><br></pre></td></tr></table></figure><p>openethereum经典下不下来，但是git checkout似乎没问题，先看看能不能编译出来</p><h3 id="安装go"><a href="#安装go" class="headerlink" title="安装go"></a>安装go</h3><p>安装go，选择1.16.15，<a href="https://golang.google.cn/dl/">https://golang.google.cn/dl/</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -C /usr/local -xzf go1.16.15.linux-amd64.tar.gz</span><br><span class="line">build go ehtereum</span><br></pre></td></tr></table></figure><p>报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alleysira@LAPTOP-M4HO8L6S:~/NeoDiff$ make -C ./go-ethereum all</span><br><span class="line">make: Entering directory &#x27;/home/alleysira/NeoDiff/go-ethereum&#x27;</span><br><span class="line">env GO111MODULE=on go run build/ci.go install</span><br><span class="line">go: github.com/Azure/azure-pipeline-go@v0.2.2: Get &quot;https://proxy.golang.org/github.com/%21azure/azure-pipeline-go/@v/v0.2.2.mod&quot;: dial tcp 172.217.163.49:443: i/o timeout</span><br><span class="line">make: *** [Makefile:21: all] Error 1</span><br><span class="line">make: Leaving directory &#x27;/home/alleysira/NeoDiff/go-ethereum&#x27;</span><br></pre></td></tr></table></figure><p>挂代理用 <code>source ../proxy</code>,<code>curl www.google.com</code>检查，作用不大，卒</p><p>换国内的代理解决</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go env -w GO111MODULE=on</span><br><span class="line">go env -w  GOPROXY=https://goproxy.cn,direct </span><br></pre></td></tr></table></figure><h3 id="build-openethereum"><a href="#build-openethereum" class="headerlink" title="build openethereum"></a>build openethereum</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --proto &#x27;=https&#x27; --tlsv1.2 -sSf https://sh.rustup.rs | sh</span><br></pre></td></tr></table></figure><p>换ustc的源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ./openethereum/bin/evmbin</span><br><span class="line">cargo build --release</span><br></pre></td></tr></table></figure><p>卡在441/442</p><p><img src="/2023/09/25/NeoDiff/image-20231016212223747.png" alt="image-20231016212223747"></p><h3 id="安装虚拟环境"><a href="#安装虚拟环境" class="headerlink" title="安装虚拟环境"></a>安装虚拟环境</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;Installing reqs for us, creating virtualenv&quot;</span><br><span class="line">virtualenv -p &quot;$(command -v python3)&quot; &quot;$(pwd)/.env&quot;</span><br><span class="line">. .env/bin/activate</span><br><span class="line">pip3 install -r requirements.txt</span><br></pre></td></tr></table></figure><p>轻松愉快</p><h3 id="安装Neo-python的环境"><a href="#安装Neo-python的环境" class="headerlink" title="安装Neo python的环境"></a>安装Neo python的环境</h3><p>本来是轻松加愉快，缺一个leveldb，补上就行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd neo-python</span><br><span class="line">pip install -r requirements.txt</span><br><span class="line">sudo apt-get install libleveldb-dev</span><br></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>在虚拟环境<code>.env</code>中运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">. .env/bin/activate</span><br><span class="line">./utils/EVMrun.sh 1</span><br><span class="line">./utils/EVMscale.sh [proc_count]</span><br></pre></td></tr></table></figure><p><img src="/2023/09/25/NeoDiff/image-20231016215516748.png" alt="image-20231016215516748"></p><p>运行100轮，测试geth和openEthereum查看结果</p><p><img src="/2023/09/25/NeoDiff/image-20231018180131426.png" alt="image-20231018180131426"></p><p>平均运行一轮消耗时间为76/25=3</p><p><img src="/2023/09/25/NeoDiff/image-20231018195339302.png" alt="image-20231018195339302"></p><p>运行了22小时，379轮</p><p><img src="/2023/09/25/NeoDiff/image-20231019162646551.png" alt="image-20231019162646551"></p><p>在utils目录下运行analyse_data.py得到对应的csv文件</p><h1 id="问题和思考"><a href="#问题和思考" class="headerlink" title="问题和思考"></a>问题和思考</h1><ul><li>变异策略生成的合约操作码能够执行的比例占多少</li><li>为什么说Ethereum VM没有类型</li><li>和EVMfuzzer相比，对于不一致性的对比更加细致（不再仅思考输出的不一致性，还考虑了中间过程）</li><li>状态哈希需要研究者手动定义对于diff来说哪些信息重要</li><li>minimization认为最短的序列不一定是最短；代码可能有跳转</li><li>python语义的对比：为什么是和python2 和 3对比，而不是直接比较</li></ul><p>本文定义的变异策略显示coverage已经足够好了</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Uncovering-Smart-Contract-VM-Bugs-Via-Differential-Fuzzing&quot;&gt;&lt;a href=&quot;#Uncovering-Smart-Contract-VM-Bugs-Via-Differential-Fuzzing&quot; class=&quot;headerlink&quot; title=&quot;Uncovering Smart Contract VM Bugs Via Differential Fuzzing&quot;&gt;&lt;/a&gt;Uncovering Smart Contract VM Bugs Via Differential Fuzzing&lt;/h1&gt;&lt;p&gt;Maier D, Fäßler F, Seifert J P. Uncovering Smart Contract VM Bugs Via Differential Fuzzing[C]//Reversing and Offensive-oriented Trends Symposium. 2021: 11-22.&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/categories/Blockchain/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="SmartContract" scheme="https://alleysira.github.io/tags/SmartContract/"/>
    
  </entry>
  
  <entry>
    <title>EVMFuzzer</title>
    <link href="https://alleysira.github.io/2023/09/19/EVMFuzzer/"/>
    <id>https://alleysira.github.io/2023/09/19/EVMFuzzer/</id>
    <published>2023-09-19T08:09:27.000Z</published>
    <updated>2024-01-10T08:23:05.446Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="EVMFuzzer-Detect-EVM-Vulnerabilities-via-Fuzz-Testing"><a href="#EVMFuzzer-Detect-EVM-Vulnerabilities-via-Fuzz-Testing" class="headerlink" title="EVMFuzzer: Detect EVM Vulnerabilities via Fuzz Testing"></a>EVMFuzzer: Detect EVM Vulnerabilities via Fuzz Testing</h1><p>Fu Y, Ren M, Ma F, et al. Evmfuzzer: detect evm vulnerabilities via fuzz testing[C]//Proceedings of the 2019 27th ACM joint meeting on european software engineering conference and symposium on the foundations of software engineering. 2019: 1110-1114.</p><span id="more"></span><p><a href="https://www.youtube.com/watch?v=9Lejgf2GSOk&amp;ab_channel=EVMFuzzer">EVMFuzzer: Detect EVM Vulnerabilities via Fuzz Testing - YouTube</a></p><p>对以太坊合约进行测试的挑战在于测试输入数据的格式以及预言机的存在，EVMFuzzer是第一个采用差分模糊测试技巧检查以太坊漏洞的工具。本文的核心思想是不断生成种子合约并输入给目标EVM和其他测试标准EVM，通过发现尽可能多的执行结果的不一致性，最终发现带有输出交叉引用的漏洞</p><p>给定目标EVM和对应的API，EVMFuzzer通过预定义的mutators生成新的种子合约，采用动态优先级调度算法来指导种子合约选择过程，最大化不一致性。最终EVMFuzzer将其他测试标准EVM作为交叉应用的预言机来避免手动检查</p><p>实验结果：将36295个真实世界的合约作为种子，生成了253153个合约，其中66.3的合约表现出了不同的性能。在4个EVM上发现了若干先前未知的漏洞，其中5个已经作为CVE记录在NVD了</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Oyente和MAIAN采用符号执行来发现智能合约的漏洞，如果EVM本身存在漏洞，会导致严重的后果</p><p>选择了10个通过了Oyente安全检查的合约在EVM上执行，发现了其中7个的gas消耗不一样</p><p>合约层面的验证无法保证以太坊交易执行的正确性，需要保证EVM执行的正确性</p><p>对EVM的测试面临着以下的挑战</p><ul><li>如何定义一般场景测试标准<ul><li>EVM有超过10种不同编程语言的实现</li></ul></li><li>如何生成能够引发bug的测试样例<ul><li>目前没有对EVM进行系统测试的工具</li></ul></li></ul><p>贡献</p><ul><li>给出一种对EVM进行差分模糊测试的评价标准，定义了8个变异器（种子合约生成），设计了动态优先级调度算法</li><li>实现了EVMFuzz，能够自动进行差分模糊测试</li><li>测试了目前广泛使用的EVM，发现了5个CVE</li></ul><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>例子</p><p><img src="/2023/09/19/EVMFuzzer/image-20230920151552188.png" alt="image-20230920151552188"></p><p>这个合约能够通过若干合约测试和验证工具，在不同EVM实现中结果不同，甚至可能会导致dos</p><p>分别在js-evm,py-evm,aleth上进行测试</p><p>aleth会打印执行路径然后一直占有CPU资源，指导系统kill所有进程然后宕机</p><p>aleth不会给出用户有好的反馈或者及时止损或者减少恶意占用的资源，最终导致dos</p><p>这个例子表示一些包含边界条件的合约可能触发EVM实现的边界条件，但是这种合约比较难以构造，因此可以采用差分模糊测试</p><h2 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work"></a>Related work</h2><ul><li>Fuzzing：采用边界数据作为输入来保证程序没有bug<ul><li>主流工具AFL类的，采用多种策略加速fuzzing</li></ul></li><li>Differential Testing：针对预期功能相同的不同实现进行测试，发现不同<ul><li>DLFuzz对深度学习框架进行差分模糊测试</li></ul></li><li>智能合约验证：Oyente从字节码构造控制流图再进行符号执行；Zeus是一个sound的分析器，将智能合约翻译到LLVM中</li></ul><p>EVMFuzzer面向的目标是EVM，其他工作主要关注智能合约</p><h2 id="Approach-Overview"><a href="#Approach-Overview" class="headerlink" title="Approach Overview"></a>Approach Overview</h2><p>Differential fuzz testing is to continuously provide invalid, unexpected or random data as inputs to several programs with the same functions.</p><p>如果发现运行结果不同，可能发现了bug</p><p>种子合约生成模块基于 静态分析</p><p>统一合约执行基于 循环模糊测试</p><p><img src="/2023/09/19/EVMFuzzer/image-20230920154124925.png" alt="image-20230920154124925"></p><h2 id="EVMFuzzer-design"><a href="#EVMFuzzer-design" class="headerlink" title="EVMFuzzer design"></a>EVMFuzzer design</h2><p>主要包含 种子合约生成模块和EVM执行模块，种子合约生成模块会不断生成高质量的种子，力图扩大不同EVM执行结果之间的区别。EVM执行模块会为目标EVM和其他测试标准EVM创建统一的执行环境</p><p><img src="/2023/09/19/EVMFuzzer/image-20230919164625085.png" alt="image-20230919164625085"></p><h3 id="种子合约生成"><a href="#种子合约生成" class="headerlink" title="种子合约生成"></a>种子合约生成</h3><p>输入合约，输出关键性质改变后的合约</p><ul><li>构造种子合约的重要位置标识的CAST抽象语法树，辅助后续的变异和分析</li><li>将seed合约放入池中</li><li>EVMFuzz对合约进行评估，排列为带有优先队列，对优先级进行动态调整</li><li>选择排在第一的合约，利用8个（arxiv）预定义的变异器和组合策略来指导变异并获得EVM的输入</li></ul><p>测试用例生成器</p><p>seed合约存储在seed pool中，EVMFuzzer根据动态优先级对候选合约进行排序，首位的合约会被选中进行变异，采用8个预定的编译器和组合策略进行变异</p><ul><li>种子变异：从3个细粒度（word char statement）设计了8个编译器，维护基于度量差异的优先级队列；如果度量差异增加，对应的变异器的权重按降序排列加入到队列中，否则不会更新队列</li><li>种子优先级和选择：为了保证多样性，其他优先级低的合约同样需要有一定的概率被选中，因此采用动态优先级调度算法维护一个候选队列，每个合约有初始的权限，随着等待时间增加</li></ul><h3 id="指标的公式"><a href="#指标的公式" class="headerlink" title="指标的公式"></a>指标的公式</h3><p>EVM作为基于交易的状态机，状态的改变基于操作码和输入的参数以及gas限制</p><ul><li>操作码序列：表示了程序的执行过程，能用于检查执行的正确性 $opSeqLen(i,C)$，i表示平台，执行合约C</li><li>消耗的gas：一个交易或一条消息中消耗的gas总量，直接和交易的执行费相关联，$gsdUsed(i,C)$</li></ul><p>根据两个指标，定义了差异信息的评估指标dif f，值越大表示产生不一致执行结果的概率越大 $output(i,C)$表示执行输出，对于函数调用是返回值；对于交易是balance</p><p>两个指标反应了实现和执行的差距，执行输出反应了EVM运行的正确性和一致性</p><h3 id="CAST的构造"><a href="#CAST的构造" class="headerlink" title="CAST的构造"></a>CAST的构造</h3><p>模糊测试之前，首先执行静态分析，生成CAST</p><p>智能合约的CAST是对Solidity源代码的抽象语法结构的结构化树形表示，树上的每个节点表示源码中出现的结构，CAST定义并分解了所有语句中的性质，分解成CAST方便进行变异，能够根据关键属性直接进行搜索、替代、删除或者插入操作符</p><p>CAST将种子合约的关键位置表示出来（和ehter交易相关的子树），主要包含6个语句符号 new, call , delegatecall , callcode, send and transfer</p><p>变异器主要作用于这些关键位置来测试EVM的核心功能，阴影部分就是重要的位置</p><p><img src="/2023/09/19/EVMFuzzer/image-20230920164427662.png" alt="image-20230920164427662"></p><h3 id="种子合约优先级"><a href="#种子合约优先级" class="headerlink" title="种子合约优先级"></a>种子合约优先级</h3><p>候选合约的重要性不同，使得合约之间指标差异增加的合约应当作为下一轮变异迭代的标准</p><p>同时，为了保证多样性，其他合约应该有一定概率被选中。因此采用动态优先级分配算法来维护一个候选队列，每个合约有初始的优先级，随着等待时间增加，值会增加</p><p><img src="/2023/09/19/EVMFuzzer/image-20230920170033059.png" alt="image-20230920170033059"></p><p>看看伪代码，指标差异优先级初始值为0-10，优先级等于=差异加上时间优先级，根据优先级进行降序排序</p><p>选中优先级最高的作为下一轮变异的合约，输出，对剩余合约的time_pri 加1</p><h3 id="种子合约的变异"><a href="#种子合约的变异" class="headerlink" title="种子合约的变异"></a>种子合约的变异</h3><p>为了生成高质量的种子合约，能够在不同的EVM中触发更多的不一致性</p><p>根据伪代码，首先生成CAST，根据上次迭代的差异信息更新每个变异器（做排序）</p><p><img src="/2023/09/19/EVMFuzzer/image-20230920171115727.png" alt="image-20230920171115727"></p><p>选择组合策略（输入）来变异候选种子合约，最后利用 <a href="https://www.npmjs.com/package/soltar">soltar - npm (npmjs.com)</a> 从CAST中重建代码，输出变异后的代码</p><ul><li>典型的变异器：需要保证被修改合约的语义正确性保证能够正确生成代码，根据合约的逻辑设计了8个变异器<ul><li><img src="/2023/09/19/EVMFuzzer/image-20230920182840510.png" alt="image-20230920182840510"><ul><li>对于方法内的本地变量，修改变量的类型</li><li>对于函数修改对应的属性<ul><li>实际代码实现是修改可见性，可能导致类似的问题：一个函数同时为public和private，已修正</li></ul></li><li>修改算术运算符<ul><li>实际的代码实现没有对当前运算符是否有效（运算符可能出现在注释里面）</li></ul></li><li>修改条件判断语句内的运算符</li><li>修改循环内的边界条件</li><li>对函数内的语句增加assert或者删去assert</li><li>删除函数的return</li><li>对于方法的控制流增加break或者continue</li></ul></li></ul></li><li>变异器选择：同样给这些变异器优先级，根据返回的dif进行调整权重，如果变异后差异变大，将变异器的id加入到队列中，降序排列<ul><li>除了权重更新外，还定义了组合策略，来增加随机性和多样性<ul><li>组合索引为奇数的变异器</li><li>组合索引为偶数的变异器</li><li>组合第一个和最后一个变异器</li><li>不带权重随机选一个变异器</li><li>每轮在上面的策略中随机选一个</li></ul></li></ul></li></ul><h3 id="统一的EVM执行"><a href="#统一的EVM执行" class="headerlink" title="统一的EVM执行"></a>统一的EVM执行</h3><p>为多个EVM提供统一的运行时环境，收到种子合约后编译为字节码，参数根据被调用函数的参数类型生成</p><ul><li><p>solc −bin −runtime xx.sol</p></li><li><p>对于每个数据类型，预先定义了一些常见的或者极端值，生成时随机选取</p></li></ul><p>之后调用每个EVM的执行接口自动在所有EVM上执行，将输出结果标准化后，根据测试指标计算差异信息，比较执行输出结果。</p><p>根据种子提高指标差异的程度，决定是否将种子放入seed pool中（保存了高质量的合约），该模块会记录潜在的异常，为了后续进行手工的问题根源分析</p><h3 id="种子合约选择"><a href="#种子合约选择" class="headerlink" title="种子合约选择"></a>种子合约选择</h3><p>dif的意义是为了评估生成的种子合约的质量，定义如下</p><p><img src="/2023/09/19/EVMFuzzer/image-20230920194726395.png" alt="image-20230920194726395"></p><p>看看伪代码</p><p>diff最大值为10，值进行标准化，时间优先级置0，更新flag</p><p><img src="/2023/09/19/EVMFuzzer/image-20230920200434697.png" alt="image-20230920200434697"></p><h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><p>回答的问题</p><ul><li>EVM之间是否存在不一致性<ul><li>gas消耗的不一致性<ul><li><img src="/2023/09/19/EVMFuzzer/image-20230920202213767.png" alt="image-20230920202213767"></li><li>原因：以太坊黄皮书未定义某些特定opcode的gas消耗，如MSOTRE,SLOAD等；采用的退款机制不同</li><li>将gas消耗的平均值作为基准，js-evm 好</li><li><img src="/2023/09/19/EVMFuzzer/image-20230920202945965.png" alt="image-20230920202945965"></li></ul></li><li>opcode的不一致性：仅1,275合约能同时在4个EVM上运行并返回相同结果，字节码长度不同<ul><li>原因可能是EVM进行了优化</li><li><img src="/2023/09/19/EVMFuzzer/image-20230920203426230.png" alt="image-20230920203426230"></li><li>结果可以看到aleth和geth保持一致，js-evm更小（某种程度上减轻了EVM的开销，但是这种开销减少的代价可能是丧失了鲁棒性）</li><li><img src="/2023/09/19/EVMFuzzer/image-20230920204613634.png" alt="image-20230920204613634"></li></ul></li></ul></li><li>EVMFuzz是否能高效地生成高质量的种子合约<ul><li>狠狠跑了3天，生成了25 3153份不同的合约，66.2%的合约成功出发了不一致性（因为包含了gas不一致，水分比较大）Ind.1是除此之外都crash，Ind.2是除此之外都不crash</li><li><img src="/2023/09/19/EVMFuzzer/image-20230920204015260.png" alt="image-20230920204015260"></li><li>为了说明变异器的质量，找了个复杂的合约进行了测试，记录每轮的weight变化</li><li>单独使用一种变异器的速度，evencomb最快但没跳出局部最优解，总体上comball效果最好，完全随机效果最差<ul><li><img src="/2023/09/19/EVMFuzzer/image-20230920204702036.png" alt="image-20230920204702036"></li></ul></li><li>详细分析CombAll来研究不同变异器的权重和作用，0.125作为基准</li><li><img src="/2023/09/19/EVMFuzzer/image-20230920204957741.png" alt="image-20230920204957741"></li><li><img src="/2023/09/19/EVMFuzzer/image-20230920205443157.png" alt="image-20230920205443157"></li></ul></li><li>是否能通过EVMFuzz发现EVM的漏洞<ul><li>需要手工分析，发现了5个CVE（现有的CVE中与EVM相关的有6个，智能合约的500个，总数为112913）</li><li><img src="/2023/09/19/EVMFuzzer/image-20230920205747171.png" alt="image-20230920205747171"></li></ul></li></ul><p>合约部署在以太坊上，分析了合约的行数，函数，相关的操作码和特定的操作码，其中超过6500份合约有超过500行代码，90个超过2000行，表明目标合约比较复杂</p><h2 id="Using-EVMFuzzer"><a href="#Using-EVMFuzzer" class="headerlink" title="Using EVMFuzzer"></a>Using EVMFuzzer</h2><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><img src="/2023/09/19/EVMFuzzer/image-20230919172850242.png" alt="image-20230919172850242"></p><p>后端集成了4个广泛使用的EVM作为基准</p><ul><li>ethereumjs-vm v2.4.0</li><li>py-evm v0.2.0-alpha.31</li><li>aleth v1.5.0-alpha.6</li><li>geth v1.8.13</li></ul><p>合约compiler solc 0.4.24版本</p><h3 id="运行的例子"><a href="#运行的例子" class="headerlink" title="运行的例子"></a>运行的例子</h3><p>用户提供EVM的源码/可执行文件和API，论文中的target EVM是加强版的js-EVM（之前她的B会的工作）</p><p>报告从3个维度来评价这个EVM</p><ul><li>代码实现完整性</li><li>gas计算的准确性</li><li>执行路径规划的合理性</li></ul><p><img src="/2023/09/19/EVMFuzzer/image-20230919174027003.png" alt="image-20230919174027003"></p><h2 id="Preliminary-Evaluation"><a href="#Preliminary-Evaluation" class="headerlink" title="Preliminary Evaluation"></a>Preliminary Evaluation</h2><p>初始的seed合约是36295个，实验在笔记本上跑的</p><p>根据2类内部测试指标（消耗的gas和操作码序列），发现了大量的不一致</p><p>33,424/36,295合约的操作码序列是正确的，用于进行gas的对比（排除了不同操作码带来的gas差异）</p><p>每个平台约50%的gas消耗都和其他平台不一样，aleth甚至达到90%</p><p><img src="/2023/09/19/EVMFuzzer/image-20230919190818271.png" alt="image-20230919190818271"></p><p>1275个合约成功在4个EVM上执行，返回了相同的输出但是序列的长度不同</p><p><img src="/2023/09/19/EVMFuzzer/image-20230919191002754.png" alt="image-20230919191002754"></p><p>aleth和geth的相同，作为baseline，js-evm的长度始终短于baseline，py-evm的长度高于baseline</p><p>可以推断出：EVM的执行和实现存在不一致，可以利用<code>gasUsed</code>和操作码序列指示器的度量差异来引导合约的生成，从而导致潜在的执行输出的不一致</p><p>发现的漏洞：发现了不一致后需要手工进行分析，探索根源，查看了EVM的实现，发现了5个CVE</p><p><img src="/2023/09/19/EVMFuzzer/image-20230919191848784.png" alt="image-20230919191848784"></p><p>其中一个针对geth的CVE，稳定触发 执行时段错误，原因在于异常处理程序没有处理所有边界情况</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>提出了第一个对EVM实现的差分模糊测试的工具，给出了两个度量标准（gas和opcode sequence），在生成的253,153个合约的执行中，超过一半的合约表现出了差异</p><p>未来工作：设计更通用的mutator，对更多EVM的安全性进行评估</p><ul><li>设计更多的变异器：目前仅在AST层面修改关键部分，后续可以在源码层次层架函数调用，合约继承等</li><li>更高效的优先级处理：目前是用堆实现的优先队列，插入删除的复杂度是$\Theta(logn)$，排序的复杂度是$\Theta(nlogn)$，可以有其他的思路，比如搞成系数</li><li>支持更多EVM的实现</li><li>更精确的选择标准：gas和opcode之间可以加系数，gas可能没有那么重要</li></ul><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>尝试配一下</p><p>安装solc-select，配置环境变量，source一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pip3 install solc-select</span><br><span class="line">sudo nano ~/.bashrc</span><br><span class="line">//add this line</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;/home/alleysira/.local/bin:<span class="variable">$PATH</span>&quot;</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line">solc-select install 0.4.24</span><br><span class="line">solc-select use 0.4.24</span><br></pre></td></tr></table></figure><p>配置wsl代理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/resolv.conf</span><br><span class="line">export ALL_PROXY=&quot;http://172.20.80.1:7890&quot;</span><br></pre></td></tr></table></figure><p>安装ethereum</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install software-properties-common</span><br><span class="line">sudo add-apt-repository -y ppa:ethereum/ethereum</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install ethereum #network issue</span><br></pre></td></tr></table></figure><p>补充安装numpy</p><p>pip3 install eth_utils</p><p>每日一乐</p><p><img src="/2023/09/19/EVMFuzzer/image-20230921200746505.png" alt="image-20230921200746505"></p><p>修改一下node的路径jsevm就可以运行了，修改为/usr/bin/node</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p><code>python -m virtualenv env</code> 在当前目录下创建一个名为 “env” 的虚拟环境</p><p><img src="/2023/09/19/EVMFuzzer/image-20231016192446379.png" alt="image-20231016192446379"></p><p>执行 <code>source env/bin/activate</code></p><p><img src="/2023/09/19/EVMFuzzer/image-20231016192501740.png" alt="image-20231016192501740"></p><p>在虚拟环境env中调用EVMFuzzer</p><p><img src="/2023/09/19/EVMFuzzer/image-20231016192632283.png" alt="image-20231016192632283"></p><p>选择当前执行10轮</p><p><img src="/2023/09/19/EVMFuzzer/image-20230921203024645.png" alt="image-20230921203024645"></p><p><img src="/2023/09/19/EVMFuzzer/image-20230921201837081.png" alt="image-20230921201837081"></p><p>会给出当前轮选择的变异策略，以及采用的变异器</p><p>10轮测试耗时约250s，生成了20个种子合约</p><p><img src="/2023/09/19/EVMFuzzer/image-20230921202131725.png" alt="image-20230921202131725"></p><p>第79轮产生了不一致</p><p><img src="/2023/09/19/EVMFuzzer/image-20231018171322281.png" alt="image-20231018171322281"></p><p><img src="/2023/09/19/EVMFuzzer/image-20231018171336978.png" alt="image-20231018171336978"></p><p><img src="/2023/09/19/EVMFuzzer/image-20231018171526617.png" alt="image-20231018171526617"></p><p>实验结束后<code>deactivate</code>虚拟环境</p><p>测试100轮，时间为2494s，时间为线性</p><p><img src="/2023/09/19/EVMFuzzer/image-20231018175507578.png" alt="image-20231018175507578"></p><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><ul><li><p>SB Curated: A Curated Dataset of Vulnerable Solidity Smart Contracts</p><ul><li><a href="https://github.com/smartbugs/smartbugs-curated">https://github.com/smartbugs/smartbugs-curated</a></li><li>根据 <a href="https://dasp.co/"><strong>DASP</strong> 2018</a>（遗憾的是已经不再维护）前top 10的漏洞类型进行划分，包括143个.sol文件</li><li>包括重入漏洞 访问控制 算术漏洞 call Dos 随机性 front running 时间戳 短地址 unknown</li><li>Smartbugs 项目的Samples文件夹下有10个样例合约</li></ul></li><li><p>Smartbugs测试时采用的数据集，包括47,587个合约，47398个.sol文件</p><ul><li>69个带注释的合约</li><li>47,518个以太坊上下载的合约</li></ul></li><li><p>SolidiFI Benchmark，7类1700个合约</p><ul><li><a href="https://github.com/DependableSystemsLab/SolidiFI-benchmark">https://github.com/DependableSystemsLab/SolidiFI-benchmark</a></li></ul></li><li><p>爬Etherscan</p><ul><li><a href="https://docs.etherscan.io/api-endpoints/contracts">https://docs.etherscan.io/api-endpoints/contracts</a></li></ul></li></ul><h2 id="学习代码"><a href="#学习代码" class="headerlink" title="学习代码"></a>学习代码</h2><h3 id="Run-py"><a href="#Run-py" class="headerlink" title="Run.py"></a>Run.py</h3><p>每次运行清除TestOut文件夹</p><p>支持分析的合约函数的参数类型仅支持<code>bool uint int address</code>，不支持数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inputData = generate_input.make(dataList) </span><br></pre></td></tr></table></figure><p>将smartbugs的samples文件夹下的所有.sol文件作为输入，执行后发现很多合约的参数类型不满足条件，因此无法生成对应参数，无法运行合约</p><p>尝试扩展到支持string，把array简化为同类型的一个变量</p><p><img src="/2023/09/19/EVMFuzzer/image-20231101171439238.png" alt="image-20231101171439238"></p><p>对于array，尝试手动构造一个</p><p>生成函数签名是用solc编译合约的方法实现的，能够输出函数签名</p><p><img src="/2023/09/19/EVMFuzzer/image-20231020141102264.png" alt="image-20231020141102264"></p><p><code>generate_input.py</code>的<code>make()</code>负责根据参数列表生成参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make</span>(<span class="params">dataList</span>):</span></span><br><span class="line">    ret = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> _, val <span class="keyword">in</span> <span class="built_in">enumerate</span>(dataList) : </span><br><span class="line">        <span class="keyword">if</span> (val.find(<span class="string">&quot;uint&quot;</span>) != -<span class="number">1</span>) <span class="keyword">or</span> (val.find(<span class="string">&quot;int&quot;</span>) != -<span class="number">1</span>) :</span><br><span class="line">            ls1 = <span class="built_in">list</span>(np.random.randint(<span class="number">0</span>, <span class="number">100</span>, size=<span class="number">1</span>))</span><br><span class="line">            ls2 = [<span class="built_in">hex</span>(i)[<span class="number">2</span>:] <span class="keyword">for</span> i <span class="keyword">in</span> ls1]</span><br><span class="line">            uint_str = <span class="string">&#x27;&#x27;</span>.join(ls2)</span><br><span class="line">            full_str = uint_str.zfill(<span class="number">64</span>) <span class="comment"># 不足用0补</span></span><br><span class="line">            ret += full_str</span><br><span class="line">        <span class="keyword">elif</span> val.find(<span class="string">&quot;bool&quot;</span>) != -<span class="number">1</span>:</span><br><span class="line">            ls1 = <span class="built_in">list</span>(np.random.randint(<span class="number">0</span>, <span class="number">2</span>, size=<span class="number">1</span>))</span><br><span class="line">            ls2 = [<span class="built_in">hex</span>(i)[<span class="number">2</span>:] <span class="keyword">for</span> i <span class="keyword">in</span> ls1]</span><br><span class="line">            bool_str = <span class="string">&#x27;&#x27;</span>.join(ls2)</span><br><span class="line">            full_str = bool_str.zfill(<span class="number">64</span>)</span><br><span class="line">            ret += full_str</span><br><span class="line">        <span class="keyword">elif</span> val.find(<span class="string">&quot;address&quot;</span>) != -<span class="number">1</span>:</span><br><span class="line">            ls1 = <span class="built_in">list</span>(np.random.randint(<span class="number">0</span>, <span class="number">16</span>, size=<span class="number">40</span>))</span><br><span class="line">            ls2 = [<span class="built_in">hex</span>(i)[<span class="number">2</span>:] <span class="keyword">for</span> i <span class="keyword">in</span> ls1]</span><br><span class="line">            addr_str = <span class="string">&#x27;&#x27;</span>.join(ls2)</span><br><span class="line">            full_str = addr_str.zfill(<span class="number">64</span>)</span><br><span class="line">            ret += full_str</span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><ul><li>生成uint和int类型的参数时，没有考虑具体的参数长度，如uint256和int64是不同的数据范围，简化为<ul><li>生成0-100的数</li><li>转16进制</li><li>zfill补为64长</li><li>可以考虑具体读uint256 64 128 再生成对应长度的参数</li></ul></li><li>生成address和bool完全可以简化为直接生成16进制字符串</li></ul><p>Input data=函数签名+生成的参数，有效位数太小，修改可能精度可以提高触发率</p><p>4类变异策略</p><h3 id="update-weight"><a href="#update-weight" class="headerlink" title="update_weight()"></a>update_weight()</h3><p><code>update_weight()</code>函数根据上一轮每个变异器造成的差异生成权重，排序后根据传入的变异策略决定当前轮的变异器列表choice</p><p><code>mutators_weight.py</code>根据输入的策略对种子合约进行变异</p><p><img src="/2023/09/19/EVMFuzzer/image-20231019184748514.png" alt="image-20231019184748514"></p><p>发现缩进的代码的问题，但实际执行没有出现报错？（已解决）</p><p>解决jsevm调用后，发现确实存在问题，见cnt=0</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weight, choice = update_weight(dirPATH, <span class="string">&quot;mutator_diff&quot;</span>, select) <span class="comment"># combined strategy</span></span><br></pre></td></tr></table></figure><p>Run.py中cnt仅出现3次</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(diff_list)):</span><br><span class="line">        cnt += <span class="built_in">int</span>(diff_list[i])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(diff_list)):</span><br><span class="line">        weight[i+<span class="number">1</span>] = <span class="built_in">float</span>(<span class="built_in">int</span>(diff_list[i]) / cnt)</span><br></pre></td></tr></table></figure><p>修改代码逻辑，为cnt=0时，权重定义为1/8</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">weight = &#123;&#125;  <span class="comment"># an empty dict</span></span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(diff_list)):</span><br><span class="line">    cnt += <span class="built_in">int</span>(diff_list[i])</span><br><span class="line"><span class="keyword">if</span> cnt!=<span class="number">0</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(diff_list)):</span><br><span class="line">        weight[i+<span class="number">1</span>] = <span class="built_in">float</span>(<span class="built_in">int</span>(diff_list[i]) / cnt)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(diff_list)):</span><br><span class="line">        weight[i+<span class="number">1</span>] = <span class="number">1</span> / <span class="number">8</span></span><br></pre></td></tr></table></figure><h3 id="mutators-weight-py"><a href="#mutators-weight-py" class="headerlink" title="mutators_weight.py"></a>mutators_weight.py</h3><p>逻辑实现错误，当合约中函数已经有可见性修饰时，工具的实现是在修饰符后再加一个修饰符，显然会导致编译错误，没有任何意义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># have other modifiers</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    modifier = line[start_pos + <span class="number">2</span>:end_pos]</span><br><span class="line">    <span class="keyword">if</span> modifier.find(property_[num - <span class="number">1</span>]) == -<span class="number">1</span>:</span><br><span class="line">        str_list = <span class="built_in">list</span>(line)</span><br><span class="line">        str_list.insert(start_pos + <span class="number">2</span>, property_[num - <span class="number">1</span>] + <span class="string">&quot; &quot;</span>)</span><br><span class="line">        content = <span class="string">&quot;&quot;</span>.join(str_list)</span><br><span class="line">f2.write(content)</span><br><span class="line">it += <span class="number">1</span></span><br><span class="line"><span class="comment"># revised version</span></span><br><span class="line"> <span class="keyword">else</span>:</span><br><span class="line">    modifier = line[start_pos + <span class="number">2</span>:end_pos]</span><br><span class="line">    <span class="comment"># print(&quot;modifier&quot;,modifier)</span></span><br><span class="line">    <span class="keyword">if</span> modifier.find(property_[num - <span class="number">1</span>]) == -<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(property_)):</span><br><span class="line">            <span class="keyword">if</span> modifier.find(property_[(num - <span class="number">1</span>+i)%<span class="built_in">len</span>(property_)])!=-<span class="number">1</span>:</span><br><span class="line">                mod_start = modifier.find(property_[(num - <span class="number">1</span>+i)%<span class="built_in">len</span>(property_)]) + start_pos + <span class="number">2</span></span><br><span class="line">                mod_end = mod_start + <span class="built_in">len</span>(property_[(num - <span class="number">1</span>+i)%<span class="built_in">len</span>(property_)])</span><br><span class="line">                <span class="comment"># print(mod_start,mod_end)</span></span><br><span class="line">                str_list = <span class="built_in">list</span>(line)</span><br><span class="line">                <span class="comment"># print(&quot;&quot;.join(str_list))</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># print(&quot;del part&quot;,str_list[mod_start:mod_end])</span></span><br><span class="line">                <span class="keyword">del</span> str_list[mod_start:mod_end]</span><br><span class="line">                </span><br><span class="line">                str_list.insert(mod_start, property_[num - <span class="number">1</span>])</span><br><span class="line">                <span class="comment"># print(&quot;&quot;.join(str_list))</span></span><br><span class="line">                content = <span class="string">&quot;&quot;</span>.join(str_list)</span><br><span class="line">                <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h3 id="TestOut-dir"><a href="#TestOut-dir" class="headerlink" title="/TestOut dir"></a>/TestOut dir</h3><p>TestOut/contract1 中</p><ul><li><p>/bincode是solc —bin-runtime编译出的，形式为 bincode_funName_index，index是当前轮数</p></li><li><p>/seed是变异后的种子合约</p></li><li>/output文件夹记录了所有虚拟机执行后的输出，包括pc，op，gas，gasprice和栈</li><li><p>mutator_diff记录当前轮变异器是否产生了diff，8行</p></li><li><p>newdiff记录当前轮总的diff</p></li><li><p>diffHis记录了变异器的权重变化的历史</p></li><li>Mycontract.signatures 是函数签名（哈希值，函数名，参数类型）</li><li>result.json记录了具体是jsevm cppevm pyevm在opcode和gas出现的不一致以及对应不一致的输出，相关的交易数据</li></ul><p>以下是与4个虚拟机交互的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">retcode = subprocess.call(<span class="string">&quot;/usr/bin/node &quot;</span> + PROJECT_DIR + <span class="string">&quot;/benchmarkEVMs/jsEVM/js_runcode.js --code &quot;</span> + bincode + <span class="string">&quot; --sig &quot;</span> + sigName + <span class="string">&quot; &gt; &quot;</span> + outputPATH + <span class="string">&quot;jsout.json&quot;</span>,shell=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">retcode = subprocess.call(<span class="string">&quot;python3 &quot;</span> + PROJECT_DIR + <span class="string">&quot;/benchmarkEVMs/py-evm/test_tx.py --data &quot;</span> + bincode + <span class="string">&quot; --sig &quot;</span> + sigName + <span class="string">&quot; &gt; &quot;</span> + outputPATH + <span class="string">&quot;pyout.json&quot;</span>,shell=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">retcode = subprocess.call(<span class="string">&quot;./benchmarkEVMs/evm --debug --json --code &quot;</span> + bincode + <span class="string">&quot; --input &quot;</span> + sigName[<span class="number">2</span>:] + <span class="string">&quot; run &gt; &quot;</span> + outputPATH + <span class="string">&quot;gethout.json&quot;</span>, shell=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># aleth 比较复杂</span></span><br><span class="line">retcode = subprocess.call(<span class="string">&quot;./benchmarkEVMs/aleth-vm trace --code &quot;</span> + bincode + <span class="string">&quot; --mnemonics --input &quot;</span> + sigName + <span class="string">&quot; &gt; &quot;</span> + outputPATH + <span class="string">&quot;aletraceout&quot;</span>,shell=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">retcode = subprocess.call(<span class="string">&quot;python3 &quot;</span> + PROJECT_DIR + <span class="string">&quot;/utils/cpp_convert_json_1.py &quot;</span> + outputPATH + <span class="string">&quot;aletraceout &quot;</span> + <span class="string">&quot; &gt; &quot;</span> + outputPATH + <span class="string">&quot;alethout.json&quot;</span>,shell=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># aleth output</span></span><br><span class="line">retcode = subprocess.call(<span class="string">&quot;./benchmarkEVMs/aleth-vm stats --code &quot;</span> + bincode + <span class="string">&quot; --mnemonics --input &quot;</span> + sigName + <span class="string">&quot; &gt; &quot;</span> + outputPATH + <span class="string">&quot;aleresultout&quot;</span>,shell=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">retcode = subprocess.call(<span class="string">&quot;python3 &quot;</span> + PROJECT_DIR + <span class="string">&quot;/utils/cpp_convert_json_2.py &quot;</span> + outputPATH + <span class="string">&quot;aleresultout &quot;</span> + <span class="string">&quot; &gt;&gt; &quot;</span> + outputPATH + <span class="string">&quot;alethout.json&quot;</span>,shell=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/node js_runcode.js --code 0xyyyy --sig 0xyyyy &gt; jsout.json</span><br><span class="line">python3 test_tx.py --data 0xyyyy --sig 0xyyyy &gt; pyout.json</span><br><span class="line">./evm --debug --json --code 0xyyyy --input yyyy run &gt; gethout.json</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> pyevm call</span></span><br><span class="line">python3 /home/alleysira/EVMFuzzer/benchmarkEVMs/py-evm/test_tx.py --data 608060405260043610610062576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680634ddd108a1461006757806387f71cef14610092578063890eba68146100dd578063aa237e211461010c575b600080fd5b34801561007357600080fd5b5061007c610145565b6040518082815260200191505060405180910390f35b34801561009e57600080fd5b506100c7600480360381019080803590602001909291908035906020019092919050505061014b565b6040518082815260200191505060405180910390f35b3480156100e957600080fd5b506100f261024f565b604051808215151515815260200191505060405180910390f35b34801561011857600080fd5b5061014360048036038101908080351515906020019092919080359060200190929190505050610261565b005b60015481565b6000806000806000806000806000806000808c8e111561017d578c8e019950899850888a1415151561017957fe5b889a505b8c8e101561019b578c8e0397506000881015151561019757fe5b879a505b8c8e14156101c557600096505b600a8710156101c1578c8e019d508660010196506101a8565b8d9a505b8c8e1015156101e7578c8e029550601494508486141515156101e357fe5b859a505b8c8e111515610214578c8e8115156101fb57fe5b049350600184039250600a8311151561021057fe5b829a505b8c8e14151561023b578c8e1115610230578c91508d9050610237565b8d91508c90505b819a505b8a9b50505050505050505050505092915050565b6000809054906101000a900460ff1681565b816000806101000a81548160ff0219169083151502179055508060018190555050505600a165627a7a7230582036c5562a74060217554d53de9758f565aa5aae303e48c5027a8fb554aba828dc0029 --sig 0x87f71cef00000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000043</span><br></pre></td></tr></table></figure><h3 id="utils-cmp-js"><a href="#utils-cmp-js" class="headerlink" title="/utils/cmp.js"></a>/utils/cmp.js</h3><p>cmp.js负责实现比较json文件中实验结果的逻辑，result.json记录了不同虚拟机执行相同交易后对比的结果</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//result.json</span></span><br><span class="line">&#123;<span class="attr">&quot;error&quot;</span>:<span class="string">&quot;js&amp;py_output+gas&quot;</span>,<span class="attr">&quot;js_output&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="attr">&quot;py_output&quot;</span>:<span class="string">&quot;0000000000000000000000000000000000000000000000000000000000000022&quot;</span>,<span class="attr">&quot;js_gasUsed&quot;</span>:<span class="string">&quot;0x2e&quot;</span>,<span class="attr">&quot;py_gasUsed&quot;</span>:<span class="string">&quot;0x2d9&quot;</span>,<span class="attr">&quot;txdata&quot;</span>:<span class="string">&quot;0x87f71cef0000000000000000000000000000000000000000000000000000000000000022000000000000000000000000000000000000000000000000000000000000003e&quot;</span>&#125; </span><br></pre></td></tr></table></figure><p>从输出来看，只比较了三个cpp/aleth jsevm 和pyevm的输出</p><p>计算newdiff，newdiff文件的数字是totalDiff，totalDiff=opcodediff+gasusedDiff</p><p>opcodediff是三个虚拟机行数差的绝对值</p><p>gasusedDiff是三个.json文件最后一行的gasused字段差的绝对值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">opcodeDiff=<span class="built_in">Math</span>.abs(js_file_data.length-cpp_file_data.length)+</span><br><span class="line">    <span class="built_in">Math</span>.abs(js_file_data.length-py_file_data.length)+</span><br><span class="line">    <span class="built_in">Math</span>.abs(py_file_data.length-cpp_file_data.length)</span><br></pre></td></tr></table></figure><p>代码里没有实现geth和cpp py js虚拟机对比的代码</p><p>实现geth和js对比的函数<code>js_geth_cmp</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gethout.json</span></span><br><span class="line">&#123;<span class="attr">&quot;pc&quot;</span>:<span class="number">2</span>,<span class="attr">&quot;op&quot;</span>:<span class="number">96</span>,<span class="attr">&quot;gas&quot;</span>:<span class="string">&quot;0x2540be3fd&quot;</span>,<span class="attr">&quot;gasCost&quot;</span>:<span class="string">&quot;0x0&quot;</span>,<span class="attr">&quot;memory&quot;</span>:<span class="string">&quot;0x&quot;</span>,<span class="attr">&quot;memSize&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;stack&quot;</span>:[<span class="string">&quot;0x80&quot;</span>],<span class="attr">&quot;depth&quot;</span>:<span class="number">1</span>,<span class="attr">&quot;refund&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;opName&quot;</span>:<span class="string">&quot;PUSH1&quot;</span>,<span class="attr">&quot;error&quot;</span>:<span class="string">&quot;&quot;</span>&#125;</span><br><span class="line"><span class="comment">//jsout.json</span></span><br><span class="line">&#123;<span class="attr">&quot;pc&quot;</span>:<span class="number">4</span>,<span class="attr">&quot;op&quot;</span>:<span class="number">82</span>,<span class="attr">&quot;gas&quot;</span>:<span class="string">&quot;0xfffffff9&quot;</span>,<span class="attr">&quot;gasCost&quot;</span>:<span class="string">&quot;0x3&quot;</span>,<span class="attr">&quot;stack&quot;</span>:[<span class="string">&quot;0x80&quot;</span>,<span class="string">&quot;0x40&quot;</span>],<span class="attr">&quot;depth&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;opName&quot;</span>:<span class="string">&quot;MSTORE&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>逻辑混乱，前面用的是gasused（即所有gas\timesgasCost，后面仅比较gasCost）</p><h2 id="代码问题总结"><a href="#代码问题总结" class="headerlink" title="代码问题总结"></a>代码问题总结</h2><h3 id="jsevm错误调用，已解决"><a href="#jsevm错误调用，已解决" class="headerlink" title="jsevm错误调用，已解决"></a>jsevm错误调用，已解决</h3><p>实验结果中newdiff文件发现有50000个不同，回溯数据，发现result.json有490条不同，不同的原因是js-evm仅能执行12条指令，其他3个虚拟机都能执行111个合约</p><p><img src="/2023/09/19/EVMFuzzer/image-20231026172846459.png" alt="image-20231026172846459"></p><p>jsout.json的行数远远小于其他两个虚拟机的输出长度</p><p>代码写的有问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">retcode = subprocess.call(<span class="string">&quot;/usr/bin/node &quot;</span> + PROJECT_DIR + <span class="string">&quot;/benchmarkEVMs/jsEVM/js_runcode.js --code &quot;</span> + bincode + <span class="string">&quot; --sig &quot;</span> + sigName + <span class="string">&quot; &gt; &quot;</span> + outputPATH + <span class="string">&quot;jsout.json&quot;</span>, shell=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># shell中直接调用jsevm</span></span><br><span class="line">node benchmarkEVMs/jsEVM/js_runcode.js --code 608060405260043610610062576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680634ddd108a1461006757806387f71cef14610092578063890eba68146100dd578063aa237e211461010c575b600080fd5b34801561007357600080fd5b5061007c610145565b6040518082815260200191505060405180910390f35b34801561009e57600080fd5b506100c7600480360381019080803590602001909291908035906020019092919050505061014b565b6040518082815260200191505060405180910390f35b3480156100e957600080fd5b506100f261024f565b604051808215151515815260200191505060405180910390f35b34801561011857600080fd5b5061014360048036038101908080351515906020019092919080359060200190929190505050610261565b005b60015481565b6000806000806000806000806000806000808c8e111561017d578c8e019950899850888a1415151561017957fe5b889a505b8c8e101561019b578c8e0397506000881015151561019757fe5b879a505b8c8e14156101c557600096505b600a8710156101c1578c8e019d508660010196506101a8565b8d9a505b8c8e1015156101e7578c8e029550601494508486141515156101e357fe5b859a505b8c8e111515610214578c8e8115156101fb57fe5b049350600184039250600a8311151561021057fe5b829a505b8c8e14151561023b578c8e1115610230578c91508d9050610237565b8d91508c90505b819a505b8a9b50505050505050505050505092915050565b6000809054906101000a900460ff1681565b816000806101000a81548160ff0219169083151502179055508060018190555050505600a165627a7a7230582036c5562a74060217554d53de9758f565aa5aae303e48c5027a8fb554aba828dc0029 --sig <span class="number">0x890eba680000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000003e</span></span><br></pre></td></tr></table></figure><p>虚拟机没有正确解析sig参数，验证github，源码确实存在这个问题</p><p><img src="/2023/09/19/EVMFuzzer/image-20231026200824290.png" alt="image-20231026200824290"></p><p>修改后继续进行测试</p><h3 id="cnt-0导致错误，已解决"><a href="#cnt-0导致错误，已解决" class="headerlink" title="cnt=0导致错误，已解决"></a>cnt=0导致错误，已解决</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;Run.py&quot;, line 736, in &lt;module&gt;</span><br><span class="line">    main()</span><br><span class="line">  File &quot;Run.py&quot;, line 353, in main</span><br><span class="line">    weight, choice = update_weight(dirPATH, &quot;mutator_diff&quot;, select) # combined strategy</span><br><span class="line">  File &quot;Run.py&quot;, line 120, in update_weight</span><br><span class="line">    weight[i+1] = float(int(diff_list[i]) / cnt)</span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure><p>原因是weight更新部分漏写了部分逻辑</p><h3 id="geth和aleth输出对应错误，已解决"><a href="#geth和aleth输出对应错误，已解决" class="headerlink" title="geth和aleth输出对应错误，已解决"></a>geth和aleth输出对应错误，已解决</h3><p>代码实现前后逻辑不一致</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">retcode = subprocess.call(<span class="string">&quot;./benchmarkEVMs/evm --debug --json --code &quot;</span> + bincode + <span class="string">&quot; --input &quot;</span> + sigName[<span class="number">2</span>:] + <span class="string">&quot; run &gt; &quot;</span> + outputPATH + <span class="string">&quot;gethout.json&quot;</span>,shell=<span class="literal">True</span>)</span><br><span class="line">retcode = subprocess.call( <span class="string">&quot;python3 &quot;</span> + PROJECT_DIR + <span class="string">&quot;/utils/cpp_convert_json_1.py &quot;</span> + outputPATH + <span class="string">&quot;aletraceout &quot;</span> + <span class="string">&quot; &gt; &quot;</span> + outputPATH + <span class="string">&quot;alethout.json&quot;</span>,shell=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><img src="/2023/09/19/EVMFuzzer/image-20231026220208745.png" alt="image-20231026220208745"></p><p>修改为一致的顺序</p><h3 id="未实现geth和cpp-py-js虚拟机对比的代码"><a href="#未实现geth和cpp-py-js虚拟机对比的代码" class="headerlink" title="未实现geth和cpp py js虚拟机对比的代码"></a>未实现geth和cpp py js虚拟机对比的代码</h3><p>仅对比EVM和其他四个虚拟机的结果，aleth py js 3个虚拟机互相对比，没有geth和aleth py js虚拟机之间对比的代码</p><p>原因可能是论文中提到geth和aleth的实验结果一致</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (my_output != js_output) and (my_output != py_output) and (my_output != geth_output) and (my_output != aleth_output):</span><br><span class="line">   X1 += 1</span><br></pre></td></tr></table></figure><p>逻辑是and，是因为仅4个虚拟机输出相同与targetEVM不同才有意义，因此需要加上4个虚拟机相同的逻辑</p><p>出现不支持的操作码 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> js-evm geth</span></span><br><span class="line">101 &#123;&quot;gasCost&quot;:&#123;&quot;__old&quot;:&quot;0x0&quot;,&quot;__new&quot;:&quot;0xc&quot;&#125;,&quot;opName&quot;:&#123;&quot;__old&quot;:&quot;INVALID&quot;,&quot;__new&quot;:&quot;Missing opcode 0xfe&quot;&#125;&#125;  opName: INVALID js: INVALID geth: Missing opcode 0xfe</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> result.json</span></span><br><span class="line">&#123;&quot;error&quot;:&quot;js&amp;py_output+gas&quot;,&quot;js_output&quot;:&quot;&quot;,&quot;py_output&quot;:&quot;0000000000000000000000000000000000000000000000000000000000000028&quot;,&quot;js_gasUsed&quot;:&quot;0xffffffff&quot;,&quot;py_gasUsed&quot;:&quot;0x2d1&quot;,&quot;txdata&quot;:&quot;0x87f71cef00000000000000000000000000000000000000000000000000000000000000470000000000000000000000000000000000000000000000000000000000000028&quot;&#125; </span><br><span class="line"></span><br><span class="line">&#123;&quot;error&quot;:&quot;cpp&amp;py_output+gas&quot;,&quot;cpp_output&quot;:&quot;&quot;,&quot;py_output&quot;:&quot;0000000000000000000000000000000000000000000000000000000000000028&quot;,&quot;cpp_gasUsed&quot;:&quot;0x7fffffffffffffff&quot;,&quot;py_gasUsed&quot;:&quot;0x2d1&quot;,&quot;txdata&quot;:&quot;0x87f71cef00000000000000000000000000000000000000000000000000000000000000470000000000000000000000000000000000000000000000000000000000000028&quot;&#125; </span><br><span class="line"></span><br><span class="line">&#123;&quot;error&quot;:&quot;js&amp;py_output+gas&quot;,&quot;js_output&quot;:&quot;&quot;,&quot;py_output&quot;:&quot;0000000000000000000000000000000000000000000000000000000000000000&quot;,&quot;js_gasUsed&quot;:&quot;0x9d&quot;,&quot;py_gasUsed&quot;:&quot;0x1d3&quot;,&quot;txdata&quot;:&quot;0xaa237e2100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012&quot;&#125; </span><br><span class="line"></span><br><span class="line">&#123;&quot;error&quot;:&quot;cpp&amp;py_output+gas&quot;,&quot;cpp_output&quot;:&quot;&quot;,&quot;py_output&quot;:&quot;0000000000000000000000000000000000000000000000000000000000000000&quot;,&quot;cpp_gasUsed&quot;:&quot;0x7fffffffffffffff&quot;,&quot;py_gasUsed&quot;:&quot;0x1d3&quot;,&quot;txdata&quot;:&quot;0xaa237e2100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012&quot;&#125; </span><br></pre></td></tr></table></figure><p>在cmp.js中增加了geth和其他三个evm对比的代码</p><p>Run.py主函数中将test_evm和其他4个虚拟机进行对比，当且仅当gas和opcode与4个虚拟机都不同时，认为虚拟机的实现是存在问题的（体会思想，因为被参考的4个虚拟机也存在不同）</p><h3 id="虚拟机output不同，已排除"><a href="#虚拟机output不同，已排除" class="headerlink" title="虚拟机output不同，已排除"></a>虚拟机output不同，已排除</h3><p>发现问题一般是pyout和其他虚拟机不同</p><ul><li>pyout末尾为0028</li><li>输出为空时，输出全0</li></ul><p><img src="/2023/09/19/EVMFuzzer/image-20231030192218403.png" alt="image-20231030192218403"></p><p>怀疑可能是pyevm和其他evm版本差距过大，查看pyevm的版本，实验环境中的版本是0.8.0-b1，Evmfuzz当时的pyevm是0.2.0a31，但实际上执行的pyevm不是0.7.0-a4，已解决</p><p><img src="/2023/09/19/EVMFuzzer/image-20231030193108290.png" alt="image-20231030193108290"></p><p><img src="/2023/09/19/EVMFuzzer/image-20231030233846704.png" alt="image-20231030233846704"></p><p>py虚拟机存在的问题</p><p><img src="/2023/09/19/EVMFuzzer/image-20231102235320918.png" alt="image-20231102235320918"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eth.exceptions.InvalidJumpDestination: Invalid Jump Destination</span><br></pre></td></tr></table></figure><p>pyevm官方文档的解释</p><p><img src="/2023/09/19/EVMFuzzer/image-20231107165715063.png" alt="image-20231107165715063"></p><h3 id="aleth-always-success，已解决"><a href="#aleth-always-success，已解决" class="headerlink" title="aleth always success，已解决"></a>aleth always success，已解决</h3><p>aleth虚拟机的返回值应该没有正确解析，无论怎么样的输入aleth都能正确输出</p><p>4个输出，仅考虑最后一个输出是否有效，不合理，修改代码实现</p><p><img src="/2023/09/19/EVMFuzzer/image-20231102222744372.png" alt="image-20231102222744372"></p><h3 id="argument-type，已解决"><a href="#argument-type，已解决" class="headerlink" title="argument type，已解决"></a>argument type，已解决</h3><p>原因是未传入code参数或传入空字符串，默认值为true</p><p><img src="/2023/09/19/EVMFuzzer/image-20231102215912217.png" alt="image-20231102215912217"></p><p><img src="/2023/09/19/EVMFuzzer/image-20231102212643892.png" alt="image-20231102212643892"></p><p>code参数怎么会是bool值，输出一下还真是boolean</p><p>argv.code未读到参数时默认的值为true，增加这样一个模块</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (argv.code!=<span class="literal">true</span>)&#123;</span><br><span class="line">    code=argv.code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新jsevm后，yargs模块提供了默认值的设计</p><h3 id="json为空"><a href="#json为空" class="headerlink" title="json为空"></a>json为空</h3><p>当gethout.json为空时，不符合json数据格式报错，不影响程序的正确执行</p><p><img src="/2023/09/19/EVMFuzzer/image-20231102212659481.png" alt="image-20231102212659481"></p><p>现有解决方案是若空则执行0x00 </p><h3 id="特殊类型参数无法生成，已解决"><a href="#特殊类型参数无法生成，已解决" class="headerlink" title="特殊类型参数无法生成，已解决"></a>特殊类型参数无法生成，已解决</h3><p>未能生成含参数为自定义的结构体Bet类型的函数签名，尝试采用solc直接编译，但是也没有对应的solc</p><p><img src="/2023/09/19/EVMFuzzer/image-20231102230039548.png" alt="image-20231102230039548"></p><p>生成的.signature中确实没有该函数的函数签名</p><p><img src="/2023/09/19/EVMFuzzer/image-20231102230128925.png" alt="image-20231102230128925"></p><p>以函数betPrize为例，该函数第一个参数是结构体类型，solc0.4.24无法编译出该合约的函数签名</p><p><img src="/2023/09/19/EVMFuzzer/image-20231108171659739.png" alt="image-20231108171659739"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(env) alleysira@LAPTOP-M4HO8L6S:~/EVMFuzzer/candidateContract/smartbugs$ solc SmartBillions.sol --hashes | grep -n bet</span><br><span class="line"></span><br><span class="line">(env) alleysira@LAPTOP-M4HO8L6S:~/EVMFuzzer/candidateContract/smartbugs$solc SmartBillions.sol --abi | grep -n bet</span><br></pre></td></tr></table></figure><p>尝试abi之后均没有编译出该函数的函数签名</p><p><img src="/2023/09/19/EVMFuzzer/image-20231108171941124.png" alt="image-20231108171941124"></p><p>换solc的版本解决</p><h3 id="geth不支持push0，已解决"><a href="#geth不支持push0，已解决" class="headerlink" title="geth不支持push0，已解决"></a>geth不支持push0，已解决</h3><p>尝试了在执行时设置—prestate genesis.json， failed</p><p>目前还是调回了paris</p><p>解决方法：调整prestate参数的位置到run的前面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retcode = subprocess.call(<span class="string">&quot;./benchmarkEVMs/evm --debug --gas 0xffffffff --noreturndata --json --code &quot;</span> + bincode + <span class="string">&quot; --input &quot;</span> + sigName[<span class="number">2</span>:] + <span class="string">&quot; --prestate ./benchmarkEVMs/genesis.json run &gt; &quot;</span> + PROJECT_DIR + <span class="string">&quot;/manCheck/gethout.json&quot;</span>,shell=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="exp1"><a href="#exp1" class="headerlink" title="exp1"></a>exp1</h3><ul><li>实验数据：smartbugs-curated的access_control arithmetic bad_randomness denial_of_service前四类的48个合约</li><li>运行10轮</li><li>solc版本为0.4.24</li></ul><h4 id="合约接口无法识别"><a href="#合约接口无法识别" class="headerlink" title="合约接口无法识别"></a>合约接口无法识别</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/home/alleysira/EVMFuzzer/TestOut/contract4/seed/PreProcess_BECToken_2.sol:46:3: Error: Expected &#x27;&#123;&#x27; but got &#x27;function&#x27;</span><br><span class="line">  function transfer(address to, uint256 value) public returns (bool);</span><br><span class="line">  ^------^</span><br><span class="line">1 PreProcess_BECToken_2.sol</span><br></pre></td></tr></table></figure><p>solidity源代码中的合约接口被编译器错误理解为函数实现，原因是Solidity 版本 0.4.24 以及之前的版本确实不支持显式的合约接口（contract interface）声明。在这些旧版本中，需要使用抽象合约（abstract contract）来实现类似接口的功能。</p><p>尝试用0.5.x的编译器，查看是否能够支持合约接口（是否有意义）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/home/alleysira/EVMFuzzer/TestOut/contract4/seed/PreProcess_BECToken_2.sol:56:1: Error: Function, variable, struct or modifier declaration expected.</span><br><span class="line">continue;</span><br><span class="line">^------^</span><br><span class="line">1 PreProcess_BECToken_2.sol</span><br></pre></td></tr></table></figure><h4 id="mutator导致多个可见性"><a href="#mutator导致多个可见性" class="headerlink" title="mutator导致多个可见性"></a>mutator导致多个可见性</h4><p>关于函数可见性变异的代码可能有问题，已修正</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/home/alleysira/EVMFuzzer/TestOut/contract4/seed/PreProcess_BECToken_7.sol:46:57: Error: Visibility already specified as &quot;internal&quot;.</span><br><span class="line">  function transfer(address to, uint256 value) internal public returns (bool);</span><br><span class="line"></span><br><span class="line">/home/alleysira/EVMFuzzer/TestOut/contract17/seed/PreProcess_phishable_9.sol:17:55: Error: Visibility already specified as &quot;external&quot;.</span><br><span class="line">  function withdrawAll(address _recipient) external public &#123;</span><br><span class="line">                                                      ^----^</span><br><span class="line">1 PreProcess_phishable_9.sol</span><br></pre></td></tr></table></figure><p>类似的问题，已修正</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/home/alleysira/EVMFuzzer/TestOut/contract4/seed/PreProcess_BECToken_1.sol:90:62: Error: Visibility already specified as &quot;private&quot;.</span><br><span class="line">  function allowance(address owner, address spender) private public constant returns (uint256);</span><br><span class="line">                                                             ^----^</span><br><span class="line">/home/alleysira/EVMFuzzer/TestOut/contract4/seed/PreProcess_BECToken_1.sol:149:64: Error: Visibility already specified as &quot;private&quot;.</span><br><span class="line">  function allowance(address _owner, address _spender) private public constant returns (uint256 remaining) &#123;</span><br><span class="line">                                                               ^----^</span><br><span class="line">1 PreProcess_BECToken_1.sol</span><br><span class="line"></span><br><span class="line">/home/alleysira/EVMFuzzer/TestOut/contract19/seed/PreProcess_token_3.sol:26:47: Error: Visibility already specified as &quot;private&quot;.</span><br><span class="line">   function balanceOf(address _owner) private public constant returns (uint balance) &#123;</span><br><span class="line">                                              ^----^</span><br><span class="line">1 PreProcess_token_3.sol</span><br></pre></td></tr></table></figure><p>添加break和continue不太准确，查看源代码，没发现这个问题，未能复现</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/home/alleysira/EVMFuzzer/TestOut/contract22/seed/PreProcess_smart_billions_4.sol:155:1: Error: Function, variable, struct or modifier declaration expected.</span><br><span class="line">break;</span><br></pre></td></tr></table></figure><h4 id="mutator对注释后的代码进行变异"><a href="#mutator对注释后的代码进行变异" class="headerlink" title="mutator对注释后的代码进行变异"></a>mutator对注释后的代码进行变异</h4><p>出现问题的原因可能是 变异器没有考虑注释行，变异的位置在被注释的部分，实际上合约的逻辑没有发生变化，无效变异</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/home/alleysira/EVMFuzzer/TestOut/contract24/seed/PreProcess_integer_overflow_1_3.sol:12:13: Error: Expected primary expression.</span><br><span class="line">         ++ &lt;yes&gt; &lt;report&gt; ARITHMETIC</span><br><span class="line">            ^</span><br><span class="line">1 PreProcess_integer_overflow_1_3.sol</span><br></pre></td></tr></table></figure><p>举例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// before mutation</span><br><span class="line">contract Overflow &#123;</span><br><span class="line">     uint private sellerBalance=0;</span><br><span class="line"></span><br><span class="line">     function add(uint value) returns (bool)&#123;</span><br><span class="line">         // &lt;yes&gt; &lt;report&gt; ARITHMETIC</span><br><span class="line">         sellerBalance += value; // possible overflow</span><br><span class="line"></span><br><span class="line">         // possible auditor assert</span><br><span class="line">         // assert(sellerBalance &gt;= value);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">//after mutation, it seems that &gt; is replaced with &gt;=, but in the commented line</span><br><span class="line"> contract Overflow &#123;</span><br><span class="line">     uint private sellerBalance=0;</span><br><span class="line"></span><br><span class="line">     function add(uint value) returns (bool)&#123;</span><br><span class="line">         // &gt;=yes&gt;= &gt;=report&gt;= ARITHMETIC</span><br><span class="line">         sellerBalance += value; // possible overflow</span><br><span class="line"></span><br><span class="line">         // possible auditor assert</span><br><span class="line">         // assert(sellerBalance &gt; value);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>变异时把注释用的//变异为了**，因此导致的错误</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/home/alleysira/EVMFuzzer/TestOut/contract41/seed/PreProcess_open_address_lottery_9.sol:<span class="number">67</span>:<span class="number">9</span>: Error: Expected primary expression.</span><br><span class="line">        ** calculate the number of current address - <span class="number">1</span> <span class="keyword">in</span> <span class="number">8</span> chance</span><br><span class="line">        ^^</span><br><span class="line"><span class="number">1</span> PreProcess_open_address_lottery_9.sol</span><br><span class="line">    </span><br><span class="line">    function luckyNumberOfAddress(address addr) constant returns(uint n)&#123;</span><br><span class="line">        // calculate the number of current address - <span class="number">1</span> <span class="keyword">in</span> <span class="number">8</span> chance</span><br><span class="line">        n = uint(keccak256(uint(addr), secretSeed)[<span class="number">0</span>]) % <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 运行了5个小时，输入49个合约，生成了1500个种子合约</span></span><br><span class="line">                         Detection Report</span><br><span class="line"></span><br><span class="line">After 18512.80s running, EVMFuzzer successfully generated 1500 seeds.</span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> In 0.0% (0/1500) of the tests, the output results are different from the standard execution.</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> In 1.13% (17/1500) of the tests, the gas consuming are more than the average value.</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> In 62.13% (932/1500) of the tests, the gas consuming are less than the average value.</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> In 36.73% (551/1500) of the tests, the gas consuming are equal to the average value.</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> In 4.73% (71/1500) of the tests, the execution sequence are more than the average value.</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> In 47.8% (717/1500) of the tests, the execution sequence are less than the average value.</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> In 47.47% (712/1500) of the tests, the execution sequence are equal to the average value.</span></span><br><span class="line"></span><br><span class="line">Final Conslusion:</span><br><span class="line">1. The code implementation of test EVM is relatively complete, can be used for Ethereum.</span><br><span class="line">2. The deviation of gas calculation is large, there exists dynamic optimization during the calculation process, and the optimization effect is good.</span><br><span class="line">3. The execution path planning is correct, there exists dynamic optimization during the executing procedure, and the optimization effect is good.</span><br></pre></td></tr></table></figure><h3 id="exp2"><a href="#exp2" class="headerlink" title="exp2"></a>exp2</h3><ul><li>实验数据：smartbugs-curated的剩余的6类，共100个合约，其中包含若干个unchecked的合约</li></ul><h4 id="pyevm和TestEVM独有的问题"><a href="#pyevm和TestEVM独有的问题" class="headerlink" title="pyevm和TestEVM独有的问题"></a>pyevm和TestEVM独有的问题</h4><p>可能是因为脚本是python实现的</p><ul><li>gas不足</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/home/alleysira/EVMFuzzer/TestOut/contract33/seed/PreProcess_0x561eac93c92360949ab1f1403323e6db345cbf31_5.sol:28:24:</span><br><span class="line"></span><br><span class="line">eth.exceptions.OutOfGas: Out of gas: Needed 5000 - Remaining 2141 - Reason: SSTORE: 0x8888888888888888888888888888888888888888[29102676481673041902632991033461445430619272659676223336789171408008386403024] -&gt; 0 (0)</span><br></pre></td></tr></table></figure><ul><li>未发现16进制数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/home/alleysira/EVMFuzzer/myEVM/runTx.py&quot;, line 159, in &lt;module&gt;</span><br><span class="line">    main()</span><br><span class="line">  File &quot;/home/alleysira/EVMFuzzer/myEVM/runTx.py&quot;, line 130, in main</span><br><span class="line">    genesis_state(base_state, simple_contract_address, args.data))</span><br><span class="line">  File &quot;/home/alleysira/EVMFuzzer/myEVM/runTx.py&quot;, line 93, in genesis_state</span><br><span class="line">    &#x27;code&#x27;: decode_hex(bytecode),  # contract bytecode</span><br><span class="line">  File &quot;/home/alleysira/EVMFuzzer/env/lib/python3.8/site-packages/eth_utils/hexadecimal.py&quot;, line 20, in decode_hex</span><br><span class="line">    return binascii.unhexlify(ascii_hex)</span><br><span class="line">binascii.Error: Non-hexadecimal digit found</span><br></pre></td></tr></table></figure><ul><li>eth.exceptions.InvalidJumpDestination: Invalid Jump Destination</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/home/alleysira/EVMFuzzer/benchmarkEVMs/py-evm/test_tx.py&quot;, line 165, in &lt;module&gt;</span><br><span class="line">    main()</span><br><span class="line">  File &quot;/home/alleysira/EVMFuzzer/benchmarkEVMs/py-evm/test_tx.py&quot;, line 158, in main</span><br><span class="line">    result_bytes = chain.get_transaction_result(call_txn, chain.get_canonical_head())</span><br><span class="line">  File &quot;/home/alleysira/EVMFuzzer/benchmarkEVMs/py-evm/eth/chains/base.py&quot;, line 575, in get_transaction_result</span><br><span class="line">    computation.raise_if_error()</span><br><span class="line">  File &quot;/home/alleysira/EVMFuzzer/benchmarkEVMs/py-evm/eth/vm/computation.py&quot;, line 173, in raise_if_error</span><br><span class="line">    raise self._error</span><br><span class="line">  File &quot;/home/alleysira/EVMFuzzer/benchmarkEVMs/py-evm/eth/vm/computation.py&quot;, line 587, in apply_computation</span><br><span class="line">    opcode_fn(computation=computation)</span><br><span class="line">  File &quot;/home/alleysira/EVMFuzzer/benchmarkEVMs/py-evm/eth/vm/opcode.py&quot;, line 49, in wrapped_logic_fn</span><br><span class="line">    return logic_fn(computation)</span><br><span class="line">  File &quot;/home/alleysira/EVMFuzzer/benchmarkEVMs/py-evm/eth/vm/logic/flow.py&quot;, line 24, in jump</span><br><span class="line">    raise InvalidJumpDestination(&quot;Invalid Jump Destination&quot;)</span><br><span class="line">eth.exceptions.InvalidJumpDestination: Invalid Jump Destination</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/home/alleysira/EVMFuzzer/myEVM/runTx.py&quot;, line 159, in &lt;module&gt;</span><br><span class="line">    main()</span><br><span class="line">  File &quot;/home/alleysira/EVMFuzzer/myEVM/runTx.py&quot;, line 155, in main</span><br><span class="line">    result_bytes = chain.get_transaction_result(call_txn, chain.get_canonical_head())</span><br><span class="line">  File &quot;/home/alleysira/EVMFuzzer/myEVM/eth/chains/base.py&quot;, line 575, in get_transaction_result</span><br><span class="line">    computation.raise_if_error()</span><br><span class="line">  File &quot;/home/alleysira/EVMFuzzer/myEVM/eth/vm/computation.py&quot;, line 173, in raise_if_error</span><br><span class="line">    raise self._error</span><br><span class="line">  File &quot;/home/alleysira/EVMFuzzer/myEVM/eth/vm/computation.py&quot;, line 587, in apply_computation</span><br><span class="line">    opcode_fn(computation=computation)</span><br><span class="line">  File &quot;/home/alleysira/EVMFuzzer/myEVM/eth/vm/opcode.py&quot;, line 49, in wrapped_logic_fn</span><br><span class="line">    return logic_fn(computation)</span><br><span class="line">  File &quot;/home/alleysira/EVMFuzzer/myEVM/eth/vm/logic/flow.py&quot;, line 24, in jump</span><br><span class="line">    raise InvalidJumpDestination(&quot;Invalid Jump Destination&quot;)</span><br><span class="line">eth.exceptions.InvalidJumpDestination: Invalid Jump Destination</span><br></pre></td></tr></table></figure><h2 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h2><h3 id="solc"><a href="#solc" class="headerlink" title="solc"></a>solc</h3><p>更新pip，更新solc，安装0.8.23和0.8.22版本的solc</p><p>solc 0.8.22编出的合约存在的问题：</p><p>evm本身存在version</p><p>solc编译时可以设定编译对象evm版本：<a href="https://docs.soliditylang.org/en/latest/using-the-compiler.html#setting-the-evm-version-to-target">https://docs.soliditylang.org/en/latest/using-the-compiler.html#setting-the-evm-version-to-target</a></p><p>详细的EVM version <a href="https://docs.blockscout.com/for-developers/evm-version-information">https://docs.blockscout.com/for-developers/evm-version-information</a></p><h3 id="geth"><a href="#geth" class="headerlink" title="geth"></a>geth</h3><p>build 更新go版本，参考<a href="https://www.cnblogs.com/pebblecome/p/14815365.html">https://www.cnblogs.com/pebblecome/p/14815365.html</a></p><p>ppa安装最新的geth1.13.4</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository -y ppa:ethereum/ethereum</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install ethereum</span><br><span class="line">sudo apt-get upgrade geth</span><br></pre></td></tr></table></figure><p>geth官方提供的非常有用的资料 <a href="https://geth.ethereum.org/docs/developers/evm-tracing">https://geth.ethereum.org/docs/developers/evm-tracing</a></p><p>更新后的geth evm</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(env) alleysira@LAPTOP-M4HO8L6S:~/EVMFuzzer/benchmarkEVMs$ evm --version</span><br><span class="line">evm version 1.13.4-stable-3f907d6a</span><br><span class="line">(env) alleysira@LAPTOP-M4HO8L6S:~/EVMFuzzer/benchmarkEVMs$ ./evm --version</span><br><span class="line">evm version 1.9.0-unstable-95b2ec71</span><br></pre></td></tr></table></figure><p>发现的geth的输出发生了变化，通过跑myContract来看一下</p><p><img src="/2023/09/19/EVMFuzzer/image-20231114203433001.png" alt="image-20231114203433001"></p><p>由于<code>fmt.Fprintln(os.Stderr, &quot;#### LOGS ####&quot;)</code>输出在标准错误，因此命令行会出现这个</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;pc&quot;:0,&quot;op&quot;:96,&quot;gas&quot;:&quot;0x2540be400&quot;,&quot;gasCost&quot;:&quot;0x3&quot;,&quot;memSize&quot;:0,&quot;stack&quot;:[],&quot;depth&quot;:1,&quot;refund&quot;:0,&quot;opName&quot;:&quot;PUSH1&quot;&#125;</span><br><span class="line">&#123;&quot;pc&quot;:2,&quot;op&quot;:96,&quot;gas&quot;:&quot;0x2540be3fd&quot;,&quot;gasCost&quot;:&quot;0x3&quot;,&quot;memSize&quot;:0,&quot;stack&quot;:[&quot;0xff&quot;],&quot;depth&quot;:1,&quot;refund&quot;:0,&quot;opName&quot;:&quot;PUSH1&quot;&#125;</span><br><span class="line">&#123;&quot;pc&quot;:4,&quot;op&quot;:0,&quot;gas&quot;:&quot;0x2540be3fa&quot;,&quot;gasCost&quot;:&quot;0x0&quot;,&quot;memSize&quot;:0,&quot;stack&quot;:[&quot;0xff&quot;,&quot;0xff&quot;],&quot;depth&quot;:1,&quot;refund&quot;:0,&quot;opName&quot;:&quot;STOP&quot;&#125;</span><br><span class="line">&#123;&quot;output&quot;:&quot;&quot;,&quot;gasUsed&quot;:&quot;0x6&quot;&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">### LOGS ####</span></span></span><br></pre></td></tr></table></figure><h3 id="jsevm"><a href="#jsevm" class="headerlink" title="jsevm"></a>jsevm</h3><p>旧的js版本 2.4.0，node版本为v10.19.0</p><p>官方文档：useful <a href="https://github.com/ethereumjs/ethereumjs-monorepo/tree/master/packages/evm">https://github.com/ethereumjs/ethereumjs-monorepo/tree/master/packages/evm</a></p><p>not that new <a href="https://ethereumjs.readthedocs.io/en/latest/">https://ethereumjs.readthedocs.io/en/latest/</a></p><p>npm doc： <a href="https://www.npmjs.com/package/@ethereumjs/evm">https://www.npmjs.com/package/@ethereumjs/evm</a></p><p>修改后，使用的node的版本为20.9.0</p><p>如何运行合约，可以参考：<a href="https://github.com/ethereumjs/ethereumjs-monorepo/blob/f9525af55b4c2068a003e8035184913c0adcd980/packages/evm/test/runCall.spec.ts#L608">https://github.com/ethereumjs/ethereumjs-monorepo/blob/f9525af55b4c2068a003e8035184913c0adcd980/packages/evm/test/runCall.spec.ts#L608</a></p><p>收集jsevm results的参数</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  logs: [],</span><br><span class="line">  returnValue: Uint8Array(<span class="number">0</span>) [],</span><br><span class="line">  selfdestruct: Set(<span class="number">0</span>) &#123;&#125;,</span><br><span class="line">  createdAddresses: Set(<span class="number">0</span>) &#123;&#125;,</span><br><span class="line">  runState: &#123;</span><br><span class="line">    programCounter: <span class="number">103</span>,</span><br><span class="line">    opCode: <span class="number">253</span>,</span><br><span class="line">    memory: Memory &#123; _store: [Uint8Array] &#125;,</span><br><span class="line">    memoryWordCount: <span class="number">3</span>n,</span><br><span class="line">    highestMemCost: <span class="number">9</span>n,</span><br><span class="line">    stack: Stack &#123; _len: <span class="number">1</span>, _store: [Array], _maxHeight: <span class="number">1024</span> &#125;,</span><br><span class="line">    returnStack: Stack &#123; _len: <span class="number">0</span>, _store: [], _maxHeight: <span class="number">1023</span> &#125;,</span><br><span class="line">    code: Uint8Array(<span class="number">672</span>) [</span><br><span class="line">       <span class="number">96</span>, <span class="number">128</span>,  <span class="number">96</span>,  <span class="number">64</span>,  <span class="number">82</span>,  <span class="number">96</span>,   <span class="number">4</span>,  <span class="number">54</span>,  <span class="number">16</span>,  <span class="number">97</span>,   <span class="number">0</span>,  <span class="number">98</span>,</span><br><span class="line">       <span class="number">87</span>,  <span class="number">96</span>,   <span class="number">0</span>,  <span class="number">53</span>, <span class="number">124</span>,   <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>, <span class="number">144</span>,   <span class="number">4</span>,</span><br><span class="line">       <span class="number">99</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>,  <span class="number">22</span>, <span class="number">128</span>,  <span class="number">99</span>,  <span class="number">77</span>, <span class="number">221</span>,  <span class="number">16</span>, <span class="number">138</span>,</span><br><span class="line">       <span class="number">20</span>,  <span class="number">97</span>,   <span class="number">0</span>, <span class="number">103</span>,  <span class="number">87</span>, <span class="number">128</span>,  <span class="number">99</span>, <span class="number">135</span>, <span class="number">247</span>,  <span class="number">28</span>, <span class="number">239</span>,  <span class="number">20</span>,</span><br><span class="line">       <span class="number">97</span>,   <span class="number">0</span>, <span class="number">146</span>,  <span class="number">87</span>, <span class="number">128</span>,  <span class="number">99</span>, <span class="number">137</span>,  <span class="number">14</span>, <span class="number">186</span>, <span class="number">104</span>,  <span class="number">20</span>,  <span class="number">97</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">201</span>,  <span class="number">87</span>, <span class="number">128</span>,  <span class="number">99</span>, <span class="number">170</span>,  <span class="number">35</span>, <span class="number">126</span>,  <span class="number">33</span>,  <span class="number">20</span>,  <span class="number">97</span>,   <span class="number">0</span>,</span><br><span class="line">      <span class="number">248</span>,  <span class="number">87</span>,  <span class="number">91</span>,  <span class="number">96</span>,</span><br><span class="line">      ... <span class="number">572</span> more items</span><br><span class="line">    ],</span><br><span class="line">    validJumps: Uint8Array(<span class="number">672</span>) [</span><br><span class="line">      <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">      <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">      <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">      <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">      <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">      <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">      <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">      <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">      <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">      ... <span class="number">572</span> more items</span><br><span class="line">    ],</span><br><span class="line">    cachedPushes: &#123;</span><br><span class="line">      &#x27;1&#x27;: <span class="number">128</span>n,</span><br><span class="line">      &#x27;3&#x27;: <span class="number">64</span>n,</span><br><span class="line">      &#x27;6&#x27;: <span class="number">4</span>n,</span><br><span class="line">      &#x27;10&#x27;: <span class="number">98</span>n,</span><br><span class="line">      &#x27;14&#x27;: <span class="number">0</span>n,</span><br><span class="line">      &#x27;17&#x27;: <span class="number">26959946667150639794667015087019630673637144422540572481103610249216</span>n,</span><br><span class="line">      &#x27;49&#x27;: <span class="number">4294967295</span>n,</span><br><span class="line">      &#x27;56&#x27;: <span class="number">1306333322</span>n,</span><br><span class="line">      &#x27;62&#x27;: <span class="number">103</span>n,</span><br><span class="line">      &#x27;67&#x27;: <span class="number">2281118959</span>n,</span><br><span class="line">      &#x27;73&#x27;: <span class="number">146</span>n,</span><br><span class="line">      &#x27;78&#x27;: <span class="number">2299443816</span>n,</span><br><span class="line">      &#x27;84&#x27;: <span class="number">201</span>n,</span><br><span class="line">      &#x27;89&#x27;: <span class="number">2854452769</span>n,</span><br><span class="line">      &#x27;95&#x27;: <span class="number">248</span>n,</span><br><span class="line">      &#x27;100&#x27;: <span class="number">0</span>n,</span><br><span class="line">      &#x27;108&#x27;: <span class="number">115</span>n,</span><br><span class="line">      &#x27;112&#x27;: <span class="number">0</span>n,</span><br><span class="line">      &#x27;118&#x27;: <span class="number">124</span>n,</span><br><span class="line">      &#x27;121&#x27;: <span class="number">305</span>n,</span><br><span class="line">      &#x27;126&#x27;: <span class="number">64</span>n,</span><br><span class="line">      &#x27;133&#x27;: <span class="number">32</span>n,</span><br><span class="line">      &#x27;139&#x27;: <span class="number">64</span>n,</span><br><span class="line">      &#x27;151&#x27;: <span class="number">158</span>n,</span><br><span class="line">      &#x27;155&#x27;: <span class="number">0</span>n,</span><br><span class="line">      &#x27;161&#x27;: <span class="number">199</span>n,</span><br><span class="line">      &#x27;164&#x27;: <span class="number">4</span>n,</span><br><span class="line">      &#x27;176&#x27;: <span class="number">32</span>n,</span><br><span class="line">      &#x27;186&#x27;: <span class="number">32</span>n,</span><br><span class="line">      &#x27;196&#x27;: <span class="number">311</span>n,</span><br><span class="line">      &#x27;206&#x27;: <span class="number">213</span>n,</span><br><span class="line">      &#x27;210&#x27;: <span class="number">0</span>n,</span><br><span class="line">      &#x27;216&#x27;: <span class="number">222</span>n,</span><br><span class="line">      &#x27;219&#x27;: <span class="number">574</span>n,</span><br><span class="line">      &#x27;224&#x27;: <span class="number">64</span>n,</span><br><span class="line">      &#x27;235&#x27;: <span class="number">32</span>n,</span><br><span class="line">      &#x27;241&#x27;: <span class="number">64</span>n,</span><br><span class="line">      &#x27;253&#x27;: <span class="number">260</span>n,</span><br><span class="line">      &#x27;257&#x27;: <span class="number">0</span>n,</span><br><span class="line">      &#x27;263&#x27;: <span class="number">303</span>n,</span><br><span class="line">      &#x27;266&#x27;: <span class="number">4</span>n,</span><br><span class="line">      &#x27;280&#x27;: <span class="number">32</span>n,</span><br><span class="line">      &#x27;290&#x27;: <span class="number">32</span>n,</span><br><span class="line">      &#x27;300&#x27;: <span class="number">592</span>n,</span><br><span class="line">      &#x27;307&#x27;: <span class="number">1</span>n,</span><br><span class="line">      &#x27;313&#x27;: <span class="number">0</span>n,</span><br><span class="line">      &#x27;316&#x27;: <span class="number">0</span>n,</span><br><span class="line">      &#x27;319&#x27;: <span class="number">0</span>n,</span><br><span class="line">      &#x27;322&#x27;: <span class="number">0</span>n,</span><br><span class="line">      &#x27;325&#x27;: <span class="number">0</span>n,</span><br><span class="line">      &#x27;328&#x27;: <span class="number">0</span>n,</span><br><span class="line">      &#x27;334&#x27;: <span class="number">360</span>n,</span><br><span class="line">      &#x27;352&#x27;: <span class="number">356</span>n,</span><br><span class="line">      &#x27;366&#x27;: <span class="number">390</span>n,</span><br><span class="line">      &#x27;375&#x27;: <span class="number">0</span>n,</span><br><span class="line">      &#x27;382&#x27;: <span class="number">386</span>n,</span><br><span class="line">      &#x27;396&#x27;: <span class="number">441</span>n,</span><br><span class="line">      &#x27;400&#x27;: <span class="number">0</span>n,</span><br><span class="line">      &#x27;405&#x27;: <span class="number">109</span>n,</span><br><span class="line">      &#x27;410&#x27;: <span class="number">437</span>n,</span><br><span class="line">      &#x27;419&#x27;: <span class="number">423</span>n,</span><br><span class="line">      &#x27;429&#x27;: <span class="number">1</span>n,</span><br><span class="line">      &#x27;434&#x27;: <span class="number">403</span>n,</span><br><span class="line">      &#x27;448&#x27;: <span class="number">484</span>n,</span><br><span class="line">      &#x27;457&#x27;: <span class="number">461</span>n,</span><br><span class="line">      &#x27;466&#x27;: <span class="number">20</span>n,</span><br><span class="line">      &#x27;476&#x27;: <span class="number">480</span>n,</span><br><span class="line">      &#x27;491&#x27;: <span class="number">520</span>n,</span><br><span class="line">      &#x27;500&#x27;: <span class="number">1</span>n,</span><br><span class="line">      &#x27;506&#x27;: <span class="number">10</span>n,</span><br><span class="line">      &#x27;512&#x27;: <span class="number">516</span>n,</span><br><span class="line">      &#x27;527&#x27;: <span class="number">559</span>n,</span><br><span class="line">      &#x27;535&#x27;: <span class="number">548</span>n,</span><br><span class="line">      &#x27;545&#x27;: <span class="number">555</span>n,</span><br><span class="line">      &#x27;576&#x27;: <span class="number">0</span>n,</span><br><span class="line">      &#x27;582&#x27;: <span class="number">256</span>n,</span><br><span class="line">      &#x27;588&#x27;: <span class="number">255</span>n,</span><br><span class="line">      &#x27;595&#x27;: <span class="number">0</span>n,</span><br><span class="line">      &#x27;598&#x27;: <span class="number">256</span>n,</span><br><span class="line">      &#x27;605&#x27;: <span class="number">255</span>n,</span><br><span class="line">      &#x27;620&#x27;: <span class="number">1</span>n,</span><br><span class="line">      &#x27;631&#x27;: <span class="number">108278179835992</span>n,</span><br><span class="line">      &#x27;649&#x27;: <span class="number">22782674781861623699170174827345051082396830843149090857</span>n</span><br><span class="line">    &#125;,</span><br><span class="line">    stateManager: DefaultStateManager &#123;</span><br><span class="line">      DEBUG: <span class="literal">false</span>,</span><br><span class="line">      _debug: [Function],</span><br><span class="line">      _proofTrie: [Trie],</span><br><span class="line">      common: [Common],</span><br><span class="line">      _checkpointCount: <span class="number">0</span>,</span><br><span class="line">      _trie: [Trie],</span><br><span class="line">      _storageTries: &#123;&#125;,</span><br><span class="line">      originalStorageCache: [OriginalStorageCache],</span><br><span class="line">      _prefixCodeHashes: <span class="literal">true</span>,</span><br><span class="line">      _prefixStorageTrieKeys: <span class="literal">false</span>,</span><br><span class="line">      _accountCacheSettings: [Object],</span><br><span class="line">      _accountCache: [AccountCache],</span><br><span class="line">      _storageCacheSettings: [Object],</span><br><span class="line">      _storageCache: [StorageCache],</span><br><span class="line">      _codeCacheSettings: [Object],</span><br><span class="line">      _codeCache: [CodeCache]</span><br><span class="line">    &#125;,</span><br><span class="line">    blockchain: Blockchain &#123;</span><br><span class="line">      _isInitialized: <span class="literal">true</span>,</span><br><span class="line">      common: [Common],</span><br><span class="line">      _hardforkByHeadBlockNumber: <span class="literal">false</span>,</span><br><span class="line">      _validateConsensus: <span class="literal">true</span>,</span><br><span class="line">      _validateBlocks: <span class="literal">true</span>,</span><br><span class="line">      _customGenesisState: undefined,</span><br><span class="line">      db: [MapDB],</span><br><span class="line">      dbManager: [DBManager],</span><br><span class="line">      consensus: [EthashConsensus],</span><br><span class="line">      _heads: &#123;&#125;,</span><br><span class="line">      _lock: [Lock],</span><br><span class="line">      _genesisBlock: [Block],</span><br><span class="line">      _headHeaderHash: [Uint8Array],</span><br><span class="line">      _headBlockHash: [Uint8Array]</span><br><span class="line">    &#125;,</span><br><span class="line">    env: &#123;</span><br><span class="line">      address: [Address],</span><br><span class="line">      caller: [Address],</span><br><span class="line">      callData: &lt;Buffer <span class="number">38</span> <span class="number">34</span> <span class="number">36</span> <span class="number">32</span> <span class="number">31</span> <span class="number">35</span> <span class="number">31</span> <span class="number">63</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">36</span> <span class="number">61</span> <span class="number">65</span> <span class="number">62</span> <span class="number">64</span> <span class="number">30</span> <span class="number">32</span> <span class="number">65</span> <span class="number">62</span> <span class="number">32</span> <span class="number">62</span> <span class="number">63</span> <span class="number">34</span> <span class="number">61</span> <span class="number">65</span> <span class="number">61</span> <span class="number">34</span> <span class="number">34</span> ... <span class="number">22</span> more bytes&gt;,</span><br><span class="line">      callValue: <span class="number">0</span>n,</span><br><span class="line">      code: [Uint8Array],</span><br><span class="line">      isStatic: <span class="literal">false</span>,</span><br><span class="line">      depth: <span class="number">0</span>,</span><br><span class="line">      gasPrice: <span class="number">0</span>n,</span><br><span class="line">      origin: [Address],</span><br><span class="line">      block: [Object],</span><br><span class="line">      contract: [Account],</span><br><span class="line">      codeAddress: [Address],</span><br><span class="line">      gasRefund: <span class="number">0</span>n,</span><br><span class="line">      containerCode: undefined,</span><br><span class="line">      blobVersionedHashes: [],</span><br><span class="line">      createdAddresses: undefined</span><br><span class="line">    &#125;,</span><br><span class="line">    shouldDoJumpAnalysis: <span class="literal">false</span>,</span><br><span class="line">    interpreter: Interpreter &#123;</span><br><span class="line">      opDebuggers: [Object],</span><br><span class="line">      _evm: [EVM],</span><br><span class="line">      _stateManager: [DefaultStateManager],</span><br><span class="line">      common: [Common],</span><br><span class="line">      _runState: [Object],</span><br><span class="line">      journal: [Journal],</span><br><span class="line">      _env: [Object],</span><br><span class="line">      _result: [Object],</span><br><span class="line">      profilerOpts: undefined,</span><br><span class="line">      performanceLogger: [EVMPerformanceLogger]</span><br><span class="line">    &#125;,</span><br><span class="line">    gasRefund: <span class="number">0</span>n,</span><br><span class="line">    gasLeft: <span class="number">4294967138</span>n,</span><br><span class="line">    returnBytes: Uint8Array(<span class="number">0</span>) [],</span><br><span class="line">    logs: [],</span><br><span class="line">    returnValue: Uint8Array(<span class="number">0</span>) [],</span><br><span class="line">    selfdestruct: Set(<span class="number">0</span>) &#123;&#125;,</span><br><span class="line">    createdAddresses: undefined,</span><br><span class="line">    address: Address &#123; bytes: [Uint8Array] &#125;,</span><br><span class="line">    caller: Address &#123; bytes: [Uint8Array] &#125;,</span><br><span class="line">    callData: &lt;Buffer <span class="number">38</span> <span class="number">34</span> <span class="number">36</span> <span class="number">32</span> <span class="number">31</span> <span class="number">35</span> <span class="number">31</span> <span class="number">63</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">36</span> <span class="number">61</span> <span class="number">65</span> <span class="number">62</span> <span class="number">64</span> <span class="number">30</span> <span class="number">32</span> <span class="number">65</span> <span class="number">62</span> <span class="number">32</span> <span class="number">62</span> <span class="number">63</span> <span class="number">34</span> <span class="number">61</span> <span class="number">65</span> <span class="number">61</span> <span class="number">34</span> <span class="number">34</span> ... <span class="number">22</span> more bytes&gt;,</span><br><span class="line">    callValue: <span class="number">0</span>n,</span><br><span class="line">    isStatic: <span class="literal">false</span>,</span><br><span class="line">    depth: <span class="number">0</span>,</span><br><span class="line">    gasPrice: <span class="number">0</span>n,</span><br><span class="line">    origin: Address &#123; bytes: [Uint8Array] &#125;,</span><br><span class="line">    block: &#123; header: [Object] &#125;,</span><br><span class="line">    contract: Account &#123;</span><br><span class="line">      nonce: <span class="number">0</span>n,</span><br><span class="line">      balance: <span class="number">0</span>n,</span><br><span class="line">      storageRoot: [Uint8Array],</span><br><span class="line">      codeHash: [Uint8Array]</span><br><span class="line">    &#125;,</span><br><span class="line">    codeAddress: Address &#123; bytes: [Uint8Array] &#125;,</span><br><span class="line">    containerCode: undefined,</span><br><span class="line">    blobVersionedHashes: []</span><br><span class="line">  &#125;,</span><br><span class="line">  exceptionError: EvmError &#123; error: &#x27;revert&#x27;, errorType: &#x27;EvmError&#x27; &#125;,</span><br><span class="line">  gas: <span class="number">4294967138</span>n,</span><br><span class="line">  executionGasUsed: <span class="number">157</span>n,</span><br><span class="line">  gasRefund: <span class="number">0</span>n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="py-evm"><a href="#py-evm" class="headerlink" title="py-evm"></a>py-evm</h3><p>直接更新后由于接口改变，无法直接使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/home/alleysira/EVMFuzzer/benchmarkEVMs/py-evm/test_tx.py&quot;, line 18, in &lt;module&gt;</span><br><span class="line">    from eth.vm.forks.shanghai import ShanghaiVM</span><br><span class="line">ModuleNotFoundError: No module named &#x27;eth.vm.forks.shanghai&#x27;</span><br><span class="line"></span><br><span class="line">[&#x27;/home/alleysira/EVMFuzzer/benchmarkEVMs/py-evm&#x27;, &#x27;/usr/lib/python38.zip&#x27;, &#x27;/usr/lib/python3.8&#x27;, &#x27;/usr/lib/python3.8/lib-dynload&#x27;, &#x27;/home/alleysira/EVMFuzzer/env/lib/python3.8/site-packages&#x27;]</span><br><span class="line">sys_path</span><br></pre></td></tr></table></figure><p>太智障了，本地的pyevm文件夹优先级更高</p><h4 id="trace-py-evm的过程信息"><a href="#trace-py-evm的过程信息" class="headerlink" title="trace py-evm的过程信息"></a>trace py-evm的过程信息</h4><p>和old版本对比，调用的函数是execute_transaction，输出json在这之后</p><p>新版本采用的函数是apply_transaction</p><p>trace之后，是在这里：class FrontierTransactionExecutor(BaseTransactionExecutor)</p><p><img src="/2023/09/19/EVMFuzzer/image-20231121225605895.png" alt="image-20231121225605895"></p><p>computation = self.build_computation(message, valid_transaction)</p><p>实现在class FrontierTransactionExecutor(BaseTransactionExecutor):的 def build_computation(self, message, transaction):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">      computation = self.vm_state.get_computation(  message,transaction_context).apply_message()</span><br><span class="line">apply_message()</span><br><span class="line"></span><br><span class="line">computation = self.apply_computation(</span><br><span class="line">    self.state,</span><br><span class="line">    self.msg,</span><br><span class="line">    self.transaction_context,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply_computation</span> <span class="title">in</span> </span></span><br></pre></td></tr></table></figure><p><img src="/2023/09/19/EVMFuzzer/image-20231121231928188.png" alt="image-20231121231928188"></p><p>apply_computation实现了对执行过程的记录</p><p>为了记录输出，需要在/home/alleysira/EVMFuzzer/env/lib/python3.8/site-packages/eth/vm/computation.py 中的def <strong>exit</strong>函数中实现对结果的记录</p><p>对比新老版本，发现新的实现中当EVM error出现时，会erase当前的返回值（可能解释了更新之后jsevm均是revert）</p><p><img src="/2023/09/19/EVMFuzzer/image-20231122143445037.png" alt="image-20231122143445037"></p><h3 id="aleth"><a href="#aleth" class="headerlink" title="aleth"></a>aleth</h3><p>当前版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(env) alleysira@LAPTOP-M4HO8L6S:~/EVMFuzzer/benchmarkEVMs$ ./aleth-vm --version</span><br><span class="line">aleth-vm 1.7.0-alpha.0-23+commit.32f9c88f</span><br><span class="line">Build: linux/relwithdebinfo</span><br></pre></td></tr></table></figure><p>更新工作完成后的虚拟机采用了shanghai分叉，具体版本</p><ul><li>geth 1.13.4-stable-3f907d6a<ul><li>Neodiff：1.9.21-unstable</li></ul></li><li>pyevm：0.8.0b1<ul><li>EVMFuzz：0.2.0-alpha.31</li></ul></li><li>jsevm：4.1.3，旧版本是 2.4.0</li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="push0"><a href="#push0" class="headerlink" title="push0"></a>push0</h4><p>geth的evm不支持push0，可能是未采用shanghai fork，目前已通过对solc增加—evm-version paris解决，后续采用prestate —genesis.json解决</p><h4 id="storge"><a href="#storge" class="headerlink" title="storge"></a>storge</h4><p>jsevm执行涉及到storge的操作码（如 SLOAD）会遇到问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Error: getContractStorage() called on non-existing account</span><br><span class="line">    at DefaultStateManager.getContractStorage (/home/alleysira/node_modules/@ethereumjs/statemanager/dist/cjs/stateManager.js:291:19)</span><br><span class="line">/home/alleysira/EVMFuzzer/benchmarkEVMs/jsEVM/usage.js:86</span><br><span class="line">            &#x27;output&#x27;:results.returnValue.toString(16),</span><br></pre></td></tr></table></figure><p>目前通过对newdiff文件判断解决</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    thisline = newdiffFile.readline().strip()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> thisline==<span class="string">&quot;NaN&quot;</span>:</span><br><span class="line">        newdiff = <span class="number">0</span> </span><br><span class="line">    <span class="keyword">else</span>:    </span><br><span class="line">        <span class="built_in">print</span>(thisline,thisline==<span class="string">&quot;NaN&quot;</span>)</span><br><span class="line">        newdiff = <span class="built_in">int</span>(thisline.strip())</span><br><span class="line">        newdiffFile.close()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error: <span class="string">&quot;/home/alleysira/EVMFuzzer/TestOut/contract3/seed/PreProcess_Rocket_Crash.sol&quot;</span> is not found.</span><br><span class="line">1 PreProcess_Rocket_Crash.sol</span><br></pre></td></tr></table></figure><p><a href="https://github.com/ethereumjs/ethereumjs-monorepo/issues/2654">https://github.com/ethereumjs/ethereumjs-monorepo/issues/2654</a></p><p>阅读github相关issue，通过采用runCall代替runCode解决</p><p>The main change is to use <code>runCall</code> instead of <code>runCode</code> which as is documented in the method notes, isn’t intended to be called directly from the <code>evm</code> class. <code>runCall</code> is the preferred way to execute raw bytecode in the <code>evm</code> with minimal fuss.</p><h1 id="EVM-history"><a href="#EVM-history" class="headerlink" title="EVM history"></a>EVM history</h1><p>以太坊官方的EVM变更历史：<a href="https://ethereum.org/en/history/">https://ethereum.org/en/history/</a></p><p>目前正在进行<a href="https://coindataflow.com/en/ethereum-cancun-hard-fork-countdown分叉">https://coindataflow.com/en/ethereum-cancun-hard-fork-countdown分叉</a></p><p>目前的代码里使用的都是shanghai分叉之后的EVM，但是相关的配置文件没有找到，仅istanbul之前的版本有详细的gas相关的设置</p><p><img src="/2023/09/19/EVMFuzzer/image-20231123223503259.png" alt="image-20231123223503259"></p><p>上海分叉仅提供了对应的EIP</p><p><img src="/2023/09/19/EVMFuzzer/image-20231123223532622.png" alt="image-20231123223532622"></p><p>查看对应EIP进行的约定</p><p><img src="/2023/09/19/EVMFuzzer/image-20231123230240051.png" alt="image-20231123230240051" style="zoom:90%;"></p><p><img src="/2023/09/19/EVMFuzzer/image-20231123224321349.png" alt="image-20231123224321349"></p><p><img src="/2023/09/19/EVMFuzzer/image-20231123224725125.png" alt="image-20231123224725125" style="zoom:75%;"></p><p><img src="/2023/09/19/EVMFuzzer/image-20231123224750211.png" alt="image-20231123224750211" style="zoom:90%;"></p><p>定义默认值：/home/alleysira/node_modules/@ethereumjs/evm/src/types.ts</p><h1 id="possible-vul"><a href="#possible-vul" class="headerlink" title="possible vul"></a>possible vul</h1><h2 id="FATAL-ERROR-v8-ToLocalChecked-Empty-MaybeLocal"><a href="#FATAL-ERROR-v8-ToLocalChecked-Empty-MaybeLocal" class="headerlink" title="FATAL ERROR: v8::ToLocalChecked Empty MaybeLocal"></a>FATAL ERROR: v8::ToLocalChecked Empty MaybeLocal</h2><ul><li><p>环境</p></li><li><p>solc 0.4.24 </p></li><li><p>contract = PreProcess_dos_number.sol</p></li><li><p>func = insertNnumbers</p></li><li><p>sig = 0x529f6f2d00000000000000000000000000000000000000000000000000000000643bf62f000000000000000000000000000000000000000000000000000000001a2a62cd</p></li><li><p>表现：OOM错误</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FATAL ERROR: v8::ToLocalChecked Empty MaybeLocal</span><br><span class="line"> 1: 0xc99970 node::Abort() [/home/alleysira/node/node-v20.9.0-linux-x64/bin/node]</span><br><span class="line"> 2: 0xb6feda node::OOMErrorHandler(char const*, v8::OOMDetails const&amp;) [/home/alleysira/node/node-v20.9.0-linux-x64/bin/node]</span><br><span class="line"> 3: 0xebfb60 v8::api_internal::ToLocalEmpty() [/home/alleysira/node/node-v20.9.0-linux-x64/bin/node]</span><br><span class="line"> 4: 0xca0d9c  [/home/alleysira/node/node-v20.9.0-linux-x64/bin/node]</span><br><span class="line"> 5: 0xf26ecf v8::internal::FunctionCallbackArguments::Call(v8::internal::CallHandlerInfo) [/home/alleysira/node/node-v20.9.0-linux-x64/bin/node]</span><br><span class="line"> 6: 0xf2773d  [/home/alleysira/node/node-v20.9.0-linux-x64/bin/node]</span><br><span class="line"> 7: 0xf27c05 v8::internal::Builtin_HandleApiCall(int, unsigned long*, v8::internal::Isolate*) [/home/alleysira/node/node-v20.9.0-linux-x64/bin/node]</span><br><span class="line"> 8: 0x1931df6  [/home/alleysira/node/node-v20.9.0-linux-x64/bin/node]</span><br><span class="line">Aborted</span><br><span class="line">Killed</span><br></pre></td></tr></table></figure><p><img src="/2023/09/19/EVMFuzzer/image-20231203120926246.png" alt="image-20231203120926246"></p><p>具体原因是jsout.json和gethout.json太大了（5g），导致执行cmp.js时内存不足，已经排除虚拟机的问题</p><p>修改geth和jsevm的初始geth为0xffff</p><h2 id="jsevm-crash"><a href="#jsevm-crash" class="headerlink" title="jsevm crash"></a>jsevm crash</h2><p>环境：旧版的jsevm</p><p>表现：jsevm占满CPU资源，不释放，写了一个113G的大文件</p><p><img src="/2023/09/19/EVMFuzzer/image-20231109223105417.png" alt="image-20231109223105417"></p><p>收集错误信息尝试复现</p><p>合约0x663e4229142a27f00bafb5d087e1e730648314c3.sol共计2000行，包含18个具体的合约。造成错误时对应的函数是<code>tokensOfOwner</code>，code参数来自于文件<code>bincode_tokendsOfOwner_3/PandaMinting.bin-runtime</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Select contract:  PreProcess_0x663e4229142a27f00bafb5d087e1e730648314c3.sol</span><br><span class="line">Select function:  tokensOfOwner</span><br><span class="line">Input data:  0x8462151c0000000000000000000000006aebd02eb2bc4aea449f7555fb46a404e164e575</span><br><span class="line"></span><br><span class="line">/home/alleysira/EVMFuzzer/TestOut/contract88/seed/PreProcess_0x663e4229142a27f00bafb5d087e1e730648314c3_3.sol:78:5: Error: Function, variable, struct or modifier declaration expected.</span><br><span class="line">    ++ function tokensOfOwner(address _owner) external view</span><br><span class="line">    ^^</span><br><span class="line">1 PreProcess_0x663e4229142a27f00bafb5d087e1e730648314c3_3.sol</span><br><span class="line"></span><br><span class="line">Select contract:  PreProcess_0x663e4229142a27f00bafb5d087e1e730648314c3.sol</span><br><span class="line">Select function:  tokensOfOwner</span><br><span class="line">Input data:  0x8462151c0000000000000000000000006aebd02eb2bc4aea449f7555fb46a404e164e575</span><br><span class="line"></span><br><span class="line">PandaMinting.bin-runtime</span><br><span class="line"></span><br><span class="line">bincode </span><br><span class="line"></span><br><span class="line">608060405260043610610301576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806301ffc9a7146103065780630519ce791461036a57806306fd...</span><br></pre></td></tr></table></figure><p>导致wsl产生了Bus error</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">^CBus error</span><br><span class="line">alleysira@LAPTOP-M4HO8L6S:~/EVMFuzzer$ top -c</span><br><span class="line">Segmentation fault</span><br></pre></td></tr></table></figure><p><img src="/2023/09/19/EVMFuzzer/image-20231109224034073.png" alt="image-20231109224034073"></p><p>将wsl备份后，尝试进行复现，未能成功复现。结合windows的报错来看，可能是硬件内存故障</p><p><img src="/2023/09/19/EVMFuzzer/image-20231109223921434.png" alt="image-20231109223921434"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">                                            Detection Report</span><br><span class="line"></span><br><span class="line">After 14328.35s running, EVMFuzzer successfully generated 1135 seeds.</span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> In 0.0% (0/1135) of the tests, the output results are different from the standard execution.</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> In 0.0% (0/1135) of the tests, the gas consuming are more than the average value.</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> In 77.89% (884/1135) of the tests, the gas consuming are less than the average value.</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> In 22.11% (251/1135) of the tests, the gas consuming are equal to the average value.</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> In 33.83% (384/1135) of the tests, the execution sequence are more than the average value.</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> In 53.83% (611/1135) of the tests, the execution sequence are less than the average value.</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> In 12.33% (140/1135) of the tests, the execution sequence are equal to the average value.</span></span><br><span class="line"></span><br><span class="line">Final Conslusion:</span><br><span class="line">1. The code implementation of test EVM is relatively complete, can be used for Ethereum.</span><br><span class="line">2. The deviation of gas calculation is large, there exists dynamic optimization during the calculation process, and the optimization effect is good.</span><br><span class="line">3. The deviation of executing sequence is large, there exists dynamic optimization during the executing procedure, and the optimization effect is good.</span><br></pre></td></tr></table></figure><p>更新到最新版本后，依然没有复现成功</p><h1 id="manual-check"><a href="#manual-check" class="headerlink" title="manual check"></a>manual check</h1><h2 id="1129-manual-check"><a href="#1129-manual-check" class="headerlink" title="1129 manual check"></a>1129 manual check</h2><h3 id="contract15"><a href="#contract15" class="headerlink" title="contract15"></a>contract15</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;error&quot;</span>:<span class="string">&quot;js&amp;py_output+gas&quot;</span>,<span class="attr">&quot;js_output&quot;</span>:<span class="string">&quot;4e487b710000000000000000000000000000000000000000000000000000000000000012&quot;</span>,<span class="attr">&quot;py_output&quot;</span>:<span class="string">&quot;4e487b710000000000000000000000000000000000000000000000000000000000000001&quot;</span>,<span class="attr">&quot;js_gasUsed&quot;</span>:<span class="string">&quot;0xe75&quot;</span>,<span class="attr">&quot;py_gasUsed&quot;</span>:<span class="string">&quot;0x364&quot;</span>,<span class="attr">&quot;txdata&quot;</span>:<span class="string">&quot;87f71cef00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;</span>&#125; </span><br><span class="line">&#123;<span class="attr">&quot;error&quot;</span>:<span class="string">&quot;geth&amp;js_output+gas&quot;</span>,<span class="attr">&quot;geth_output&quot;</span>:<span class="string">&quot;4e487b710000000000000000000000000000000000000000000000000000000000000001&quot;</span>,<span class="attr">&quot;js_output&quot;</span>:<span class="string">&quot;4e487b710000000000000000000000000000000000000000000000000000000000000012&quot;</span>,<span class="attr">&quot;geth_gasUsed&quot;</span>:<span class="string">&quot;0x364&quot;</span>,<span class="attr">&quot;js_gasUsed&quot;</span>:<span class="string">&quot;0xe75&quot;</span>,<span class="attr">&quot;txdata&quot;</span>:<span class="string">&quot;87f71cef00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;</span>&#125; </span><br></pre></td></tr></table></figure><p>手动运行</p><p>code=MyContract.bin-runtime,sig=txdata</p><p>测试jsevm</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node benchmarkEVMs/jsEVM/runcode.js --code  --sig &gt; manCheck/jsout.json</span><br></pre></td></tr></table></figure><p>evm</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">benchmarkEVMs/evm --debug --json --code --input run &gt; manCheck/gethout.json</span><br></pre></td></tr></table></figure><p>pyevm </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 benchmarkEVMs/py-evm/main.py --data  --sig  &gt; manCheck/pyout.json</span><br></pre></td></tr></table></figure><p>实验验证发现三个虚拟机的输出是一致的，只不过如果pyevm是revert的话，会把revert当时的消息返回到stdout，而不是记录在json中，此时发现的不一致性应该是和上一轮的结果对比得到的</p><p><img src="/2023/09/19/EVMFuzzer/image-20231130194007013.png" alt="image-20231130194007013"></p><p>实际上问题在于记录txdata的模块有误，导致实际运行的参数和记录的不一致</p><h3 id="contract8"><a href="#contract8" class="headerlink" title="contract8"></a>contract8</h3><p>init 函数的调用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">code = 608060405234801561001057600080fd5b506004361061002b5760003560e01c8063a5843f0814610030575b600080fd5b61004a600480360381019061004591906100b4565b61004c565b005b80600080848152602001908152602001600020600082825461006e9190610123565b925050819055505050565b600080fd5b6000819050919050565b6100918161007e565b811461009c57600080fd5b50565b6000813590506100ae81610088565b92915050565b600080604083850312156100cb576100ca610079565b5b60006100d98582860161009f565b92505060206100ea8582860161009f565b9150509250929050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600061012e8261007e565b91506101398361007e565b9250828203905081811115610151576101506100f4565b5b9291505056fea26469706673582212205f70c63820cc0b692b6fcbc38408e72d7ec11e42ee43e008dfad6dade831de7164736f6c63430008160033</span><br><span class="line">sig = 0xa5843f0800000000000000000000000000000000000000000000000000000000f0c4de6400000000000000000000000000000000000000000000000000000000ac348fbf</span><br></pre></td></tr></table></figure><p>检查后发现同样是geth和pyevm revert，但是jsevm输出为空，复现成功，发现实际上是调用参数的问题，已排除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">geth&amp;pyevm revert with the same result</span><br><span class="line">4e487b710000000000000000000000000000000000000000000000000000000000000011</span><br><span class="line">jsout &quot;&quot;</span><br></pre></td></tr></table></figure><h3 id="contract45"><a href="#contract45" class="headerlink" title="contract45"></a>contract45</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">code = 608060405234801561001057600080fd5b50600436106100365760003560e01c806306661abd1461003b578063a444f5e914610059575b600080fd5b610043610075565b60405161005091906100af565b60405180910390f35b610073600480360381019061006e91906100fb565b61007b565b005b60005481565b8060008082825461008c9190610157565b9250508190555050565b6000819050919050565b6100a981610096565b82525050565b60006020820190506100c460008301846100a0565b92915050565b600080fd5b6100d881610096565b81146100e357600080fd5b50565b6000813590506100f5816100cf565b92915050565b600060208284031215610111576101106100ca565b5b600061011f848285016100e6565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600061016282610096565b915061016d83610096565b925082820390508181111561018557610184610128565b5b9291505056fea264697066735822122060a4627f3d1d3a1c54591b731ad267cadbd87d7cfd362c0e979629f8e9d658bd64736f6c63430008160033</span><br><span class="line">sig = 0xa444f5e9000000000000000000000000000000000000000000000000000000006357ee11</span><br></pre></td></tr></table></figure><p>复现成功，但实际上是调用参数的问题，已排除</p><h2 id="1203-1205-1206-manual-check"><a href="#1203-1205-1206-manual-check" class="headerlink" title="1203+1205+1206 manual check"></a>1203+1205+1206 manual check</h2><ul><li>1203 跑了curated所有的合约，solc 0.4.24</li></ul><p><img src="/2023/09/19/EVMFuzzer/image-20231203162214645.png" alt="image-20231203162214645"></p><p>从实验结果来看，最新的geth和py的实现较为完善，只有5个合约触发了不一致的输出，手工对不一致性进行分析</p><ul><li>1206 修复了jsevm caller的问题后，再进行一次相同规模的测试</li></ul><p>After 5063.21s running, EVMFuzzer successfully generated 2720 seeds.</p><p><img src="/2023/09/19/EVMFuzzer/image-20231206155011637.png" alt="image-20231206155011637"></p><h3 id="contract28-已排除"><a href="#contract28-已排除" class="headerlink" title="contract28 已排除"></a>contract28 已排除</h3><ul><li>合约：PreProcess_0x89c1b3807d4c67df034fffb62f3509561218d30b.sol </li><li>合约源码要求的编译器是0.4.9</li></ul><p>三个虚拟机均正常return，geth和py output与gas相同，jsevm不同</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;error&quot;</span>:<span class="string">&quot;js&amp;py_output+gas&quot;</span>,<span class="attr">&quot;js_output&quot;</span>:<span class="string">&quot;0000000000000000000000000000000000000000000000000000000000000001&quot;</span>,<span class="attr">&quot;py_output&quot;</span>:<span class="string">&quot;0400000000000000000000000000000000000000000000000000000000000000&quot;</span>,<span class="attr">&quot;js_gasUsed&quot;</span>:<span class="string">&quot;0xce36&quot;</span>,<span class="attr">&quot;py_gasUsed&quot;</span>:<span class="string">&quot;0x259b&quot;</span>,<span class="attr">&quot;txdata&quot;</span>:<span class="string">&quot;0x4c125e7900000000000000000000000000000000000000000000000000000000691cc6c9&quot;</span>&#125; </span><br><span class="line">&#123;<span class="attr">&quot;error&quot;</span>:<span class="string">&quot;geth&amp;js_output+gas&quot;</span>,<span class="attr">&quot;geth_output&quot;</span>:<span class="string">&quot;0400000000000000000000000000000000000000000000000000000000000000&quot;</span>,<span class="attr">&quot;js_output&quot;</span>:<span class="string">&quot;0000000000000000000000000000000000000000000000000000000000000001&quot;</span>,<span class="attr">&quot;geth_gasUsed&quot;</span>:<span class="string">&quot;0x259b&quot;</span>,<span class="attr">&quot;js_gasUsed&quot;</span>:<span class="string">&quot;0xce36&quot;</span>,<span class="attr">&quot;txdata&quot;</span>:<span class="string">&quot;0x4c125e7900000000000000000000000000000000000000000000000000000000691cc6c9&quot;</span>&#125; </span><br></pre></td></tr></table></figure><p>调用cancel函数导致的错误</p><p>geth的log出现了输出</p><p><img src="/2023/09/19/EVMFuzzer/image-20231203164124414.png" alt="image-20231203164124414"></p><p>看函数源码，geth和py都返回了FAIL_FLAG的值，但是jsevm返回的是SUCCESS_FLAG，进入了不同的分支，传入一个不存在的requests[requestId].requester时，jsevm中能够绕过requests[requestId].requester == msg.sender</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function cancel(uint64 requestId) public returns (int) &#123;</span><br><span class="line">        if (externalCallFlag) &#123;</span><br><span class="line">            throw;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (killswitch) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        uint fee = requests[requestId].fee;</span><br><span class="line">        if (requests[requestId].requester == msg.sender &amp;&amp; fee &gt;= CANCELLATION_FEE) &#123;</span><br><span class="line">            // If the request was sent by this user and has money left on it,</span><br><span class="line">            // then cancel it.</span><br><span class="line">            requests[requestId].fee = CANCELLED_FEE_FLAG;</span><br><span class="line">            externalCallFlag = true;</span><br><span class="line">            if (!msg.sender.call.value(fee - CANCELLATION_FEE)()) &#123;</span><br><span class="line">                throw;</span><br><span class="line">            &#125;</span><br><span class="line">            externalCallFlag = false;</span><br><span class="line">            Cancel(requestId, msg.sender, requests[requestId].requester, requests[requestId].fee, 1);</span><br><span class="line">            return SUCCESS_FLAG; //1, jsevm output</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Cancel(requestId, msg.sender, requests[requestId].requester, fee, -1);</span><br><span class="line">            return FAIL_FLAG; //geth and pyevm output</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在remix上复现同样得到了和geth pyevm相同的结果</p><p><img src="/2023/09/19/EVMFuzzer/image-20231205175003496.png" alt="image-20231205175003496"></p><p>修改msg.sender的地址后发现是误报</p><p><img src="/2023/09/19/EVMFuzzer/image-20231205175024037.png" alt="image-20231205175024037"></p><h3 id="contract29-已排除"><a href="#contract29-已排除" class="headerlink" title="contract29 已排除"></a>contract29 已排除</h3><ul><li><p>合约：0x9d06cbafa865037a01d322d3f4222fa3e04e5488.sol delta.sol</p></li><li><p>表现：geth和py reverted，消耗的gas相同，但是jsevm return了值，gas消耗也不同</p></li><li>函数：<ul><li>243f6e0c: change_active(uint256)</li><li>bec60bd2: change_token_price(uint256)</li><li>2e1a7d4d: withdraw(uint256)</li><li>均出现了一样的问题</li></ul></li></ul><p>先看change_active函数的运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">modifier onlyOwner() &#123;</span><br><span class="line">if (msg.sender != owner) &#123;</span><br><span class="line">       throw;</span><br><span class="line">   &#125;</span><br><span class="line">   _;</span><br><span class="line">&#125;    </span><br><span class="line"> //Change active</span><br><span class="line"> function change_active(uint256 _active) onlyOwner returns (bool result) &#123;</span><br><span class="line">   active = _active;</span><br><span class="line">   return true;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>正确的执行结果应该是revert，验证发现jsevm居然返回0000001(true)，jsevm是如何判断当前用户是owner的？修改返回值为false，返回值变成了全0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function withdraw(uint256 _amount) onlyOwner returns (bool result) &#123;</span><br><span class="line">    uint256 balance;</span><br><span class="line">    balance = this.balance;</span><br><span class="line">    if(_amount &gt; 0) balance = _amount;</span><br><span class="line">    // &lt;yes&gt; &lt;report&gt; UNCHECKED_LL_CALLS</span><br><span class="line">    owner.send(balance);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>withdraw函数中，返回值为true，又绕过了only owner修饰符，出现了越权访问</p><p>以及msg.sender=全0地址</p><p>jsevm中的默认的 msg.sender = 0000000000000000000000000000000000000000000000000000000000000000，显然不能和</p><p>执行 msg.sender==owner 成立，发现evm中执行没有静态状态变量的值，全是0</p><p>修改msg.sender的地址为与pyevm一致的地址0x1c7cd2d37ffd63856a5bd56a9af1643f2bcf545f后，该问题已解决</p><h3 id="contract33-已部分排除"><a href="#contract33-已部分排除" class="headerlink" title="contract33 已部分排除"></a>contract33 已部分排除</h3><ul><li>合约：PreProcess_list_dos_1.sol after_M5_lendGovernmentMoney_PreProcess_list_dos_1.sol</li><li>表现：py输出为空，报错invalid ; geth和jsevm输出全0但是正常返回</li><li>txdata：0xd95a2d42000000000000000000000000228cc1a8fda4b263de06a4596e20a8ad284df8e6</li><li>函数：lendGovernmentMoney(address)</li></ul><p>pyevm报错 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eth.exceptions.InvalidInstruction: Invalid opcode 0xfe @ 1264</span><br></pre></td></tr></table></figure><p>结合geth和jsevm的result.json，pyevm未能执行CALLER</p><ul><li>js的过程</li></ul><p><img src="/2023/09/19/EVMFuzzer/image-20231203191506616.png" alt="image-20231203191506616"></p><ul><li>py的过程</li></ul><p><img src="/2023/09/19/EVMFuzzer/image-20231203192319230.png" alt="image-20231203192319230"></p><p>正确的实验结果应该是报错，在remix vm上复现成功，geth和js均正确，pyevm返回为空</p><p>复现发现<code>pyevm</code>报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eth.exceptions.InvalidInstruction: Invalid opcode 0xfe @ 1264</span><br></pre></td></tr></table></figure><p>测试函数<code>lendGovernmentMoney(address)</code></p><p>为什么会有两个output，以及geth和jsevm均进入了第二个分支</p><p>原因：</p><ul><li>传入的<code>msg.value</code>不一样？pyevm默认的<code>msg.data = 0</code><ul><li><img src="/2023/09/19/EVMFuzzer/image-20231206172616178.png" alt="image-20231206172616178"></li></ul></li><li>pyevm 进入了 if (lastTimeOfNewCredit + TWELVE_HOURS &lt; block.timestamp)这个分支</li></ul><p>错误原因：pyevm能够读到timestamp，而geth和jsevm没有timestamp的值</p><p>进入同一个分支后，geth和jsevm burn all the gas，pyevm返回了两次？无法解释</p><h3 id="contract102-重复"><a href="#contract102-重复" class="headerlink" title="contract102 重复"></a>contract102 重复</h3><ul><li>合约：实际上就是contract33，函数签名都一样</li></ul><h3 id="contract122-已排除"><a href="#contract122-已排除" class="headerlink" title="contract122 已排除"></a>contract122 已排除</h3><p>问题大户，修改了caller之后已经不再出现该问题</p><ul><li><p>合约：contract FiftyFlip PreProcess_0xe09b1ab8111c2729a76f16de96bc86a7af837928_1.sol </p></li><li><p>表现：</p><ul><li>jsevm输出为空，geth和py输出有值，geth pyevm revert</li></ul></li><li><p>txdata：</p><ul><li>0x2d4f40c600000000000000000000000047a8320bfb820ef9098a1de8cf34d70f597c5e94</li><li>0xd702087f000000000000000000000000c3cfbdf2c080bb895e5b54108d6baf22319bbbb1</li><li>0xd493b9ac000000000000000000000000fb322ec50d729c4442d24fbf0cd53918c97bbbdf000000000000000000000000ccf49b92e14951c322d65d034faf3e3401f75bba000000000000000000000000000000000000000000000000000000006f926c24</li><li>0x89c5077f00000000000000000000000063c8e71019ee71b33287ec4a4a106b255e8a653f00000000000000000000000000000000000000000000000000000000e5ffe3f6</li></ul></li><li><p>函数：</p><ul><li><p>2d4f40c6: setBotAddress(address)</p><ul><li><p>geth和pyevm均revert且输出了相同的值，js没有输出，最后一个操作码是stop；</p></li><li><p>```shell</p><h1 id="pyevm-error"><a href="#pyevm-error" class="headerlink" title="pyevm error"></a>pyevm error</h1><p>eth.exceptions.Revert: b”\x08\xc3y\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00 \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00’You are not the owner of this contract!\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- d702087f: setSecretSigner(address)</span><br><span class="line"></span><br><span class="line">  - 和上一个一样，geth和pyevm均revert且输出了相同的值，js没有输出，最后一个操作码是stop</span><br><span class="line"></span><br><span class="line">  - ```shell</span><br><span class="line">    # pyevm error</span><br><span class="line">    eth.exceptions.Revert: b&quot;\x08\xc3y\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00 \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&#x27;You are not the owner of this contract!\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&quot;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>d493b9ac: transferAnyERC20Token(address,address,uint256)</p><ul><li>和上面两个类似，geth和pyevm均revert且输出了相同的值，但是此时jsevm revert，没输出</li></ul></li><li><p>89c5077f: withdrawDevFee(address,uint256)</p><ul><li><p>三者均revert，geth/py输出相同，jsevm的输出非常接近但是不一样</p><ul><li>jsevm： 08c379a00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003a596f752061726520747279696e6720746f207769746864726177206d6f726520616d6f756e74207468616e20646576656c6f706572206665652e000000000000</li><li>geth/py: 08c379a000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000027596f7520617265206e6f7420746865206f776e6572206f66207468697320636f6e74726163742100000000000000000000000000000000000000000000000000</li></ul></li><li><p>```shell<br>eth.exceptions.Revert: b”\x08\xc3y\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00 \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00’You are not the owner of this contract!\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 1212 manual check</span><br><span class="line"></span><br><span class="line">爬取了etherscan最新的4000个验证后的合约，合约基本均为0.8.x版本。将每个合约中的所有函数经过5轮变异</span><br><span class="line"></span><br><span class="line">仅发现了3类gas不一致，没有output不一致的情况</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">../expResult/1211/contract2802/result.json addeed</span><br><span class="line">../expResult/1211/contract1070/result.json addeed</span><br><span class="line">../expResult/1211/contract484/result.json addeed</span><br><span class="line">&#123;&#x27;js&amp;py_gas&#x27;: 0.5, &#x27;geth&amp;js_gas&#x27;: 0.4782608695652174, &#x27;geth&amp;py_gas&#x27;: 0.021739130434782608&#125;</span><br><span class="line">Total Error type:  3</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><p><img src="/2023/09/19/EVMFuzzer/image-20231211155836992.png" alt="image-20231211155836992" style="zoom: 50%;"></p><p><img src="/2023/09/19/EVMFuzzer/image-20231211155926329.png" alt="image-20231211155926329" style="zoom: 50%;"></p><p>逐个分析3个合约不一致性的来源</p><h3 id="contract-484"><a href="#contract-484" class="headerlink" title="contract 484"></a>contract 484</h3><ul><li><p>合约：PreProcess_0x17971fe4dd6f31c39d8608a5062b18ade246a87a_3.sol <a href="https://docs.bannochmoor.com/">https://docs.bannochmoor.com/</a></p></li><li><p>contractname：Bannochmoor</p></li><li><p>input: </p><ul><li>isBlacklisted(address) 0xfe575a87000000000000000000000000bffd98ec9ba3dc965b8a97d876670bb367fa84c2</li><li>setBlacklistEnabled(address,bool) 0xeec2744e00000000000000000000000050be92661fb0da16356a6e31f2208dc41663aa4d0000000000000000000000000000000000000000000000000000000000000000</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(env) alleysira@LAPTOP-M4HO8L6S:~/EVMFuzzer$ solc --bin-runtime manCheck/contract/PreProcess_0x17971fe4dd6f31c39d8608a5062b18ade246a87a.sol -o manCheck/contract/ --overwrite</span><br></pre></td></tr></table></figure><h4 id="isBlacklisted-address"><a href="#isBlacklisted-address" class="headerlink" title="isBlacklisted(address)"></a>isBlacklisted(address)</h4><p>执行函数isBlacklisted(address)，发现geth和pyevm的 gas消耗是0xcc6，jsout是0x168a</p><p>对比gethout.json和jsout.json，geth执行<code>staticcall</code>本来应该消耗 0x2f2485的gas，但是实际上没消耗</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//geth</span></span><br><span class="line">&#123;<span class="attr">&quot;pc&quot;</span>:<span class="number">16225</span>,<span class="attr">&quot;op&quot;</span>:<span class="number">250</span>,<span class="attr">&quot;gas&quot;</span>:<span class="string">&quot;0x2fe413&quot;</span>,<span class="attr">&quot;gasCost&quot;</span>:<span class="string">&quot;0x2f2485&quot;</span>,<span class="attr">&quot;memSize&quot;</span>:<span class="number">192</span>,<span class="attr">&quot;stack&quot;</span>:[<span class="string">&quot;0xfe575a87&quot;</span>,<span class="string">&quot;0xcaf&quot;</span>,<span class="string">&quot;0xbffd98ec9ba3dc965b8a97d876670bb367fa84c2&quot;</span>,<span class="string">&quot;0x0&quot;</span>,<span class="string">&quot;0x0&quot;</span>,<span class="string">&quot;0xfe575a87&quot;</span>,<span class="string">&quot;0xa4&quot;</span>,<span class="string">&quot;0x20&quot;</span>,<span class="string">&quot;0x80&quot;</span>,<span class="string">&quot;0x24&quot;</span>,<span class="string">&quot;0x80&quot;</span>,<span class="string">&quot;0x0&quot;</span>,<span class="string">&quot;0x2fe413&quot;</span>],<span class="attr">&quot;depth&quot;</span>:<span class="number">1</span>,<span class="attr">&quot;refund&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;opName&quot;</span>:<span class="string">&quot;STATICCALL&quot;</span>&#125;</span><br><span class="line"><span class="comment">//jsout</span></span><br><span class="line">&#123;<span class="attr">&quot;pc&quot;</span>:<span class="number">16225</span>,<span class="attr">&quot;gas&quot;</span>:<span class="string">&quot;0xf43a&quot;</span>,<span class="attr">&quot;gasCost&quot;</span>:<span class="string">&quot;0x0&quot;</span>,<span class="attr">&quot;memory&quot;</span>:<span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012800000000000000000000000000000000254879013500000000000019125315223615516322015091138151216118103111791032501321940000000000000000000000000000&quot;</span>,<span class="attr">&quot;memsize&quot;</span>:<span class="string">&quot;6&quot;</span>,<span class="attr">&quot;stack&quot;</span>:[<span class="string">&quot;0xfe575a87&quot;</span>,<span class="string">&quot;0xcaf&quot;</span>,<span class="string">&quot;0xbffd98ec9ba3dc965b8a97d876670bb367fa84c2&quot;</span>,<span class="string">&quot;0x0&quot;</span>,<span class="string">&quot;0x0&quot;</span>,<span class="string">&quot;0xfe575a87&quot;</span>,<span class="string">&quot;0xa4&quot;</span>,<span class="string">&quot;0x20&quot;</span>,<span class="string">&quot;0x80&quot;</span>,<span class="string">&quot;0x24&quot;</span>,<span class="string">&quot;0x80&quot;</span>,<span class="string">&quot;0x0&quot;</span>,<span class="string">&quot;0xf43a&quot;</span>],<span class="attr">&quot;depth&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;opName&quot;</span>:<span class="string">&quot;STATICCALL&quot;</span>&#125;</span><br><span class="line"><span class="comment">//py</span></span><br><span class="line">&#123;<span class="attr">&quot;pc&quot;</span>: <span class="number">16225</span>, <span class="attr">&quot;op&quot;</span>: <span class="number">250</span>, <span class="attr">&quot;gas&quot;</span>: <span class="string">&quot;0xa082&quot;</span>, <span class="attr">&quot;gasCost&quot;</span>: <span class="string">&quot;0x0&quot;</span>, <span class="attr">&quot;stack&quot;</span>: [<span class="string">&quot;0xfe575a87&quot;</span>, <span class="string">&quot;0xaf0c&quot;</span>, <span class="string">&quot;0xc284fa67b30b6776d8978a5b96dca39bec98fdbf&quot;</span>, <span class="string">&quot;0x0&quot;</span>, <span class="string">&quot;0x0&quot;</span>, <span class="string">&quot;0x875a57fe&quot;</span>, <span class="string">&quot;0xa4&quot;</span>, <span class="string">&quot;0x20&quot;</span>, <span class="string">&quot;0x8000000000000000000000000000000000000000000000000000000000000000&quot;</span>, <span class="string">&quot;0x24&quot;</span>, <span class="string">&quot;0x8000000000000000000000000000000000000000000000000000000000000000&quot;</span>, <span class="string">&quot;0x0&quot;</span>, <span class="string">&quot;0xa082&quot;</span>], <span class="attr">&quot;depth&quot;</span>: <span class="number">0</span>, <span class="attr">&quot;opName&quot;</span>: <span class="string">&quot;STATICCALL&quot;</span>, <span class="attr">&quot;error&quot;</span>: <span class="string">&quot;None&quot;</span> &#125;</span><br></pre></td></tr></table></figure><p>其中，pyevm依然出现了之前的2次返回的情况，执行<code>staticcall</code>后返回了</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;pc&quot;</span>: <span class="number">0</span>, <span class="attr">&quot;op&quot;</span>: <span class="number">0</span>, <span class="attr">&quot;gas&quot;</span>: <span class="string">&quot;0x9d9e&quot;</span>, <span class="attr">&quot;gasCost&quot;</span>: <span class="string">&quot;0x0&quot;</span>, <span class="attr">&quot;stack&quot;</span>: [], <span class="attr">&quot;depth&quot;</span>: <span class="number">1</span>, <span class="attr">&quot;opName&quot;</span>: <span class="string">&quot;STOP&quot;</span>, <span class="attr">&quot;error&quot;</span>: <span class="string">&quot;None&quot;</span> &#125;</span><br><span class="line">&#123;<span class="attr">&quot;output&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="attr">&quot;gasUsed&quot;</span>: <span class="string">&quot;0x0&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>看函数，未初始化的全局变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Initializer initializer;</span><br><span class="line"></span><br><span class="line">function isBlacklisted(address account) external view returns (bool) &#123;</span><br><span class="line"></span><br><span class="line">    return initializer.isBlacklisted(account);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在remix上部署报错</p><ul><li><p>Warning: Contract code size is 31376 bytes and exceeds 24576 bytes (a limit introduced in Spurious Dragon). This contract may not be deployable on Mainnet. Consider enabling the optimizer (with a low “runs” value!), turning off revert strings, or using libraries.   —&gt; contracts/test.sol:207:1:    | 207 | contract Bannochmoor is IERC20 {    | ^ (Relevant source part starts here and spans across multiple lines). </p></li><li><p>Contract creation initialization returns data with length of more than 24576 bytes. The deployment will likely fail if the current network has activated the eip 170. More info: <a href="https://eips.ethereum.org/EIPS/eip-170">eip-170</a></p></li></ul><p>通过开启优化器解决源代码文件过大的问题</p><p><img src="/2023/09/19/EVMFuzzer/image-20231211212219307.png" alt="image-20231211212219307"></p><p>对于staticcall的gas消耗的计算：<a href="https://github.com/wolflo/evm-opcodes/blob/main/gas.md#aa-4-staticcall">https://github.com/wolflo/evm-opcodes/blob/main/gas.md#aa-4-staticcall</a></p><p>分析一下具体执行了哪些操作码和对应的个数：整挺好，发现geth多了一个<code>STOP</code></p><p>发现不同操作码的gas消耗确实不太一样，NeoDiff没有记录这些操作码</p><p>MSTORE</p><ul><li>geth C+9+6+3=30</li><li>js and py: 3+3+3+3=12</li></ul><p>非常奇怪，从输出来看js和py是一样的，但实际执行结果是geth和py一致，js不同</p><h4 id="setBlacklistEnabled-address-bool"><a href="#setBlacklistEnabled-address-bool" class="headerlink" title="setBlacklistEnabled(address,bool)"></a>setBlacklistEnabled(address,bool)</h4><p>看一下第二个函数，执行bincode_setBlacklistEnabled_3/Bannochmoor.bin-runtime时出现了jsevm gas不一致，py geth 0x15c6, jsevm 0x1f8a</p><p>原来是onlyOwner被变异了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">modifier onlyOwner() &#123; </span><br><span class="line">         require(_owner &lt;= msg.sender, &quot;Caller =/= owner.&quot;); _; </span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">modifier onlyOwner() &#123; </span><br><span class="line">         require(_owner == msg.sender, &quot;Caller =/= owner.&quot;); _; </span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><p>导致了gas不一致的结果，但是保证jsevm和pyevm的sender一样也有不一致性</p><h3 id="contract-1070-已排除"><a href="#contract-1070-已排除" class="headerlink" title="contract 1070 已排除"></a>contract 1070 已排除</h3><ul><li><p>合约：PreProcess_0xdabb3d9d0d2c36a4131b301444672111fcbf5ceb_3.sol</p></li><li><p>input: </p><ul><li><p>5d37a8dd: assureCanTransfer(address,address,address,uint256)</p><p>0x5d37a8dd000000000000000000000000383fc804d250a74fa346deb30b0396d97e226ed6000000000000000000000000d98e3a0fbdd3ef5eadca9ad24a09abfa93c9235100000000000000000000000009988669ba6b8a9aa2aee66e71c94faf26562b5200000000000000000000000000000000000000000000000000000000a85d2903</p></li></ul></li><li><p>表现：py different with geth and js</p></li></ul><p>和未变异的合约相比，将<code>！=</code>变为了<code>&gt;</code>，因此是调用方式造成的不一致性，卒</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    function assureCanTransfer( address msgSender, address from, address to, uint256) external &#123;</span><br><span class="line">    // msg.sender !=  </span><br><span class="line">        if (msg.sender &gt; 0xbddc20ed7978B7d59eF190962F441cD18C14e19f) return;</span><br><span class="line">        bytes32 cachedBanned = banned;</span><br><span class="line">        if (</span><br><span class="line">            keccak256(abi.encodePacked(msgSender)) &gt;= cachedBanned &amp;&amp;</span><br><span class="line">            keccak256(abi.encodePacked(from)) &lt;= cachedBanned &amp;&amp;</span><br><span class="line">            keccak256(abi.encodePacked(to)) &lt;= cachedBanned</span><br><span class="line">        ) revert Banned();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="contract-2802-已排除"><a href="#contract-2802-已排除" class="headerlink" title="contract 2802 已排除"></a>contract 2802 已排除</h3><p>提供了最多的gas不一致</p><ul><li><p>合约：PreProcess_0xd85cc69b92fbd5551870e7def7baeba764008395.sol</p></li><li><p>input: </p><ul><li>getClaimableDividendOf(address) 0x8ecc37fb0000000000000000000000004ccaf589fc374ccad1f79b5b339322f9cf19c65f</li><li>getDividendsClaimedOf(address)  0x5cc33f74000000000000000000000000521c755ce0c5f49e708d327789892ba0ff2416e1</li><li>getDividendsClaimedOf(address)  0x5cc33f740000000000000000000000003bde5776e515c56d4a083e2e1ec32bd7f60805c6</li></ul></li><li>表现：js different with geth and py</li></ul><p>DividendDistributor.bin-runtime和IDividendDistributor.signature都有5cc33f74，但是后者.bin-runtime为空</p><p>对于函数getClaimableDividendOf(address) ，无法复现，猜测是已经通过设置相同的地址解决了</p><h1 id="opcodes"><a href="#opcodes" class="headerlink" title="opcodes"></a>opcodes</h1><p>以太坊官方对操作码介绍：<a href="https://ethereum.org/en/developers/docs/evm/opcodes/">https://ethereum.org/en/developers/docs/evm/opcodes/</a></p><p>操作码和对应的gas：<a href="https://www.evm.codes/?fork=shanghai">https://www.evm.codes/?fork=shanghai</a></p><p>查阅字节码：<a href="https://github.com/wolflo/evm-opcodes">https://github.com/wolflo/evm-opcodes</a></p><p>2Hours crash course：<a href="https://www.youtube.com/watch?v=8p7RKYJ9AF0&amp;ab_channel=UttamSingh">https://www.youtube.com/watch?v=8p7RKYJ9AF0&amp;ab_channel=UttamSingh</a></p><h2 id="Yellow-paper"><a href="#Yellow-paper" class="headerlink" title="Yellow paper"></a>Yellow paper</h2><p>学习以太坊官方对EVM的介绍：<a href="https://ethereum.org/en/developers/tutorials/yellow-paper-evm/">https://ethereum.org/en/developers/tutorials/yellow-paper-evm/</a></p><h3 id="EVM-Basic"><a href="#EVM-Basic" class="headerlink" title="EVM Basic"></a>EVM Basic</h3><p>EVM栈的深度为1024，每个单元大小为256比特，方便哈希运算和椭圆曲线运算</p><p>memory是32字节长，初始为全0，执行<code>mstore(0, 0x60A7)</code>之后，内存的0-29都是<code>0</code>，30是<code>0x60</code>,31是<code>0xa7</code></p><p>EVM的四类内存：stack memory storge calldata</p><p>标准的冯诺依曼架构将code和data存储在同一个内存中，EVM为了安全性期间没有采用这样的设计，将代码存储在storge中</p><h3 id="Fees-OVERVIEW"><a href="#Fees-OVERVIEW" class="headerlink" title="Fees OVERVIEW"></a>Fees OVERVIEW</h3><ul><li>操作码：存在对应的计算公式</li><li>运行消耗：创建合约、调用合约</li><li>扩展内存：gas消耗和内存的平方成正比</li></ul><p>以上仅是定义的gas价格，没有考虑市场中对validator的消费</p><h3 id="Execution-environment"><a href="#Execution-environment" class="headerlink" title="Execution environment"></a>Execution environment</h3><p><img src="/2023/09/19/EVMFuzzer/image-20231203153419624.png" alt="image-20231203153419624"></p><h3 id="EVM-Execution-Overview"><a href="#EVM-Execution-Overview" class="headerlink" title="EVM Execution Overview"></a>EVM Execution Overview</h3><p>退出时的操作码：RETURN REVERT STOP SELFSTRUCT </p><p><img src="/2023/09/19/EVMFuzzer/image-20231203154214956.png" alt="image-20231203154214956"></p><p>第二条，如果执行的操作码是REVERT，新的状态和旧的相同，损失部分gas</p><p>正常的halting</p><ul><li>如果操作码不是halt，返回空集</li><li>如果遇到STOP或SELFDESTRUCT，返回0字节</li><li>如果遇到return和revert，从内存中返回操作码指定的字节，栈顶是第一个字节，第二个值是长度</li></ul><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><h2 id="论文阅读"><a href="#论文阅读" class="headerlink" title="论文阅读"></a>论文阅读</h2><ul><li>发现了不一致性后，如何解释一致性可能产生的影响——攻击者可以操作合约输出不一致的结果<ul><li>如何寻找bug的来源——手工分析</li></ul></li><li>能不能测试其他的安全组件？consensus implementation</li><li>采用的中间表示形式是AST，换成3AC或者SSA是否具有可行性？<ul><li>后续的opcode不同和gas是否可能是由CAST转换为solidity的过程引入的</li><li>设计变异器时利用了控制流，直观理解是更合适</li><li>solc本身支持输出ast形式</li><li><img src="/2023/09/19/EVMFuzzer/image-20231020143445389.png" alt="image-20231020143445389"></li><li><img src="/2023/09/19/EVMFuzzer/image-20230920183950597.png" alt="image-20230920183950597"></li></ul></li><li>time_pri仅加1，合理性在于初始值为0-10</li><li>dif的定义应该有问题，需要把abs拆开</li><li>编译器的版本为0.4.24，如果对新的版本的合约进行差分测试，需要进行哪些更改</li><li><p>考虑操作码一致性时，为什么不考虑结果不同的，也可以说明一定问题？</p><ul><li>只有结果一致的，才能说明benchmark是有效的，因为被参考的4个虚拟机之间就有非常多差异</li></ul></li><li><p><del>给出该论文的后续工作，已解决</del></p><ul><li><a href="https://scholar.google.com/scholar?start=0&amp;hl=en&amp;as_sdt=2005&amp;sciodt=0,5&amp;cites=7702365947421966340&amp;scipsc=">Fu: Evmfuzzer: detect evm vulnerabilities via fuzz testing - Google Scholar</a></li></ul></li></ul><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><ul><li>如何确定发现的不一致性可能导致的危害<ul><li>可能导致网络分叉，算力占多数的节点采用的客户端会成为网络的主链</li><li>上层应用对区块链的状态的认识可能不正确</li><li>恶意的开发者可能利用合约执行差异的漏洞来隐藏后门</li></ul></li></ul><p>和王老师交流内容</p><ul><li><p>目前工作：</p><ul><li>阅读代码实现，修正功能实现上的错误，如错误调用jsevm、aleth always true</li><li>增加了对geth pyevm jsevm aleth之间进行对比的代码</li><li>种子合约大约给了200个，1500+，简单的分析</li></ul></li><li><p>理想的一个工具，距离一篇论文</p><ul><li>测试对象：targetEVM 测试的虚拟机的版本、编译器的版本</li><li>针对现有的EVM compatible的链的虚拟机来做测试</li><li>如何找漏洞：输出output不同的地方，如何解释输入会导致不同</li><li>定义安全参数：opcode/gas diff</li></ul></li></ul><h1 id="请教"><a href="#请教" class="headerlink" title="请教"></a>请教</h1><ul><li>1214 杰峰</li><li>0107 贺宁宇<ul><li>介绍基本情况，复现了evmfuzzer，差分模糊测试，standalone 没有前置状态，seed是种子</li><li>变异 拿收集的合约solc编译成字节码再跑，变异的话是在ast上变异完反到solidity上去再编译到字节码，Etherscan4000个，每个函数执行5次，发现的问题都是gas相关的。<ul><li>实验的意义，是否可能发现</li><li>直接生成字节码的 比较适合参考的工作<ul><li>wasm直接生成opcode</li><li>不能直接基于字节码</li></ul></li><li>实验对象 EVM兼容1.0 2.0代表性</li><li>构造攻击：可能导致分叉，双花和拒绝服务</li><li>不需要权限的合约，mutation的base，种类，合约的 ERC20/720/DEFI，合约的占比，全部都爬下来sample，全节点</li><li>mutation based testing: </li><li>+状态：先做standalone，优先级</li></ul></li><li>反馈是操作码序列和gas</li><li>基于源码的工作太弱了，学术界认可度不高</li></ul></li></ul><h1 id="CVE"><a href="#CVE" class="headerlink" title="CVE"></a>CVE</h1><p>回头看一下论文的CVE，实际上都没有得到开发者的确认，质量堪忧</p><ul><li><p><a href="https://github.com/ethereum/py-evm/issues/1448">https://github.com/ethereum/py-evm/issues/1448</a></p></li><li><p><a href="https://github.com/ethereumjs/ethereumjs-monorepo/issues/386">https://github.com/ethereumjs/ethereumjs-monorepo/issues/386</a></p></li><li><a href="https://github.com/ethereum/go-ethereum/issues/18069">https://github.com/ethereum/go-ethereum/issues/18069</a> <a href="https://github.com/ethereumjs/ethereumjs-monorepo/issues/395">https://github.com/ethereumjs/ethereumjs-monorepo/issues/395</a><ul><li><img src="/2023/09/19/EVMFuzzer/image-20231204145531439.png" alt="image-20231204145531439"></li></ul></li></ul><p>在CNVD发现同一个issue拿了两个CNVD编号</p><p><a href="https://www.cnvd.org.cn/flaw/show/CNVD-2020-34744">https://www.cnvd.org.cn/flaw/show/CNVD-2020-34744</a></p><p><a href="https://www.cnvd.org.cn/flaw/show/CNVD-2018-24156，带CVE">https://www.cnvd.org.cn/flaw/show/CNVD-2018-24156，带CVE</a></p><p>blocksec挖的两个cve</p><p><a href="https://nvd.nist.gov/vuln/detail/CVE-2020-26241">https://nvd.nist.gov/vuln/detail/CVE-2020-26241</a></p><h1 id="TO-DO"><a href="#TO-DO" class="headerlink" title="TO DO"></a>TO DO</h1><ul><li>[ ] 工具实现<ul><li>[ ] 重构模块<ul><li>[x] 保留pyevm jsevm geth，去掉aleth和own vm</li><li>[ ] 测试网中部署/运行合约，实现geth和jsevm完整的带链上状态和交易的实验<ul><li>[ ] 思考为了测试操作码的话是否有必要</li></ul></li></ul></li></ul></li><li>[ ] 收集数据集<ul><li>[x] .sol数据集<ul><li>[x] 目前爬了4000个etherscan中的合约</li></ul></li><li>[ ] bin runtime数据集：也爬etherscan</li><li>[ ] 总结github issue的pattern</li></ul></li><li>[ ] 基于操作码进行变异<ul><li>[ ] 学习NeoDiff的设计</li><li>[ ] 总结对合约进行fuzz的工具</li></ul></li><li>[ ] 不一致性复现<ul><li>[x] 发现了jsevm不revert的例子，等待与开发者确认</li><li>[x] 手动检查1203simplify</li><li>[x] 询问王老师如何判断合约不一致性可能导致的问题，手工分析</li><li>[x] check Government<ul><li>[x] 向开发者提issue</li></ul></li><li>[ ] 分析4000个合约运行后revert的原因，如何避免<ul><li>[x] 咨询杰峰同志，去读gas meter</li></ul></li><li>[ ] static call操作码消耗值的计算</li><li>[ ] jsevm和py geth 消耗的gas不一样的问题</li></ul></li><li>[ ] 功能修复<ul><li>[x] result.json中的txdata永远是函数签名+全0：cmp.js中的yargs模块误用</li><li>[x] geth不支持solc —evm-version shanghai，使用prestate参数解决</li><li>[x] 解决了caller默认为全0导致与状态变量判断相等的问题</li><li>[x] 解决了solc 0.8.x 版本会编译出Error signatures和 Evnet signatures的问题</li><li>[ ] solc可能无法编译出过大合约的问题，考虑默认开启optimizer？</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;EVMFuzzer-Detect-EVM-Vulnerabilities-via-Fuzz-Testing&quot;&gt;&lt;a href=&quot;#EVMFuzzer-Detect-EVM-Vulnerabilities-via-Fuzz-Testing&quot; class=&quot;headerlink&quot; title=&quot;EVMFuzzer: Detect EVM Vulnerabilities via Fuzz Testing&quot;&gt;&lt;/a&gt;EVMFuzzer: Detect EVM Vulnerabilities via Fuzz Testing&lt;/h1&gt;&lt;p&gt;Fu Y, Ren M, Ma F, et al. Evmfuzzer: detect evm vulnerabilities via fuzz testing[C]//Proceedings of the 2019 27th ACM joint meeting on european software engineering conference and symposium on the foundations of software engineering. 2019: 1110-1114.&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/categories/Blockchain/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="SmartContract" scheme="https://alleysira.github.io/tags/SmartContract/"/>
    
  </entry>
  
  <entry>
    <title>trusted_computing</title>
    <link href="https://alleysira.github.io/2023/09/17/trusted-computing/"/>
    <id>https://alleysira.github.io/2023/09/17/trusted-computing/</id>
    <published>2023-09-17T11:04:12.000Z</published>
    <updated>2023-12-28T11:49:20.433Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>写写作业，记记笔记（maybe</p><span id="more"></span><h1 id="Reflections-on-Trusting-Trust——KEN-THOMPSON"><a href="#Reflections-on-Trusting-Trust——KEN-THOMPSON" class="headerlink" title="Reflections on Trusting Trust——KEN THOMPSON"></a>Reflections on Trusting Trust——KEN THOMPSON</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><p>吹水部分提到了Dennis Ritchie（C语言之父），他俩有一次写了个20行 <em>逐字符</em> 相同的汇编程序（磕到了）</p><p>程序员这个职业是Ken写在个人收入申报表上的职业，因此他介绍了他写过的最好玩的一个程序</p><ul><li>Stage1：写出最短的编译运行后能够生成自己源码的程序</li><li>Stage2：learning program的思路是教会编译器如何处理给定的字符</li><li>Stage3：当编译器匹配到某个pattern时，编译出bug</li></ul><p>以上步骤组合起来，修改编译器编译出bin、安装为库后，再恢复为正常的编译器，由于程序是可复制的，后续所有采用该库编译的代码都会有bug而无迹可寻</p><p>作者给出了很有哲理的结论：You can’t trust code that you did not totally create yourself. 不要信任非自己亲手写的代码（反思自己平常用的github上star不多的代码和gpt生成的代码）</p><p>最后呼吁了媒体严肃对黑客这一群体的认识，媒体对他们的报告是“神童”，一种偏褒义的评价。然而实际上侵入计算机系统的后果最轻是故意破坏公物，最坏是非法侵入和盗窃等罪名，还是很严肃的。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>真的无迹可寻吗？如果反编译可执行文件，发现执行逻辑和源码不同，就会意识到程序有bug，寻找bug的源头可能会去检查编译器的版本，发现编译器没问题可能就会去查看依赖库（当然比较难找了）</p><h1 id="Recognizing-Safety-and-Liveness——Bowen-Alpern"><a href="#Recognizing-Safety-and-Liveness——Bowen-Alpern" class="headerlink" title="Recognizing Safety and Liveness——Bowen Alpern"></a>Recognizing Safety and Liveness——Bowen Alpern</h1><h2 id="主要内容-1"><a href="#主要内容-1" class="headerlink" title="主要内容"></a>主要内容</h2><p>安全性和活性的通俗理解：</p><ul><li>安全性：坏事儿不会发生，证明满足性质是不变性论证</li><li>活性：好事儿最终会发生（类比区块链的活性，诚实用户的交易在一定时间后一定会出现在诚实节点的账本中），证明满足性质是良基论证</li></ul><p>本篇论文的主要工作包括：</p><ul><li>通过测试来判断一个Büchi有限状态自动机描述的性质是否满足活性和安全性<ul><li>证明了对于确定性Büchi有限状态自动机的性质，可以用不变性论证来证明；</li><li>活性可以通过良基论证来证明</li></ul></li><li>给出了活性和安全性的形式化定义</li><li>给出了将性质分解为活性和安全性的方法，其中活性和安全性的合取就是原始属性</li></ul><p>Büchi有限状态自动机接受两类输入</p><ul><li><p>所有第一个状态满足谓词 $\neg Pre$的无限序列</p></li><li><p>满足$Pre\  \neg Done \ Done\wedge Post$的无限序列</p><p><img src="/2023/09/17/trusted-computing/image-20231228155506277.png" alt="image-20231228155506277"></p></li></ul><p>如果对每个状态存在能到接收状态的路径，称Büchi有限状态自动机是可缩减的</p><p>对于安全性的定义的理解是对于性质$P$，如果在无限序列$\sigma$中坏事发生了，一定在有限前缀后，能够符合$P$；如果$\sigma$不符合$P$，说明存在$\sigma$的某个前缀包括坏事，对于该前缀的任何扩展，都不会满足$P$。</p><script type="math/tex; mode=display">\text { Safety: }\left(\forall \sigma: \sigma \in S^\omega: \sigma \models P \Leftrightarrow\left(\forall i: 0 \leq i:\left(\exists \beta: \beta \in S^\omega: \sigma[. . i] \beta=P\right)\right)\right)</script><p>对于活性的定义，需要观察到的是，没有任何部分执行是不可挽回的，因为如果某个部分执行是不可挽回的，那么它就是一个坏事。作者认为这是活性的定义特征。如果属性$P$满足以下条件，则$P$是一个活性属性</p><script type="math/tex; mode=display">\text { Liveness: }\left(\forall \alpha: \alpha \in S^*:\left(\exists \beta: \beta \in S^\omega: \alpha \beta \vDash P\right)\right)</script><h2 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h2><p>这篇论文采用有限状态自动机来形式化地描述和验证性质，我很好奇是否存在其他的模型能够被用来形式化这些性质，以及在具体的应用场景中，比如区块链上，是否可以通过设计一个静态分析或形式化验证的工具，定义一些性质来检测区块链共识的漏洞。</p><h1 id="Fairness-Through-Awareness——Cynthia-Dwork"><a href="#Fairness-Through-Awareness——Cynthia-Dwork" class="headerlink" title="Fairness Through Awareness——Cynthia Dwork"></a>Fairness Through Awareness——Cynthia Dwork</h1><h2 id="主要内容-2"><a href="#主要内容-2" class="headerlink" title="主要内容"></a>主要内容</h2><p>本文研究的是分类中的公平性，主要贡献在于是提出了一个公平分类的框架</p><ul><li>用于确定个体在当前分类任务中相似程度的（假设性的）任务特定度量</li><li>在公平约束条件下最大化效用的算法，即对待相似的个体应类似对待</li></ul><p>本文还讨论了公平性与隐私的关系，公平性何时暗示隐私，以及在差分隐私背景下开发的工具如何应用于公平性问题。提供了一个公平分类的规范方法和一个实现公平性的框架。</p><h2 id="思考-2"><a href="#思考-2" class="headerlink" title="思考"></a>思考</h2><p>本文主要的idea是实现相似的人在分类中被类似地对待，讨论部分提出的在广告领域中的公平性是否会隐藏广告商的信息的问题非常有趣，从相反的视角来考虑提升公平性可能带来对隐私的破坏。（隐隐看来本文的工作非常契合西方对”政治正确”的偏好）</p><h1 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h1><p>BLP模型中的安全等级可以更改</p><ul><li>谁可以更改：安全服务的使用者</li><li>什么时候可以更改：$\text{收益}\leq\text{成本}$ 时不会更改</li><li>如何判断是否应该改？本质是上一个问题，需要量化当前的收益，cybersecurity inssurance</li></ul><p>存在Covert Channel</p><p>完整性指信息的真实性 可靠性</p><p>可用性：信息匹配服务</p><h2 id="安全策略的执行和验证"><a href="#安全策略的执行和验证" class="headerlink" title="安全策略的执行和验证"></a>安全策略的执行和验证</h2><p>可扩展系统的的安全性</p><ul><li>插件</li><li>应用</li><li>服务器跑脚本</li></ul><p>可用方法</p><ul><li>类型检查</li><li>静态验证</li><li>代码重构（目前国产软件的层次）</li><li>运行时强制执行（重点介绍）</li></ul><p>前两个方法需要代码审计者的程序设计水平更高</p><p>利用执行监视器强制实施安全策略，只能获得程序原子操作一次执行的结果，例子</p><ul><li>文件系统访问控制</li><li>防火墙</li><li>堆栈检查</li><li>动态边界检查</li><li>恶意软件检测器</li><li>Chrome SP</li></ul><p>审计监视策略的缺点：滞后性，只有发生事件之后才能观察到</p><h2 id="引用监视器"><a href="#引用监视器" class="headerlink" title="引用监视器"></a>引用监视器</h2><p>机制完整性：假设输入符号对应实际执行，真实的状态转换对应于自动机的转换函数，建模可以覆盖100%的程序</p><p>解决策略</p><ul><li>隔离：目标程序无法写自动机的内部表示</li><li>complete mediation：一个变量在研究中完全传递或完全解释了两个其他变量之间的关系</li></ul><p>如何证明程序S满足策略集合P：</p><p>当S违反任意策略时终止，否则继续运行</p><p>需要保证实施方案符合隔离、complete mediations</p><p>重写器：输入机器语言程序，输出嵌入了安全策略的程序</p><h2 id="trusted-machine-learning"><a href="#trusted-machine-learning" class="headerlink" title="trusted machine learning"></a>trusted machine learning</h2><p>目前的LLM可分为预训练模型（基模型）+特定任务模型</p><p>大模型的参数增长速度远远大于摩尔定律算力的增长，无法采用静态分析类似的思想进行大模型的安全性分析，后续的工作都是抽查的思想</p><p>训练数据本身存在误差</p><p>如果训练数据没有误差是否会正确</p><p>消除幻觉</p><p>一致性</p><p>对齐：和人类社会的规则、价值观保持一致</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;写写作业，记记笔记（maybe&lt;/p&gt;</summary>
    
    
    
    
    <category term="Coursework" scheme="https://alleysira.github.io/tags/Coursework/"/>
    
    <category term="Trsted Computing" scheme="https://alleysira.github.io/tags/Trsted-Computing/"/>
    
  </entry>
  
  <entry>
    <title>program_analysis_NJU</title>
    <link href="https://alleysira.github.io/2023/08/31/program-analysis-NJU/"/>
    <id>https://alleysira.github.io/2023/08/31/program-analysis-NJU/</id>
    <published>2023-08-31T02:27:00.000Z</published>
    <updated>2023-10-11T13:03:47.778Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>学习南京大学的静态程序分析技术课程</p><p>课程主页：<a href="https://tai-e.pascal-lab.net/lectures.html">Static Program Analysis | Tai-e (pascal-lab.net)</a></p><p>共计32小时</p><span id="more"></span><h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>PL的三个研究方向</p><ul><li>理论</li><li>环境</li><li>应用<ul><li>程序分析<ul><li>静态程序分析</li></ul></li></ul></li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230831102930623.png" alt="image-20230831102930623"></p><p>静态分析：在编译时对程序进行检测</p><p>静态程序分析的应用</p><ul><li>程序可靠性</li><li>安全性</li><li>编译优化<ul><li>O(1)</li></ul></li><li>程序理解<ul><li>IDE实现的call的提示：利用静态分析实现</li></ul></li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230831103339266.png" alt="image-20230831103339266"></p><p>运行程序前了解程序的性质和行为（写一个程序来分析，分析器）</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230831104435688.png" alt="image-20230831104435688"></p><ul><li>运行时可能指向同一地址吗<ul><li>需要加锁解决竞争问题</li></ul></li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230831104701170.png" alt="image-20230831104701170"></p><p>对于一个正常的语言写的程序，我们感兴趣的运行时的性质是否满足 是不可判定的，即不存在完美的静态分析</p><p>perfect static analysis满足</p><ul><li>sound：包含所有truth，过近似</li><li>complete：是truth的子集，欠近似</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230831105420735.png" alt="image-20230831105420735"></p><p>不存在perfect，因此想要一种useful的静态分析，可以仅满足一种性质，妥协另一种性质</p><ul><li>满足soundness：存在误报，false positive</li><li>满足complete：存在漏报，false negative</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230831105711467.png" alt="image-20230831105711467"></p><p>绝大多数的程序分析都是sound，妥协complete</p><p>sound一般对应的是正确性，如下例，考虑到两条分支后才能得出正确的结论</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230831150801393.png" alt="image-20230831150753259"></p><p>可能有两个结论，都是sound的</p><p>平常的思维是动态思维，静态分析无法获得运行时的数据</p><p>第一个结论需要维护path branch和一个条件，比较昂贵；第二个比较cheap，速度快</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230831151433500.png" alt="image-20230831151433500"></p><p>确保（足够接近）soundness的情况下，在精度和分析速度上做平衡</p><p><strong>抽象</strong> <strong>过近似</strong> 是静态分析的核心思想</p><p>过近似包括transfer函数和控制流</p><p>抽象就是把具体值转变为符号</p><p>用bottom符号表示错误</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230831152709196.png" alt="image-20230831152709196"></p><p>transfer functions定义了转换规则，根据分析的具体问题和语句的语义设计</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230831153019783.png" alt="image-20230831153019783"></p><p>3说明静态分析会产生误报</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230831153355882.png" alt="image-20230831153355882"></p><p>控制流：在每个merge的地方进行抽象，可能出现过近似，默认采用的方式</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230831153713197.png" alt="image-20230831153713197"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230831154741536.png" alt="image-20230831154741536"></p><h1 id="Intermediate-Representation"><a href="#Intermediate-Representation" class="headerlink" title="Intermediate Representation"></a>Intermediate Representation</h1><p><a href="https://www.bilibili.com/video/BV1zE411s77Z/?spm_id_from=333.788&amp;vd_source=fbfceeec0a697a64e4aba2132714eb9d">南京大学《软件分析》课程02（Intermediate Representation）_哔哩哔哩_bilibili</a></p><p>直接分析源代码存在弊端</p><p>静态分析需要一种程序表示的形式，没有严格的定义，因此介绍主流的IR</p><p>不介绍对C/C++的LLVM</p><h2 id="编译器和静态分析器"><a href="#编译器和静态分析器" class="headerlink" title="编译器和静态分析器"></a>编译器和静态分析器</h2><p>了解关系即可</p><p>编译的步骤：</p><ul><li><p>词法分析（符号和词的合法性），需要词法方法，正则表达式</p><ul><li>语法分析器parser，上下文无关文法</li></ul></li><li><p>语法分析，对AST进行分析，语义指简单的（类型检查）</p></li><li>代码生成，静态分析器在IR基础上做</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230831163003482.png" alt="image-20230831163003482"></p><p>正常的IR需要所有前端模块才能生成</p><h2 id="AST-vs-IR"><a href="#AST-vs-IR" class="headerlink" title="AST vs. IR"></a>AST vs. IR</h2><p>3地址码3-address code</p><p>IR更接近于机器码，不依赖于编程语言（方舟编译器可以将不同语言生成为统一的IR）</p><p>AST缺乏对控制流的表达</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230831163353046.png" alt="image-20230831163353046"></p><h2 id="IR-3AC"><a href="#IR-3AC" class="headerlink" title="IR: 3AC"></a>IR: 3AC</h2><p>没有形式化的定义</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230831163931505.png" alt="image-20230831163931505"></p><p>指令右端只有1个操作符，每个语句只包含3个地址</p><ul><li>变量名 a,b</li><li>常量 3</li><li>编译器自动生成的临时变量 t1</li></ul><p>常见的形式</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230831164147119.png" alt="image-20230831164147119"></p><h2 id="Soot"><a href="#Soot" class="headerlink" title="Soot"></a>Soot</h2><p>java中最流行的静态分析器</p><p><a href="https://github.com/Sable/soot/wiki/Tutorials">https://github.com/Sable/soot/wiki/Tutorials</a></p><p>对应的IR是 Jimple，带有类型的3地址码</p><p>冒号是一种特殊的赋值</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230831165004862.png" alt="image-20230831165004862"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230831170458580.png" alt="image-20230831170458580"></p><p>JVM中的4种调用</p><ul><li><p>invokespecial: call constructor, call superclass methods, call private methods</p></li><li><p>invokevirtual: instance method call (virtual dispatch)</p></li><li><p>invokeinterface: cannot optimization, checking interface implementation 不能优化</p></li><li><p>invokestatic: call static methods</p></li></ul><p>Java7 invokedynamic -&gt; Jaava static typing, dynamic runs on JVM</p><p>meethod signature: class name, return type, method name, parameter types</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230831170815120.png" alt="image-20230831170815120"></p><p>所有类的父类，java.lang.object</p><p>默认生成的构造函数init</p><p>clinit 类的初始化的函数，compiler加载引用的变量进行初始化 class load init</p><h2 id="SSA"><a href="#SSA" class="headerlink" title="SSA"></a>SSA</h2><p>一种IR，有利于某些算法的设计，80年代提出的技术</p><p>和3AC的区别是每个变量的定义有新的命名，每个变量仅有一个等式</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230901090511569.png" alt="image-20230901090511569"></p><p>如果有控制流，采用$\phi$函数</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230901090643097.png" alt="image-20230901090643097"></p><p>为什么使用SSA</p><ul><li><p>flow-sensitive 维护程序执行顺序，精度更高，SSA本身带有部分flow的信息</p></li><li><p>数据的存储更清晰</p></li></ul><p>为什么不用SSA</p><ul><li>引入变量太多</li><li>译为机器码可能开销太大</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230901091235279.png" alt="image-20230901091235279"></p><p>静态分析一般在CFG上分析，如何给定3AC建立CFG?</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230901091633485.png" alt="image-20230901091633485"></p><h2 id="Basic-Blocks"><a href="#Basic-Blocks" class="headerlink" title="Basic Blocks"></a>Basic Blocks</h2><p>basic blocks是最多的连续的3AC码的集合，满足以下指令：</p><ul><li>只能从第一个指令进入（没有其他控制流</li><li>出口是最后一个指令</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230901091648122.png" alt="image-20230901091648122"></p><ul><li>如果指令是goto的地址，只能作为入口</li><li>goto只能作为出口<ul><li>goto的下一句一定是入口 </li></ul></li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230901093246402.png" alt="image-20230901093246402"></p><p>仅确定入口即可</p><p>BB是CFG的节点，补充边就有了CFG</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230901093928280.png" alt="image-20230901093928280"></p><h2 id="CFG"><a href="#CFG" class="headerlink" title="CFG"></a>CFG</h2><p><img src="/2023/08/31/program-analysis-NJU/image-20230901094252846.png" alt="image-20230901094252846"></p><p>条件jump有2两个出口</p><p>B2是B1的后继，前驱只能有一个，后继可以有多个</p><p>entry也可以有很多</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230901101340886.png" alt="image-20230901101340886"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230901101445829.png" alt="image-20230901101445829"></p><p>IR和AST的区别</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230901101732041.png" alt="image-20230901101732041"></p><p>企业可能认为content-insentive比较慢，学术界关注的是content-sensitive的技术</p><h1 id="Data-Flow-Analysis-Applications"><a href="#Data-Flow-Analysis-Applications" class="headerlink" title="Data Flow Analysis Applications"></a>Data Flow Analysis Applications</h1><p>编译后端优化的技术</p><p>3个应用</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230901142516251.png" alt="image-20230901142516251"></p><h2 id="Overview-of-Data-Flow-Analysis"><a href="#Overview-of-Data-Flow-Analysis" class="headerlink" title="Overview of Data Flow Analysis"></a>Overview of Data Flow Analysis</h2><p>研究数据怎样在CFG中流动</p><p>静态程序分析是过拟合的，输出可能是假阳</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230901143647456.png" alt="image-20230901143647456"></p><p>过拟合和欠拟合都是安全的分析，应该将over改成safe</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230901143914835.png" alt="image-20230901143914835"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230901144138225.png" alt="image-20230901144138225"></p><p>主要介绍不同的数据流分析的应用</p><h2 id="Preliminaries-of-Data-Flow-Analysis"><a href="#Preliminaries-of-Data-Flow-Analysis" class="headerlink" title="Preliminaries of Data Flow Analysis"></a>Preliminaries of Data Flow Analysis</h2><p>形式化方法</p><p>程序执行前后会产生状态变化，与程序点关联</p><p>顺序执行的语句前一条语句的输出和后一条的输入相关，具体还有分支的形式</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230901144554623.png" alt="image-20230901144554623"></p><p>操作符是meet operator，可以是union或者其他运算符</p><p>数据流分析需要对每个程序点的所有可能状态的抽象（data flow value，绿色的）</p><p>domain是value的值域</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230901145243994.png" alt="image-20230901145243994"></p><p>数据流分析是为了找到对输入输出状态的约束的解，有两类</p><ul><li>基于状态的语义（转移函数）<ul><li>前向分析</li><li>反向分析（可能会对逆向的CFG进行前向分析）</li><li><img src="/2023/08/31/program-analysis-NJU/image-20230901150349427.png" alt="image-20230901150349427"></li></ul></li><li>基于控制流的约束<ul><li>Basic Blocks里面的<ul><li>$IN[s_{i+1}]=OUT[s_i],\text{for all }i\in\{1,\dots,n-1\}$</li></ul></li><li>BB之间的<ul><li>复合函数</li><li><img src="/2023/08/31/program-analysis-NJU/image-20230901150752423.png" alt="image-20230901150752423"></li><li><img src="/2023/08/31/program-analysis-NJU/image-20230901150828752.png" alt="image-20230901150828752"></li><li>红色的是反向的</li></ul></li></ul></li></ul><h2 id="Reaching-Definitions-Analysis"><a href="#Reaching-Definitions-Analysis" class="headerlink" title="Reaching Definitions Analysis"></a>Reaching Definitions Analysis</h2><p>不涉及函数调用，讨论的是方法内的CFG</p><p>变量是别名的形式（指针分析，别名分析，指向分析）</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230901152313029.png" alt="image-20230901152313029"></p><p>reaching definition</p><ul><li>存在一条路径能到达</li><li>不能被二次赋值</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230901152523679.png" alt="image-20230901152523679"></p><p>编译优化会用到，也可以用来分析undefined variable</p><p>是一种may-Analysis，过拟合</p><p>100个定义用100个definition来定义</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230901154814673.png" alt="image-20230901154814673"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230901155156563.png" alt="image-20230901155156563"></p><p>给出了转移函数的定义</p><p>因为无法确定BB之间的前驱关系，所有定义了当前BB内的定义的语句都需要被kill掉</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230901155520326.png" alt="image-20230901155520326"></p><p>对于control flow进行分析，定义</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230901155548910.png" alt="image-20230901155548910"></p><p>入口的output为空，entry没有定义 （may analyse一般为空，must analyse一般考虑为undefined）</p><p>除了entry的BB的output都为空（程序都没运行）</p><p>当任何OUT改变的话</p><p>会停机吗？</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230901161421363.png" alt="image-20230901161421363"></p><p>B3的Input=10110000</p><p>B3的Output=00000010 union (10110000 - 10001000) = 00000010 union 00110000 = 00110010</p><p>上一轮的BB的out都是空，全变了，再循环一轮</p><p>B2的out= 10111100    </p><p>B3的out= 00110110 </p><p><img src="/2023/08/31/program-analysis-NJU/image-20230901171055532.png" alt="image-20230901171055532"></p><p>根据转移函数的定义，当输入不变时输出不变</p><p>如何证明算法的收敛</p><p>$OUT[S]=gen_s\cup (IN[S] -kill_s)$</p><ul><li>$gen_s \text{和}kill_s$不变</li><li>more facts加入后，只会让多+1而不会多kill，单调递增的感觉</li><li>facts是有限的</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230901171929909.png" alt="image-20230901171929909"></p><p>为什么每个out不再变化就说明停机了？</p><p>Out不变，In不变，Out不变</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230901172108100.png" alt="image-20230901172108100"></p><p>算法到达了不动点，和单调性相关</p><h2 id="Live-Variables-Analysis"><a href="#Live-Variables-Analysis" class="headerlink" title="Live Variables Analysis"></a>Live Variables Analysis</h2><p>数据流分析的应用，归结为在格上求解不动点的问题</p><p>一般分析算法求出的是最大不动点和最小不动点</p><p>定义：某处变量的值是否能够在后面可以使用（用之前是live，不能被重定义）</p><p>live变量的信息可以用于寄存器分配，当寄存器满了的时候</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230904094328736.png" alt="image-20230904094328736"></p><p>定义中指出是some path，因此是一种may analysis，定义的直观含义是某点的变量是否会被后续用到</p><p>变量和定义的区别在哪里？</p><p>都用bit vector表示</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230904100041064.png" alt="image-20230904100041064"></p><p>采用backward的方法进行分析</p><p>In[B]= use_B union (Out[B] - redine[B])</p><p>通过具体情况枚举分析</p><p>use在define之前</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230904155628294.png" alt="image-20230904155628294"></p><p>更正：此处的$OUT[B]=\cup_S IN[s]$</p><p>给定的out求in，边界条件为in=空</p><p>一般情况下may analyse的初始化是空，must analyse是all，和reaching definition定义很像</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230904160245948.png" alt="image-20230904160245948"></p><p>0001000 </p><p>B4有两个后继，out[b4]=in[b2] union in[b5] = 0001000 union 0000000 = 0001000</p><p>in[b4]= 0100000 union (0001000 - 1000000) = 0101000</p><p>B2的Input是 100 1001，因为m是在define后用的</p><p>B1的输入0011101</p><p>第二轮 </p><p>0101001 </p><p><img src="/2023/08/31/program-analysis-NJU/image-20230904160646443.png" alt="image-20230904160646443"></p><p>计算INPUT的顺序不同会影响迭代的次数</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230904162203684.png" alt="image-20230904162203684"></p><h2 id="Available-Expressions-Analysis"><a href="#Available-Expressions-Analysis" class="headerlink" title="Available Expressions Analysis"></a>Available Expressions Analysis</h2><p>一种must analysis，为了实现对程序的优化而不是解决安全问题</p><p>从程序入口到p的所有路径必须经过表达式 $x\  op\  y$，并且表达式最后的求值之后，$x$和$y$不能被重定义</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230904162801564.png" alt="image-20230904162801564"></p><p>类似于表达式简化的思想，p点之后对该表达式可以进行替代</p><p>首先给出抽象</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230904162854755.png" alt="image-20230904162854755"></p><p>是一种前向分析</p><p>out = gen union (input - kill)</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230904165840491.png" alt="image-20230904165840491"></p><p>两个分支后是available的</p><p>因为所有pass都必须available，输入是前驱输出的交集</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230904165925795.png" alt="image-20230904165925795"></p><p>优化而不是找bug，不能误报</p><p>初始化为全1（因为要交）</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230904172544309.png" alt="image-20230904172544309"></p><p>out[B1]=10000</p><p>out[B2]=01010 union (10000 - 10000)=01010</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230904172906013.png" alt="image-20230904172906013"></p><p>B4 input=11111, Output= 00110 union (01010-00010) =01110</p><p>先算kill再算gen，根据定义</p><p>01010 union (00010 - 00111)=01010</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230904185613558.png" alt="image-20230904185613558"></p><p>三类定义的对比</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230904190155676.png" alt="image-20230904190155676"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230904191638058.png" alt="image-20230904191638058"></p><h1 id="Data-Flow-Analysis-Foundation"><a href="#Data-Flow-Analysis-Foundation" class="headerlink" title="Data Flow Analysis Foundation"></a>Data Flow Analysis Foundation</h1><p><img src="/2023/08/31/program-analysis-NJU/image-20230904192251591.png" alt="image-20230904192251591"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230904192304012.png" alt="image-20230904192304012"></p><p>上节课3个应用的算法均是迭代式算法，回答存在的问题</p><p>从23的基础上定义格</p><p>复习核心内容是8</p><h2 id="Iterative-Algorithm-Another-View"><a href="#Iterative-Algorithm-Another-View" class="headerlink" title="Iterative Algorithm, Another View"></a>Iterative Algorithm, Another View</h2><p>给定CFG，有k个statement，迭代算法每次更新节点的OUT[n]</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230904194220880.png" alt="image-20230904194220880"></p><p>进行形式化</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230904194710101.png" alt="image-20230904194710101"></p><p>实际上是不动点</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230904194725702.png" alt="image-20230904194725702"></p><ul><li>迭代式算法一定能终止并给出一个解吗？</li><li>假设能达到不动点，只有一个不动点吗？如果有若干个不动点，迭代式算法得到的不动点足够精确吗？</li><li>迭代式算法到达不动点或得到解需要多长时间？（复杂度）</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230904195054862.png" alt="image-20230904195054862"></p><h2 id="Partial-Order"><a href="#Partial-Order" class="headerlink" title="Partial Order"></a>Partial Order</h2><p>参考 <a href="https://zhuanlan.zhihu.com/p/365442689">偏序与等价关系 - 知乎 (zhihu.com)</a></p><p>偏序集的定义$P,\subseteq$，带有偏序关系的集合，并满足以下关系</p><ul><li>自反性</li><li>反对称性 </li><li>传递性</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230905100158884.png" alt="image-20230905100158884"></p><p>整数集上的小于关系不是偏序关系</p><p>子串是偏序关系</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230905100307750.png" alt="image-20230905100307750"></p><p>偏序集的含义是不是所有的元素互相之间必须满足偏序关系，如pin和sin没有偏序关系，但是{pin,sin,sing,gin}和singing构成偏序集</p><p>幂集</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230905100734386.png" alt="image-20230905100734386"></p><h2 id="Upper-and-Lower-Bounds"><a href="#Upper-and-Lower-Bounds" class="headerlink" title="Upper and Lower Bounds"></a>Upper and Lower Bounds</h2><p><img src="/2023/08/31/program-analysis-NJU/image-20230905101107238.png" alt="image-20230905101107238"></p><p>最小上界lub和最大下界glb</p><p>bound可以不在S当中，在P中即可</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230905101527501.png" alt="image-20230905101527501"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230905101943246.png" alt="image-20230905101943246"></p><p>偏序集的glb和lub是唯一的</p><p>证明：反证法，反对称性</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230905102005722.png" alt="image-20230905102005722"></p><h2 id="Lattice-Semilattice-Complete-and-Product-Lattice"><a href="#Lattice-Semilattice-Complete-and-Product-Lattice" class="headerlink" title="Lattice, Semilattice, Complete and Product Lattice"></a>Lattice, Semilattice, Complete and Product Lattice</h2><p>在程序分析中学格（</p><p>每两个元素存在glb和lub的偏序集称为格</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230905102436174.png" alt="image-20230905102436174"></p><p>半格：任意两个元素只存在glb或者lub</p><ul><li>只存在glb，称为meet半格</li><li>只存在lub，称为join半格</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230905102707115.png" alt="image-20230905102707115"></p><p>全格</p><p>格的任意一个子集，均存在glb和lub</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230905110741805.png" alt="image-20230905110741805"></p><p>整数集的子集为什么不是全格，但是格？</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230905111254543.png" alt="image-20230905111254543"></p><p>回顾格的定义，任意两个元素存在glb和lub即可；全格要求所有子集都有glb和lub</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230905110540907.png" alt="image-20230905110540907"></p><p>有限的格一定是全格，complete的lattice一定是有限的吗，不是</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230905111616613.png" alt="image-20230905111616613"></p><p>一般程序内的是有限的</p><p>积格的定义</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230905112107491.png" alt="image-20230905112107491"></p><ul><li>积格的lub：实际上是每个格内两个元素的lub</li><li>积格的glb：每个格内的两个元素的glb</li></ul><p>性质</p><ul><li>根据定义，积格也是格</li><li>积格是全格的积时，积格也是全格</li></ul><h2 id="Data-Flow-Analysis-Framework-via-Lattice"><a href="#Data-Flow-Analysis-Framework-via-Lattice" class="headerlink" title="Data Flow Analysis Framework via Lattice"></a>Data Flow Analysis Framework via Lattice</h2><p>介绍格是为了用格形式化数据流分析</p><p> <img src="/2023/08/31/program-analysis-NJU/image-20230905113959239.png" alt="image-20230905113959239"></p><p>有点类似沿着控制流上升到上界</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230905114738987.png" alt="image-20230905114738987"></p><p>试图回答第1个问题</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230905114859061.png" alt="image-20230905114859061"></p><p>需要单调性和不动点定理</p><h2 id="Monoticity-and-Fixed-point-Theorem"><a href="#Monoticity-and-Fixed-point-Theorem" class="headerlink" title="Monoticity and Fixed point Theorem"></a>Monoticity and Fixed point Theorem</h2><p>前面提到complete的格不一定是有限的，所以这里额外第二个条件是finite</p><p>从bottom出发，迭代f函数能够找到的第一个不动点叫做最小不动点；从top出发，求到的是最大不动点</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230905151443765.png" alt="image-20230905151443765"></p><p>证明不动点的存在：</p><p>根据$\perp$的定义，有$\perp \subseteq f(\perp)$</p><p>根据单调性的定义，$f(\perp)\subseteq f(f(\perp))$</p><p>递归地有 $\perp \subseteq f(\perp) \subseteq \dots f^i(\perp)$</p><p>根据$L$的有限性，存在一个$k$,$f^k(\perp)=f^{k+1}(\perp)=f^{fix}$</p><p>即存在不动点，回答了问题1</p><p>（可以假设不存在不动点，则根据单调性和有限性推出矛盾）</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230905154855422.png" alt="image-20230905154855422"></p><p>再证明得到的不动点是最小不动点</p><p>设存在另一个不动点为$x=f(x)$</p><p>根据$\perp$的定义，有$\perp \subseteq x$</p><p>根据单调性有 $f(\perp) \subseteq f(x)$ (数学归纳法的奠基)</p><p>采用数学归纳法，假设$f^i(\perp)\subseteq f^i(x)$</p><p>根据单调性，有$f^{i+1}(\perp)\subseteq f^{i+1}(x)=f(x)$</p><p>则有$f^{fix}=f^k(\perp)\subseteq f^k(x)=x$</p><p>即证明了求出的不动点是最小不动点，回答了问题2</p><p>间接证明了求出的不动点的唯一性</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230905155031011.png" alt="image-20230905155031011"></p><p>依然存在的问题，仅回答了lattice上函数的性质，没有和迭代式算法建立联系</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230905160510624.png" alt="image-20230905160510624"></p><h2 id="Relate-Iterative-Algorithm-to-Fixed-Point-Theorem"><a href="#Relate-Iterative-Algorithm-to-Fixed-Point-Theorem" class="headerlink" title="Relate Iterative Algorithm to Fixed Point Theorem"></a>Relate Iterative Algorithm to Fixed Point Theorem</h2><p><img src="/2023/08/31/program-analysis-NJU/image-20230905164944314.png" alt="image-20230905164944314"></p><p>关键是F的单调性</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230905165647774.png" alt="image-20230905165647774"></p><p>先证明两个运算的单调性</p><p>思路是利用最小上界的定义 偏序关系的传递性</p><p>证明下确界运算的思路类似</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230905172002679.png" alt="image-20230905172002679"></p><p>最后解答复杂性的问题</p><p>先介绍格的高度的定义</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230905172123723.png" alt="image-20230905172123723"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230905172819265.png" alt="image-20230905172819265"></p><p>复杂度取决于CFG节点个数和格的高度 </p><h2 id="May-Must-Analysis-A-Lattive-View"><a href="#May-Must-Analysis-A-Lattive-View" class="headerlink" title="May/Must Analysis, A Lattive View"></a>May/Must Analysis, A Lattive View</h2><p><img src="/2023/08/31/program-analysis-NJU/image-20230905173425800.png" alt="image-20230905173425800"></p><p>先抽象成一个积格进行理解，先看may alalysis</p><p>以reaching definition为例，作为一种may analysis 最下面No definitions can reach是所有变量都被初始化了，最上面是所有变量都可能被redefine，safe是指从找bug的角度，给所有变量报错是safe but useless，因此需要从下往上找到safe和unsafe的边界 truth</p><p>如何判断是否超过了truth（根据不动点</p><p>设计transfer function和cf merge的原则是safe approximation</p><p>根据单调性，求得的是最小不动点</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230905174535083.png" alt="image-20230905174535083"></p><p>must analyse解决的是优化问题，从top出发，所有表达式都能优化显然是错误的，bottom是安全的但是没用的，没有表达式可以优化</p><p>must analyse的分析不能有误报，要求是complete</p><p>另一个维度理解may的最小不动点：transfer function是固定的，join是求最小上界，每次迭代走的是minimal step，因此得到的是最小不动点</p><h2 id="Distributivity-and-MOP"><a href="#Distributivity-and-MOP" class="headerlink" title="Distributivity and MOP"></a>Distributivity and MOP</h2><p>考虑解的精确性，MOP是衡量的一个指标</p><p>总的transfer function就是各个f的组合</p><p>MOP是枚举所有的path的结果再join或meet（计算了每条路径最终的值</p><p>静态分析中有的路径可能是不可达的，导致结果不是完全精确的</p><p>实际上是不可枚举的</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230906103700614.png" alt="image-20230906103700614"></p><p>和迭代式算法的区别</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230906103918799.png" alt="image-20230906103918799"></p><p>x和y之间的关系</p><p>最小上界小于上界</p><p>所以MOP更准确</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230906104601252.png" alt="image-20230906104601252"></p><p>当F满足分配律，两者一样准确</p><p>之前提到的bit-vector或Gen/Kill问题都是distributive</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230906104858404.png" alt="image-20230906104858404"></p><h2 id="Constant-Propagation"><a href="#Constant-Propagation" class="headerlink" title="Constant Propagation"></a>Constant Propagation</h2><p>这个DFA不是distributive的</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230906105336040.png" alt="image-20230906105336040"></p><p>NAC: not a constant</p><p>一般不考虑未初始化的问题</p><p>对于两个常量分类讨论</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230906105930450.png" alt="image-20230906105930450"> </p><p> 关注赋值语句，kill掉与被赋值相关的常量</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230906111532756.png" alt="image-20230906111532756"></p><p>例子</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230906111959118.png" alt="image-20230906111959118"></p><h2 id="Worklist-Algorithm"><a href="#Worklist-Algorithm" class="headerlink" title="Worklist Algorithm"></a>Worklist Algorithm</h2><p>区别于迭代算法，实际的工具不采用迭代算法，worklist可以看做优化</p><p>回顾迭代式算法</p><p>仅遍历计算in变了的部分</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230906112920299.png" alt="image-20230906112920299"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230906113352119.png" alt="image-20230906113352119"></p><h1 id="Interprocedural-Analysis"><a href="#Interprocedural-Analysis" class="headerlink" title="Interprocedural Analysis"></a>Interprocedural Analysis</h1><p>过程间分析</p><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p><img src="/2023/08/31/program-analysis-NJU/image-20230906113916346.png" alt="image-20230906113916346"></p><p>过程内分析对方法调用进行最保守的假设，可以做任何事情</p><p>问题：过于保守，降低了精度</p><p>过程间分析需要call graph，调用的目的地址</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230906114450105.png" alt="image-20230906114450105"></p><h2 id="Call-graph"><a href="#Call-graph" class="headerlink" title="Call graph"></a>Call graph</h2><p>call edge连接call site和callee</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230906114617419.png" alt="image-20230906114617419"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230906114641085.png" alt="image-20230906114641085"></p><p>主要针对面向对象的语言，给出了4个算法</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230906114815381.png" alt="image-20230906114815381"></p><p>virtualcall实现多态，难以处理</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230906115124716.png" alt="image-20230906115124716"></p><p>具体调用的方法在运行时确定，取决于</p><ul><li>对象的类型</li><li>方法签名（可以唯一确定一个方法</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230906115354456.png" alt="image-20230906115354456"></p><p>优先当前类有方法体的方法，不能是抽象的，如果没有则去父类找</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230906115605922.png" alt="image-20230906115605922"></p><p>CHA需要类的继承的信息，根据A的类型来决定对应的call</p><p>OO语言的顶会</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230906200743561.png" alt="image-20230906200743561"></p><p>算法采用分类讨论</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230906201056655.png" alt="image-20230906201056655"></p><p>static call最简单</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230906201244904.png" alt="image-20230906201244904"></p><p>B类可能没有foo，因此需要一个Dispatch而不是直接用B.foo()\</p><p>私有和构造函数都能用dispatch解决</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230906201506211.png" alt="image-20230906201506211"></p><p>对于virtual call，包含了所有的子类的方法，因为</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230906201707497.png" alt="image-20230906201707497"></p><p>例子都属于virtual call</p><p>{C.foo()}</p><p>{A.foo(), C.foo(), D.foo()}</p><p>{A.foo(), C.foo(), D.foo()}</p><p>如果B b =new B(), Resolve(b.foo())={A.foo(), C.foo(), D.foo()} 结果不变</p><p>这里是一个special call吗？不是因为Java支持动态方法分配，且涉及到了继承关系</p><p>因为算法只考虑变量的声明类型</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230906211704923.png" alt="image-20230906211704923"></p><p>一般用在IDE中</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230906211826590.png" alt="image-20230906211826590"></p><p>navigate菜单中</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230906211956325.png" alt="image-20230906211956325"></p><p>reachable是处理过的方法</p><p>通过resolve发现新的方法</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230907095105736.png" alt="image-20230907095105736"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230907100051983.png" alt="image-20230907100051983"></p><h2 id="Interprocedural-CFG"><a href="#Interprocedural-CFG" class="headerlink" title="Interprocedural CFG"></a>Interprocedural CFG</h2><p>ICFG表示的是整个程序的结构</p><p>紧跟着call site的就是return site，利用call graph来解决ICFG</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230907100501603.png" alt="image-20230907100501603"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230907100605564.png" alt="image-20230907100605564"></p><p>为什么还保留一条额外的边</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230907100725411.png" alt="image-20230907100725411"></p><h2 id="Interprocedural-Data-Flow-Analysis"><a href="#Interprocedural-Data-Flow-Analysis" class="headerlink" title="Interprocedural Data Flow Analysis"></a>Interprocedural Data Flow Analysis</h2><p><img src="/2023/08/31/program-analysis-NJU/image-20230907101105920.png" alt="image-20230907101105920"></p><p>遇到call node需要kill掉left hand side variable的值 </p><p><img src="/2023/08/31/program-analysis-NJU/image-20230907103248743.png" alt="image-20230907103248743"></p><p>edge transfer就是给形参赋值</p><p>保留call to return edge是为了保证本地数据流关系的保留，即函数内部的</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230907104117327.png" alt="image-20230907104117327"></p><p>如果没有这条边，相当于函数addOne内还需要维护a的值，如下图，效率很低</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230907104201277.png" alt="image-20230907104201277"></p><p>kill的具体原因，需要用返回值覆盖</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230907105040021.png" alt="image-20230907105040021"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230907105101994.png" alt="image-20230907105101994"></p><p>如果是过程内分析，会进行最保守的假设，所有调用返回值都是NAC，imprecise</p><p>过程间分析更加精确</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230907105527714.png" alt="image-20230907105527714"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230907105536788.png" alt="image-20230907105536788"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230907105714714.png" alt="image-20230907105714714"></p><h1 id="Pointer-Analysis-Introduction"><a href="#Pointer-Analysis-Introduction" class="headerlink" title="Pointer Analysis Introduction"></a>Pointer Analysis Introduction</h1><h2 id="Motivation-1"><a href="#Motivation-1" class="headerlink" title="Motivation"></a>Motivation</h2><p>利用CHA来求目标方法会有多个，不精确</p><p>CHA利用对象的类和子类来分析</p><p>如果对x进行常量传播，x是NAC</p><p>指针分析更精确</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914182323812.png" alt="image-20230914182323812"></p><h2 id="Introduction-to-Pointer-Analysis"><a href="#Introduction-to-Pointer-Analysis" class="headerlink" title="Introduction to Pointer Analysis"></a>Introduction to Pointer Analysis</h2><p>指针分析回答指针可以指向哪些地址</p><p>作为一种may analysis，过近似，给出可能指向的所有地址</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911092021640.png" alt="image-20230911092021640"></p><p>OO语言内的指针包括filed和variable</p><p>指针分析的输入是一段程序，输出是如右表所示的表格</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911093038934.png" alt="image-20230911093038934"></p><h3 id="Alias-Analysis别名分析"><a href="#Alias-Analysis别名分析" class="headerlink" title="Alias Analysis别名分析"></a>Alias Analysis别名分析</h3><ul><li><p>指针分析：指针可以指向哪些对象</p></li><li><p>别名分析：两个指针能否指向同一地址</p></li></ul><p>显然，可以利用指针分析实现别名分析</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911093309820.png" alt="image-20230911093309820"></p><p>指针分析的应用：</p><ul><li>计算调用图</li><li>编译优化</li><li>漏洞检测 空指针</li><li>…</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230911093514885.png" alt="image-20230911093514885"></p><h2 id="Key-Factors"><a href="#Key-Factors" class="headerlink" title="Key Factors"></a>Key Factors</h2><p>非常复杂，在精度和效率之间取舍</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911093643312.png" alt="image-20230911093643312"></p><h3 id="Heap-Abstraction"><a href="#Heap-Abstraction" class="headerlink" title="Heap Abstraction"></a>Heap Abstraction</h3><p>堆抽象：如何对堆内存建模</p><p>因为在动态执行中，堆的对象可能是无穷的，静态分析需要在一定时间内得出结果，堆抽象需要将具体的对象抽象成有限数量的抽象的对象</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911093955437.png" alt="image-20230911093955437"></p><p>了解有两大流派，学习allocation sites技术</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911094118770.png" alt="image-20230911094118770"></p><p>根据对象的创建点来建模，$O_2$表示创建点</p><p>因为程序中创建对象的语句是有限的，显然抽象的对象数量是有限的</p><h3 id="Context-Sensitivity"><a href="#Context-Sensitivity" class="headerlink" title="Context Sensitivity"></a>Context Sensitivity</h3><p>上下文：考虑如何对调用点建模</p><p>方法可能被调用很多次，对应不同的上下文时，方法内的调用可能不同</p><ul><li><p>上下文敏感可以模拟 区分不同的上下文，上下文不同时，对同一个方法分析多次</p></li><li><p>上下文不敏感每个方法仅分析一次</p></li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230911100457311.png" alt="image-20230911100457311"></p><p>上下文敏感可以显著提高精度</p><p>学习计划是先学习不敏感，再学习敏感</p><h3 id="Flow-Sensitivity"><a href="#Flow-Sensitivity" class="headerlink" title="Flow Sensitivity"></a>Flow Sensitivity</h3><p>指如何对<strong>控制流</strong>进行建模</p><ul><li>控制流敏感：尊重语句的执行顺序</li><li>控制流不敏感：忽视控制流的顺序</li></ul><p>java的数据类型可以分为值类型和引用类型；</p><ul><li>基本类型也称为值类型，分别是字符类型 char，布尔类型 boolean以及数值类型 byte、short、int、long、float、double。</li><li>引用类型则包括类、接口、数组、枚举等。</li></ul><p>Java 将内存空间分为堆和栈。基本类型直接在栈中存储数值，而引用类型是将引用放在栈中，实际存储的值是放在堆中，通过栈中的引用指向堆中存放的数据。</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911101619604.png" alt="image-20230911101619604"></p><p>右边是flow不敏感分析的结果，目前主流是flow insensitive（对精度影响不大）</p><h3 id="Analysis-Scope"><a href="#Analysis-Scope" class="headerlink" title="Analysis Scope"></a>Analysis Scope</h3><p>回答应该分析程序中的哪些部分</p><ul><li>所有程序</li><li>需求驱动的分析：计算量更小；效率差异可能不够明显，仅满足特定需求<ul><li>如果有多个client的需求，可能会有重叠，不如进行全程序分析效率高</li></ul></li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230911104031780.png" alt="image-20230911104031780"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911104343223.png" alt="image-20230911104343223"></p><h2 id="Concerned-Statements"><a href="#Concerned-Statements" class="headerlink" title="Concerned Statements"></a>Concerned Statements</h2><p>只关心影响与指针有关的语句</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911105633949.png" alt="image-20230911105633949"></p><ul><li>本地变量：x 数量最多</li><li>静态field：C.f 和变量类似，不是重点</li><li>Instance field：x.f 对象的field</li><li>数组元素 Array[i]，一般会忽略index，静态分析无法得到，抽象成 <em>只有一个field的对象</em>，所有指都可以能取到，因此和instance field类似了</li></ul><p>结论：学会1 3即可（不是</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911110032514.png" alt="image-20230911110032514"></p><p>主要是5条语句</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911110354258.png" alt="image-20230911110354258"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911110406168.png" alt="image-20230911110406168"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911110735865.png" alt="image-20230911110735865"></p><h1 id="Pointer-Analysis-Foundations-1"><a href="#Pointer-Analysis-Foundations-1" class="headerlink" title="Pointer Analysis Foundations 1"></a>Pointer Analysis Foundations 1</h1><p><img src="/2023/08/31/program-analysis-NJU/image-20230911110905857.png" alt="image-20230911110905857"></p><h2 id="Rules"><a href="#Rules" class="headerlink" title="Rules"></a>Rules</h2><p>首先分析没有方法调用的程序（前4条语句），再学习如何处理方法调用</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911111820078.png" alt="image-20230911111820078"></p><p>规则是推导式的，$pt(p)$指的是p指向的对象</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911113127194.png" alt="image-20230911113127194"></p><p>new是将$o_i$加入到$pt(x)$中去</p><p>赋值将$y$指向的加入到$x$指向的</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911113140353.png" alt="image-20230911113140353"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911113613953.png" alt="image-20230911113613953"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911113800642.png" alt="image-20230911113800642"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911113809394.png" alt="image-20230911113809394"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911160527617.png" alt="image-20230911160527617"></p><h2 id="How-to-implement-pointer-analysis"><a href="#How-to-implement-pointer-analysis" class="headerlink" title="How to implement pointer analysis"></a>How to implement pointer analysis</h2><p>本质上是将指针信息传播给其他指针，也可以理解为求解包含约束</p><p>指针分析的关键是当指针集$pt(x)$变化时，将变化传播给其他相关的指针</p><p>利用图来传播</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911161609721.png" alt="image-20230911161609721"></p><p>指针流图pointer flow graph</p><p>有向图，表示对象如何在图中流动</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911161731273.png" alt="image-20230911161731273"></p><p>边的含义是x的变化可能流向y</p><p>如何建立PFG的边？根据程序的语句的4条规则</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911162000627.png" alt="image-20230911162000627"></p><p>c.f仅是一个指针表达式，不是一个指针，指针必须是对象</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911163008942.png" alt="image-20230911163008942"></p><p>实现包括两步</p><ul><li>构建指针流图</li><li>在PFG上传播指向信息</li></ul><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>分别对应4个语句</p><p>S是要分析的语句的集合</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911164230546.png" alt="image-20230911164230546"></p><p>WL包含了指针和指针集，是后续要分析的对象</p><p>简化只有2种语句</p><p>集合的减法是为了去重，去掉ptn已经有的指针</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911170359600.png" alt="image-20230911170359600"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911170411007.png" alt="image-20230911170411007"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911170430735.png" alt="image-20230911170430735"></p><p>已经是union了为什么要去重？不影响正确性，但是可以跳过</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911171405824.png" alt="image-20230911171405824"></p><p>另外两条对称的语句</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230911172033462.png" alt="image-20230911172033462"></p><p>可能有其他同类的不同对象已经连接了实例方法，因此是may引入新的PFG边</p><p>执行这个例子</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912162251382.png" alt="image-20230912162251382"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912162437486.png" alt="image-20230912162437486"></p><h1 id="Pointer-Analysis-Foundations-2"><a href="#Pointer-Analysis-Foundations-2" class="headerlink" title="Pointer Analysis Foundations 2"></a>Pointer Analysis Foundations 2</h1><p>如何处理方法调用</p><p>过程间分析，需要call graph</p><p>与CHA方法对比，根据指针分析来确定call graph</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912164701071.png" alt="image-20230912164701071"></p><p>实际上指针分析和call graph是一起构建的，on the fly</p><p>复杂起来了（</p><ul><li><p>disptach：根据接受者对象和方法签名去找目标方法m，在做call graph</p></li><li><p>传receiver对象：$m_{this}$，OO语言很多操作通过this实现</p></li><li>传参：实参传给形参，变量之间连起来</li><li>传回返回值</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230912165752464.png" alt="image-20230912165752464"></p><p>solidity的dispatch只需要函数签名</p><p>问题：为什么this不加一个边？</p><p>连上会传递错误的信息，this只指向当前对象</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912170440967.png" alt="image-20230912170440967"></p><p>实际的操作</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912170522098.png" alt="image-20230912170522098"></p><p>从入口方法main函数进行分析，只分析reachable的方法，reachable对效率和精度有帮助</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912172112179.png" alt="image-20230912172112179"></p><p>黄色部分是新增的步骤，和call graph相关</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912172223253.png" alt="image-20230912172223253"></p><p>reachable方法</p><ul><li>入口方法</li><li>出现新的调用边</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230912173001173.png" alt="image-20230912173001173"></p><p>为什么只处理new和assign，因为这两个语句不需要语境</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912184947416.png" alt="image-20230912184947416"></p><p>为什么call graph存在$l\to m$就不再执行？实际上是对象的类型来决定目标方法的，虽然oi是新的对象，但是其他同类型的对象oj可能已经连过这一条边</p><p>这些判断条件存在的原因：为了实用性，减少不必要的操作</p><p>上下文非敏感，每个算法处理一次</p><p>算法的输出是每个变量的指针集以及调用图</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912185840030.png" alt="image-20230912185840030"></p><p>例子，动笔自己写一写</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912190641848.png" alt="image-20230912190641848"></p><p>和CHA的区别：更精确了</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912192345447.png" alt="image-20230912192345447"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912192951269.png" alt="image-20230912192951269"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912193211655.png" alt="image-20230912193211655"></p><h1 id="Pointer-Analysis-Context-Sentivity"><a href="#Pointer-Analysis-Context-Sentivity" class="headerlink" title="Pointer Analysis Context Sentivity"></a>Pointer Analysis Context Sentivity</h1><p>Java指针分析中对精度提升最明显的技术 </p><p>动态执行时该程序时$i=1$</p><p>采用常量传播分析是NAC</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912194827600.png" alt="image-20230912194827600"></p><p>需要上下文敏感的指针分析，每次调用id时对实参进行区分</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912195049875.png" alt="image-20230912195049875"></p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>上下文不敏感为什么会不准确 </p><ul><li>动态执行时，一个方法可能在不同的语境下被多次调用</li><li>不同调用语境中方法的变量可能指向不同对象</li><li>不同语境下的对象 <em>混合</em> 并 <em>传播</em> 到了程序的其他部分</li></ul><p>提高上下文敏感分析的效率</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912201100384.png" alt="image-20230912201100384"></p><p>最古老和最著名的技术是call-site当做上下文，对调用栈的抽象</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912201119775.png" alt="image-20230912201119775"></p><p>下节课介绍其他变种，后续介绍都是call-site</p><p>具体关注的是变量的上下文</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912201045606.png" alt="image-20230912201045606"></p><p>上下文敏感 堆</p><ul><li>OO程序会频繁操作对象，heap-intensive</li><li>为了提高精度需要对 对象加上下文<ul><li>粒度更细的抽象</li></ul></li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230912201334791.png" alt="image-20230912201334791"></p><p>为什么能提高精度？</p><p>动态执行时，每次调用都会创建新的对象</p><p>同一个语句，不同对象的操作可能不同</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912201515062.png" alt="image-20230912201515062"></p><p>例子</p><p>动态执行指向n1，堆不敏感的程序分析指向n1 n2</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912202332554.png" alt="image-20230912202332554"></p><p>有上下文敏感heap时，右边x.f语句会产生两个不同，意思是方法内对 对象的field也进行区分</p><p>如果没有变量上下文敏感，只做堆上下文敏感，相当于没做</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912205913463.png" alt="image-20230912205913463"></p><p>都加上下文才能提高精度</p><h2 id="Rules-1"><a href="#Rules-1" class="headerlink" title="Rules"></a>Rules</h2><p>先给出定义域和记号</p><p>程序的变量、对象都加上 上下文</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912210139484.png" alt="image-20230912210139484"></p><p>策略决定c的内容，可以理解为一系列call-site</p><p>注意field没有，具体的实例的field有，因为通过对象来访问</p><p>指针也分两类，分别是变量和对象的；因此表示方式是两类的并</p><p>具体实现指针分析器需要利用这些规则</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912213823131.png" alt="image-20230912213823131"></p><p>具体的理解</p><p>对于new语句，语境当中的规则：假设在方法m中，上下文是c，则给对象也加上下文</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912214053341.png" alt="image-20230912214053341"></p><p>对于assign语句，比较直观</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912214230647.png" alt="image-20230912214230647"></p><p>先分别取出x和y指向的对象，为什么不是同一个上下文c？</p><p>因为x和y的上下文相同，但是x和y指向的对象的语境不一定相同，上下文c和c‘可以相同</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912214620756.png" alt="image-20230912214620756"></p><p>load和store对称</p><p>对于调用的规则，如何决定c</p><p>假设调用在某个方法里，当前的语境是c</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912215123422.png" alt="image-20230912215123422"></p><ul><li>先取出对象指向的上下文</li><li>选择对应方法，与上下文无关，取决于类型</li><li>选择上下文：为目标方法$m$选择上下文，根据当前调用点$l$能得到的信息<ul><li>具体怎么选，请看下集</li></ul></li><li>传receiver object</li><li>传返回值</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230912215631131.png" alt="image-20230912215631131"></p><p>好像是直接用了L？考虑如果在例子外面套个循环，就需要一个方法select进行选择了；除了还有其他的表示方法</p><p>$c^t$ 是新的一个上下文</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230912220108442.png" alt="image-20230912220108442"></p><p>目前Java流敏感分析的效果不够好</p><h2 id="Algorithms"><a href="#Algorithms" class="headerlink" title="Algorithms"></a>Algorithms</h2><p>算法有两部分，构造PFG，在PFG上传播指针信息</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913152920936.png" alt="image-20230913152920936"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913153854777.png" alt="image-20230913153854777"></p><p>区别在于每个节点表示的都是上下文敏感的变量或者field，节点额外带有上下文，笛卡尔积多了一个维度</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913153130047.png" alt="image-20230913153130047"></p><p>连边就根据4条规则</p><p>对于call比较复杂，方法dispatch，传参数，this不连边，传返回值</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913154003008.png" alt="image-20230913154003008"></p><p>打码之后和上下文不敏感的算法几乎一样</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913154510890.png" alt="image-20230913154510890"></p><p>首先看solve算法</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913154601481.png" alt="image-20230913154601481"></p><p>下面的集合也带有上下文信息</p><p>比如RM foo在ct下可达</p><p>CG也是上下文敏感的call-site和callee都有上下文，$c\to c^t$</p><p>入口函数的上下文为空</p><p>同一个call-site，目标函数内的context是一样的</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913162044882.png" alt="image-20230913162044882"></p><p>Addedge和Propagate和CI分析一致</p><h2 id="Variants"><a href="#Variants" class="headerlink" title="Variants"></a>Variants</h2><p>其他技术</p><p>给出select函数的定义</p><p>最常用的三种上下文敏感的变量</p><ul><li>call-site敏感</li><li>object敏感</li><li>type敏感</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230913162648159.png" alt="image-20230913162648159"></p><p>如果是上下文不敏感，可以看做是上下文敏感的特殊情况，select返回为空</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913164121180.png" alt="image-20230913164121180"></p><p>每个context包括一系列的call-sites，将call site加入到caller，类似于调用栈，也叫call string，K-CFA(k-Context-Free Analysis)</p><h3 id="call-site-sentivity"><a href="#call-site-sentivity" class="headerlink" title="call site sentivity"></a>call site sentivity</h3><p><img src="/2023/08/31/program-analysis-NJU/image-20230913164034410.png" alt="image-20230913164034410"></p><p>怎么得到当前的代码行数呢</p><p>递归调用的时候（方法调用自己），会出现无穷多次call-site</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913164548268.png" alt="image-20230913164548268"></p><p>因此需要一个深度$k$，限制上下文的长度为$k$，一般$k\leq3$，会合并连续相同的callsite然后取队列末尾的$k$个</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913165010456.png" alt="image-20230913165010456"></p><p>上下文层数越多，精度越高，一般是至少2层</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913170125124.png" alt="image-20230913170125124"></p><p>分析x.get具体指向的方法</p><p>动态的理解：会返回1</p><p>静态分析：得到One.get()</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913172604357.png" alt="image-20230913172604357"></p><p>利用调用点区分了14和15两个调用，如果是CI分析</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913172709985.png" alt="image-20230913172709985"></p><h3 id="object-sensitivity"><a href="#object-sensitivity" class="headerlink" title="object sensitivity"></a>object sensitivity</h3><p><img src="/2023/08/31/program-analysis-NJU/image-20230913193654682.png" alt="image-20230913193654682"></p><p>另一种表现形式的select，根据receiver object和heap context来区分</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913195207715.png" alt="image-20230913195207715"></p><p>this指的是上下文本身（对象）</p><p>和1call site进行对比</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913195721511.png" alt="image-20230913195721511"></p><p>换成2 call site能区分</p><p>object是否一定比call site好呢</p><p>this一样，调用的方法也一样</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913201016340.png" alt="image-20230913201016340"></p><ul><li>一般情况下精度是不可比较的</li><li>但是对Java这种OO语言，object更准确</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230913201700466.png" alt="image-20230913201700466"></p><h3 id="type-sensitivity"><a href="#type-sensitivity" class="headerlink" title="type sensitivity"></a>type sensitivity</h3><p>实际上是对object的抽象</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913202205377.png" alt="image-20230913202205377"></p><p>InType得到的不是生成的对象的类型，而是语句所在类</p><p>精度不如对象敏感技术，牺牲了精度换取速度</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913202510805.png" alt="image-20230913202510805"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913201401242.png" alt="image-20230913201401242"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913202953061.png" alt="image-20230913202953061"></p><h1 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h1><p>抽象什么是安全：在敌手存在时达成某个目标</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913205207631.png" alt="image-20230913205207631"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913205405562.png" alt="image-20230913205405562"></p><p>美国的NVD发现最多的漏洞是injection</p><p>injection和leak实际上是一类问题，信息流</p><h2 id="Information-Flow-Security"><a href="#Information-Flow-Security" class="headerlink" title="Information Flow Security"></a>Information Flow Security</h2><p>目标：阻止不必要的信息流</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913205701513.png" alt="image-20230913205701513"></p><ul><li>Access Control：标准方法，检查是否具有权限来访问特定信息；考虑信息是如何被处理的<ul><li>得到信息后如何使用？</li></ul></li><li>信息流安全 end2end<ul><li>跟踪程序如何安全地处理信息</li><li>考虑信息如何传播</li></ul></li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230913205921749.png" alt="image-20230913205921749"></p><p>信息论的定义</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913210049720.png" alt="image-20230913210049720"></p><p>给变量分级</p><p>不同等级变量之间信息如何流动</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913210226746.png" alt="image-20230913210226746"></p><p>最简单分法是2级分法（使用最广泛</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913210241719.png" alt="image-20230913210241719"></p><p>可以利用偏序关系（格）来建模</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913210345697.png" alt="image-20230913210345697"></p><p>可以有比较复杂的level设置</p><p>policy：限制信息如何在不同密级之间流动</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913211342441.png" alt="image-20230913211342441"></p><ul><li>高级变量不能影响低级变量</li><li>通过观测低级信息无法推测出高级信息</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230913211325855.png" alt="image-20230913211325855"></p><h2 id="Confidentiality-and-Integrity"><a href="#Confidentiality-and-Integrity" class="headerlink" title="Confidentiality and Integrity"></a>Confidentiality and Integrity</h2><p><img src="/2023/08/31/program-analysis-NJU/image-20230913211612588.png" alt="image-20230913211612588"></p><p>和密码学定义的Integrity不同，更像是真实性，外界信息的真实性</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913211740289.png" alt="image-20230913211740289"></p><p>给US air force提出的问题</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913212019260.png" alt="image-20230913212019260"></p><p>从完整性角度看，高级流向低级也不安全</p><p>扩展完整性的定义，之前的定义有点类似于正确性</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913212158190.png" alt="image-20230913212158190"></p><p>数据流和信息流的区别：</p><p>数据流可以看做具体的数据</p><p>信息流更加抽象，广义，可以将数据流看做是信息流</p><h2 id="Explicit-Flows-and-Covert-Channels"><a href="#Explicit-Flows-and-Covert-Channels" class="headerlink" title="Explicit Flows and Covert Channels"></a>Explicit Flows and Covert Channels</h2><p><img src="/2023/08/31/program-analysis-NJU/image-20230913212559603.png" alt="image-20230913212559603"></p><p>以上是显式流动</p><p>秘密可能作为条件语句的判断条件，称为隐式流</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913212739282.png" alt="image-20230913212739282"></p><p>while循环 是一个信息流，但不是数据流</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913213034386.png" alt="image-20230913213034386"></p><p>最后一个如果为负数，可能有error</p><p>统称上面这种类型为隐藏信道</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913213249693.png" alt="image-20230913213249693"></p><p>还有侧信道，观察缓存命中率</p><p>总结所有类型的CC非常有挑战性</p><p>一般情况下，Cover Channel泄露信息有限</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913213650461.png" alt="image-20230913213650461"></p><p>因此后续课程主要采用污点分析分析显式流</p><ul><li>感觉后者更有意义</li></ul><h2 id="Taint-Analysis"><a href="#Taint-Analysis" class="headerlink" title="Taint Analysis"></a>Taint Analysis</h2><p>使用最广泛的信息流分析工具</p><p>数据分类</p><ul><li>感兴趣的数据，label（同位素）</li><li>untainted </li></ul><p>污点数据来源于特定方法的返回值</p><p>关心污点数据是否会流动到特定的sink，一般是一些比较敏感的方法</p><p>是否存在从source到sink的流</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913213911354.png" alt="image-20230913213911354"></p><p>应用</p><ul><li>保密性： $\text{ secret data} \to \text{method}$</li><li>完整性：$\text{input} \to \text{critical command}$</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230913214159779.png" alt="image-20230913214159779"></p><p>两个性质的对称性</p><p>污点分析回答的问题</p><ul><li>标记数据是否会流动到某个sink（sink的指针会指向标记的数据吗？）</li></ul><p>两者是高度一致的，因此可以借助指针分析进行污点分析</p><ul><li>将标记的数据视为特殊的object</li><li>source是allocation site</li><li>利用指针分析进行污点数据传播</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230913214528489.png" alt="image-20230913214528489"></p><p>首先扩展指针分析的定义域，污点数据是指针分析的子集</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913214946878.png" alt="image-20230913214946878"></p><p>输入输出</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913215045186.png" alt="image-20230913215045186"></p><p>规则</p><p>call：如果dispatch方法来自source，认为可能是需要污点分析的</p><p>后续的传播和指针分析一样</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913215415014.png" alt="image-20230913215415014"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913215406095.png" alt="image-20230913215406095"></p><p>检查sink？调用sink方法时，参数是否是tainted</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913215502781.png" alt="image-20230913215502781"></p><p>例子</p><p>java中都是浅拷贝</p><p>x和y是别名</p><p>方便debug</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913220135749.png" alt="image-20230913220135749"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913220115069.png" alt="image-20230913220115069"></p><p>对于运算符重载，需要更复杂的机制设计</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913220301552.png" alt="image-20230913220301552"></p><h1 id="Datalog-Based-Program-Analysis"><a href="#Datalog-Based-Program-Analysis" class="headerlink" title="Datalog-Based Program Analysis"></a>Datalog-Based Program Analysis</h1><h2 id="Motivation-2"><a href="#Motivation-2" class="headerlink" title="Motivation"></a>Motivation</h2><p>命令式语言：</p><p>声明式语言：sql</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913221434446.png" alt="image-20230913221434446"></p><p>实现一个复杂的指针分析，采用不同语言的区别</p><p>回顾指针分析的rules和算法</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913221600990.png" alt="image-20230913221600990"></p><p>还需要考虑的细节</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913221610803.png" alt="image-20230913221610803"></p><p>如果用声明式语言实现</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913221806951.png" alt="image-20230913221806951"></p><p>可读性更强了</p><h2 id="Introduction-1"><a href="#Introduction-1" class="headerlink" title="Introduction"></a>Introduction</h2><p>声明式逻辑编程语言，Prolog的子集</p><p>曾经是数据库的查询语言</p><ul><li>程序分析</li><li>网络协议</li><li>吹牛</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230913222022073.png" alt="image-20230913222022073"></p><p>没有控制流？没有函数</p><p>表达能力不够</p><h3 id="data-predicate"><a href="#data-predicate" class="headerlink" title="data/predicate"></a>data/predicate</h3><p>事实</p><p>数据的表</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913222125660.png" alt="image-20230913222125660"></p><p>元组属于data，真的，称为fact</p><p>谓词由Atom表示</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913222349159.png" alt="image-20230913222349159"></p><p>原子可以判定真假 </p><p>下面这个类型也是原子</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913222547175.png" alt="image-20230913222547175"></p><h3 id="Rules-Logic"><a href="#Rules-Logic" class="headerlink" title="Rules/Logic"></a>Rules/Logic</h3><p>制定了如何推导fact</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913222737380.png" alt="image-20230913222737380"></p><p><code>，</code>是逻辑与</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913222823795.png" alt="image-20230913222823795"></p><p>如何理解规则</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913222951872.png" alt="image-20230913222951872"></p><p>考虑所有组合，如果一个组合可以让所有子目标为真，head为真，包含所有为真的谓词</p><p>交换subgoal不交换结果</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913223252088.png" alt="image-20230913223252088"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913223410217.png" alt="image-20230913223410217"></p><p>问题在于初始数据来源</p><ul><li><p>EDB：程序运行前定义好的；不变； </p></li><li><p>IDB：根据Rules定义，程序的输出，head只能是IDB</p></li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230913223615033.png" alt="image-20230913223615033"></p><p>表示 或</p><p>写两条语句或者采用<code>;</code></p><p>优先级低</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913223949083.png" alt="image-20230913223949083"></p><p>表示非采用<code>!</code></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913224015374.png" alt="image-20230913224015374"></p><p>否 是搜索所有情况吗</p><p>支持递归，能力强大的来源</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913224101296.png" alt="image-20230913224101296"></p><p>如果没有递归，只能支持基本的关系代数</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913224230753.png" alt="image-20230913224230753"></p><p>需要保证规则是safe，所有的变量是有限的</p><ul><li>表是有限的，表取反就是无限的</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230913224527154.png" alt="image-20230913224527154"></p><p>取反和递归必须分开</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913224943480.png" alt="image-20230913224943480"></p><p>程序如何执行？engine</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230913225056738.png" alt="image-20230913225056738"></p><p>只能产生facts</p><h2 id="Pointer-Analysis"><a href="#Pointer-Analysis" class="headerlink" title="Pointer Analysis"></a>Pointer Analysis</h2><p>指针分析的EDB是语法分析可以直接获得到的信息</p><p>IDB是指针分析的结果</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914081639719.png" alt="image-20230914081639719"></p><p>通过定义域定义4类语句</p><p>IDB只有2类，变量指向和fields指向</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914082014217.png" alt="image-20230914082014217"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914082257853.png" alt="image-20230914082257853"></p><p>程序的可读性非常强，代码实现很干净</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914082932296.png" alt="image-20230914082932296"></p><p>首先运行New，因为varpoints都是空</p><p>将整个New复制到Varpointsto</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914083536305.png" alt="image-20230914083536305"></p><p>终止条件：不再能产生新的facts</p><p>如何处理函数</p><p>引入新的谓词 EDB和IDB</p><p>k应该包含参数信息，不然无法处理多态</p><p>和之前类似，传4部分信息</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914090327689.png" alt="image-20230914090327689"></p><p>增加对入口方法的处理即有了全程序分析</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914090712426.png" alt="image-20230914090712426"></p><h2 id="Taint-Analysis-1"><a href="#Taint-Analysis-1" class="headerlink" title="Taint Analysis"></a>Taint Analysis</h2><p>在指针分析的基础上，修改EDB和IDB</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914091418518.png" alt="image-20230914091418518"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914091438076.png" alt="image-20230914091438076"></p><p>_是因为不关心当前的下标</p><p>优势和劣势</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914095905639.png" alt="image-20230914095905639"></p><ul><li>简洁、可读性强</li><li>engine优化，效率高</li></ul><p>缺点</p><ul><li>表达性受限，不是图灵完备<ul><li>如果需要删除facts，无法实现</li><li>对于all的逻辑不是很好表达</li></ul></li><li>engine是黑盒，无法自行优化效率</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230914100142781.png" alt="image-20230914100142781"></p><h1 id="CFL-Reachability-and-IFDS"><a href="#CFL-Reachability-and-IFDS" class="headerlink" title="CFL-Reachability and IFDS"></a>CFL-Reachability and IFDS</h1><p>context free language是IFDS的理论基础</p><p>利用图可达进行程序分析表达</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914101547722.png" alt="image-20230914101547722"></p><p>放松心态，学懂50%就算成功！</p><h2 id="Feasiable-and-Realizable-Paths"><a href="#Feasiable-and-Realizable-Paths" class="headerlink" title="Feasiable and Realizable Paths"></a>Feasiable and Realizable Paths</h2><p>存在一些路径是不可达的</p><p>希望程序分析尽可能不被这些不可达路径污染，然而静态分析中这个问题是不可判定的</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914101250283.png" alt="image-20230914101250283"></p><p>红色路径是静态分析无法避免的错误</p><p>绿色路径可以通过上下文敏感避免</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914101854201.png" alt="image-20230914101854201"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914101908102.png" alt="image-20230914101908102"></p><p>realizable path：跨函数调用的返回应该和call匹配</p><p>unrealizable一定是不会执行的，如何识别</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914102037213.png" alt="image-20230914102037213"></p><p>括号匹配，太复杂就不适用，寻找系统的方法</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914102223380.png" alt="image-20230914102223380"></p><h2 id="CFL-reachability"><a href="#CFL-reachability" class="headerlink" title="CFL-reachability"></a>CFL-reachability</h2><p>上下文无关文法生成的是上下文无关语言</p><p>没学过编译但学过计算理论</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914102916339.png" alt="image-20230914102916339"></p><p>编程语言文法一般是CFG</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914103028029.png" alt="image-20230914103028029"></p><p>部分 括号匹配</p><p>有右括号一定有左括号，反之不一定成立（call了不一定return）</p><p>通过call-site进行括号的索引</p><p>如何形式化括号匹配的问题？写CFL的语法</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914104300136.png" alt="image-20230914104300136"></p><p>从规则来看，没有单独产生右括号的规则</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914104707483.png" alt="image-20230914104707483"></p><h2 id="IFDS"><a href="#IFDS" class="headerlink" title="IFDS"></a>IFDS</h2><p><img src="/2023/08/31/program-analysis-NJU/image-20230914104809038.png" alt="image-20230914104809038"></p><p>可以通过图可达性来表达的图分析算法</p><p>不再是迭代式算法，用图的方式（没有传播的过程）</p><p>过程间的 <em>有限 可分配的</em> 子集问题</p><p>定义域有限 流函数是distributive</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914105259135.png" alt="image-20230914105259135"></p><p>具体可以认为是先meet再transfer和调换顺序结果一致</p><p>回顾MOP，利用IFDS能够给出MRP</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914105804428.png" alt="image-20230914105804428"></p><p>是所有edge上的f的复合函数</p><p>MOP是把所有path的结果并起来</p><p>MRP只考虑realizaable path（返回边和callsite对应，不能返回到之前已经返回过的边），不再沿着假的边去分析，可能更精准</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914110511798.png" alt="image-20230914110511798"></p><p>显然是MOP的子集</p><p>构造supergraph，定义flow func</p><p>构造explded supergraph</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914111707351.png" alt="image-20230914111707351"></p><p>$G^*$由一系列的$G_{main}$和$G_p$组成</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914140129907.png" alt="image-20230914140129907"></p><p>每个call site都有3条edge</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914140322154.png" alt="image-20230914140322154"></p><p>flow function的设计采用 可能未初始化的变量 的设计</p><p>具体的函数形式为lambda表达式</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914141003251.png" alt="image-20230914141003251"></p><p>lambda表达式类似于匿名函数，$\lambda e_{param}\cdot e_{body}$</p><p>无论输入，输出$x,g$</p><p>S是所有没有被初始化的值</p><p>$\lambda \ S.{S-x}$</p><p>减去g为了提高精度，真实情况不会有这条边，增加这一条边传播了本地变量的信息</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914142144730.png" alt="image-20230914142144730"></p><p>有了supergraph之后，建立exploded supergraph，拆分了flow function</p><p>D=2</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914142834835.png" alt="image-20230914142834835"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914144611310.png" alt="image-20230914144611310"></p><p>和传统的程序分析的定义区分，之前通过n4的out来判断存在</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914150855265.png" alt="image-20230914150855265"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914151715271.png" alt="image-20230914151715271"></p><p>利用tabulation算法判断可达性</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914151704558.png" alt="image-20230914151704558"></p><p>如果d可达就涂成蓝色</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914151857768.png" alt="image-20230914151857768"></p><p>这个算法比较复杂，不做详细介绍</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914152005445.png" alt="image-20230914152005445"></p><p>E是边的个数，D是domain size</p><p>处理exit节点时， 找到对应的call边</p><p>额外还有call到return的 summary edge，加速</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914152618402.png" alt="image-20230914152618402"></p><p>可分配性的理解</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914153507313.png" alt="image-20230914153507313"></p><p>具体问题能够利用IFDS解决需要用可分配性判断</p><p>IFDS的flow函数只能处理一个元素</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914153649860.png" alt="image-20230914153649860"></p><p>如果需要多个输入事实来判断能否产生正确的输出，不能用IFDS</p><p>最后的两个例子可以用IFDS</p><p>x,y,x.f指向o，正确吗</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914154323952.png" alt="image-20230914154323952"></p><p>缺少别名信息，这个信息同时需要x和y，因此指针分析不能用标准的IFDS</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914154812428.png" alt="image-20230914154812428"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914154937595.png" alt="image-20230914154937595"></p><h1 id="Soundness-and-Soundiness"><a href="#Soundness-and-Soundiness" class="headerlink" title="Soundness and Soundiness"></a>Soundness and Soundiness</h1><p>程序分析约有50年，soundiness是2015年提出的</p><p>前沿的话题</p><h2 id="soundness"><a href="#soundness" class="headerlink" title="soundness"></a>soundness</h2><p>保守的近似，近似所有可能的程序行为</p><ul><li>学术界：分析真实程序语言编写的完整的程序，没有sound</li><li>工业界：所有工具都不得不牺牲soundness</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230914155709950.png" alt="image-20230914155709950"></p><p>每个编程语言存在的难以分析的feature</p><p>比如js的eval，c对指针加减</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914155955552.png" alt="image-20230914155955552"></p><p>因此现在论文的结果可能声称是sound，对hard one是unsound；</p><p>或者忽略</p><p>不分析会导致严重的结果吗？Java</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914161155068.png" alt="image-20230914161155068"></p><p>soundiness指真实的程序没法分析一些困难的语言的特征</p><p>大佬振臂高呼，提soundiness</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914161603588.png" alt="image-20230914161603588"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914161732880.png" alt="image-20230914161732880"></p><p>三类概念的区别</p><p>为什么下面的两类很困难</p><h2 id="Hard-Language-Feature-Java-Reflection"><a href="#Hard-Language-Feature-Java-Reflection" class="headerlink" title="Hard Language Feature: Java Reflection"></a>Hard Language Feature: Java Reflection</h2><p>对java和安卓分析的噩梦，notorious</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914162225436.png" alt="image-20230914162225436"></p><p>为什么难分析</p><p>在Java编程语言中，反射（Reflection）是指在运行时动态地获取、检查和操作类、对象、方法和属性的能力。它允许程序在运行时通过名称来获取类的信息，调用方法，访问字段，创建对象等，而不需要在编译时明确地引用类或方法。</p><p>Java反射提供了一组类和接口，如<code>Class</code>、<code>Method</code>、<code>Field</code>等，用于在运行时检查和操作类的结构。通过使用反射，可以实现以下功能：</p><ol><li><strong>获取类的信息</strong>：通过反射，可以获取类的名称、父类、实现的接口、构造函数、方法和字段等信息。</li><li><strong>动态创建对象</strong>：通过反射，可以在运行时通过类名创建对象的实例，而无需提前知道类的具体类型。</li><li><strong>调用方法</strong>：通过反射，可以在运行时调用对象的方法，包括公共方法、私有方法和静态方法。</li><li><strong>访问和修改字段</strong>：通过反射，可以在运行时访问和修改对象的字段（即成员变量），包括公共字段和私有字段。</li><li><strong>操作数组</strong>：通过反射，可以动态创建、访问和修改数组对象。</li></ol><p><img src="/2023/08/31/program-analysis-NJU/image-20230914163513966.png" alt="image-20230914163513966"></p><p>反射是运行时行为</p><p>为什么需要分析呢（应用在哪里，松耦合，编程更灵活）</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914164026620.png" alt="image-20230914164026620"></p><p>右边这个例子可能是错误的</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914164317486.png" alt="image-20230914164317486"></p><p>分析反射的技术：字符串分析+指针分析</p><p>直观的想法</p><p>存在的问题：这些变量可能是从文件中读入的；编码过的</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914164531901.png" alt="image-20230914164531901"></p><p>李老师和谭老师的工作绕不过去</p><p>类型推理+字符串分析+指针分析</p><p>在调用的时候利用参数来推理</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914165357239.png" alt="image-20230914165357239"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914165556297.png" alt="image-20230914165556297"></p><p>目前最新的工作也是他俩做的</p><p>第三类方法，利用动态分析的结果，依赖于test case，给出的都是真的</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914165745956.png" alt="image-20230914165745956"></p><h2 id="Hard-Language-Feature-Native-Code"><a href="#Hard-Language-Feature-Native-Code" class="headerlink" title="Hard Language Feature: Native Code"></a>Hard Language Feature: Native Code</h2><p><img src="/2023/08/31/program-analysis-NJU/image-20230914165932042.png" alt="image-20230914165932042"></p><p>native声明指方法由外部语言实现的，如跨语言调用C/C++</p><p>JNI</p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914170548019.png" alt="image-20230914170548019"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914171130534.png" alt="image-20230914171130534"></p><p>现在的解决方案：</p><ul><li>手动建模native code<ul><li>用java简单模拟一下功能</li><li>大概比java实现快一个数量级</li></ul></li><li>binary分析</li></ul><p><img src="/2023/08/31/program-analysis-NJU/image-20230914171721458.png" alt="image-20230914171721458"></p><p><a href="http://soundiness.org/">Soundiness Home Page</a></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914172026836.png" alt="image-20230914172026836"></p><p><img src="/2023/08/31/program-analysis-NJU/image-20230914172057149.png" alt="image-20230914172057149"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习南京大学的静态程序分析技术课程&lt;/p&gt;
&lt;p&gt;课程主页：&lt;a href=&quot;https://tai-e.pascal-lab.net/lectures.html&quot;&gt;Static Program Analysis | Tai-e (pascal-lab.net)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;共计32小时&lt;/p&gt;</summary>
    
    
    
    
    <category term="static analysis" scheme="https://alleysira.github.io/tags/static-analysis/"/>
    
  </entry>
  
  <entry>
    <title>GearBox</title>
    <link href="https://alleysira.github.io/2023/08/18/GearBox/"/>
    <id>https://alleysira.github.io/2023/08/18/GearBox/</id>
    <published>2023-08-18T08:03:48.000Z</published>
    <updated>2023-11-02T09:11:15.968Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="GearBox-Optimal-size-Shard-Committees-by-Leveraging-the-Safety-Liveness-Dichotomy"><a href="#GearBox-Optimal-size-Shard-Committees-by-Leveraging-the-Safety-Liveness-Dichotomy" class="headerlink" title="GearBox: Optimal-size Shard Committees by Leveraging the Safety-Liveness Dichotomy"></a>GearBox: Optimal-size Shard Committees by Leveraging the Safety-Liveness Dichotomy</h1><p>David B, Magri B, Matt C, et al. GearBox: Optimal-size Shard Committees by Leveraging the Safety-Liveness Dichotomy[C]//Proceedings of the 2022 ACM SIGSAC Conference on Computer and Communications Security. 2022: 683-696.</p><span id="more"></span><p>分片是克服区块链可扩展性难题的新兴技术，没有分片，每个节点都必须监听和处理所有账本的信息</p><p>分片的基本思想是并行化账本协议：将节点划分为子集处理，通过执行轻量化的账本协议实例来处理部分原来的工作，分片越小，因为提高了并行化，分片共识协议的开销小，效率越高</p><p>沿着这个脉络，本文提出了一个新的方案——采用安全性-活性二分法，在分片共识种将活性和安全性拆分开，允许动态调整分片参数实现在当前腐化比例下最优的效率</p><ul><li>首先建立一个相对小的分片（诚实节点的比例可能很小）</li><li>在共识协议中仔细地用安全性来trade-off活性，来容忍小的诚实节点的比例，但不丧失安全性<ul><li>困难性在于分片想要获得活性，最坏情况下需要更高的诚实节点比例</li><li>采用一条永远满足活性和安全性的control chain来检测活性失败</li><li>分片被检测出不满足活性的情况下 重新设置为更大的分片大小和活性容忍度直到满足活，保证所有分片永远安全并且效率最优</li></ul></li><li>具体数据：10000参与方，30%的腐化比例，60-bit安全，之前的设计要求每个分片超过5800个参与方保证安全性，本方案最坏情况下需要1713节点，最好情况下需要35个节点</li></ul><p>在高并发的执行环境下，保证账本协议和子协议在通用组合下的安全性非常重要，为了证明协议的安全性，本文给出了分片账本、控制链和分片共识的理想的功能，形式化并证明了在UC框架下的安全性</p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>阻碍区块链大规模应用的障碍之一是较低的交易吞吐率，分片是克服这一困难的解</p><p>60bit安全的含义：保证安全性的概率为$1-2^{-60 } $</p><p>旧的安全性带来的参数要求：</p><ul><li>10000参与方，33%恶意，60bit安全，分片的大小为5886；</li><li>30bit的话，分片大小为3000；</li></ul><p>为了保证分片大小为几百，可以考虑降低安全性</p><p>区块链的安全性包含2个性质</p><ul><li>活性：交易在一定时间内会被打包，活性门限记作$L$</li><li>安全性：节点对输出的交易序列达成一致，安全性对应的门限记作$S$</li></ul><p>现有方案考虑的是最坏情况下的界，导致了活性和安全性的界相同</p><h2 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h2><p>采用活性和安全性分开的思想，企图实现尽可能小的分片大小，主要面对半同步网络（可以适用于同步网络），协议开始时采用激进的设置，活性门限较低（$S=0.89,L=0.05$），这样的设计会导致较小的分片大小，但是分片可能会死锁，因此引入了独立的一条链control-chain来检测分片的活性，分片需要向控制链发送heartbeat心跳交易，控制链可以解散死锁的分片，然后建立一个新的带有更高活性的分片，迭代直到寻找到了能够找到保持活性的最小分片大小；另一方面，没有检测到死锁时，可以动态降低分片的大小，已达到最优的分片大小</p><p>下面是两类实施本文方案的方法</p><ul><li>部分同步网络</li></ul><p>对于10000个节点，$L=0\%,S=99\%,Size=35\to L=30\%,S=39\%,Size=1713$</p><ul><li>混合模式</li></ul><p>能够运行同步的CC容忍50%的恶意敌手比例，在分片内为部分同步网络，能够切换到同步网络下（25%的恶意敌手之前）</p><p>静态与适应性安全：当敌手能够立即腐化超过半数委员会成员时，基于诚实大多数委员会保证安全的分片协议都基本会失败。Free2Shard能够容忍动态敌手，假设的安全模型不同，无法直接比较。如果假设腐化有时间延迟，可以通过重新选择委员会的方法保证安全性。</p><p>跨片通信：本文的分片可能丧失活性，依赖control-chain进行保证，基本思想是将相关交易的merkle树值包含在心跳信息中</p><p>UC形式化：给出了分片区块链的理想功能，证明了UC-realize，本文是第一个实现了任意组合下的安全性的分片区块链</p><h2 id="Technical-Overview"><a href="#Technical-Overview" class="headerlink" title="Technical Overview"></a>Technical Overview</h2><ul><li>Control chain 建模为一种定时的账本功能，对消息进行排序、打上时间戳。更形式化来说是全排序的广播，带有一致性和时间戳保证<ul><li>CC被所有参与方执行，但是仅存储分片的大小</li></ul></li><li>分片：建模为账本功能，参数包括分片委员会的大小和敌手比例<ul><li>协议不保证领导者恶意时的活性，因为可以利用cc进行恢复<ul><li>代价是需要经常更新委员会，解决无响应leader的机制更加复杂了</li></ul></li></ul></li><li>协议：协议的目标是实现一种分片的账本，开始时所有分片的委员会尽可能小，利用CC进行初始化和委员会重新选举<ul><li>协议的核心在于心跳消息，是的CC能够实时评估分片的活性，通过要求分片周期性发送区块的哈希值来实现，每次发送一个区块会设置一个超时时间，如果下一个有效的区块没有按时到来，分片被认为死锁</li><li>当分片死锁之后，采用更大的委员会重启来保证活性</li></ul></li></ul><h2 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work"></a>Related work</h2><p>目前对于分片区块链的研究，尤其是来自工业界的，对安全性的理解是启发式的，没有形式化的安全证明，因此这部分介绍少数几个知名的分片区块链</p><p>推荐综述[AFT19]Gang Wang, Zhijie Jerry Shi, Mark Nixon, and Song Han. 2019. SoK: Sharding on Blockchain. In Proceedings of the 1st ACM Conference on Advances in Financial Technologies, AFT 2019, Zurich, Switzerland, October 21-23, 2019. ACM, 41–61.<a href="https://doi.org/10.1145/3318041.3355457">https://doi.org/10.1145/3318041.3355457</a></p><p>分片区块链协议</p><ul><li>Elastico是第一个分片区块链，同步 每轮节点解PoW来确定委员会成员，puzzle的随机性来自于上一轮，作者希望实现小的分片委员会大小，但是6轮后不安全的概率为97%，导致协议的不安全</li><li>OmniLedger基于Elastico，PoW引入了身份，但是仅能在敌手小于25%实现高效率（能支持33%但是效率较差）</li><li>RapidChain作为同步的分片协议，能够容忍1/3的恶意敌手，每轮选举委员会，委员会及负责生成随机数</li><li>Monoxide提出了可横向扩展的区块链，提出了若干独立的并行的链，将网络的通信、计算和存储分散到不同区域内，当出现跨区交易时，采用最终原子性技术来保证一致性</li><li>Avarikioti[1]等人的工作提出了一个分片区块链的安全框架，基于比特币骨干协议，但是该框架不满足可组合性</li></ul><p>共性问题</p><ul><li>对于具体参数，委员会的大小必须足够大来保证分片的安全性</li><li>之前的文章没有考虑通用可组合性下的安全性</li></ul><h1 id="Preliminaries"><a href="#Preliminaries" class="headerlink" title="Preliminaries"></a>Preliminaries</h1><h2 id="安全模型"><a href="#安全模型" class="headerlink" title="安全模型"></a>安全模型</h2><p>需要给出同步和部分同布网络下UC安全的记号，假设参与方能够访问可靠的网络功能，时延上限为$\Delta_{NET}$，假设存在理想的签名功能，为了简洁，不给出所有功能的模型，而是给出参考文献，安全地实现本协议是一个很难并且独立的任务</p><ul><li>时间功能$\mathcal{F}_{CLOCK}$本质上等同于假设完美的同步 离散时钟，利用time slot表示两个时间刻度之间的间隙，也称tick，两个诚实参与者$P_i,P_j$分别在$r_i,r_j$时刻，则满足$|r_i-r_j|\leq 1$，参与者能够执行任意多项式复杂度的计算</li><li>网络$\mathcal{F}^{\Delta_{NET}}_{N-MC}$ 允许参与者进行多播消息，时延上限为$\Delta_{NET}$，当参与者对该上限不知情时是部分同步网络</li><li>敌手模型 考虑被腐化的敌手是静态的，5.3有扩展到适应性腐化的内容</li></ul><h1 id="Ledger-Functionalitiies"><a href="#Ledger-Functionalitiies" class="headerlink" title="Ledger Functionalitiies"></a>Ledger Functionalitiies</h1><h2 id="Sharded-Timed-Ledger"><a href="#Sharded-Timed-Ledger" class="headerlink" title="Sharded Timed Ledger"></a>Sharded Timed Ledger</h2><p>时序账本的账本$\mathcal{F}^\Delta_{BD-TL}$ 允许所有参与者输入消息，消息会被全局排序，提供时间戳，能保证一致性和活性</p><p><img src="/2023/08/18/GearBox/image-20230819180300128.png" alt="image-20230819180300128"></p><p>一致性要求了诚实节点的输出一定存在前缀的关系；活性要求发送的消息在$\Delta$时间内会出现在诚实节点的消息列表中</p><p>定义 $\mathcal{F}^\Delta_{BD-TL}:=\mathcal{F}^{\Delta,1}_{BD-STL}$，是仅有1个分片的特殊情况</p><p>时序账本可以用BFT类共识Hotstuff 或者 PoW的区块链来实现</p><p>分片的时序账本：简单来说是多个并行的时序账本的集合，每个独立的账本都是一个分片，假设分片的数量固定，每个分片有独立的标识符$sid$，以下给出$\mathcal{F}^{\Delta,1}_{BD-STL}$的形式化定义</p><p><img src="/2023/08/18/GearBox/image-20230819182237876.png" alt="image-20230819182237876"></p><p>和传统的链质量 链增长链前缀定义不同，看起来更简洁（？</p><p>本文的形式化更接近于 基于性质的定义，而不是传统的UC安全的定义</p><p>输出给敌手的含义是 对应的行为会向敌手泄露对应的行为发生了</p><h2 id="Shards"><a href="#Shards" class="headerlink" title="Shards"></a>Shards</h2><p>本质上一个分片就是一个账本，本文的定义为$\mathcal{F}^{s,\mathcal{L},\Delta}_{SHARD}$，由委员会的大小$s$，活性相关的敌手结构$\mathcal{L}$定义</p><p>敌手结构$\mathcal{L}$是一个集合，指分片功能必须在$(P_{i_1},\dots,P_{i_t})$为腐化节点时保持活性，其中$(P_{i_1},\dots,P_{i_t})\subset \mathcal{L}$</p><p>分片内的节点可以通过<code>SEND</code>命令发送交易，可以利用<code>CLOSE</code>命令关闭分片</p><p>分片需要保证的性质分别是</p><ul><li>证明的完备性：只有正确的描述才能产生有效的证明</li><li>抗审查性：防止敌手排除特定消息<ul><li>是活性不满足的情况下的一种保证</li></ul></li></ul><p><img src="/2023/08/18/GearBox/image-20230819184837902.png" alt="image-20230819184837902"></p><p><img src="/2023/08/18/GearBox/image-20230819185706285.png" alt="image-20230819185706285"></p><h1 id="Committee-selection-and-shard-consensus"><a href="#Committee-selection-and-shard-consensus" class="headerlink" title="Committee selection and shard consensus"></a>Committee selection and shard consensus</h1><p>分片的核心部分，讨论如何实现随机信标并分析委员会的大小</p><h2 id="Committee-selection"><a href="#Committee-selection" class="headerlink" title="Committee selection"></a>Committee selection</h2><p>委员会选择功能：$\mathcal{F}^{\mathcal{P,U}}_{COMSEL}$，其中集合$P$是参加委员会选择的节点，集合$\mathcal{U}$是委员会节点被选择出的集合</p><p>U和P的区别不明确</p><p><img src="/2023/08/18/GearBox/image-20230820091849435.png" alt="image-20230820091849435"></p><p><img src="/2023/08/18/GearBox/image-20230820091905102.png" alt="image-20230820091905102"></p><p>给出的选择方法看上去是随机选，实际上公有链上需要基于资源进行选择，因此需要一个虚拟的参与方集合  $\mathcal{U}$，这个集合是根据节点的资源生成的，因此不是简单的随机选</p><p>利用random beacon实现 $\mathcal{F}^{\mathcal{P,U}}_{COMSEL}$，所有参与者可以均匀随机选择随机性并且验证，具体实现是利用随机信标从$\mathcal{U}$中随机选一个$s$长的序列即可</p><p>Remark：目前实现中$\mathcal{U}$对应的是所有参与者，即一个参与者可能会出现在多个分片中，实际需要更复杂的机制来限制一个节点能够被分配的分片个数</p><p>其他实现委员会选择的方法：PoW和PoS，PoS可以分为：</p><ul><li>基于硬币投掷的随机性信标的均匀随机委员会选择</li><li>基于可验证随机函数的偏倚委员会选择（不满足抗偏置性，效率更高）</li></ul><h2 id="Shard-Consensus"><a href="#Shard-Consensus" class="headerlink" title="Shard Consensus"></a>Shard Consensus</h2><p>实现3.2中分片功能</p><p>$t_L$是活性能容忍的腐化节点数量，对应的安全性为$t_s:=s-2t_L-1$，仅在对应委员会大小下安全</p><p>调用$\mathcal{F}_{CT}^{\mathcal{P,D}}$能够获得大小为$s$的均匀随机的委员会，委员会的第一个成员作为特殊的leader，称为sequencer，周期性地提出新区块，如果至少$s-t_L$个人签署则认为有效</p><p>传统的BFT有换主的协议，本协议有外部的利用cc进行更换委员会的方式，不需要换主机制</p><p>因此分片活性的条件是至多$t_L$个腐化节点与领导者诚实</p><script type="math/tex; mode=display">\mathcal{F}_{SHARD}^{s,\mathcal{L},\Delta},\mathcal{L}=\{A\subseteq \{1,\dots,s \} |A|\leq t_L \land 1 \notin A \}</script><p>为了保证抗审查性，每个参与者发送新交易时包含若干旧交易，如果排序者没有包含这些就消息，拒绝为区块签名（丧失活性）</p><p>同样可以实现带有换主的分片共识，考虑到直接更换委员会效率较低，对应的功能为</p><script type="math/tex; mode=display">\mathcal{F}_{SHARD}^{s,\mathcal{L},\Delta},\mathcal{L}=\{A\subseteq \{1,\dots,s \} |A|\leq t_L \}</script><h2 id="确定委员会大小"><a href="#确定委员会大小" class="headerlink" title="确定委员会大小"></a>确定委员会大小</h2><p>分片协议需要获得最小的委员会大小$s_{min}$来保证腐化节点的数量小于给定的门限</p><p>超几何分布的形式，其中n是节点总数，s是委员会大小，$t’$是门限</p><script type="math/tex; mode=display">\operatorname{Pr}\left[\text { FAIL }_{t^{\prime}, s}^{t, n}\right]=\sum_{i=t^{\prime}+1}^{i=s} \frac{\left(\begin{array}{l}t \\i\end{array}\right)\left(\begin{array}{c}n-t \\s-i\end{array}\right)}{\left(\begin{array}{l}n \\s\end{array}\right)}</script><p>最大的腐化比例为$t’/s$，能够求出满足$\operatorname{Pr}\left[\text { FAIL }_{t^{\prime}, s}^{t, n}\right]\leq 2^{-\kappa}$的 $\kappa$，给出了python代码如何计算$\kappa$</p><p>委员会大小随着安全性要求指数级增长，因此降低诚实节点比例要求能够显著提高效率</p><p><img src="/2023/08/18/GearBox/image-20230820101337925.png" alt="image-20230820101337925"></p><p>表一给出了不同活性和安全性门限下的最小的委员会大小</p><p><img src="/2023/08/18/GearBox/image-20230820103157673.png" alt="image-20230820103157673"></p><h1 id="Constructing-a-sharded-ledger"><a href="#Constructing-a-sharded-ledger" class="headerlink" title="Constructing a sharded ledger"></a>Constructing a sharded ledger</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>为了实现$\mathcal{F}^{\Delta’,v}_{BD-TL}$，利用$\mathcal{F}^\Delta_{BD-TL}$作为控制链，$\mathcal{F}_{REPO}$存储分片确定的账本和之前的状态</p><p>反映了至少需要一方始终存储每个分片的状态的事实，分片功能有多个档位，即$\mathcal{F}_{SHARD}^{s_1,\mathcal{L},\Delta},\dots,\mathcal{F}_{SHARD}^{s_l,\mathcal{L},\Delta}$，其中委员会的大小逐渐增大</p><p>每个分片的共识协议 网络延迟和 活性结构均可以不同，分了方便分析固定了活性结构，延迟，活性保证$\gamma&gt;0$</p><p>GearBox能够保证两个性质</p><ul><li>安全性：对于每个大小为$s_i$的委员会，$\mathcal{F}_{SHARD}^{s_i,\mathcal{L},\Delta}$不满足安全性概率为$2^{-\kappa}$</li><li>Eventually live 最终活性：$\mathcal{F}_{SHARD}^{s_i,\mathcal{L},\Delta}$满足活性概率至少为$\gamma$</li></ul><p>首先运行$\mathcal{F}_{SHARD}^{s_1,\mathcal{L},\Delta}$观察是否满足活性，如果丧失活性则切换为$\mathcal{F}_{SHARD}^{s_2,\mathcal{L},\Delta}$，到达最大档位之后就是重启了</p><p>最坏情况下，$L=0.3,S=0.39$ 依然强于现有的共识方案</p><h2 id="分片区块链协议-Pi-BD-STL"><a href="#分片区块链协议-Pi-BD-STL" class="headerlink" title="分片区块链协议$\Pi_{BD-STL}$"></a>分片区块链协议$\Pi_{BD-STL}$</h2><p>检测活性失败的方法可以归纳为几类</p><ul><li>分片管理：$\mathcal{P}$中所有参与者执行的协议，为了维持分片的活性</li><li>分片操作：分片委员会成员的行为，仅执行与当前委员会相关的分片管理行为</li></ul><p>获得输入后，参与方执行实现了对应接口的指令</p><p>经典的一页协议</p><p><img src="/2023/08/18/GearBox/image-20230820111300956.png" alt="image-20230820111300956" style="zoom: 63%;"></p><p><img src="/2023/08/18/GearBox/image-20230820111322916.png" alt="image-20230820111322916"></p><p><img src="/2023/08/18/GearBox/image-20230820111404496.png" alt="image-20230820111404496" style="zoom:125%;"></p><p>定理5.1：以上协议在部分同步网络，静态敌手假设下 在 实现了UC 功能$\mathcal{F}_{BD-STL}^{\Delta’,v}$</p><p><img src="/2023/08/18/GearBox/image-20230820112558207.png" alt="image-20230820112558207"></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li>降低档位</li><li>适应性和移动腐化模型：重新选择委员会</li></ul><h2 id="跨片交易处理和通信"><a href="#跨片交易处理和通信" class="headerlink" title="跨片交易处理和通信"></a>跨片交易处理和通信</h2><p>本文不给出形式化的跨片通信机制的介绍</p><p>因为分片很可能重新启动，分片的交易不能立即认为有效，需要依赖控制链的CC交易，后续给出将gearbox利用到现有方案的方法</p><ul><li>Atomix（OmniLedger的跨片交易处理机制）：分片A的用户向发起到分片B的交易时，首先在A内发起export交易锁定金额，当export交易在A中被记录后，用户向B发送证明证明自己的交易被A接收了<ul><li>如果采用gearbox，可能导致A中的金额被锁定，B中被解锁，但是A在发送heartbeat之前崩溃了，导致双花</li><li>改进：用户的证明还需要证明该交易已经被CC确定了</li><li>分片的性能不受制于CC，因为一个heartbeat消息能够包含分片内的所有交易，即和跨片交易数量独立</li><li><img src="/2023/08/18/GearBox/image-20230820114026946.png" alt="image-20230820114026946"></li></ul></li><li>分片委员会驱动的跨片交易处理：分片的leader直接发送证明，开销转嫁到leader</li><li>向包含了证明的用户发放奖励，如果用户和leader都未能对跨片交易给出证明的话，存在激励机制鼓励其他用户进行</li></ul><h1 id="Instantiations"><a href="#Instantiations" class="headerlink" title="Instantiations"></a>Instantiations</h1><h2 id="Instantiation-of-Timed-Ledger"><a href="#Instantiation-of-Timed-Ledger" class="headerlink" title="Instantiation of Timed Ledger"></a>Instantiation of Timed Ledger</h2><p>之前都是模块化的设计，后续给出一个具体的协议</p><p>采用Hotstuff进行$\mathcal{F}_{BD-TL}^{\Delta}$，因为是固定换主的协议，但是不提供时间戳，leader将当前时间作为时间戳加入（假设weakly synchrnized clocks）</p><p>因为并不是所有的参与者需要从CC读写，CC需要满足1/3的安全性，最大为16037</p><h2 id="Instantiation-of-Shard-Consensus-and-Gearbox"><a href="#Instantiation-of-Shard-Consensus-and-Gearbox" class="headerlink" title="Instantiation of Shard Consensus and Gearbox"></a>Instantiation of Shard Consensus and Gearbox</h2><p>可以选择一种没有领导者替换或者像Hotstuff这种实现了领导者轮换制的共识协议，后续的分析主要是Hotstuff</p><p>具体可以选4个档位，活性的门限设置为10% 20% 25% 30%</p><h2 id="Instantiation-of-Randomness-Beacon"><a href="#Instantiation-of-Randomness-Beacon" class="headerlink" title="Instantiation of Randomness Beacon"></a>Instantiation of Randomness Beacon</h2><ul><li>可以采用外部无偏的随机数信标  <a href="https://drand.love/">Drand - Distributed Randomness Beacon.</a></li></ul><p>网页做的很好看</p><p><img src="/2023/08/18/GearBox/image-20230820151942150.png" alt="image-20230820151942150"></p><ul><li>可以采用外部PoS生成的公开可验证的随机数</li></ul><p>为了使用一种自给的方案，而不是依赖基于Hotstuff的CC，传统的PoS随机信标</p><p>UC安全的PVSS(ALBATROSS)要求每个参与方417120模幂运算，需要在CC链上写21.2Mbytes</p><p>VRF的效率更高，2112模幂+0.065MBytes的通信，然而存在偏置性，可以通过轻微增大委员会大小来减轻开销</p><h2 id="Efficiency-Analysis-of-Overall-Protocol"><a href="#Efficiency-Analysis-of-Overall-Protocol" class="headerlink" title="Efficiency Analysis of Overall Protocol"></a>Efficiency Analysis of Overall Protocol</h2><h3 id="为了活性需要选择的委员会个数"><a href="#为了活性需要选择的委员会个数" class="headerlink" title="为了活性需要选择的委员会个数"></a>为了活性需要选择的委员会个数</h3><ul><li>实际的敌手腐化比例为10%<ul><li>需要leader诚实，概率为90%</li><li>预期的委员会个数为2</li></ul></li><li>实际的腐化比例为30%<ul><li>选择出委员会中敌手比例不超过30%的概率是0.5</li><li>诚实领导者的概率为70%</li><li>期望的委员会个数小于6</li></ul></li></ul><h3 id="延迟和吞吐量"><a href="#延迟和吞吐量" class="headerlink" title="延迟和吞吐量"></a>延迟和吞吐量</h3><p>基于Hotstuff的实验结果,仅支持128节点，对后续的结果进行了推理</p><p>CC链的payload限制为128字节</p><p>延迟大概是$l=0.37s+6$，其中$s$是委员会的大小，约为6s</p><p>吞吐量计算公式约为$t=2400000/l$，约为404msg per sec</p><p>实际处理交易的分片的大小为1024Bytes</p><p>延迟大概是$l=0.67s+20$，其中$s$是委员会的大小，吞吐量计算公式约为$t=2400000/l$</p><p>委员会的大小取82, 232, 528, and 2264，延迟对应为75 175 374 1537 ms，吞吐量为32000,13714,6417和1561，实际的带宽取决于CC链的带宽</p><h3 id="可扩展性和分片数量的界"><a href="#可扩展性和分片数量的界" class="headerlink" title="可扩展性和分片数量的界"></a>可扩展性和分片数量的界</h3><p>由于HotStuff具有线性通信复杂度，而本文的委员会大小是有限的，因此我们的协议在通信复杂度方面具有可扩展性。</p><p>实际的分片数量受CC链的吞吐量限制，若CC链的吞吐量为400，分片每10s发heartbeat消息，则，能支持4000个分片，因此不支持无限的可扩展性，如果确实需要无限可扩展性，可以考虑采用多条CC链</p><h1 id="实验参数的分析"><a href="#实验参数的分析" class="headerlink" title="实验参数的分析"></a>实验参数的分析</h1><p>目标：2000节点，单片共识支持500个节点，单片错误概率小于$10^{-18}$，可扩展为4个分片（但好像不是我们的任务）</p><p><img src="/2023/08/18/GearBox/image-20230821092708085.png" alt="image-20230821092708085"></p><p><img src="/2023/08/18/GearBox/image-20230820185618306.png" alt="image-20230820185618306"></p><p><img src="/2023/08/18/GearBox/image-20230820185137655.png" alt="image-20230820185137655"></p><p>以下是K=18的结果</p><p><img src="/2023/08/18/GearBox/image-20230820185118323.png" alt="image-20230820185118323"></p><h1 id="Video"><a href="#Video" class="headerlink" title="Video"></a>Video</h1><p>链接：<a href="https://www.youtube.com/watch?v=pmeVnbRlJyQ&amp;ab_channel=TPBC">GearBox: An Efficient UC Sharded Ledger Leveraging the Safety-Liveness Dichotomy - YouTube</a></p><p><img src="/2023/08/18/GearBox/image-20230818184146046.png" alt="image-20230818184146046"></p><p>带入实际参数，想要满足安全性的话需要的节点太多，只能分2个片</p><p><img src="/2023/08/18/GearBox/image-20230818184310857.png" alt="image-20230818184310857"></p><p>如何进行优化</p><ul><li>降低全局敌手比例的界，找到实际中更精确的界</li><li>提高失败比例，比如40bit安全性可接受？</li></ul><p><img src="/2023/08/18/GearBox/image-20230818184637028.png" alt="image-20230818184637028"></p><p>仍然不够，实际的BFT算法超过1000节点效率就不高了</p><p>终极目标是：安全性不变，通过更少的分片内节点的数量，实现更高的效率（吞吐量）</p><p>如果想要保证安全性（全局敌手比例+60bit），只能从片内敌手比例入手了</p><p><img src="/2023/08/18/GearBox/image-20230818185205913.png" alt="image-20230818185205913"></p><p>当支持的片内敌手比例达到44%以下后，就需要1000个以上的节点了</p><p>难道不需要片内30%的比例来保证安全性吗？</p><p>本方案给出 安全性和活性二分法 来解决这个问题</p><p><img src="/2023/08/18/GearBox/image-20230818185503978.png" alt="image-20230818185503978"></p><p>如果$L=S$，就是之前的解</p><p>对于活性，假设诚实节点不会为冲突的区块签名，则活性可以归纳为</p><p><img src="/2023/08/18/GearBox/image-20230818190028903.png" alt="image-20230818190028903"></p><p>对于安全性，已知$2L+S&lt;1$成立，白色部分是剩下的部分</p><p><img src="/2023/08/18/GearBox/image-20230818190256418.png" alt="image-20230818190256418"></p><p>假设2个区块冲突了，即不满足安全性，则每个都被至少$1-L$个签名了，则同时为2个区块签名的节点数量（交叉的部分）大于$S$，即存在诚实节点为冲突的区块背书了，产生了冲突（不成立）</p><p>则得出结论：敌手比例小于$S$，能够满足安全性</p><p>问题：没有给出$2L+S&lt;1$的根据，在完整版论文的附录A</p><p><img src="/2023/08/18/GearBox/image-20230818190506447.png" alt="image-20230818190506447"></p><p>实际中一个更好的协议需要考虑</p><ul><li>最坏情况下，能够达到30%（半同步</li><li>一般情况下敌手比例会小于30%</li><li>当敌手比例小的时候，有更好的效率</li></ul><p><img src="/2023/08/18/GearBox/image-20230818191344481.png" alt="image-20230818191344481"></p><p>本方案类似于汽车的手动挡，安全性一定保证，活性以概率保证（丧失活性的概率是$2^\kappa$，以下是实现的结果</p><p><img src="/2023/08/18/GearBox/image-20230818191416876.png" alt="image-20230818191416876"></p><p>难点在于想要实现活性，但是不知道具体的敌手比例</p><p>解决方案是利用一条监控的链， 采用$S=L=1/3$，能够检测出活性不满足的情况</p><p>还需要解决死锁问题（不是传统意义的死锁，指丧失活性后。当分片需要调整安全性，换挡）</p><p><img src="/2023/08/18/GearBox/image-20230818193049568.png" alt="image-20230818193049568"></p><p><img src="/2023/08/18/GearBox/image-20230818193129685.png" alt="image-20230818193129685"></p><p>总结</p><ul><li>最主要的贡献：给出了将活性和安全性分开的两个不等式</li><li>提出了根据具体情况牺牲活性，来提高效率的思想</li><li>给出了UC安全的证明（看不懂</li></ul><p>可研究的点</p><ul><li>目前所有分片都从最低档开始逐级提高活性，能否有其他的机制，一步达到最优的活性的解<ul><li>首先运行少数分片实例</li><li>等待首批分片达到活性后，采用首批分片达到活性时的平均值作为其其余分片的初始配置</li></ul></li><li>本文实际上的分片是要求所有共识节点维护一条全局的链来收集状态，另外分片再维护分片的链进行交易处理<ul><li>Control Chain带来的开销需要考虑</li><li>考虑如何优化这种架构</li></ul></li><li>具体如何实现这个共识没有开源</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;GearBox-Optimal-size-Shard-Committees-by-Leveraging-the-Safety-Liveness-Dichotomy&quot;&gt;&lt;a href=&quot;#GearBox-Optimal-size-Shard-Committees-by-Leveraging-the-Safety-Liveness-Dichotomy&quot; class=&quot;headerlink&quot; title=&quot;GearBox: Optimal-size Shard Committees by Leveraging the Safety-Liveness Dichotomy&quot;&gt;&lt;/a&gt;GearBox: Optimal-size Shard Committees by Leveraging the Safety-Liveness Dichotomy&lt;/h1&gt;&lt;p&gt;David B, Magri B, Matt C, et al. GearBox: Optimal-size Shard Committees by Leveraging the Safety-Liveness Dichotomy[C]//Proceedings of the 2022 ACM SIGSAC Conference on Computer and Communications Security. 2022: 683-696.&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/categories/Blockchain/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="Sharding" scheme="https://alleysira.github.io/tags/Sharding/"/>
    
  </entry>
  
  <entry>
    <title>blockchain_security_practice</title>
    <link href="https://alleysira.github.io/2023/08/08/blockchain-security-practice/"/>
    <id>https://alleysira.github.io/2023/08/08/blockchain-security-practice/</id>
    <published>2023-08-08T07:24:54.000Z</published>
    <updated>2023-09-07T08:52:49.637Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>记录进行区块链安全相关实践的内容</p><span id="more"></span><h1 id="Etherscan"><a href="#Etherscan" class="headerlink" title="Etherscan"></a>Etherscan</h1><p>网址 <a href="https://etherscan.io/">Ethereum (ETH) Blockchain Explorer (etherscan.io)</a></p><p>该地址下可以看到已经部署验证后的合约<a href="https://etherscan.io/contractsVerified">Ethereum Verified Contracts</a></p><p>以<a href="https://goerli.etherscan.io/address/0xD1077555f910F90EFC8Bd755EaA9B2772907189D#code">ERC20Staking</a>合约为例，能够看到合约的源代码，合约的ABI、合约的合约创建代码和合约的部署字节码</p><ul><li><p>合约创建代码定义了合约的初始状态、功能和行为。通常包括合约的构造函数和初始状态设置。以字节码的形式存在</p></li><li><p>合约的部署字节码，也称为运行时字节码，是智能合约在部署到以太坊网络后实际运行的字节码表示形式</p></li></ul><p><img src="/2023/08/08/blockchain-security-practice/image-20230808153518780.png" alt="image-20230808153518780"></p><p>可以对合约的字节代码进行反编译</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230808153721923.png" alt="image-20230808153721923"></p><p>顺便测试之前老师提到的 智能合约反编译的网站 <a href="https://ethervm.io/decompile">https://ethervm.io/decompile</a></p><p>填写合约地址，选择对应的测试网后能够进行反编译，给出合约的public函数和internal函数，合约源代码以及反汇编的结果</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230808154346951.png" alt="image-20230808154346951" style="zoom: 67%;"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230808154435450.png" alt="image-20230808154435450"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230808154716045.png" alt="image-20230808154716045"></p><h2 id="Blocksec-MetaDock"><a href="#Blocksec-MetaDock" class="headerlink" title="Blocksec-MetaDock"></a>Blocksec-MetaDock</h2><p>安装了MetaDock之后能够在浏览器的IDE中直接查看合约的源代码</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230808162645237.png" alt="image-20230808162645237"></p><ul><li>[ ] 但是好像没有之前老师的下载zip的功能，后续再请教一下老师</li></ul><h2 id="安装solidity编译器"><a href="#安装solidity编译器" class="headerlink" title="安装solidity编译器"></a>安装solidity编译器</h2><p>参考登链社区翻译的 <a href="https://solidity-cn.readthedocs.io/zh/develop/installing-solidity.html">文档</a> 在Ubuntu上安装编译器</p><p>最好安装<a href="https://github.com/crytic/solc-select">crytic/solc-select: Manage and switch between Solidity compiler versions (github.com)</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:ethereum/ethereum</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install solc</span><br></pre></td></tr></table></figure><p>安装成功</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230808162254861.png" alt="image-20230808162254861"></p><p>写了一个简单的合约后采用solc进行编译，下载的编译器版本只能编译0.8.21的合约</p><p>采用 <code>--bin</code> 参数能够在命令行直接输出字节码</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230808164530260.png" alt="image-20230808164530260"></p><p>采用<code>--abi --opcodes</code>参数能分别显示合约的abi和操作码</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230808164836841.png" alt="image-20230808164836841"></p><p>加-o 参数可以把编译结果写入文件</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230808165222863.png" alt="image-20230808165222863"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230808165241088.png" alt="image-20230808165241088"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230808165357492.png" alt="image-20230808165357492"></p><p>合约的源码 字节码和操作码之间的关系：</p><ul><li>源代码是人类可读的智能合约程序代码，通常使用 Solidity 这样的高级编程语言编写。源码首先被编译成EVM操作码，再被被编码成字节码 </li><li>操作码是EVM的基本指令，包括数学运算、位运算、流程控制等</li><li>字节码是合约在区块链上实际执行的形式，包括操作码opcode和操作数operand，每个字节对应一个操作码或者操作数；操作码一般是1个字节，操作数可以是多个字节</li></ul><h1 id="Ganache和MetaMask"><a href="#Ganache和MetaMask" class="headerlink" title="Ganache和MetaMask"></a>Ganache和MetaMask</h1><p><img src="/2023/08/08/blockchain-security-practice/image-20230809123056555.png" alt="image-20230809123056555" style="zoom:67%;"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230809123117003.png" alt="image-20230809123117003"></p><p>可以查看发币的交易</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230809123156744.png" alt="image-20230809123156744"></p><p>领取LINK token</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230809123255480.png" alt="image-20230809123255480"></p><p>安装好Ganathe后，将一个账户的私钥导入metamask并添加测试网络，填写RPC和链ID等信息</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230809150904086.png" alt="image-20230809150904086"></p><p>成功将metamask与ganathe连接</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230809123908501.png" alt="image-20230809123908501"></p><h1 id="Remix"><a href="#Remix" class="headerlink" title="Remix"></a>Remix</h1><p>将合约部署在测试网Sepolia上</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230809152038862.png" alt="image-20230809152038862"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230809152103463.png" alt="image-20230809152103463"></p><p>将合约部署在Ganathe上</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230809151550887.png" alt="image-20230809151550887"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230809151841133.png" alt="image-20230809151841133"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230809151740084.png" alt="image-20230809151740084"></p><h1 id="Smartbugs工具使用"><a href="#Smartbugs工具使用" class="headerlink" title="Smartbugs工具使用"></a>Smartbugs工具使用</h1><p>Smartbugs集成了19种智能合约漏洞检查的工具，并提供了统一的调用接口，现已为2.0版本（还挂在arxiv上</p><p>项目地址 <a href="https://github.com/smartbugs/smartbugs">smartbugs/smartbugs: SmartBugs: A Framework to Analyze Ethereum Smart Contracts (github.com)</a></p><p>支持的工具包括</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230808161355316.png" alt="image-20230808161355316" style="zoom:67%;"></p><p>对分析后结果进行解析，方便肉眼查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./reparse results <span class="comment"># 获得json</span></span><br><span class="line">./results2csv -p results &gt; results.csv <span class="comment">#得到csv文件</span></span><br></pre></td></tr></table></figure><p><img src="/2023/08/08/blockchain-security-practice/image-20230809104309202.png" alt="image-20230809104309202"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230809104629946.png" alt="image-20230809104629946"></p><h2 id="Confuzzius"><a href="#Confuzzius" class="headerlink" title="Confuzzius"></a>Confuzzius</h2><p>项目地址 <a href="https://github.com/christoftorres/ConFuzzius">christoftorres/ConFuzzius: A data dependency-aware hybrid fuzzer for Ethereum smart contracts (EuroS&amp;P 2021). (github.com)</a> 玩了个孔子的谐音梗</p><p>下载作者提供的docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull christoftorres/confuzzius</span><br><span class="line">docker run -i -t christoftorres/confuzzius</span><br><span class="line">python3 fuzzer/main.py -s examples/TokenSale/contracts/TokenSale.sol -c TokenSale --solc v0.4.26 --evm byzantium -t 10</span><br></pre></td></tr></table></figure><p>测试的合约是被测试合约为TokenSale.sol，比较简单</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.26;</span><br><span class="line"></span><br><span class="line">interface Token &#123;</span><br><span class="line">  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);</span><br><span class="line">  function allowance(address owner, address spender) external view returns (uint256);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract TokenSale &#123;</span><br><span class="line">  uint256 start = now;</span><br><span class="line">  uint256 end = now + 30 days;</span><br><span class="line">  address wallet = 0xCafEBAbECAFEbAbEcaFEbabECAfebAbEcAFEBaBe;</span><br><span class="line">  Token token = Token(0x1234567812345678123456781234567812345678);</span><br><span class="line"></span><br><span class="line">  address owner;</span><br><span class="line">  bool sold;</span><br><span class="line"></span><br><span class="line">  function Tokensale() public &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function buy() public payable &#123;</span><br><span class="line">    require(now &lt; end);</span><br><span class="line">    require(msg.value == 42 ether + (now - start) / 60 / 60 / 24 * 1 ether);</span><br><span class="line">    require(token.transferFrom(this, msg.sender, token.allowance(wallet, this)));</span><br><span class="line">    sold = true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function withdraw() public &#123;</span><br><span class="line">    require(msg.sender == owner);</span><br><span class="line">    require(now &gt;= end);</span><br><span class="line">    require(sold);</span><br><span class="line">    owner.transfer(address(this).balance);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验结果显示代码覆盖率非常优秀，能够检测出区块信息依赖和以太币泄露漏洞</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230726161506767.png" alt="image-20230726161506767"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230726161452774.png" alt="image-20230726161452774"></p><p>能够给出具体产生漏洞的交易序列：</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230726161536978.png" alt="image-20230726161536978"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230726161548380.png" alt="image-20230726161548380"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230726161601382.png" alt="image-20230726161601382"></p><h3 id="测试较为复杂的合约WalletLibrary"><a href="#测试较为复杂的合约WalletLibrary" class="headerlink" title="测试较为复杂的合约WalletLibrary"></a>测试较为复杂的合约WalletLibrary</h3><p><img src="/2023/08/08/blockchain-security-practice/image-20230726161201164.png" alt="image-20230726161201164"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230726161215584.png" alt="image-20230726161215584"></p><p>代码覆盖率依然比较优秀，74.99%（2881/3842），单个合约仅10.62s</p><h2 id="Mythril"><a href="#Mythril" class="headerlink" title="Mythril"></a>Mythril</h2><p>这个工具是HITB大会上Smashing Ethereum Smart Contracts for Fun and Real Profit这篇报告对应的工具，据Confuzzius作者在论文中提到，是Smartbugs1.0工具中效果最好的</p><p>项目地址 <a href="https://github.com/Consensys/mythril">Consensys/mythril: Security analysis tool for EVM bytecode. Supports smart contracts built for Ethereum, Hedera, Quorum, Vechain, Roostock, Tron and other EVM-compatible blockchains. (github.com)</a></p><h3 id="Smartbugs内的测试"><a href="#Smartbugs内的测试" class="headerlink" title="Smartbugs内的测试"></a>Smartbugs内的测试</h3><p>测试samples目录下所有合约</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jie@jie-virtual-machine:~/smartbugs$ ./smartbugs -t mythril -f samples/*.sol --processes 2 --mem-limit 4g --timeout 600</span><br></pre></td></tr></table></figure><p><img src="/2023/08/08/blockchain-security-practice/image-20230808190913454.png" alt="image-20230808190913454"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230808191054123.png" alt="image-20230808191054123"></p><h3 id="安装作者提供的工具"><a href="#安装作者提供的工具" class="headerlink" title="安装作者提供的工具"></a>安装作者提供的工具</h3><p>下载作者提供的docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mythril/myth</span><br></pre></td></tr></table></figure><p>参考文档<a href="https://mythril-classic.readthedocs.io/en/master/installation.html#docker">官方文档</a>进行调用</p><p>windows没跑出结果，已经在github上跟作者反应了，<a href="https://github.com/Consensys/mythril/issues/1790">Issues · Consensys/mythril (github.com)</a>，怀疑是powershell的问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@jie-virtual-machine:~$ docker run mythril/myth a /opt/mythril/solidity_examples/calls.sol mythril.interfaces.cli [ERROR]: Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/mythril/interfaces/cli.py&quot;</span>, line 966, <span class="keyword">in</span> parse_args_and_execute</span><br><span class="line">    address = load_code(disassembler, args)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/mythril/interfaces/cli.py&quot;</span>, line 717, <span class="keyword">in</span> load_code</span><br><span class="line">    address, _ = disassembler.load_from_solidity(</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/mythril/mythril/mythril_disassembler.py&quot;</span>, line 252, <span class="keyword">in</span> load_from_solidity</span><br><span class="line">    solc_binary = self.solc_binary or util.extract_binary(file)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/mythril/ethereum/util.py&quot;</span>, line 227, <span class="keyword">in</span> extract_binary</span><br><span class="line">    with open(file) as f:</span><br><span class="line">FileNotFoundError: [Errno 2] No such file or directory: <span class="string">&#x27;/opt/mythril/solidity_examples/calls.sol&#x27;</span></span><br></pre></td></tr></table></figure><p>换了Ubuntu之后，可以成功挂载本地合约进行测试了</p><p>实验命令和实验结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><span class="line">jie@jie-virtual-machine:~$ docker run -v $(<span class="built_in">pwd</span>):/tmp mythril/myth analyze /tmp/contracts/calls.sol</span><br><span class="line">==== External Call To User-Supplied Address ====</span><br><span class="line">SWC ID: 107</span><br><span class="line">Severity: Low</span><br><span class="line">Contract: Caller</span><br><span class="line">Function name: thisisfine()</span><br><span class="line">PC address: 461</span><br><span class="line">Estimated Gas Usage: 2077 - 36971</span><br><span class="line">A call to a user-supplied address is executed.</span><br><span class="line">An external message call to an address specified by the <span class="built_in">caller</span> is executed. Note that the callee account might contain arbitrary code and could re-enter any <span class="keyword">function</span> within this contract. Reentering the contract <span class="keyword">in</span> an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are <span class="keyword">in</span> place.</span><br><span class="line">--------------------</span><br><span class="line">In file: /tmp/contracts/calls.sol:15</span><br><span class="line"></span><br><span class="line">fixed_address.call(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">--------------------</span><br><span class="line">Initial State:</span><br><span class="line"></span><br><span class="line">Account: [CREATOR], balance: 0x0, nonce:0, storage:&#123;&#125;</span><br><span class="line">Account: [ATTACKER], balance: 0x0, nonce:0, storage:&#123;&#125;</span><br><span class="line"></span><br><span class="line">Transaction Sequence:</span><br><span class="line"></span><br><span class="line">Caller: [CREATOR], calldata: 000000000000000000000000deadbeefdeadbeefdeadbeefdeadbeefdeadbeef0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, decoded_data: , value: 0x0</span><br><span class="line">Caller: [CREATOR], <span class="keyword">function</span>: thisisfine(), txdata: 0x5a6814ec, value: 0x0</span><br><span class="line"></span><br><span class="line">==== Unchecked <span class="built_in">return</span> value from external call. ====</span><br><span class="line">SWC ID: 104</span><br><span class="line">Severity: Medium</span><br><span class="line">Contract: Caller</span><br><span class="line">Function name: thisisfine()</span><br><span class="line">PC address: 461</span><br><span class="line">Estimated Gas Usage: 2077 - 36971</span><br><span class="line">The <span class="built_in">return</span> value of a message call is not checked.</span><br><span class="line">External calls <span class="built_in">return</span> a boolean value. If the callee halts with an exception, <span class="string">&#x27;false&#x27;</span> is returned and execution continues <span class="keyword">in</span> the <span class="built_in">caller</span>. The <span class="built_in">caller</span> should check whether an exception happened and react accordingly to avoid unexpected behavior. For example it is often desirable to wrap external calls <span class="keyword">in</span> require() so the transaction is reverted <span class="keyword">if</span> the call fails.</span><br><span class="line">--------------------</span><br><span class="line">In file: /tmp/contracts/calls.sol:15</span><br><span class="line"></span><br><span class="line">fixed_address.call(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">--------------------</span><br><span class="line">Initial State:</span><br><span class="line"></span><br><span class="line">Account: [CREATOR], balance: 0x0, nonce:0, storage:&#123;&#125;</span><br><span class="line">Account: [ATTACKER], balance: 0x0, nonce:0, storage:&#123;&#125;</span><br><span class="line"></span><br><span class="line">Transaction Sequence:</span><br><span class="line"></span><br><span class="line">Caller: [CREATOR], calldata: 00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, decoded_data: , value: 0x0</span><br><span class="line">Caller: [SOMEGUY], <span class="keyword">function</span>: calluseraddress(address), txdata: 0xe1d10f790000000000000000000000000000000000000000000000000000000000000000, decoded_data: (<span class="string">&#x27;0x0000000000000000000000000000000000000000&#x27;</span>,), value: 0x0</span><br><span class="line">Caller: [CREATOR], <span class="keyword">function</span>: thisisfine(), txdata: 0x5a6814ec, value: 0x0</span><br><span class="line"></span><br><span class="line">==== External Call To User-Supplied Address ====</span><br><span class="line">SWC ID: 107</span><br><span class="line">Severity: Low</span><br><span class="line">Contract: Caller</span><br><span class="line">Function name: callstoredaddress()</span><br><span class="line">PC address: 639</span><br><span class="line">Estimated Gas Usage: 2057 - 36951</span><br><span class="line">A call to a user-supplied address is executed.</span><br><span class="line">An external message call to an address specified by the <span class="built_in">caller</span> is executed. Note that the callee account might contain arbitrary code and could re-enter any <span class="keyword">function</span> within this contract. Reentering the contract <span class="keyword">in</span> an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are <span class="keyword">in</span> place.</span><br><span class="line">--------------------</span><br><span class="line">In file: /tmp/contracts/calls.sol:28</span><br><span class="line"></span><br><span class="line">stored_address.call(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">--------------------</span><br><span class="line">Initial State:</span><br><span class="line"></span><br><span class="line">Account: [CREATOR], balance: 0x0, nonce:0, storage:&#123;&#125;</span><br><span class="line">Account: [ATTACKER], balance: 0x0, nonce:0, storage:&#123;&#125;</span><br><span class="line"></span><br><span class="line">Transaction Sequence:</span><br><span class="line"></span><br><span class="line">Caller: [CREATOR], calldata: 00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, decoded_data: , value: 0x0</span><br><span class="line">Caller: [CREATOR], <span class="keyword">function</span>: setstoredaddress(address), txdata: 0x2776b163000000000000000000000000deadbeefdeadbeefdeadbeefdeadbeefdeadbeef, decoded_data: (<span class="string">&#x27;0xdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef&#x27;</span>,), value: 0x0</span><br><span class="line">Caller: [ATTACKER], <span class="keyword">function</span>: callstoredaddress(), txdata: 0xd24b08cc, value: 0x0</span><br><span class="line"></span><br><span class="line">==== Unchecked <span class="built_in">return</span> value from external call. ====</span><br><span class="line">SWC ID: 104</span><br><span class="line">Severity: Medium</span><br><span class="line">Contract: Caller</span><br><span class="line">Function name: callstoredaddress()</span><br><span class="line">PC address: 639</span><br><span class="line">Estimated Gas Usage: 2057 - 36951</span><br><span class="line">The <span class="built_in">return</span> value of a message call is not checked.</span><br><span class="line">External calls <span class="built_in">return</span> a boolean value. If the callee halts with an exception, <span class="string">&#x27;false&#x27;</span> is returned and execution continues <span class="keyword">in</span> the <span class="built_in">caller</span>. The <span class="built_in">caller</span> should check whether an exception happened and react accordingly to avoid unexpected behavior. For example it is often desirable to wrap external calls <span class="keyword">in</span> require() so the transaction is reverted <span class="keyword">if</span> the call fails.</span><br><span class="line">--------------------</span><br><span class="line">In file: /tmp/contracts/calls.sol:28</span><br><span class="line"></span><br><span class="line">stored_address.call(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">--------------------</span><br><span class="line">Initial State:</span><br><span class="line"></span><br><span class="line">Account: [CREATOR], balance: 0x0, nonce:0, storage:&#123;&#125;</span><br><span class="line">Account: [ATTACKER], balance: 0x0, nonce:0, storage:&#123;&#125;</span><br><span class="line"></span><br><span class="line">Transaction Sequence:</span><br><span class="line"></span><br><span class="line">Caller: [CREATOR], calldata: 00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, decoded_data: , value: 0x0</span><br><span class="line">Caller: [SOMEGUY], <span class="keyword">function</span>: calluseraddress(address), txdata: 0xe1d10f790000000000000000000000000000000000000000000000000000000000000000, decoded_data: (<span class="string">&#x27;0x0000000000000000000000000000000000000000&#x27;</span>,), value: 0x0</span><br><span class="line">Caller: [CREATOR], <span class="keyword">function</span>: callstoredaddress(), txdata: 0xd24b08cc, value: 0x0</span><br><span class="line"></span><br><span class="line">==== External Call To User-Supplied Address ====</span><br><span class="line">SWC ID: 107</span><br><span class="line">Severity: Low</span><br><span class="line">Contract: Caller</span><br><span class="line">Function name: reentrancy()</span><br><span class="line">PC address: 777</span><br><span class="line">Estimated Gas Usage: 7090 - 61984</span><br><span class="line">A call to a user-supplied address is executed.</span><br><span class="line">An external message call to an address specified by the <span class="built_in">caller</span> is executed. Note that the callee account might contain arbitrary code and could re-enter any <span class="keyword">function</span> within this contract. Reentering the contract <span class="keyword">in</span> an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are <span class="keyword">in</span> place.</span><br><span class="line">--------------------</span><br><span class="line">In file: /tmp/contracts/calls.sol:19</span><br><span class="line"></span><br><span class="line">fixed_address.call(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">--------------------</span><br><span class="line">Initial State:</span><br><span class="line"></span><br><span class="line">Account: [CREATOR], balance: 0x0, nonce:0, storage:&#123;&#125;</span><br><span class="line">Account: [ATTACKER], balance: 0x0, nonce:0, storage:&#123;&#125;</span><br><span class="line"></span><br><span class="line">Transaction Sequence:</span><br><span class="line"></span><br><span class="line">Caller: [CREATOR], calldata: 000000000000000000000000deadbeefdeadbeefdeadbeefdeadbeefdeadbeef0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, decoded_data: , value: 0x0</span><br><span class="line">Caller: [SOMEGUY], <span class="keyword">function</span>: reentrancy(), txdata: 0xe11f493e, value: 0x0</span><br><span class="line"></span><br><span class="line">==== Unchecked <span class="built_in">return</span> value from external call. ====</span><br><span class="line">SWC ID: 104</span><br><span class="line">Severity: Medium</span><br><span class="line">Contract: Caller</span><br><span class="line">Function name: reentrancy()</span><br><span class="line">PC address: 777</span><br><span class="line">Estimated Gas Usage: 7090 - 61984</span><br><span class="line">The <span class="built_in">return</span> value of a message call is not checked.</span><br><span class="line">External calls <span class="built_in">return</span> a boolean value. If the callee halts with an exception, <span class="string">&#x27;false&#x27;</span> is returned and execution continues <span class="keyword">in</span> the <span class="built_in">caller</span>. The <span class="built_in">caller</span> should check whether an exception happened and react accordingly to avoid unexpected behavior. For example it is often desirable to wrap external calls <span class="keyword">in</span> require() so the transaction is reverted <span class="keyword">if</span> the call fails.</span><br><span class="line">--------------------</span><br><span class="line">In file: /tmp/contracts/calls.sol:19</span><br><span class="line"></span><br><span class="line">fixed_address.call(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">--------------------</span><br><span class="line">Initial State:</span><br><span class="line"></span><br><span class="line">Account: [CREATOR], balance: 0x0, nonce:0, storage:&#123;&#125;</span><br><span class="line">Account: [ATTACKER], balance: 0x0, nonce:0, storage:&#123;&#125;</span><br><span class="line"></span><br><span class="line">Transaction Sequence:</span><br><span class="line"></span><br><span class="line">Caller: [CREATOR], calldata: 00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, decoded_data: , value: 0x0</span><br><span class="line">Caller: [SOMEGUY], <span class="keyword">function</span>: calluseraddress(address), txdata: 0xe1d10f790000000000000000000000000000000000000000000000000000000000000000, decoded_data: (<span class="string">&#x27;0x0000000000000000000000000000000000000000&#x27;</span>,), value: 0x0</span><br><span class="line">Caller: [CREATOR], <span class="keyword">function</span>: reentrancy(), txdata: 0xe11f493e, value: 0x0</span><br><span class="line"></span><br><span class="line">==== State access after external call ====</span><br><span class="line">SWC ID: 107</span><br><span class="line">Severity: Medium</span><br><span class="line">Contract: Caller</span><br><span class="line">Function name: reentrancy()</span><br><span class="line">PC address: 839</span><br><span class="line">Estimated Gas Usage: 7090 - 61984</span><br><span class="line">Write to persistent state following external call</span><br><span class="line">The contract account state is accessed after an external call to a user defined address. To prevent reentrancy issues, consider accessing the state only before the call, especially <span class="keyword">if</span> the callee is untrusted. Alternatively, a reentrancy lock can be used to prevent untrusted callees from re-entering the contract <span class="keyword">in</span> an intermediate state.</span><br><span class="line">--------------------</span><br><span class="line">In file: /tmp/contracts/calls.sol:20</span><br><span class="line"></span><br><span class="line">statevar = 0</span><br><span class="line"></span><br><span class="line">--------------------</span><br><span class="line">Initial State:</span><br><span class="line"></span><br><span class="line">Account: [CREATOR], balance: 0x0, nonce:0, storage:&#123;&#125;</span><br><span class="line">Account: [ATTACKER], balance: 0x0, nonce:0, storage:&#123;&#125;</span><br><span class="line"></span><br><span class="line">Transaction Sequence:</span><br><span class="line"></span><br><span class="line">Caller: [CREATOR], calldata: 000000000000000000000000deadbeefdeadbeefdeadbeefdeadbeefdeadbeef0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, decoded_data: , value: 0x0</span><br><span class="line">Caller: [SOMEGUY], <span class="keyword">function</span>: reentrancy(), txdata: 0xe11f493e, value: 0x0</span><br><span class="line"></span><br><span class="line">==== External Call To User-Supplied Address ====</span><br><span class="line">SWC ID: 107</span><br><span class="line">Severity: Low</span><br><span class="line">Contract: Caller</span><br><span class="line">Function name: calluseraddress(address)</span><br><span class="line">PC address: 891</span><br><span class="line">Estimated Gas Usage: 1576 - 36140</span><br><span class="line">A call to a user-supplied address is executed.</span><br><span class="line">An external message call to an address specified by the <span class="built_in">caller</span> is executed. Note that the callee account might contain arbitrary code and could re-enter any <span class="keyword">function</span> within this contract. Reentering the contract <span class="keyword">in</span> an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are <span class="keyword">in</span> place.</span><br><span class="line">--------------------</span><br><span class="line">In file: /tmp/contracts/calls.sol:24</span><br><span class="line"></span><br><span class="line">addr.call(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">--------------------</span><br><span class="line">Initial State:</span><br><span class="line"></span><br><span class="line">Account: [CREATOR], balance: 0x0, nonce:0, storage:&#123;&#125;</span><br><span class="line">Account: [ATTACKER], balance: 0x0, nonce:0, storage:&#123;&#125;</span><br><span class="line"></span><br><span class="line">Transaction Sequence:</span><br><span class="line"></span><br><span class="line">Caller: [CREATOR], calldata: 00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, decoded_data: , value: 0x0</span><br><span class="line">Caller: [SOMEGUY], <span class="keyword">function</span>: calluseraddress(address), txdata: 0xe1d10f79000000000000000000000000deadbeefdeadbeefdeadbeefdeadbeefdeadbeef, decoded_data: (<span class="string">&#x27;0xdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef&#x27;</span>,), value: 0x0</span><br><span class="line"></span><br><span class="line">==== Unchecked <span class="built_in">return</span> value from external call. ====</span><br><span class="line">SWC ID: 104</span><br><span class="line">Severity: Medium</span><br><span class="line">Contract: Caller</span><br><span class="line">Function name: calluseraddress(address)</span><br><span class="line">PC address: 891</span><br><span class="line">Estimated Gas Usage: 1576 - 36140</span><br><span class="line">The <span class="built_in">return</span> value of a message call is not checked.</span><br><span class="line">External calls <span class="built_in">return</span> a boolean value. If the callee halts with an exception, <span class="string">&#x27;false&#x27;</span> is returned and execution continues <span class="keyword">in</span> the <span class="built_in">caller</span>. The <span class="built_in">caller</span> should check whether an exception happened and react accordingly to avoid unexpected behavior. For example it is often desirable to wrap external calls <span class="keyword">in</span> require() so the transaction is reverted <span class="keyword">if</span> the call fails.</span><br><span class="line">--------------------</span><br><span class="line">In file: /tmp/contracts/calls.sol:24</span><br><span class="line"></span><br><span class="line">addr.call(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">--------------------</span><br><span class="line">Initial State:</span><br><span class="line"></span><br><span class="line">Account: [CREATOR], balance: 0x0, nonce:0, storage:&#123;&#125;</span><br><span class="line">Account: [ATTACKER], balance: 0x0, nonce:0, storage:&#123;&#125;</span><br><span class="line"></span><br><span class="line">Transaction Sequence:</span><br><span class="line"></span><br><span class="line">Caller: [CREATOR], calldata: 00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, decoded_data: , value: 0x0</span><br><span class="line">Caller: [SOMEGUY], <span class="keyword">function</span>: calluseraddress(address), txdata: 0xe1d10f790000000000000000000000000000000000000000000000000000000000000000, decoded_data: (<span class="string">&#x27;0x0000000000000000000000000000000000000000&#x27;</span>,), value: 0x0</span><br><span class="line">Caller: [CREATOR], <span class="keyword">function</span>: calluseraddress(address), txdata: 0xe1d10f790000000000000000000000000000000000000000000000000000000000000000, decoded_data: (<span class="string">&#x27;0x0000000000000000000000000000000000000000&#x27;</span>,), value: 0x0</span><br></pre></td></tr></table></figure><p>测试了另一个合约，需要修改编辑器版本，没有挂梯子域名解析错了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">jie@jie-virtual-machine:~$ docker run -v $(<span class="built_in">pwd</span>):/tmp mythril/myth analyze /tmp/contracts/killbilly.sol --solv 0.5.7</span><br><span class="line">mythril.interfaces.cli [ERROR]: Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/urllib3/connection.py&quot;</span>, line 200, <span class="keyword">in</span> _new_conn</span><br><span class="line">    sock = connection.create_connection(</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py&quot;</span>, line 60, <span class="keyword">in</span> create_connection</span><br><span class="line">    <span class="keyword">for</span> res <span class="keyword">in</span> socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/socket.py&quot;</span>, line 955, <span class="keyword">in</span> getaddrinfo</span><br><span class="line">    <span class="keyword">for</span> res <span class="keyword">in</span> _socket.getaddrinfo(host, port, family, <span class="built_in">type</span>, proto, flags):</span><br><span class="line">socket.gaierror: [Errno -3] Temporary failure <span class="keyword">in</span> name resolution</span><br><span class="line"></span><br><span class="line">The above exception was the direct cause of the following exception:</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py&quot;</span>, line 790, <span class="keyword">in</span> urlopen</span><br><span class="line">    response = self._make_request(</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py&quot;</span>, line 491, <span class="keyword">in</span> _make_request</span><br><span class="line">    raise new_e</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py&quot;</span>, line 467, <span class="keyword">in</span> _make_request</span><br><span class="line">    self._validate_conn(conn)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py&quot;</span>, line 1092, <span class="keyword">in</span> _validate_conn</span><br><span class="line">    conn.connect()</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/urllib3/connection.py&quot;</span>, line 604, <span class="keyword">in</span> connect</span><br><span class="line">    self.sock = sock = self._new_conn()</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/urllib3/connection.py&quot;</span>, line 207, <span class="keyword">in</span> _new_conn</span><br><span class="line">    raise NameResolutionError(self.host, self, e) from e</span><br><span class="line">urllib3.exceptions.NameResolutionError: &lt;urllib3.connection.HTTPSConnection object at 0x7f0a9f3649d0&gt;: Failed to resolve <span class="string">&#x27;solc-bin.ethereum.org&#x27;</span> ([Errno -3] Temporary failure <span class="keyword">in</span> name resolution)</span><br><span class="line"></span><br><span class="line">The above exception was the direct cause of the following exception:</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/requests/adapters.py&quot;</span>, line 486, <span class="keyword">in</span> send</span><br><span class="line">    resp = conn.urlopen(</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py&quot;</span>, line 844, <span class="keyword">in</span> urlopen</span><br><span class="line">    retries = retries.increment(</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py&quot;</span>, line 515, <span class="keyword">in</span> increment</span><br><span class="line">    raise MaxRetryError(_pool, url, reason) from reason  <span class="comment"># type: ignore[arg-type]</span></span><br><span class="line">urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host=<span class="string">&#x27;solc-bin.ethereum.org&#x27;</span>, port=443): Max retries exceeded with url: /linux-amd64/list.json (Caused by NameResolutionError(<span class="string">&quot;&lt;urllib3.connection.HTTPSConnection object at 0x7f0a9f3649d0&gt;: Failed to resolve &#x27;solc-bin.ethereum.org&#x27; ([Errno -3] Temporary failure in name resolution)&quot;</span>))</span><br><span class="line"></span><br><span class="line">During handling of the above exception, another exception occurred:</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/mythril/interfaces/cli.py&quot;</span>, line 958, <span class="keyword">in</span> parse_args_and_execute</span><br><span class="line">    disassembler = MythrilDisassembler(</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/mythril/mythril/mythril_disassembler.py&quot;</span>, line 60, <span class="keyword">in</span> __init__</span><br><span class="line">    self.solc_binary = self._init_solc_binary(solc_version)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/mythril/mythril/mythril_disassembler.py&quot;</span>, line 93, <span class="keyword">in</span> _init_solc_binary</span><br><span class="line">    solc_binary = util.solc_exists(version)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/mythril/ethereum/util.py&quot;</span>, line 140, <span class="keyword">in</span> solc_exists</span><br><span class="line">    solcx.install_solc(<span class="string">&quot;v&quot;</span> + version)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/solcx/install.py&quot;</span>, line 441, <span class="keyword">in</span> install_solc</span><br><span class="line">    data = requests.get(BINARY_DOWNLOAD_BASE.format(_get_os_name(), <span class="string">&quot;list.json&quot;</span>))</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/requests/api.py&quot;</span>, line 73, <span class="keyword">in</span> get</span><br><span class="line">    <span class="built_in">return</span> request(<span class="string">&quot;get&quot;</span>, url, params=params, **kwargs)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/requests/api.py&quot;</span>, line 59, <span class="keyword">in</span> request</span><br><span class="line">    <span class="built_in">return</span> session.request(method=method, url=url, **kwargs)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/requests/sessions.py&quot;</span>, line 589, <span class="keyword">in</span> request</span><br><span class="line">    resp = self.send(prep, **send_kwargs)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/requests/sessions.py&quot;</span>, line 703, <span class="keyword">in</span> send</span><br><span class="line">    r = adapter.send(request, **kwargs)</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.10/site-packages/requests/adapters.py&quot;</span>, line 519, <span class="keyword">in</span> send</span><br><span class="line">    raise ConnectionError(e, request=request)</span><br><span class="line">requests.exceptions.ConnectionError: HTTPSConnectionPool(host=<span class="string">&#x27;solc-bin.ethereum.org&#x27;</span>, port=443): Max retries exceeded with url: /linux-amd64/list.json (Caused by NameResolutionError(<span class="string">&quot;&lt;urllib3.connection.HTTPSConnection object at 0x7f0a9f3649d0&gt;: Failed to resolve &#x27;solc-bin.ethereum.org&#x27; ([Errno -3] Temporary failure in name resolution)&quot;</span>))</span><br></pre></td></tr></table></figure><h2 id="Sucurify2-0"><a href="#Sucurify2-0" class="headerlink" title="Sucurify2.0"></a>Sucurify2.0</h2><p>项目地址 <a href="https://github.com/eth-sri/securify2">eth-sri/securify2</a></p><h3 id="Smartbugs的实验"><a href="#Smartbugs的实验" class="headerlink" title="Smartbugs的实验"></a>Smartbugs的实验</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$./smartbugs -t securify -f samples/*.sol --processes 2 --mem-limit 4g --timeout 60</span><br></pre></td></tr></table></figure><p><img src="/2023/08/08/blockchain-security-practice/image-20230718103340279.png" alt="image-20230718103340279"></p><p>实验结果存储在<code>./results/securify</code>目录下</p><p>目录每个.sol文件分析后包括两个文件，以EtherLotto.sol为例具体来看。</p><ul><li><code>smartbugs.json</code>具体为调用工具时参数的情况</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//smartbugs.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;docker&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;command&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">&quot;detach&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;entrypoint&quot;</span>: <span class="string">&quot;&#x27;/sb/bin/do_solidity.sh&#x27; &#x27;/sb/EtherLotto.sol&#x27; &#x27;/sb/bin&#x27;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;image&quot;</span>: <span class="string">&quot;smartbugs/security:usolc&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;mem_limit&quot;</span>: <span class="string">&quot;4g&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;user&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;volumes&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;/tmp/tmp86tp_iz9&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;bind&quot;</span>: <span class="string">&quot;/sb&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;mode&quot;</span>: <span class="string">&quot;rw&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;filename&quot;</span>: <span class="string">&quot;samples/EtherLotto.sol&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;platform&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;cpu&quot;</span>: <span class="string">&quot;12th Gen Intel(R) Core(TM) i5-12500H&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;python&quot;</span>: <span class="string">&quot;3.10.6.final.0 (64 bit)&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;release&quot;</span>: <span class="string">&quot;5.19.0-45-generic&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;smartbugs&quot;</span>: <span class="string">&quot;2.0.7&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;system&quot;</span>: <span class="string">&quot;Linux&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;#46~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Wed Jun 7 15:06:04 UTC 20&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;result&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;duration&quot;</span>: <span class="number">17.345403909683228</span>,</span><br><span class="line">        <span class="attr">&quot;exit_code&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;logs&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">&quot;output&quot;</span>: <span class="string">&quot;result.tar&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;start&quot;</span>: <span class="number">1689647289.9699748</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;runid&quot;</span>: <span class="string">&quot;20230718_0228&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;solc&quot;</span>: <span class="string">&quot;0.4.26&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;tool&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;bin&quot;</span>: <span class="string">&quot;scripts&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;command&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">&quot;cpu_quota&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">&quot;entrypoint&quot;</span>: <span class="string">&quot;&#x27;$BIN/do_solidity.sh&#x27; &#x27;$FILENAME&#x27; &#x27;$BIN&#x27;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;securify&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;image&quot;</span>: <span class="string">&quot;smartbugs/security:usolc&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;info&quot;</span>: <span class="string">&quot;Securify uses formal verification, also relying on static analysis checks. Securify&#x27;s analysis consists of two steps. First, it symbolically analyzes the contract&#x27;s dependency graph to extract precise semantic information from the code. Then, it checks compliance and violation patterns that capture sufficient conditions for proving if a property holds or not.&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;mem_limit&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">&quot;mode&quot;</span>: <span class="string">&quot;solidity&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Securify&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;origin&quot;</span>: <span class="string">&quot;https://github.com/eth-sri/securify&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;output&quot;</span>: <span class="string">&quot;/results/&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;parser&quot;</span>: <span class="string">&quot;parser.py&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;solc&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;version&quot;</span>: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个文件是<code>result.tar</code>，解压后可以发现</p><ul><li><code>live.json</code>文件，具体内容为模式的定义</li><li><code>results.json</code>文件，给出了匹配的结果，包括violation 和 warning safe 和 conflicts</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//live.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;decompiled&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;finished&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;patternResults&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;DAO&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;completed&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasViolations&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasWarnings&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasSafe&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasConflicts&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;violations&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;warnings&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;safe&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;DAOConstantGas&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;completed&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasViolations&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasWarnings&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasSafe&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasConflicts&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;violations&quot;</span>: [</span><br><span class="line">        <span class="number">226</span>,</span><br><span class="line">        <span class="number">271</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;warnings&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;safe&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;MissingInputValidation&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;completed&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasViolations&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasWarnings&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasSafe&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasConflicts&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;violations&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;warnings&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;safe&quot;</span>: [</span><br><span class="line">        <span class="number">116</span>,</span><br><span class="line">        <span class="number">116</span>,</span><br><span class="line">        <span class="number">111</span>,</span><br><span class="line">        <span class="number">116</span>,</span><br><span class="line">        <span class="number">111</span>,</span><br><span class="line">        <span class="number">130</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;TODAmount&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;completed&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasViolations&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasWarnings&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasSafe&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasConflicts&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;violations&quot;</span>: [</span><br><span class="line">        <span class="number">271</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;warnings&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;safe&quot;</span>: [</span><br><span class="line">        <span class="number">226</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;TODReceiver&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;completed&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasViolations&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasWarnings&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasSafe&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasConflicts&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;violations&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;warnings&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;safe&quot;</span>: [</span><br><span class="line">        <span class="number">226</span>,</span><br><span class="line">        <span class="number">271</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;TODTransfer&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;completed&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasViolations&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasWarnings&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasSafe&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasConflicts&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;violations&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;warnings&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;safe&quot;</span>: [</span><br><span class="line">        <span class="number">226</span>,</span><br><span class="line">        <span class="number">271</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;UnhandledException&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;completed&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasViolations&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasWarnings&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasSafe&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasConflicts&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;violations&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;warnings&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;safe&quot;</span>: [</span><br><span class="line">        <span class="number">226</span>,</span><br><span class="line">        <span class="number">271</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;UnrestrictedEtherFlow&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;completed&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasViolations&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasWarnings&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;hasSafe&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;hasConflicts&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;violations&quot;</span>: [</span><br><span class="line">        <span class="number">226</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;warnings&quot;</span>: [</span><br><span class="line">        <span class="number">271</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;safe&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//results.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;/sb/EtherLotto.sol:EtherLotto&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;results&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;TODReceiver&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;violations&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;warnings&quot;</span>: [</span><br><span class="line">          <span class="number">48</span>,</span><br><span class="line">          <span class="number">51</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;safe&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;UnhandledException&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;violations&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;warnings&quot;</span>: [</span><br><span class="line">          <span class="number">48</span>,</span><br><span class="line">          <span class="number">51</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;safe&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;TODTransfer&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;violations&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;warnings&quot;</span>: [</span><br><span class="line">          <span class="number">48</span>,</span><br><span class="line">          <span class="number">51</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;safe&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;DAO&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;violations&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;warnings&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;safe&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;TODAmount&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;violations&quot;</span>: [</span><br><span class="line">          <span class="number">51</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;warnings&quot;</span>: [</span><br><span class="line">          <span class="number">48</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;safe&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;MissingInputValidation&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;violations&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;warnings&quot;</span>: [</span><br><span class="line">          <span class="number">20</span>,</span><br><span class="line">          <span class="number">23</span>,</span><br><span class="line">          <span class="number">32</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;safe&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;DAOConstantGas&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;violations&quot;</span>: [</span><br><span class="line">          <span class="number">48</span>,</span><br><span class="line">          <span class="number">51</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;warnings&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;safe&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;UnrestrictedEtherFlow&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;violations&quot;</span>: [</span><br><span class="line">          <span class="number">48</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;warnings&quot;</span>: [],</span><br><span class="line">        <span class="attr">&quot;safe&quot;</span>: [</span><br><span class="line">          <span class="number">51</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;conflicts&quot;</span>: []</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据实验结果，可能是运行的分析时间较短，许多合约分析结果为空（比如Mytoken.sol)</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230718105438946.png" alt="image-20230718105438946"></p><p>parse后查看给出的results.json</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230809173729853.png" alt="image-20230809173729853"></p><h2 id="sFuzz"><a href="#sFuzz" class="headerlink" title="sFuzz"></a>sFuzz</h2><p>仅支持solidity源代码，对contractFuzzer的改进</p><p>项目地址<a href="https://github.com/duytai/sFuzz">duytai/sFuzz (github.com)</a>，未提供docker，只能自行编译</p><h3 id="Smartbugs的实验-1"><a href="#Smartbugs的实验-1" class="headerlink" title="Smartbugs的实验"></a>Smartbugs的实验</h3><p><img src="/2023/08/08/blockchain-security-practice/image-20230809101350192.png" alt="image-20230809101350192"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230809101656664.png" alt="image-20230809101656664"></p><h3 id="docker内的实验"><a href="#docker内的实验" class="headerlink" title="docker内的实验"></a>docker内的实验</h3><p>在骆九同学帮助下找到了docker，直接进行实验</p><p>按照<a href="https://github.com/duytai/sFuzz">duytai/sFuzz (github.com)</a>的教程，先给出两个合约</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230809153500386.png" alt="image-20230809153500386"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./fuzzer -g -r 0 -d 120 &amp;&amp; chmod +x fuzzMe &amp;&amp; ./fuzzMe</span><br></pre></td></tr></table></figure><p>获得了fuzzing后的结果</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230809153954541.png" alt="image-20230809153954541"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230809154619989.png" alt="image-20230809154619989"></p><h2 id="Slither"><a href="#Slither" class="headerlink" title="Slither"></a>Slither</h2><p>项目地址：<a href="https://github.com/crytic/slither#usage">Issues · crytic/slither (github.com)</a></p><h3 id="Smartbugs的测试"><a href="#Smartbugs的测试" class="headerlink" title="Smartbugs的测试"></a>Smartbugs的测试</h3><p><img src="/2023/08/08/blockchain-security-practice/image-20230809103030692.png" alt="image-20230809103030692"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230809104145895.png" alt="image-20230809104145895"></p><h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull trailofbits/eth-security-toolbox</span><br><span class="line"></span><br><span class="line">ethsec@9a9fde7fab15:~/etheno-examples/BrokenMetaCoin/contracts$ slither MetaCoin.sol --solc-solcs-select 0.5.0</span><br></pre></td></tr></table></figure><p>采用—solc-solcs-select 参数指定编译器版本，不然会报错</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230809110124068.png" alt="image-20230809110124068"></p><p>测试合约中的重入漏洞</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230809111650390.png" alt="image-20230809111650390"></p><h2 id="Solhint"><a href="#Solhint" class="headerlink" title="Solhint"></a>Solhint</h2><p>项目地址：<a href="https://github.com/protofire/solhint">protofire/solhint: Solhint is an open-source project to provide a linting utility for Solidity code. (github.com)</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>更新node版本为20.5.0</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo npm cache clean -f //清除nodejs的cache</span><br><span class="line">sudo npm install -g n //使用npm安装n模块</span><br><span class="line">npm view node versions // node所有版本</span><br><span class="line">sudo n latest // 升级到最新版本</span><br></pre></td></tr></table></figure><p>安装solhint</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g solhint</span><br><span class="line">solhint --version</span><br><span class="line">3.5.1</span><br><span class="line">solhint --init</span><br></pre></td></tr></table></figure><p>使用默认的规则测试不出结果</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230809122109397.png" alt="image-20230809122109397"></p><h3 id="Smartbugs的实验-2"><a href="#Smartbugs的实验-2" class="headerlink" title="Smartbugs的实验"></a>Smartbugs的实验</h3><p><img src="/2023/08/08/blockchain-security-practice/image-20230809122728437.png" alt="image-20230809122728437"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230809122840316.png" alt="image-20230809122840316"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230809122853930.png" alt="image-20230809122853930"></p><h1 id="Echidna"><a href="#Echidna" class="headerlink" title="Echidna"></a>Echidna</h1><p>参考资料 <a href="https://juejin.cn/post/7256976847665201212">智能合约模糊测试工具推荐——Echidna - 掘金 (juejin.cn)</a>、<a href="https://ethereum.org/zh/developers/tutorials/how-to-use-echidna-to-test-smart-contracts/">如何使用 Echidna 测试智能合约 | ethereum.org</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jie@jie-virtual-machine:~/share$ docker run -it -v `<span class="built_in">pwd</span>`:/src echidna:v2.2.1 </span><br></pre></td></tr></table></figure><h1 id="docker-1"><a href="#docker-1" class="headerlink" title="docker"></a>docker</h1><p>导出镜像和导入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker save image_id -o image.tar</span><br><span class="line">docker load -i image.tar</span><br><span class="line">docker tar image_id name:tag </span><br></pre></td></tr></table></figure><h1 id="Geth"><a href="#Geth" class="headerlink" title="Geth"></a>Geth</h1><p>官方下载发行版 <a href="https://geth.ethereum.org/downloads">Downloads | go-ethereum</a></p><p>有空可以再做一遍这个 <a href="https://geth.ethereum.org/docs/getting-started">Getting started with Geth | go-ethereum</a></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230823160539917.png" alt="image-20230823160539917"></p><p>再尝试1.11.6版本</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> E:\Geth1.<span class="number">11.6</span>&gt; geth -<span class="literal">-identity</span> <span class="string">&quot;node&quot;</span> -<span class="literal">-datadir</span> .\data\ -<span class="literal">-networkid</span> <span class="number">9599</span> -<span class="literal">-http</span> -<span class="literal">-http</span>.addr <span class="string">&quot;localhost&quot;</span> -<span class="literal">-http</span>.api=<span class="string">&quot;eth,net,web3,personal,miner,admin,txpool,debug&quot;</span> -<span class="literal">-allow</span><span class="literal">-insecure</span><span class="literal">-unlock</span> -<span class="literal">-http</span>.corsdomain <span class="string">&quot;*&quot;</span> -<span class="literal">-rpc</span>.gascap <span class="number">0</span> console</span><br></pre></td></tr></table></figure><p><img src="/2023/08/08/blockchain-security-practice/image-20230823161424799.png" alt="image-20230823161424799"></p><p>创建账户，然后将账户copy进json配置文件的alloc，将密钥保存到keystore目录下</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230823161937784.png" alt="image-20230823161937784"></p><p>查看账户</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230823162544339.png" alt="image-20230823162544339"></p><p>首先设置coinbase地址为当前账户，挖矿前的余额为0，开始挖矿后可以查看到挖矿状态，一段时间后查询余额</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230823163015429.png" alt="image-20230823163015429"></p><p>停止挖矿</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230823163047474.png" alt="image-20230823163047474"></p><p>利用区块号查看创世区块</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230823163434087.png" alt="image-20230823163434087"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230823163415266.png" alt="image-20230823163415266"></p><p>没有交易，再新建一个账户来处理交易</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230823163827741.png" alt="image-20230823163827741">eth.sendTransaction({from: eth.accounts[0], to: eth.accounts[1],value: web3.toWei(100,”ether”)})</p><h2 id="连接remix"><a href="#连接remix" class="headerlink" title="连接remix"></a>连接remix</h2><p>geth —http —http.corsdomain=”<a href="https://remix.ethereum.org">https://remix.ethereum.org</a>“ —http.api web3,eth,debug,personal,net —vmdebug —datadir .\data`</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230823174806363.png" alt="image-20230823174806363"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230823175012906.png" alt="image-20230823175012906" style="zoom:80%;"></p><h1 id="Hardhat"><a href="#Hardhat" class="headerlink" title="Hardhat"></a>Hardhat</h1><p>教程 <a href="https://hardhat.org/tutorial/testing-contracts">5. Testing contracts | Ethereum development environment for professionals by Nomic Foundation (hardhat.org)</a></p><p>npm安装 </p><p><img src="/2023/08/08/blockchain-security-practice/image-20230823181841584.png" alt="image-20230823181841584"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230823181923882.png" alt="image-20230823181923882"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230823182024043.png" alt="image-20230823182024043"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230823183046224.png" alt="image-20230823183046224"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230823183530947.png" alt="image-20230823183530947"></p><p>安装soldity-coverage工具</p><h1 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h1><p>学习教程 <a href="https://chain.link/education/blockchain-oracles">What Is an Oracle in Blockchain? » Explained | Chainlink</a></p><p>定义：将区块链和外部系统连接起来的实体，使得智能合约能够基于现实世界的输入和输出执行</p><p>例子：Alice 和 Bob赌球，合约如何得知比赛结果？Oracle</p><p>Oracle的安全性非常重要</p><p>中心化的oracle 单点故障，腐化, garbage in, garbage out</p><p>去中心化的Oracle更加安全，如chainlink</p><p>分类</p><ul><li>input oracles：最普遍的，从现实世界中获取信息传递给区块链</li><li>output oracles：合约向链下的系统发送命令来执行特定的操作，比如让银行进行某笔支付，或者让云服务存储某个数据</li><li>cross-chain oracles：在不同区块链间读写，支持跨链转移数据和资产</li><li>compute-enabled oracles：新类型，在逐渐被广泛使用，安全地链下计算来执行链上不现实或者昂贵的计算，计算零知识证明或者可验证随机数</li></ul><p>作为一种基础服务，历史的信誉可以查看</p><ul><li><a href="https://market.link/">Market.link</a>，已经停更，现在是Dune Analytics<ul><li><a href="https://dune.com/sergiimk/Oracle-Comparison-(Chainlink-API3-Band-Ocean">Oracle Comparison (Chainlink, API3, Band, Ocean) (dune.com)</a>)</li></ul></li><li><a href="http://reputation.link/">http://reputation.link/</a><ul><li>无法访问</li></ul></li></ul><p><img src="/2023/08/08/blockchain-security-practice/image-20230907113242784.png" alt="image-20230907113242784"></p><h2 id="在Remix中调用chainlink"><a href="#在Remix中调用chainlink" class="headerlink" title="在Remix中调用chainlink"></a>在Remix中调用chainlink</h2><p>样例合约是读取sepolia上  latest price answer from the <a href="https://docs.chain.link/data-feeds/price-feeds/addresses">BTC / USD feed</a> on the Sepolia testnet</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230907114835842.png" alt="image-20230907114835842"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230907114936147.png" alt="image-20230907114936147"></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230907150342512.png" alt="image-20230907150342512"></p><h1 id="ERC和EIP"><a href="#ERC和EIP" class="headerlink" title="ERC和EIP"></a>ERC和EIP</h1><h2 id="ERC"><a href="#ERC" class="headerlink" title="ERC"></a>ERC</h2><p>Ethereum Request for Comments，定义了以太坊网络上创建智能合约和代币的规则和标准，ERC 标准为开发人员提供了一套共识规则，使他们能够在以太坊上创建兼容的智能合约和代币。</p><p>最著名的 ERC 标准之一是 ERC-20，它定义了代币合约的基本功能和交互方式。ERC-20 代币是以太坊上最常见的代币类型，广泛应用于加密货币交易所和钱包。它们具有标准的转账和余额查询功能，使得不同的 ERC-20 代币可以在以太坊生态系统中互相兼容。</p><p>此外，还有其他的 ERC 标准，如 ERC-721（非同质化代币）和 ERC-1155（可互换和非同质化代币的混合标准）。这些标准为不同类型的代币定义了不同的规范和功能，以满足不同的应用场景需求。总之，ERC 是以太坊上定义智能合约和代币标准的术语，它促进了以太坊生态系统的互操作性和发展。</p><p>具体的标准</p><p><a href="https://ethereum.org/en/developers/docs/standards/tokens/erc-20/">ERC-20 Token Standard | ethereum.org</a></p><p><a href="https://eips.ethereum.org/EIPS/eip-20">ERC-20: Token Standard (ethereum.org)</a></p><h3 id="ERC20代币发行"><a href="#ERC20代币发行" class="headerlink" title="ERC20代币发行"></a>ERC20代币发行</h3><p>教程 <a href="https://www.youtube.com/watch?v=gJuWQyZJ7S0&amp;t=11s&amp;ab_channel=MoralisWeb3">https://www.youtube.com/watch?v=gJuWQyZJ7S0&amp;t=11s&amp;ab_channel=MoralisWeb3</a></p><p><img src="/2023/08/08/blockchain-security-practice/image-20230907163457554.png" alt="image-20230907163457554"></p><p>花钱总是要心疼/犹豫一下</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230907163509186.png" alt="image-20230907163509186"></p><p>部署合约的交易</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230907163542704.png" alt="image-20230907163542704"></p><p>符合ERC20的标准</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230907163632536.png" alt="image-20230907163632536"></p><p>查看本账户的余额</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230907163742011.png" alt="image-20230907163742011"></p><p>填写合约地址可以导入到metamask中去</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230907163944543.png" alt="image-20230907163944543"></p><p>查看ERC20的若干参数</p><p><img src="/2023/08/08/blockchain-security-practice/image-20230907164115840.png" alt="image-20230907164115840"></p><h2 id="EIP"><a href="#EIP" class="headerlink" title="EIP"></a>EIP</h2><p>EIP 是以太坊改进提案（Ethereum Improvement Proposal）的缩写。EIP 是以太坊社区中用于提出和讨论关于以太坊网络改进的标准化文件。它们是以太坊社区成员之间进行协作和讨论的重要工具，用于引入新功能、修复问题、改进协议和提出新的标准。</p><p>EIP 的目的是促进以太坊网络的发展和创新，并提供一种透明和开放的方式来讨论和决策关于以太坊协议的变更。EIP 的提案可以涉及各种主题，包括协议改进、新功能的引入、标准化规范、网络升级、治理流程等。</p><p>每个 EIP 都有一个唯一的编号、标题和详细描述，其中包含了提案的目的、动机和技术细节。EIP 还可以包含相关的代码示例、实现建议和测试用例等。</p><p>EIP 分为几个不同的类别，包括核心协议（Core），标准化（Standards），元标准（Meta），信息（Informational）和退役（Retired）等。这些类别有助于对提案进行分类和组织，并提供了不同的审核和采纳流程。</p><p>以太坊社区的成员可以提出新的 EIP 提案，并通过社区的讨论、审核和投票过程来确定是否采纳。一旦 EIP 被采纳，它可能会成为以太坊网络的一部分，影响网络的协议和功能。</p><p>总之，EIP 是以太坊社区中用于提出和讨论关于以太坊网络改进的标准化文件，它们起到了推动以太坊发展和创新的重要作用。</p><p><a href="https://eips.ethereum.org/">Home | Ethereum Improvement Proposals</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录进行区块链安全相关实践的内容&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/categories/Blockchain/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>sharding-blockchain-survey</title>
    <link href="https://alleysira.github.io/2023/08/06/sharding-blockchain-survey/"/>
    <id>https://alleysira.github.io/2023/08/06/sharding-blockchain-survey/</id>
    <published>2023-08-06T01:14:25.000Z</published>
    <updated>2023-08-14T01:25:20.442Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Building-blocks-of-sharding-blockchain-systems-Concepts-approaches-and-open-problems"><a href="#Building-blocks-of-sharding-blockchain-systems-Concepts-approaches-and-open-problems" class="headerlink" title="Building blocks of sharding blockchain systems: Concepts, approaches,and open problems"></a>Building blocks of sharding blockchain systems: Concepts, approaches,and open problems</h1><p>继<a href="https://alleysira.github.io/2023/05/31/Sharding-Blockchain-Consensus-lyj/">Sharding_Blockchain_Consensus</a> 之后阅读刘老师的综述文章</p><p>分片技术是打破区块链去中心化、安全性和可扩展性不可能三角的最流行的方式，分片技术可以广义的理解为将区块链中的节点动态划分为彼此之间没有细粒度同步并且执行存储、计算和通信任务的子集，子集称为分片</p><p>现有的分片区块链设计仍有很多可探索的空间，本文从此出发，对现有的分片区块链进行了系统的分析，并将它们的架构概念分解为功能组件，并推导出它们所基于的系统模型和攻击者的假设。推导出的功能组件包括：</p><ul><li>节点选择、轮随机数、节点分配、片内共识、跨片交易处理、分片重配置、激励机制</li></ul><p>对于每个功能组件，本文描述了接口、功能和性质，给出了组件如何组合成一个分片区块链系统并讨论了每个组件的后续研究方向；同样关注了潜在的安全攻击和性能问题，例如系统吞吐量和延迟</p><span id="more"></span><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>传统的区块链系统是一个点对点的分布式自治系统，依赖原子广播协议实现复制状态机</p><p>理想的区块链系统努力实现去中心化的控制、对单一状态的共识、防篡改的记录、隐私保护、高可用性</p><p>现有的区块链系统在实际应用受限于不可能三角</p><ul><li>对于去中心化：区块链需要支持多种假设下的节点（如何加入/离开网络）</li><li>对于安全性：需要证明安全，保证区块链协议能够抵抗某一类攻击</li><li>对于可扩展性：现有的方案能够分成链下方案和链上方案<ul><li>链上：采用层次化的架构，核心的区块链系统仅验证少许聚合的资源转移（许多细粒度交易和净效应），概念上类似于一个银行，中央银行就是核心区块链；分片就是一种链上解决方案<ul><li>micropayment </li><li>payment channel networks</li><li>virtual payment channels</li><li>sidechains</li></ul></li><li>链下：避免传统区块链系统的计算开销，避免了所有节点之间就交易顺序达成一致所需的计算成本。</li></ul></li></ul><p>分片希望实现和传统区块链同等的安全性和去中心化，能否实现？</p><p>分片技术最初在数据库系统提出，第一个分片区块链工作发表于CCS16的ELASTICO</p><p>现有的分片工作主要存在以下问题：</p><ul><li>分片区块链系统的结构复杂，包含多个组件</li><li>不同的分片区块链采用的模型和假设不同（网络模型、敌手模型、交易模型），不容易理解设计和安全性</li><li>现有的分片区块链系统是端到端的描述方式，没有给出整体架构，各组件的功能不够清晰</li></ul><p>贡献</p><ul><li>将分片区块链拆解为功能组件，给出了每个组件的输入输出、功能和性质；给出了如何讲各组件组合成为完整的分片区块链</li><li>对分片区块链系统详尽的分类：从系统模型和功能组件两个方向对分片区块链进行了分类，对于每个组件归类除了解决方案</li><li>对组件的深度分析。对每个组件给出基本概念（目的、功能和基本步骤），识别并分析了每个方案在安全、吞吐量、延迟等方面可能存在的问题；给出了未来的研究方向</li></ul><h1 id="Preliminaries"><a href="#Preliminaries" class="headerlink" title="Preliminaries"></a>Preliminaries</h1><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>讲区块链、区块链共识机制再讲分片区块链</p><h3 id="Consensus"><a href="#Consensus" class="headerlink" title="Consensus"></a>Consensus</h3><p>介绍区块链的不可篡改性居然加了一句（except for some special redactable blockchains）</p><p>区块链的架构</p><ul><li>网络层：节点在P2P网络内进行消息同步，节点分布式，不存在中央节点</li><li>共识层：具有特定计算和通信能力的节点作为共识节点，通过特定共识算法，承担出块的工作，图中是BFT类共识；共识层决定区块链的一致性和活性</li><li>应用层</li></ul><p><img src="/2023/08/06/sharding-blockchain-survey/image-20230806104704355.png" alt="image-20230806104704355"></p><p>现有的区块链共识协议可以分为</p><ul><li>经典的分布式共识协议：BFT类，采用复制状态机的思想</li><li>基于工作量证明机制的共识</li><li>基于权益证明的共识</li><li>混合共识协议：单一委员会和多委员会共识（分片的一种）</li></ul><h3 id="Sharding-blockchains"><a href="#Sharding-blockchains" class="headerlink" title="Sharding blockchains"></a>Sharding blockchains</h3><p>当网络中节点增加时，增加分片数量即可提高处理能力</p><p>ELASTICO作为第一篇分片的工作，结合了分片技术提高区块链的交易吞吐率</p><p>可以分为三类</p><ul><li>通信分片：片内节点大多数时间仅进行片内通信</li><li>计算分片：每个分片只负责处理相关的交易，交易的分配是多样化的（根据交易ID进行分片）</li><li>存储分片：每个分片的节点仅存储所在分片的数据（交易历史、UTXO），交易历史存在区块链上，UTXO可以为了效率单独存储；实际上减少了节点的存储开销</li></ul><p>协调者负责跨片通信和片内共识</p><p><img src="/2023/08/06/sharding-blockchain-survey/image-20230806112006224.png" alt="image-20230806112006224"></p><p>分片和其他可扩展性解决方案进行对比，可以分为链上（layer1）和链下（layer2）两类方案</p><ul><li>链上方案：分片属于链上方案，还有DAG有向无环图和侧链方案<ul><li>有向无环图的区块链<ul><li>采用多条链跟随主链，每个新区块都会链接到若干个之前的区块，可以追溯到创世区块<ul><li>IOTA市值80位，conflux市值69位</li></ul></li><li>参考<a href="https://zhuanlan.zhihu.com/p/52424180">有向无环图 DAG - 知乎 (zhihu.com)</a></li></ul></li><li>侧链方案：采用额外的区块链执行交易，可能运行多个共识算法，侧链和主链之间需要一个two-way peg（一般用智能合约实现），用于在主链和侧脸之间资产交换</li></ul></li><li>链下方案：通过channel和主链进行小的交易处理，代表性工作是闪电网络和Perun</li></ul><h2 id="Notations"><a href="#Notations" class="headerlink" title="Notations"></a>Notations</h2><p><img src="/2023/08/06/sharding-blockchain-survey/image-20230808091029311.png" alt="image-20230808091029311"></p><h2 id="Definitions"><a href="#Definitions" class="headerlink" title="Definitions"></a>Definitions</h2><p><img src="/2023/08/06/sharding-blockchain-survey/image-20230808091411255.png" alt="image-20230808091411255"></p><ul><li>网络模型：分片区块链需要考虑全部区块链网络的网络模型和分片内的网络模型，可以不同<ul><li>同步：保证消息按照轮传播</li><li>部分同步：存在时延上限，但是不能作为协议参数</li><li>异步：不存在时延上限，但是最终诚实用户的消息能够到达彼此<ul><li>FLP问题指出异步系统中不存在确定性的共识算法能够保证在有限的时间内达成共识</li></ul></li></ul></li><li>节点准入模型<ul><li>许可网络：需要完成身份认证才能加入协议</li><li>非许可网络：节点可以在任何时间加入网络；没有身份认证机制；节点数量不可预测</li></ul></li><li>敌手模型<ul><li>腐化模型：包括腐化时机和腐化速度；密码协议更关心腐化问题。腐化速度对分片区块链更重要，决定了重配置阶段（更新委员会）<ul><li>根据敌手可以发动腐化的时机，可以分为静态和适应性腐化<ul><li>静态：协议运行前确定腐化对象</li><li>适应性腐化：敌手能够根绝运行时的消息适应性动态腐化目标节点</li></ul></li><li>根据腐化速度，可以分为温和腐化和立即腐化<ul><li>温和孵化：敌手需要$\tau$时间完成腐化<ul><li>分片区块链中的轮指所有分片成员不变继续运转的时间，轮的时长和敌手完成腐化的时间强相关</li><li><img src="/2023/08/06/sharding-blockchain-survey/image-20230808093516205.png" alt="image-20230808093516205"></li></ul></li><li>立即腐化：$\tau=0$<ul><li>使用较少，Algorand</li></ul></li></ul></li></ul></li><li>全局比例模型：敌手能够控制的算力资源或权益资源<ul><li>$[0,1/3)$</li><li>$[1/3,1/2)$</li></ul></li><li>片内比例模型：片内的节点数量固定，片内敌手控制的节点数量通过$f$等式表达，由片内共识算法决定；一般全局比例会低于片内比例<ul><li>$u=2f+1$：同步的BFT</li><li>$u=3f+1$：部分同步</li></ul></li></ul></li><li>交易模型<ul><li>UTXO模型：最常用，每个UTXO包括公钥地址和交易值，每个交易消耗现有的UTXO生成新的UTXO，UTXO的输入和输出值相同 </li><li>账户模型：每个用户拥有账户，账户地址用于存储余额</li><li>其他</li></ul></li><li>片内共识<ul><li>弱一致性：存在分叉，但是保证最终一致性<ul><li>链质量 链增长 链公共前缀</li></ul></li><li>强一致性：存在委员会运行分布式共识算法来确认交易和出块<ul><li>状态机复制：对于服务器集合，包含一个原始数据和若干备份，对线性增长的账本达成一致，需要满足一致性和活性</li><li><img src="/2023/08/06/sharding-blockchain-survey/image-20230808100317670.png" alt="image-20230808100317670" style="zoom:80%;"></li></ul></li></ul></li><li>分片区块链<ul><li>给出账本的定义</li><li><img src="/2023/08/06/sharding-blockchain-survey/image-20230808100551688.png" alt="image-20230808100551688"></li><li>安全的分片区块链定义：可视为一类特殊的账本，将一致性拆分为片内公共前缀和跨片无冲突；活性分别定义了片内交易确认时延和跨片交易确认时延</li><li><img src="/2023/08/06/sharding-blockchain-survey/image-20230808100842569.png" alt="image-20230808100842569" style="zoom:80%;"></li><li>交易确认时延，设交易提交时间为$t$，交易出现在诚实节点账本的时间为$t’$，则交易确认时延为$t’-t$</li><li>应答性：交易的确认时延仅和实际网络实验$\delta$相关，和上界$\Delta$无关</li></ul></li></ul><p>简单对各种组件排列组合就能得到新的分片区块链，作者给了216种（？</p><h1 id="Decomposing-sharding-blockchains-into-functional-components"><a href="#Decomposing-sharding-blockchains-into-functional-components" class="headerlink" title="Decomposing sharding blockchains into functional components"></a>Decomposing sharding blockchains into functional components</h1><p>依次介绍每个组件的基本内容，组合组件的方法，总结现有的分片区块链</p><h2 id="Decomposition-of-sharding-blockchains"><a href="#Decomposition-of-sharding-blockchains" class="headerlink" title="Decomposition of sharding blockchains"></a>Decomposition of sharding blockchains</h2><p>分片区块链的整体流程如图所示</p><p><img src="/2023/08/06/sharding-blockchain-survey/image-20230808102927605.png" alt="image-20230808102927605"></p><ul><li>节点选择：参数$k$表示每个分片内新的节点的数量，$m$是分片个数<ul><li><img src="/2023/08/06/sharding-blockchain-survey/image-20230808103202920.png" alt="image-20230808103202920"></li><li>在无许可环境中，可能会使用PoW或者PoS进行选择；</li><li>在许可环境中，由可信第三方来执行</li><li>需要满足公平性和鲁棒性，公平性限制恶意敌手的比例，鲁棒性指在恶意敌手不超过某个比例时snodes仍然会被诚实节点接受</li></ul></li><li>轮随机数：一般是交互式的分布式组件<ul><li><img src="/2023/08/06/sharding-blockchain-survey/image-20230808103822367.png" alt="image-20230808103822367"></li><li>bias-resistance <strong>抗偏置性</strong> 指敌手的参与不会影响结果的随机性</li><li>可用性保证随机数能够产生</li><li>轮随机数一般用于 将节点随机分配为分片，作为PoW的puzzle</li></ul></li><li>节点分配：将选择出的节点随机分配到$m$个分片中，每个分片$k$个新节点<ul><li><img src="/2023/08/06/sharding-blockchain-survey/image-20230808104409602.png" alt="image-20230808104409602"></li><li>实际上 $anode$ 和下轮参与协议的节点并不一定相同，不同的分片区块链存在不同的替代旧节点的规则</li></ul></li><li>片内共识：<ul><li>在普通区块链中，proposal是交易，在分片区块链中 $p$ 可以是交易，交易输入或者其他承诺的值</li><li><img src="/2023/08/06/sharding-blockchain-survey/image-20230808104851668.png" alt="image-20230808104851668"></li><li>可以划分为强共识和弱一致性共识</li><li>异步环境下只能实现活性或者一致性，一致性对分片更重要</li></ul></li><li>跨片交易处理：<ul><li><img src="/2023/08/06/sharding-blockchain-survey/image-20230808105414053.png" alt="image-20230808105414053"></li><li>跨片交易占据分片区块链系统的大部分交易</li><li>片内交易可以视为特殊的跨片交易</li><li>可划分为2个阶段<ul><li>输入分片生成的证明，证明交易的输入有效并且将证明发送其他相关分片</li><li>所有相关分片验证交易是否有效</li></ul></li></ul></li><li>分片重配置：决定下轮每个分片内的节点<ul><li><img src="/2023/08/06/sharding-blockchain-survey/image-20230808110515006.png" alt="image-20230808110515006"></li><li>需要设计自举阶段，当新节点加入分片时如何下载历史交易数据</li><li>安全性要求每个分片是诚实的</li></ul></li><li>激励机制<ul><li>包括对诚实节点的奖励和对恶意节点的惩罚</li><li><img src="/2023/08/06/sharding-blockchain-survey/image-20230808111215363.png" alt="image-20230808111215363"></li></ul></li></ul><h2 id="Composing-separate-components-into-sharding-blockchain-systems"><a href="#Composing-separate-components-into-sharding-blockchain-systems" class="headerlink" title="Composing separate components into sharding blockchain systems"></a>Composing separate components into sharding blockchain systems</h2><p>实际的分片区块链系统是上一节提到的组件的组合</p><p><img src="/2023/08/06/sharding-blockchain-survey/image-20230808111557856.png" alt="image-20230808111557856"></p><ul><li>NS NA ER SR可以视为阶段一，对分片成员列表的确认</li><li>Isc CSTp可以视为阶段二，负责交易处理</li></ul><p>根据片内共识，sharding blockchains could be divided into instant sharding blockchains and eventual sharding blockchains</p><p>以下是对现有分片区块链拆解后进行分类的结果</p><p><img src="/2023/08/06/sharding-blockchain-survey/image-20230808112726370.png" alt="image-20230808112726370"></p><p>表2对当前的分片区块链系统进行了总结与对比</p><p><img src="/2023/08/06/sharding-blockchain-survey/image-20230808113640210.png" alt="image-20230808113640210"></p><h1 id="Node-Selection"><a href="#Node-Selection" class="headerlink" title="Node Selection"></a>Node Selection</h1><p>困难点：</p><ul><li>所有节点对选择结果的视图应该一致</li><li>需要满足诚实节点的比例足够高</li><li>给出安全证明</li></ul><p>许可链中由CA完成，主要讨论无许可链中的情况，采用PoW或PoS，需要考虑难度的设计</p><p>节点选择过程一般会导致诚实节点的比例降低，为了量化这个降低的程度，给出了诚实部分下降程度的定义</p><p><img src="/2023/08/06/sharding-blockchain-survey/image-20230809181503587.png" alt="image-20230809181503587"></p><p>为了防止诚实节点的比例下降太多，给出了公平选择的定义</p><p><img src="/2023/08/06/sharding-blockchain-survey/image-20230809181956036.png" alt="image-20230809181956036"></p><p>现有方案</p><h2 id="基于PoW的节点选择"><a href="#基于PoW的节点选择" class="headerlink" title="基于PoW的节点选择"></a>基于PoW的节点选择</h2><p>两类，依赖底层的区块链或参考委员会reference committee</p><p>首先是依赖底层区块链的方法</p><p><img src="/2023/08/06/sharding-blockchain-survey/image-20230809182522545.png" alt="image-20230809182522545"></p><p><img src="/2023/08/06/sharding-blockchain-survey/image-20230809182702543.png" alt="image-20230809182702543"></p><ul><li>$str$是上一个区块的哈希值</li><li>$pub_i$包含节点的若干公开信息，用于证明节点的身份，一般包含公钥</li><li>$D=p\cdot2^\lambda$，有$Pr[H(str,nonce,pk_i)&lt;D]=p$，即$p$是节点发现解的概率</li></ul><p>发现解的节点作为新分片的成员，当足够数量的分片成员出现后，进行分片重配置</p><p>Omniledger的具体实现是在轮$e$，想要成为$e+1$轮分片成员的节点在identity blockchain上进行挖矿</p><p>其次是依赖参考委员会的方法</p><p><img src="/2023/08/06/sharding-blockchain-survey/image-20230809183412616.png" alt="image-20230809183412616"></p><p>包含两步</p><ul><li>挖矿。节点在当前轮针对特定puzzle进行挖矿，同样是PoW，求解后发送给委员会<ul><li>和之前的区别是同一轮内所有人求解的难题相同，即不出块；</li><li>同一个节点多次计算，不影响安全性，敌手的算力有限？</li></ul></li><li>新节点列表确认。数量足够后进行片内共识，确认后广播list<ul><li>RapidChain利用参考委员会来选择节点，难题是VSS生成的</li></ul></li></ul><p>依赖底层区块链存在的问题：敌手可能进行自私挖矿、固执挖矿、扣快攻击</p><ul><li>自私挖矿：敌手出块后不公开，等待私链更长后再公开，浪费诚实节点算力</li><li>固执挖矿：类似于自私挖矿，但是挖一个并行的私链，导致分叉</li><li>扣块攻击</li><li>日蚀攻击</li><li>网络分片攻击</li></ul><p>这些介绍和节点选择理论上没关系</p><p>backbone protocol给出了理论上敌手能够控制的区块比例上界为$t/(n-t)$,t是敌手的算力，n是全网的算力</p><p>基于委员会方法的问题：包含两方面，敌手挖矿时的时间优势，新节点列表的确认</p><ul><li>时间优势指敌手可以恶意延迟诚实节点发送的消息，敌手可以提前获得挖矿的puzzle，可以恶意延迟诚实节点的解;敌手可能给出多个解，需要解的数量超过某个下界（有详细的文章讨论这个问题</li><li>发现了足够多解后，委员会运行片内共识算法进行新节点的确认，BFT类共识片内有leader负责propose新节点的列表，恶意的leader可能censor这个列表<ul><li>普通节点投票时不检查有效性，导致恶意节点数量过多</li><li>如果检查了有效性不予投票，影响活性</li><li>可能通过门限投票机制解决</li></ul></li></ul><p>未来的研究方向：</p><ul><li>设计更公平的节点选择机制，HFDD尽可能小</li><li>分析各种攻击</li><li>采用严格的分析方法分析挖矿过程的安全性</li></ul><h2 id="基于PoS的节点选择"><a href="#基于PoS的节点选择" class="headerlink" title="基于PoS的节点选择"></a>基于PoS的节点选择</h2><p>节点本身的币越多，被选择的概率就越高，需要将系统内的币分成小的单元，每个单元均有参与节点选择的权利；用VRF判断单元是否被选中，同样有两类方法，依赖底层区块链或不依赖</p><ul><li>依赖底层区块链：节点同样根据PoS出块，某一时间段内的出块者作为分片成员</li><li>不依赖底层区块链：需要先选委员会<ul><li>CCS19这篇工作的选委员会机制为 $H(v’s\  address||H(b)) \bmod k$,其中$v$是节点，$b$是上轮的最后一个区块，$k$是分片数量</li><li>？哪里有PoS</li><li>D.R. Lee, Y. Jang, H. Kim, Poster: A proof-of-stake (PoS) blockchain<br>protocol using fair and dynamic sharding management, in: Proceedings<br>of the 2019 ACM SIGSAC Conference on Computer and Communications<br>Security, CCS 2019, London, UK, November 11-15, 2019, 2019, pp.<br>2553–2555.</li></ul></li></ul><p>存在的问题：</p><ul><li>无利害攻击：在各个分叉上挖矿，成本较小；增加自己成功的概率：需要惩罚机制</li><li>grinding attack：攻击者遍历区块链，在不同的分叉上尝试出块，提高自己成为下一个leader的概率，因为有的链e+1轮的出块者是根据前一轮的出块者决定的；可以用无偏的随机性来解决</li><li>长程攻击：新节点加入时用虚假的链骗他。PoW的链可以通过比较挖矿难度来判断主链，而PoS可以获得曾经有很高权益的节点的私钥，以较低的成本实现这样的攻击；采用检查点机制可以防御</li><li>权益流失攻击：长程攻击成功后敌手可以在新的链上发动双花，交易也会在新的链上记录，导致了诚实链权益损失</li></ul><p>未来的研究方向：</p><ul><li>实际应用密码工具的通信和计算开销需要考虑</li></ul><h2 id="基于CA的节点选择"><a href="#基于CA的节点选择" class="headerlink" title="基于CA的节点选择"></a>基于CA的节点选择</h2><p>首先在CA处进行身份认证，CA在节点数量足够或当前轮最后公布节点列表</p><h1 id="Epoch-randomness"><a href="#Epoch-randomness" class="headerlink" title="Epoch randomness"></a>Epoch randomness</h1><p>首先给出轮随机数相关的基本概念，再给出现有的生成随机数的方案（VRF、PVSS)，再比较现有的DRB，分析未来的研究方向</p><h2 id="Basic-Concepts"><a href="#Basic-Concepts" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h2><p>可以用做puzzle，作为节点随机分配的种子</p><p>需要解决的问题：</p><ul><li>确定参加轮随机数协议的节点</li><li>每轮调用 随机数协议的时间点需要确定</li><li>随机数生成协议的时间 系统开销和失败概率需要仔细考虑</li><li>生成的随机数的性质需要满足分片区块链的要求</li></ul><p>当节点互不信任时，如何公平地产生随机数：密码学工具，如DRB，满足</p><ul><li>公开可验证性：任何不直接参与协议的第三方同样能利用公开的信息验证产生的随机数</li><li>不可预测性：任何节点不能预测未来的随机值</li><li>抗偏置性：节点甚至合谋的节点也不能将随机数影响为对自己有利的</li><li>可用性/活性：节点甚至合谋的节点也不影响协议进程</li></ul><h2 id="Existing-approaches"><a href="#Existing-approaches" class="headerlink" title="Existing approaches"></a>Existing approaches</h2><p>主要包括VRF、PVSS、门限签名、Hash和VDF</p><ul><li>VRF：所有节点用私钥作为输入生成随机数，输出的随机数带有零知识证明，节点将VRF的输出和轮随机数结合后签名，最小的作为leader或者委员会成员<ul><li>目的：本地生成可验证和不可预测随机数</li><li>Algorand, Ouroboros Praos, and DVRFs</li></ul></li><li><p>门限签名：签名算法需要门限个参与者才行执行，验证算法任何人都可以执行</p><ul><li>在随机数生成中的具体使用：所有参与者提供对共同消息的签名份额，验证收到的签名份额具体并输出随机数</li><li>密钥分发<ul><li>可信的dealer</li><li>DKG</li></ul></li></ul></li><li><p>PVSS：分发阶段dealer计算加密的份额，并发送非交互式零知识证明</p><ul><li>节点秘密生成一个随机值</li><li>广播随机值的承诺和份额</li><li>验证后揭露秘密，节点未能揭露则执行秘密分享的恢复算法</li></ul></li><li><p>Hash：PoW</p></li><li>VDF：计算必然缓慢，验证高效</li><li>同态加密、MACPABE多Authority的</li></ul><h2 id="现有DRB方案的比较"><a href="#现有DRB方案的比较" class="headerlink" title="现有DRB方案的比较"></a>现有DRB方案的比较</h2><p><img src="/2023/08/06/sharding-blockchain-survey/image-20230811112615922.png" alt="image-20230811112615922"></p><p>通信复杂度指所有节点每轮发送的bit，计算复杂度指每个节点每轮的操作数，验证复杂度指外部验证者每轮的操作数</p><ul><li>基于PoW和PoS的方案更适合大规模和动态参与者</li><li><p>RandRunner 受网络延迟和网络崩溃的影响非常小</p></li><li><p>Ouroboros , RandShare, Scrape and HydRand 通信复杂度过高，适合小集合参与者</p></li></ul><h2 id="Problems-and-future-directions"><a href="#Problems-and-future-directions" class="headerlink" title="Problems and future directions"></a>Problems and future directions</h2><ul><li>安全性：<ul><li>随机性的三个属性</li><li>VDF方案的安全性依赖于具体过程的时间复杂度，实际中难以设置参数</li></ul></li><li>性能：参与节点越多，系统一般越安全<ul><li>完美安全性的协议计算和通信复杂度都非常高，如Ouroboros</li><li>基于门限密码的方案需要执行DKG</li><li>大多数协议不支持频繁的节点集合更新</li></ul></li><li>形式化的安全性分析<ul><li>形式化定义：协议的可组合性</li><li>精确的假设：大多数方案是同步模型</li><li>安全性证明</li></ul></li></ul><h1 id="Node-assignment"><a href="#Node-assignment" class="headerlink" title="Node assignment"></a>Node assignment</h1><p>将新节点随机分配到不同的分片中，否则敌手可能在特定分片内可能获得控制权</p><ul><li>需要确保分配过程的随机性</li><li>合理设置参数，每个分片内诚实大多数：需要采用特定数学模型来严格分析最终的分布</li></ul><h2 id="现有方案"><a href="#现有方案" class="headerlink" title="现有方案"></a>现有方案</h2><p>$n,m,u$ 分别是节点总数，分片个数和每个分片内节点数</p><h3 id="二项分布"><a href="#二项分布" class="headerlink" title="二项分布"></a>二项分布</h3><p>节点分配过程视作随机采样问题，分配前的节点看做无限池，每次从池中取一个节点，该节点诚实和恶意的概率不变（不够合理）</p><p>当选择出的委员会为恶意，则称该分布失败</p><p>设$Q_0$表示目标的诚实节点比例，$X$表示取的次数，敌手的算力占比为$\rho$，则敌手在分片内占比为$1-Q_0$的概率为</p><script type="math/tex; mode=display">Pr[X=u(1-Q_0)]=C_{\mu}^{\mu(1-Q_0)}\rho^{\mu (1-Q_0)}(1-\rho)^{\mu Q_0}</script><p>因此失败的概率可以记作</p><script type="math/tex; mode=display">Pr[X\geq \mu(1-Q_0)+1]= \sum^{\mu}_{x=\mu(1-Q_0)+1} C_{\mu}^{x}\rho^{x}(1-\rho)^{\mu-x}</script><p>Omniledger采用了二项分布</p><h3 id="超几何分布"><a href="#超几何分布" class="headerlink" title="超几何分布"></a>超几何分布</h3><p>不再是无限池，每次选择节点后不再放回，节点的诚实和恶意的概率发生变化</p><p>失败的概率为</p><script type="math/tex; mode=display">Pr[X\geq (1-Q_0)\mu+1]=\sum^{\mu}_{x=(1-Q_0)\mu+1}\frac{C_{\rho n}^xC^{\mu-x}_{(1-\rho)n}}{C_n^\mu}</script><p>根据其他参数来选择 $\rho$ 使得失败概率足够小，如$10^{-5}$</p><p>RapidChain和SGX sharding采用了超几何分布对轮的安全性进行分析</p><h3 id="其他分布"><a href="#其他分布" class="headerlink" title="其他分布"></a>其他分布</h3><p>实际上二项分布和超几何分布都基于 节点的分配时随机的，然而现有方案可能依赖特定规则</p><p>如Polyshard在编码后的分片上进行计算以及分片异构的Pyramid</p><h2 id="Problems-and-future-directions-1"><a href="#Problems-and-future-directions-1" class="headerlink" title="Problems and future directions"></a>Problems and future directions</h2><p>节点选择和节点分配是相互联系的</p><p><img src="/2023/08/06/sharding-blockchain-survey/image-20230811153629981.png" alt="image-20230811153629981"></p><ul><li>现有方案忽略了A到B的安全性，事实上B中的敌手比例比A中的更高($&gt;\rho$)，因为<ul><li>敌手可能在消息发送中占优，即能够更早开始挖矿</li><li>如果参考委员会当中的leader是恶意的，可能会进行censor，增加被控制节点的比例</li></ul></li><li>无限池假设不够准确</li><li>累计超几何分布的失败率不够精确<ul><li>仅第一个委员会的概率是正确的，后续的委员会选择受前一个委员会的影响</li></ul></li></ul><h1 id="Intra-shard-consensus"><a href="#Intra-shard-consensus" class="headerlink" title="Intra-shard consensus"></a>Intra-shard consensus</h1><p>片内共识是分片区块链的关键模块，本章首先给出片内共识的基本概念，再划分为立即和最终分片，给出了状态机复制算法，总结了片内共识算法存在的问题</p><h2 id="Basic-concepts"><a href="#Basic-concepts" class="headerlink" title="Basic concepts"></a>Basic concepts</h2><p>片内共识算法的目的是高效地处理片内的交易以及和其他分片合作处理跨片交易，需要片内共识算法给出对相关交易输入的可用性证明，证明是签名的形式</p><p>除此之外，在某些采用参考委员会的分片区块链中，片内共识算法用于确认新委员的名单，片内共识算法影响具体的效率，需要考虑的问题包括：</p><ul><li>片内共识算法的可扩展性：与通信和计算复杂度相关</li><li>需要处理分片区块链特有的不同提案</li><li>片内的网络环境和整个区块链的网络之间的关系</li></ul><p>片内共识算法可以分为两类</p><ul><li>强一致性共识算法：每个分片均有委员会，委员会作为出块者，委员会运行BFT类共识，对应立即分片区块链</li><li>弱一致性共识算法：分片内采用PoW或者PoS，对应最终分片区块链</li></ul><h2 id="现有的方案"><a href="#现有的方案" class="headerlink" title="现有的方案"></a>现有的方案</h2><h3 id="Strong-consistency"><a href="#Strong-consistency" class="headerlink" title="Strong consistency"></a>Strong consistency</h3><p>经典的分布式共识算法，实现状态机复制</p><p>对节点的假设不同：宕机、拜占庭节点；一般认为拜占庭节点包括宕机，能够容忍拜占庭节点的协议具有更强的适应性和鲁棒性，主要介绍BFT类的共识</p><h4 id="同步网络"><a href="#同步网络" class="headerlink" title="同步网络"></a>同步网络</h4><h5 id="分布式共识协议"><a href="#分布式共识协议" class="headerlink" title="分布式共识协议"></a>分布式共识协议</h5><p>拜占庭将军问题首先提出了法定人数问题，防止恶意的leader模棱两可，即同一轮向不同的诚实节点发送不同的提案</p><p>在部分同步网络中，若敌手模型为$u=3f+1$，则法定人数为$2f+1$</p><p>设恶意的leader同一轮向不同节点发送了不同的提案$p,p’$，则如果两者投票分别为$x$，$2x-(3f+1)$就是该轮同时对两个提案投票的节点个数，则需要满足$2x-(3f+1)&lt; f+1$，即$x&lt; 2f+1$，因此设置投票法定人数为$2f+1$即可</p><p>同步的HotStuff采用了流水线的技术来改善提案效率，采用两阶段的基于领导者的方法来处理交易，交易的确认时延为$2\Delta$</p><p><img src="/2023/08/06/sharding-blockchain-survey/image-20230811164850841.png" alt="image-20230811164850841"></p><h5 id="和分片区块链结合"><a href="#和分片区块链结合" class="headerlink" title="和分片区块链结合"></a>和分片区块链结合</h5><p>在分片区块链当中，片内和全局的消息传播模型可能不同</p><p>Rapidchain采用了实用同步BFT共识协议，敌手模型为$u=2f+1$，利用参考委员会生成的随机数选举leader，片内共识主要包括四轮</p><ul><li>propose：领导者广播消息和哈希值</li><li>echo：节点收到消息后广播哈希值，确保每个诚实节点都能收到leader发送的消息</li><li>pending：如果恶意leader发送了多条消息，诚实节点能够检查到，将冲突消息标记为pending（待定）并广播，恶意leader将会被取代</li><li>accept：诚实节点收到f+1个有效的echo后认为提案是有效的，广播带有accept的哈希值</li></ul><p>Rapidchain允许leader利用pending的区块，即可以提出新的区块时重新提案pending区块的区块头</p><p>采用同步网络模型，因此容忍委员会的敌手为$50\%$，牺牲了交易处理的效率</p><p>每个节点需要每轮等待$\Delta$时间，导致了交易确认时间和实际的网络时延无关，不满足响应性。在半同步网络和异步网络中无法直接使用$\Delta$</p><h4 id="部分同步"><a href="#部分同步" class="headerlink" title="部分同步"></a>部分同步</h4><p>部分同步网络是大多数区块链采用的网络模型，首先给出经典方案再和分片区块链结合</p><h5 id="分布式共识算法"><a href="#分布式共识算法" class="headerlink" title="分布式共识算法"></a>分布式共识算法</h5><ul><li><p>Paxos：本来是为分布式数据库维护设计的算法，支持$u=2f+1$个宕机节点，不支持拜占庭节点，实际上在区块链中的应用很少</p><ul><li>主节点向超过50%的备份节点发送prepare消息</li><li>备份节点验证消息的合法性，向主节点返回承诺后的消息；</li><li>主节点在收到足够多的承诺消息后构造承诺证明，向备份节点发送包括承诺证明的确认消息；</li><li>备份节点收到确认消息后验证合法性，向主节点返回确认消息的确认消息</li></ul></li><li><p>PBFT：大多数分片区块链或基于委员会的共识协议均采用PBFT类的共识，非常重要，敌手模型为$u=3f+1$，采用消息验证码进行身份认证；实现了一致性和活性</p><ul><li>共识部分具体流程如图所示，复杂度$O(n^3)$<img src="/2023/08/06/sharding-blockchain-survey/image-20230811175214951.png" alt="image-20230811175214951"></li><li>在propose阶段，client给所有节点上传提案$p$</li><li>pre-prepare阶段：主节点给所有节点发送构造的pre-prepare消息$(pre-prepare,H(m),s,v)$，$s$是序列号，$v$是视图，记录主节点的更替，视图转换后值+1</li><li>prepare阶段：备份节点确认对于当前的$(s,v)$没有冲突的准备消息，然后广播prepare消息$(prepare,H(p),s,v)$</li><li>commit阶段：收到$2f+1$个有效的prepare消息后，备份节点认为$p$是已经准备好了，广播commit消息$(commit,H(p),s,v)$</li><li>reply阶段：收到$2f+1$个有效的commit消息后，备份节点认为$p$已经被承诺了，将承诺后的提案和签名发送给client</li></ul><p>PBFT包括以上的共识部分和视图转换部分，当主节点不能及时处理数据时，备份节点发起视图转换，换主后新的主节点开始工作，采用round robin的方式进行更换，检查点机制用于协助视图转换，所有commited的提案中最大的序列号被认为是稳定的checkpoint</p><ul><li>视图转换复杂度为$O(n^4)$，视图转换的具体协议如下所示：<ul><li>view-change message broadcast阶段，节点$i$广播视图转换消息$vc_i:(view-change,v+1,S^<em>,C,U,i)$，其中$S^</em>$​代表当前稳定的检查点的序列号，$C$是$S^<em>$的$2f+1$个commit投票，$U$包含节点$i$当前视图下, 序列号大于$S^</em>$, 且已经形成prepared的消息集合</li><li>view-change acknowledgment阶段，备份节点验证vc消息并且构造对应的ack消息$vca_i:(view-change-ack,v+1,i,j,H(vc_j))$，直接发送给新视图的主节点（轮转决定）</li><li>new-view broadcast阶段，对每个视图转换消息$vc_j$，当主节点收到$2f-1$个ack后，$vc_j$就认为有效放入集合S中，新的主节点构造新视图消息$nv:(new-view,v+1,S,U^<em>)$，其中$U^</em>$包括当前稳定的检查点和检查点之后的序列号最小的pre-prepare消息，节点根据nv更新自己本地的状态，进入视图v+1</li></ul></li></ul></li><li><p>Hotstuff是对PBFT的改进，同样是部分同步网络，$u=3f+1$，特点包括：</p><ul><li>采用流水线处理提案，每轮的消息包括前一轮的法定证明和当前轮的新天</li><li>采用BLS签名聚合$2f+1$个投票为1个签名，降低了通信复杂度</li><li>每轮负责收集投票和发送提案的主节点都要更换</li><li><img src="/2023/08/06/sharding-blockchain-survey/image-20230811182751759.png" alt="image-20230811182751759"></li><li>观察到第4轮没有填仍然进行，考虑到活性</li><li>现有其他的BFT类共识，scalable Byzantine fault tolerance，Pala</li></ul></li></ul><h5 id="和分片区块链结合-1"><a href="#和分片区块链结合-1" class="headerlink" title="和分片区块链结合"></a>和分片区块链结合</h5><p>Paxos和分片区块链结合的工作很少，现在的工作都基于PBFT类共识</p><ul><li>ELASTICO直接使用PBFT，无法处理跨片交易，效率较低</li><li>Omniledger基于Byzcoin设计了Omnicon<ul><li>Byzcoin将MAC替换为数字签名，利用了树型的通信结构和CoSi协议，结合了CoSi和PBFT</li><li>指出CoSi容易受到错误，通信树的深度太大了，进行了改进</li></ul></li><li>ZILLIQA利用EC-Schnorr multi-signature protocol提高了PBFT的效率</li><li>Chainspace采用MOD-SMART的PBFT作为片内共识</li></ul><h4 id="异步网络"><a href="#异步网络" class="headerlink" title="异步网络"></a>异步网络</h4><h5 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a>共识算法</h5><p>FLP不可能定义给出了在异步网络下不存在确定性共识算法能够解决一致性问题</p><p>HoneyBadger BFT是异步下BFT共识的代表，敌手模型为$u=3f+1$</p><p>异步BFT依赖于可靠广播RBC和异步二进制协议ABA</p><ul><li>交易收集阶段，u个参与节点同时收集交易</li><li>交易门限加密阶段对收集到的交易进行B/U加密</li><li>RBC广播阶段，每个节点依赖于RBC广播并收集信息，RBC包括echo和ready两轮</li><li>ABA共识阶段，leader负责收集所有加密的值并且初始化ABA算法</li><li>交易门限解密阶段，如果加密的交易集有效，每个节点运行门限解密算法</li></ul><p>其他异步网络下的分布式共识协议还有：MinBFT、Dumbo-MVBA、BEAT等</p><p>目前没有分片区块链采用异步共识作为片内共识算法，可能是跨片交易依赖于共识协议在每个分片内的活性，当分片区块链处理跨分片交易时，多个分片需要合作并在一定时间内响应，然而异步网络下的共识机制牺牲了活性来保证安全性</p><h3 id="weak-consistency"><a href="#weak-consistency" class="headerlink" title="weak consistency"></a>weak consistency</h3><p>最终分片区块链一般使用 PoW PoS或者其他弱一致性方法在每个分片内生成区块，不存在委员会</p><ul><li><p>Monoxide提出了楚弩挖矿来实现PoW的片内共识算法，能够防御1%攻击，矿工需要在多个链上进行挖矿，m个不同链上的区块的区块头形成merkle树，树根和nonce作为hash的输入，然而矿工需要收集并验证m个区块链上所有的信息，实际上并没有实现可扩展性</p></li><li><p>Parallel Chains将VRF和PoS结合起来在每个分片内生成区块</p></li></ul><h2 id="问题和未来的研究方向"><a href="#问题和未来的研究方向" class="headerlink" title="问题和未来的研究方向"></a>问题和未来的研究方向</h2><p>分别从立即分片区块链和最终分片区块链的角度进行总结</p><h3 id="立即分片区块链"><a href="#立即分片区块链" class="headerlink" title="立即分片区块链"></a>立即分片区块链</h3><ul><li>降低分片成员间的通信复杂度：片内分布式共识算法一般依赖多轮投票来达成一致，在投票阶段如果每个成员均发送签名、收集和验证签名，通信量很大；而且每个分片内为了保证安全性，分片成员个数需要达到安全门限</li><li>恶意委员检测和恢复机制：多个分片运行分布式共识算法，可能会有特定的委员会被敌手掌握，如何检测通过其他诚实分片检测恶意分片的委员会并且设计特定的机制来取代恶意委员会是未来的研究方向</li><li>片内和跨片的高效的视图转换机制：降低分片成员的通信复杂度，如何降低leader的负担、公平合理地选择新的leader；处理跨片交易时可能不同分片委员会之间的视图不一致，如何处理（leader诚实执行片内工作，丢弃跨片交易）</li><li>和分片区块链更好的结合：片内共识算法还需要处理跨片交易，需要多个分片运行多轮片内共识；输入可能多样化，不只是交易</li></ul><h3 id="最终分片区块链"><a href="#最终分片区块链" class="headerlink" title="最终分片区块链"></a>最终分片区块链</h3><ul><li>1%攻击问题。以PoW为例，敌手可以集中他的算力在某个分片上进行挖矿，安全性要求是敌手不能超过该分片51%的算力。假设存在m个分片，则敌手成功的所需要的算力降低为51%/m，当m足够大时，51%/m近似等于1%。因此在最终分片区块链上如何解决1%攻击非常重要</li><li>复杂的跨片交易处理。分片内产生的区块不能被立即确认，区块需要达到一定深度时才能保证稳定，因此跨片交易处理在最终分片区块链中更加复杂。</li></ul><h1 id="Cross-shard-transaction-processing"><a href="#Cross-shard-transaction-processing" class="headerlink" title="Cross-shard transaction processing"></a>Cross-shard transaction processing</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>分片区块链中交易是跨片交易的概率非常高，概率随分片数量增加而增加</p><p>Rapidchain当分片为16时，跨片交易的占比为99.8%，处理跨片交易的机制对分片区块链的性能影响很大</p><p>跨片交易处理过程中需要解决2个问题</p><ul><li>跨片通信和处理机制的设计，一个交易的输入可能被多个分片控制，多个分片需要协作判断交易的有效性</li><li>防止双花攻击的机制。防止交易输入被双花</li></ul><h2 id="现有方案-1"><a href="#现有方案-1" class="headerlink" title="现有方案"></a>现有方案</h2><ul><li><p>立即分片区块链：2阶段承诺和交易拆分</p></li><li><p>最终分片区块链：中继交易解决方案</p></li></ul><h3 id="两阶段承诺-2PC-方案"><a href="#两阶段承诺-2PC-方案" class="headerlink" title="两阶段承诺(2PC) 方案"></a>两阶段承诺(2PC) 方案</h3><p>大多数跨片交易处理方案基于2PC进行设计，包括准备阶段和承诺阶段</p><p>存在一个协调者负责收集输入的可用性证明并在相关分片内进行发送</p><ul><li>在准备阶段，协调者收集证据来证明交易的输入的可用性，证据一般是片内节点运行BFT共识输出的，一般是多个签名或单个聚合签名的形式，同时该输入应该被锁定</li><li>承诺阶段，协调者将所有输入的可用证明发送给所有相关的分片，包括输入分片和输出分片，如果所有输入有效，交易就被认为是有效的，在相关分片内进行了承诺，输入会被花费，输出将会被创建</li></ul><p>根据协调者的角色，可以将2PC方案分为客户端驱动的2PC和分片驱动的2PC</p><ul><li>客户端驱动的2PC：客户端负责在准备阶段收集证明并在承诺阶段发送给相关分片<ul><li><img src="/2023/08/06/sharding-blockchain-survey/image-20230812170637555.png" alt="image-20230812170637555"></li><li>Omniledger采用了客户端驱动的2PC方案，每个分片内由leader签名是否accept</li></ul></li><li>分片驱动的2PC：1个或2个分片承担协调者的作用。准备阶段输入分配生成输入的可用性证明，承诺阶段一个有效的交易会在所有输入和输出分片中被接受。和客户端驱动的2PC相比，客户端的压力被减轻了，只需要提交交易等待回复<ul><li><img src="/2023/08/06/sharding-blockchain-survey/image-20230812171601751.png" alt="image-20230812171601751"></li><li>图a中所有的输入分片都是协调者，图b中一个输入分片负责进行协调，两类的通信复杂度相同</li><li>Chainspace RSTB Fleetchain采用了分片驱动的跨片交易处理机制</li></ul></li></ul><h3 id="交易拆分方案"><a href="#交易拆分方案" class="headerlink" title="交易拆分方案"></a>交易拆分方案</h3><p>RapidChain提出的，将多输入多输出的跨片交易拆分为多个单输入单输出的交易</p><p>如图所示，由输出分片的委员会对交易进行拆分，如果两个输入委员会分别对$tx_1,tx_2$通过，则输出委员会会正确执行$tx_3$</p><p><img src="/2023/08/06/sharding-blockchain-survey/image-20230812172946353.png" alt="image-20230812172946353"></p><p>Instachain采用了交易拆分方案，如果一个交易输入有效，另一个交易输入无效，则有效输入对应的子交易会直接发送给输出分片（？</p><h3 id="交易中继方案"><a href="#交易中继方案" class="headerlink" title="交易中继方案"></a>交易中继方案</h3><p>一般在最终分片区块链中使用，，每个委员会内不运行BFT，交易或可用性证明不会立即确认，无法采用2PC方法。</p><p>核心思想：保证在每个输入分片内输入相关的交易未得到足够确认前，输出分片不会把交易作为有效交易</p><p>基本步骤</p><ul><li>输入分片的矿工收集跨片交易$tx$，验证账户的余额是否大于交易额，如果满足则认为合法</li><li>矿工发现PoW的解后，构造包含$tx$的区块，其他矿工验证区块，生成对应的中继交易$\psi$，发送给输出分片的矿工</li><li>输出分片的矿工收到中继交易后验证合法性，如果中继交易$\psi$已经达到了对应安全的深度$\lambda$，确定交易成功</li></ul><p>Monoxide采用了中继交易的形式</p><h2 id="问题和未来的研究方向-1"><a href="#问题和未来的研究方向-1" class="headerlink" title="问题和未来的研究方向"></a>问题和未来的研究方向</h2><p>给出3类方案对应的问题</p><h3 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h3><ul><li>客户端驱动的方案（使用不广泛）<ul><li>leader恶意：准备阶段leader可能给出错误的证明或无法回复，如果恶意的leader对不合法的输入进行保证，其他分片可能会通过</li><li>如果客户端在commit阶段未能发送对应的证明，可能导致交易被永远锁定<ul><li>客户端恶意或者离线</li></ul></li><li>客户端负担加重：客户端需要记录分片的状态和参与节点的IP地址，为了和leader通信</li></ul></li><li>分片驱动的<ul><li>运行多次BFT，设计流水线处理的片内共识处理机制</li><li>可能的攻击：<ul><li>重放攻击，利用之前交易的可用性证明伪造出新的交易的可用性证明，添加标识符即可防御；</li><li>交易泛洪攻击：敌手可能伪造大量由特定分片进行处理的交易，破坏活性；将交易分配给不同分片进行防御</li></ul></li><li>恶意的协调者：特定输入或输出分片的领导者作恶，延迟可用性证明得到处理等行为</li></ul></li></ul><h3 id="拆分交易"><a href="#拆分交易" class="headerlink" title="拆分交易"></a>拆分交易</h3><p>没有给出具体的实现细节，需要进一步研究</p><ul><li>产生$c_{out}$分片公钥的方法不明确，一般决定输入分片的方法是利用公钥的哈希值来确定输入分片，然而在交易拆分阶段，需要生成多个公钥地址，具体的方式没有给出</li><li>新生成的输出可能被非法地花费：其中一个有效一个无效；或者输出分片的leader知道新交易的私钥</li><li>处理多输出交易的方法没有给出，比较复杂</li><li>交易数量增加，增加计算和存储开销</li></ul><h3 id="中继交易"><a href="#中继交易" class="headerlink" title="中继交易"></a>中继交易</h3><ul><li>交易确认延迟比较长：每个输出分片先确认，输出分片再确认</li><li>处理多输入消息比较困难：基于账户模型比较少，UTXO比较多，open problem</li><li>一旦出现分叉，链的安全性受到影响</li></ul><h1 id="Shard-reconfiguration"><a href="#Shard-reconfiguration" class="headerlink" title="Shard reconfiguration"></a>Shard reconfiguration</h1><h2 id="Basic-concepts-1"><a href="#Basic-concepts-1" class="headerlink" title="Basic concepts"></a>Basic concepts</h2><p>为什么需要重配置：敌手可能发动腐化攻击控制节点，影响共识安全性</p><p>关键问题：</p><ul><li>确保每个人分片内的诚实节点数量超过门限</li><li>重配置阶段系统能够正常处理交易</li><li>腐化攻击不会成功</li></ul><p>基本步骤：</p><ul><li>在轮$e$，轮$e+1$的节点已经经过节点选择机制确认了</li><li>轮$e$末尾，节点替换已经达成一致</li><li>分片的新成员和旧成员协商，获得对应的账户、交易数据</li><li>旧成员不再工作，新节点开始处理交易，进入轮$e+1$</li></ul><p>目前的重配置仅部分委员会节点会被替换，原因是时间成本太高（历史交易数据</p><h2 id="Existing-approaches-1"><a href="#Existing-approaches-1" class="headerlink" title="Existing approaches"></a>Existing approaches</h2><ul><li><p>随机分配：每个旧节点被替换的概率相同，利用$PRG(H(c||\xi_e))$决定置换</p></li><li><p>特定规则</p><ul><li>时间顺序：类似于滑动窗口，取代时间最长的节点</li><li>有界布谷鸟：根据节点每轮处理的交易数量进行排序<ul><li><img src="/2023/08/06/sharding-blockchain-survey/image-20230812185632818.png" alt="image-20230812185632818"></li></ul></li></ul></li></ul><h2 id="Problems-and-future-directions-2"><a href="#Problems-and-future-directions-2" class="headerlink" title="Problems and future directions"></a>Problems and future directions</h2><ul><li>对腐化参数的定量分析：$\tau$ 表示敌手完成腐化需要的时间，PoW需要满足$\tau &gt;2T_e$,目前的文献缺少对这个参数的分析</li><li><p>新加入节点的自举：下载历史数据的过程，潜在的问题</p><ul><li>敌手可能提供假数据，如何验证正确性</li><li>性能：需要时间很长</li></ul></li><li><p>对新委员的安全性分析：对于随机替换方案，现有的分析假设了替换所有委员会节点；时间序列替换存在 敌手可能针对性攻击新加入节点的问题，导致安全性降低；对于有界布谷鸟规则，没有给出如何踢出I中的节点，实际上每个分片内节点处理的交易数量差不多</p></li><li>初始化阶段：如何安全的初始化创世区块，目前假设是可信第三方，可以考虑MPC</li></ul><h1 id="Motivaition-mechanism"><a href="#Motivaition-mechanism" class="headerlink" title="Motivaition mechanism"></a>Motivaition mechanism</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p>需要激励机制的原因</p><ul><li>节点越多，链越安全</li><li>节点消耗了计算资源和带宽，需要补偿或激励</li></ul><p>难点是奖励公平，作恶受到惩罚</p><p>一般假设节点是理性的，为了获得最大化的收益</p><p>包括incentive和penalty，研究很少</p><h2 id="现有方案-2"><a href="#现有方案-2" class="headerlink" title="现有方案"></a>现有方案</h2><ul><li>对出块者和leader的奖励：可能是一个节点获得奖励；也可能是运行BFT的委员会所有成员，再进行公平的分配<ul><li>Lever Manshaei等人的工作基于博弈论进行了分析 </li></ul></li><li>对负面行为的惩罚：需要先缴纳保证金<ul><li>捣乱sabotage：不投票、leader不出块、块内包含无效的交易</li><li>恶意行为：leader发两个冲突的提案，委员会成员投多次</li></ul></li><li>基于声誉的奖励：idea来自P2P系统，基于历史的行为打分，包括响应时间、处理的交易、节点相关的恶意行为数量，声誉越高的节点获得的奖励越多</li></ul><h2 id="问题和未来研究方向"><a href="#问题和未来研究方向" class="headerlink" title="问题和未来研究方向"></a>问题和未来研究方向</h2><ul><li>结合分片区块链：<ul><li>片内共识算法决定了需要更公平的奖励，所有人都想当leader，可能发起恶意的视图转换协议，敌手可能发起攻击，导致当前leader渎职然后换主，Hotstuff这种固定换主的共识协议更容易进行激励机制的设计</li><li>跨片交易处理的协调者如何奖励</li></ul></li><li>详细的分析，目前没有过对分片区块链激励机制的理论研究，需要经济学的基础</li></ul><h1 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h1><ul><li><p>分片共识综述</p><ul><li>[AFT19] 73分类比较抽象，组件分析不够明确 </li><li>[IEEE Access]216对每个方案进行了介绍，没有宏观的分类和分析</li><li>[arxiv19]116提供了更形式化的分析以及评价指标</li><li>[FC21] 72分析了跨片通信</li><li>[AFT22] 217主要分析了分片区块链的节点分配协议</li></ul></li><li><p>区块链共识</p></li><li>可扩展性</li></ul><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>本文将分片区块链解构为若干组件，分析了每个组件的基本概念，现有的解决方案和存在的问题以及未来的研究方向。简化了分片区块链的设计，每个组件可以单独改善，给出的未来研究方向具有一定意义</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Building-blocks-of-sharding-blockchain-systems-Concepts-approaches-and-open-problems&quot;&gt;&lt;a href=&quot;#Building-blocks-of-sharding-blockchain-systems-Concepts-approaches-and-open-problems&quot; class=&quot;headerlink&quot; title=&quot;Building blocks of sharding blockchain systems: Concepts, approaches,and open problems&quot;&gt;&lt;/a&gt;Building blocks of sharding blockchain systems: Concepts, approaches,and open problems&lt;/h1&gt;&lt;p&gt;继&lt;a href=&quot;https://alleysira.github.io/2023/05/31/Sharding-Blockchain-Consensus-lyj/&quot;&gt;Sharding_Blockchain_Consensus&lt;/a&gt; 之后阅读刘老师的综述文章&lt;/p&gt;
&lt;p&gt;分片技术是打破区块链去中心化、安全性和可扩展性不可能三角的最流行的方式，分片技术可以广义的理解为将区块链中的节点动态划分为彼此之间没有细粒度同步并且执行存储、计算和通信任务的子集，子集称为分片&lt;/p&gt;
&lt;p&gt;现有的分片区块链设计仍有很多可探索的空间，本文从此出发，对现有的分片区块链进行了系统的分析，并将它们的架构概念分解为功能组件，并推导出它们所基于的系统模型和攻击者的假设。推导出的功能组件包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;节点选择、轮随机数、节点分配、片内共识、跨片交易处理、分片重配置、激励机制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于每个功能组件，本文描述了接口、功能和性质，给出了组件如何组合成一个分片区块链系统并讨论了每个组件的后续研究方向；同样关注了潜在的安全攻击和性能问题，例如系统吞吐量和延迟&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/categories/Blockchain/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="Sharding" scheme="https://alleysira.github.io/tags/Sharding/"/>
    
  </entry>
  
  <entry>
    <title>IST23</title>
    <link href="https://alleysira.github.io/2023/07/26/IST23/"/>
    <id>https://alleysira.github.io/2023/07/26/IST23/</id>
    <published>2023-07-26T10:10:47.000Z</published>
    <updated>2023-07-26T10:36:52.805Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Chu H, Zhang P, Dong H, et al. A survey on smart contract vulnerabilities: Data sources, detection and repair[J]. Information and Software Technology, 2023: 107221.</p><p>发表于IST23 CCFB，介绍智能合约发展的综述文章</p><span id="more"></span><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>智能合约满足不可篡改性和无第三方的性质，现有研究聚焦于特定领域，如开发周期、攻击方法、安全监测工具等，本文从vulnerability data sources, vulnerability detection, and vulnerability defense三个方面进行研究。首先分析智能合约现有的安全问题和挑战，调查现有的漏洞分类框架和常见的安全漏洞，分析现有安全工具的性能，总结了智能合约安全相关研究</p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>主要研究合约层的安全，考虑以下几个问题</p><ul><li>矿工恶意，操纵交易顺序</li><li>合约相互调用可能存在风险</li><li>链上合约是由开发者写的，可能存在漏洞</li><li>合约独有的机制（如gas）可能会存在特定的安全问题</li></ul><p>发现合约的漏洞后，只能通过自毁进行止损，无法通过发布补丁或更新版本的方式进行修复</p><p>2016年以来主要的区块链攻击如表1所示</p><p><img src="/2023/07/26/IST23/image-20230726183149593.png" alt="image-20230726183149593"></p><p>作者调查了2015-2022年关于智能合约安全的文章，选出了49篇具有代表意义的</p><p>本文贡献：</p><ul><li>对智能合约安全时间和挑战全面的分析。</li><li>对智能合约安全监测和防御方法系统的回顾。包括现有的漏洞检测工具、性能测试工具和漏洞修复方法，对保证安全性的方法进行了总结</li><li>阐述了现有研究的不足和未来的研究方向。针对各种安全挑战，分析了现有智能合约安全方法的优缺点。特别是，本文广泛研究了可用的评估数据集，现有的漏洞修复方法和基于人工智能的漏洞检测方法。指出了解决这些不足的未来研究方向。</li></ul><h1 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;Chu H, Zhang P, Dong H, et al. A survey on smart contract vulnerabilities: Data sources, detection and repair[J]. Information and Software Technology, 2023: 107221.&lt;/p&gt;
&lt;p&gt;发表于IST23 CCFB，介绍智能合约发展的综述文章&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/categories/Blockchain/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="SmartContract" scheme="https://alleysira.github.io/tags/SmartContract/"/>
    
  </entry>
  
  <entry>
    <title>ConFuzzius</title>
    <link href="https://alleysira.github.io/2023/07/23/ConFuzzius/"/>
    <id>https://alleysira.github.io/2023/07/23/ConFuzzius/</id>
    <published>2023-07-23T03:09:40.000Z</published>
    <updated>2023-10-10T13:01:59.383Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="ConFuzzius-A-Data-Dependency-Aware-Hybrid-Fuzzer-for-Smart-Contracts"><a href="#ConFuzzius-A-Data-Dependency-Aware-Hybrid-Fuzzer-for-Smart-Contracts" class="headerlink" title="ConFuzzius: A Data Dependency-Aware Hybrid Fuzzer for Smart Contracts"></a>ConFuzzius: A Data Dependency-Aware Hybrid Fuzzer for Smart Contracts</h1><p>这篇工作发表于<code>EuroS&amp;P21</code></p><p>Torres C F, Iannillo A K, Gervais A, et al. Confuzzius: A data dependency-aware hybrid fuzzer for smart contracts[C]//2021 IEEE European Symposium on Security and Privacy (EuroS&amp;P). IEEE, 2021: 103-119.</p><span id="more"></span><ul><li><p>符号执行的方法存在过拟合，导致假阳率</p></li><li><p>现有的模糊测试方法分析浅层的漏洞比较有效，对于执行时的深层的漏洞分析不够有效，导致较低的代码覆盖率/假阳</p></li><li>传统程序测试中已经证明结合符号执行和模糊测试的可行性</li></ul><p>ConFuzzius是第一个针对智能合约的混合模糊测试器，采用进化的模糊测试方法执行合约的浅层部分，约束求解来生成符合复杂条件的输入，防止进化模糊测试方法探索深层部分。</p><p>ConFuzzius充分利用动态的数据依赖分析来生成更可能导致出现漏洞的交易序列</p><p>实验数据采用精选的128个合约和包含21000真实世界的合约，结果显示比当前最好的工具多检测出了23%的漏洞，代码覆盖率达到了69%，动态数据依赖分析可以加速漏洞检测18%</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>如果允许一个参与者修改智能合约，合约的信任将不复存在</p><p>智能合约系统中不允许中立的第三方，不能被废止，不可篡改性的代价是智能合约在部署前必须经过大量的测试</p><p>验证智能合约行为的四种方法：</p><ul><li>单元测试：需要人力来覆盖代码的全部部分，仅能去除测试用例中的一小部分bug</li><li>符号执行：抽象分析程序的行为；对于复杂的合约检测速度慢（路径爆炸）</li><li>静态分析：不执行代码，过度近似合约的行为，能够获得整个合约的执行情况；但是存在假阳率，需要手工检查</li><li>模糊测试：通过自动生成测试用例来快速推理合约，比静态分析假阳率低；代码覆盖率低</li></ul><p>模糊测试的挑战：</p><ul><li>输入生成：输入空间可能很大</li><li>状态探索：智能合约是基于状态的应用，执行可能依赖于特定输入序列下可达的状态</li><li>环境依赖：智能合约的运行时环境暴露了和底层区块链相关的额外的输入（时间戳、其他部署的合约），导致合约的执行流程可能依赖于环境信息和交易信息</li></ul><p>作者解决三个挑战的思路是采用符号污点分析来生成五点输入的路径约束。观察到模糊器不处理时，启动约束求解器解决当前的约束问题，将这个解决方案收集在一个变异池中，模糊器可以从中获取来跨越具有挑战性的合约条件。</p><p>现有的混合工具（如Driller）在卡住时停止fuzzer并且切换到conbolic(concrete symbolic)方法来越过复杂条件，之后重启fuzzer，本文的解决方法保持模糊器运行并且只使用约束求解来生成模糊器最终会通过变异池选择的即时数据。</p><p>除了约束求解之外，本文进行路径终止分析来清除变异池中的不相关输入。</p><p>挑战2：为了处理合约的状态性，采用遗传算法的选择和交叉算子。遗传算法包括三个操作：</p><ul><li><p>选择：从中种群选择2个个体</p></li><li><p>交叉：交叉算法将2个个体结合生成2个新的个体，挑战在于如何生成有意义的输入。因此，个体之间的数据依赖性指导我们的选择和交叉算子，只有当它们遵循一个写后读（RAW）数据依赖关系时才接受两个个体。</p></li><li><p>变异</p></li></ul><p>挑战3：为了解决环境依赖的困难问题，对执行环境（即以太坊虚拟机）进行工具化，以模糊环境信息，并将合约的输入建模为一个元组，包含交易和环境数据。</p><p>贡献</p><ul><li>第一个智能合约hybrid模糊器的设计</li><li>利用状态变量间动态数据依赖，在运行时高效的生成输入序列</li><li>ConFuzzius，第一个hybrid模糊器的实现</li><li>对128个经过筛选的智能合约和21K个真实世界的智能合约进行了CONFUZZIUS的评估，并证明了方法不仅可以检测到更多的漏洞（高达23％），而且可以实现比现有符号执行工具和模糊器更高的代码覆盖率（高达69％）</li></ul><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><h3 id="Ethereum-Smart-Contracts"><a href="#Ethereum-Smart-Contracts" class="headerlink" title="Ethereum Smart Contracts"></a>Ethereum Smart Contracts</h3><p>简单介绍智能合约和EVM</p><h3 id="fuzzing"><a href="#fuzzing" class="headerlink" title="fuzzing"></a>fuzzing</h3><p>模糊测试（Fuzzing）或模糊测试是一种自动化的软件测试技术，通过将畸形或意外的数据作为程序的输入，执行程序并监控其效果，来查找程序中的漏洞。</p><h4 id="进化模糊"><a href="#进化模糊" class="headerlink" title="进化模糊"></a>进化模糊</h4><p>指采用遗传算法收敛，测试用例的一代被定义为一个种群，而单个测试用例是一个个体。简而言之，每个一代的个体都根据适应度函数进行评估。在每一代结束时，只有最适应的个体被允许繁殖，遵循达尔文的自然选择或“适者生存”的思想。最终，个体将在收敛于最优解的过程中触发漏洞。</p><p><img src="/2023/07/23/ConFuzzius/image-20230723170403119.png" alt="image-20230723170403119"></p><p>初始种群可以随机选或者启发式采样</p><p>终止条件可以是到达指定时间或者超过最大的代数</p><h4 id="混合模糊"><a href="#混合模糊" class="headerlink" title="混合模糊"></a>混合模糊</h4><p>模糊测试在解决复杂条件时比较困难，导致代码覆盖率低</p><p>流行的解决办法是采用符号执行，理论上可以探索所有路径，但实际上由于程序复杂时路径指数级增长，导致不具备可扩展性；另一个缺陷是和执行环境的交互太少。</p><p>混合测试的想法是各取所长，在模糊器不能继续覆盖代码时，自动切换为符号执行，为没有覆盖的分支条件进行穷举搜索，当符号执行发现了未覆盖的分支条件后，求解并回退为模糊器</p><p>模糊测试和符号执行的交错保证了对程序浅的路径快速的执行和对复杂路径的覆盖</p><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>一般满足ERC-20. 用户想要以每天加1ether的价格出售代币，第一天代币的售价为42</p><p><img src="/2023/07/23/ConFuzzius/image-20230725093137613.png" alt="image-20230725093137613"></p><p>存在三个漏洞：</p><ul><li><p>访问权限：构造函数typo，compiler默认该函数为<code>public</code></p></li><li><p>时间戳依赖：<code>now</code></p></li><li>ether泄露：只有转出的代码，没有转入合约的代码</li></ul><p><img src="/2023/07/23/ConFuzzius/image-20230725094046555.png" alt="image-20230725094046555"></p><h3 id="输入生成"><a href="#输入生成" class="headerlink" title="输入生成"></a>输入生成</h3><p>输入数据生成可以是完全随机的（黑盒）或由运行时信息驱动的（灰盒），原始的方法是从之前的输入进行变异生成新的输入，然而现实世界中有比较复杂的条件，如figure1 line21，对应的CFG如下</p><p><img src="/2023/07/23/ConFuzzius/image-20230725095443342.png" alt="image-20230725095443342"></p><p>传统的随机策略将不能通过该条件（因为$2^{256}$次尝试才能产生一个合理的解harvey依赖于计算为每个分支编译输入的的开销矩阵，本文采用约束求解来按需生成复杂条件的值。本文的fuzzer不直接传播该值而是存储在变异池中，fuzzer可以从池中选择（每个函数声明都对应一个变异池）</p><p>开始时变异池为空，fuzzer用随机数据输入目标函数，一旦无法发现新的路径时，激活约束求解器生成新的值，采用符号五点分析来生成约束求解器需要的表达，污点采用符号值的形式</p><h3 id="状态探索"><a href="#状态探索" class="headerlink" title="状态探索"></a>状态探索</h3><p>合约的状态不同时，以太坊的同一条交易可能出现不同的结果</p><p>例子中先调用<code>bug</code>和<code>Tokensale</code>函数再调用<code>withdraw</code>函数，攻击者能够实现恶意提款，然而在实际的分析中自动发现函数调用特定顺序可能触发漏洞是具有挑战性的工作。</p><p>a transaction influences the output of a subsequent set of transactions if and only if it modifies a storage variable that one of the subsequent transactions will use.</p><p>观察：交易影响合约的storge变量并且该变量被后续的合约使用，即写后读的数据依赖</p><p>ConFuzzius追踪所有交易读和写的storge，然后进行将所有交易组合成写后读的形式</p><p><img src="/2023/07/23/ConFuzzius/image-20230725102212941.png" alt="image-20230725102212941"></p><h3 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h3><p>EVM在执行区块内的交易时会分析其中包含的区块信息</p><p>本文将区块信息建模为可fuzz的输入来解决这个问题，和交易数据一样进行模糊测试的流程</p><p>修改EVM实现能够在合执行时插入模糊的区块信息</p><p>还需要模拟对其他合约的调用：通过对合约调用进行实现，并将返回值建模为可模糊的输入来类似地解决这个挑战，修改的EVM在运行时注入模糊的返回值。</p><h2 id="Design-and-Implementation"><a href="#Design-and-Implementation" class="headerlink" title="Design and Implementation"></a>Design and Implementation</h2><h3 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h3><p><img src="/2023/07/23/ConFuzzius/image-20230725104943384.png" alt="image-20230725104943384"></p><ul><li>进化模糊器</li><li>EVM</li><li>执行路径分析器</li></ul><p>python 6000行</p><p>输入合约的源代码和区块链的状态（后者可选），将合约编译后获得ABI和EVM字节码，进化模糊器基于ABI生成输入，基于标准的遗传算法进行变异，将新生成的个体发送给EVM执行，EVM将执行路径发送给分析器，分析器执行若干分析（符号污点分析，数据依赖分析）</p><p>终止条件：已经生成多少代或过去了多少时间</p><h3 id="进化模糊器"><a href="#进化模糊器" class="headerlink" title="进化模糊器"></a>进化模糊器</h3><ul><li>对个体编码：<ul><li>不好的编码可能影响效率，本方案的编码如图所示，将个体表示为输入的序列，每个输入包含一个环境信息和一个交易的k-v对<ul><li>环境信息包括区块信息和调用返回值、数据大小、节点规模等</li><li>交易包含发送方的地址、交易金额、gas上限，data<ul><li>data前4个字节是函数选择器，后面是参数</li></ul></li></ul></li><li><img src="/2023/07/23/ConFuzzius/image-20230725111651222.png" alt="image-20230725111651222"></li></ul></li><li>种群初始化：最开始为N个个体，每个仅有交易，交易内的函数选择器是循环选取的，函数声明是基于ABI获取的，针对不同参数类型为每个函数生成参数，过去的k代不再影响代码覆盖率时重新选，这种软重启的方法将多样性重新引入种群并在种群变得同质化时延迟过早的收敛。<ul><li>固定长度：随机选或者从触发有效输入域的情况的一组输入中获取</li></ul></li><li>适度评估：评估个体的适度非常关键，由于需要多次计算效率，需要非常高（指数级影响），<em>虽然获得完整的代码覆盖并不一定意味着所有的漏洞都会被发现，但未被探索的代码里的漏洞不可能被发现</em>。适度函数定义基于分支覆盖和数据依赖，对个体$i$的适度函数定义如下：<ul><li>$fit(i)=fit_{branch}(i)+fit_{RAW}(i)$</li><li>$fit_{branch}(i)$：计算该个体仍未探索过的分支，迭代该个体的执行路径然后分析所有条件分支jump指令，通过从堆栈中提取真分支的跳转目标来获取其跳转目标，并通过将程序计数器增加一来获取假分支的跳转目标。对于目的地址不在执行分支上的情况，将$fit_{branch}(i)$加1，优先选出探索更多分支的个体；</li><li>同样能够生成有用交易序列的个体也很重要。$fit_{RAW}(i)$利用执行路径分析器给出的交易依赖考虑该因素，初始时为0，当出现raw后+1</li></ul></li><li>选择：为交叉阶段选择两个个体，本文选择的是参考文献[41]中提出的Linar ranking selection，将种群考虑为一个整体，而不是子集；<ul><li>Linar ranking selection：适度高的个体排在前面，被选择的概率和个体适度在种群中的排名成比例；可以给更适应的个体更多的权重，同时仍然允许一些机会选择适应度较低的个体，并潜在地为种群的多样性做出贡献。</li><li>传统的线性排名选择没有考虑数据依赖，两个个体一个采用线性排名方法选择，第二个个体是基于与第一个个体具有RAW依赖性的迭代方式进行选择的</li></ul></li><li><p>交叉：交叉算子通过对输入两个现有个体进行重新组合生成两个新的个体。</p><ul><li>本文不是随机组合两个个体，而是只有在第一个个体对存储位置进行写操作时，第二个个体才进行读操作（即RAW依赖性），才会将它们组合起来。</li><li>两种排列方式，个体 $ab/ba$</li><li>和传统的方法相比，本方案在合并两个个体而不是拆分开交换输入序列</li><li>如果两个个体间不存在依赖性，返回未加修饰的1/2个个体</li><li>存在RAW关系不意味着一定能交叉，存在交叉概率$p_c$</li><li>防止个体变得太长，交叉前检查长度的和小于$l$<ul><li>$l$ 越小处理时间越短，发现漏洞的时间越短——效率</li><li>反之，发现的漏洞可能更多——完备性</li></ul></li></ul></li><li><p>变异：变异算子随机编辑个体的某些部分来产生一个新的个体，为种群带来多样性</p><ul><li>遍历输入序列，基于概率$p_m$变异每个交易和环境信息的值</li><li>变异可以有两种形式<ul><li>采用随机的值取代原来的值</li><li>采用变异池中的值替代：类似于短期内存，允许模糊器重用之前观察到或学习到的值<ul><li>总共有9个不同的变异池：senders, amounts, gaslimits, function arguments, timestamps, block numbers, call results, call data sizes, and external code sizes</li><li>每个池是循环数组，大小能存10个值</li></ul></li></ul></li></ul></li></ul><h3 id="EVM"><a href="#EVM" class="headerlink" title="EVM"></a>EVM</h3><p>EVM负责在测试的合约的运行时字节码上执行个体生成的交易。性能对模糊器整体的性能表现影响很大，需要有很高的交易处理速度</p><p>现有的智能合约客户端需要对交易进行RLP编码来序列化交易数据，作者发现实际的EVM执行时间和编解码相比可以忽略不计，因此本工具采用了开源的<a href="https://github.com/ethereum/py-evm">EVM python</a>实现，集成到了模糊器中。该实现去除了挖矿的负担和编解码交易的时间，极大地增加了执行效率（合理吗？）</p><p>修改了EVM的设计</p><ul><li>使得能够得到交易的执行路径，包括指令名、计数器、执行栈、调用深度、执行期间是否出现内部错误</li><li>简化设计，采用简单的存储模拟器记录执行时的状态变化，均保留在内存中<ul><li>方便进行EVM状态的快照和恢复</li><li>允许插入定制的环境信息或修改函数调用结果</li></ul></li></ul><h3 id="执行分析器"><a href="#执行分析器" class="headerlink" title="执行分析器"></a>执行分析器</h3><p>从EVM收到执行路径后，执行</p><ul><li>代码覆盖率评估：计算执行路径中程序计数器的值</li><li>数据依赖分析：在模糊器执行过程中记录所有状态变量以及状态变量的读写情况，和现有静态分析的方案相比，本方案动态的获得运行时的状态变量的情况<ul><li>静态分析快 需要源代码；对于复杂的数组需要源代码</li><li>动态运行时分析可以追踪复杂的变量，缺点是额外的运行时间和实现开销，下图是以太坊对不同类型的状态变量计算方式</li><li><img src="/2023/07/23/ConFuzzius/image-20230725162130918.png" alt="image-20230725162130918"></li></ul></li><li>符号污点分析：产生符号约束，污点的形式是符号值的形式，跟踪污点的流动<ul><li>仅对能进行fuzz的指令进行动态污点分析</li><li>跨存储的污点的传播使得能够实现跨交易的污点分析</li><li>污点传播的逻辑遵循过度污点策略，如果指令的输入中至少有一个被污染，那么该指令的输出将被标记为污染</li></ul></li><li>约束求解：模糊测试无法通过复杂的条件语句时，进化模糊器可能会过早收敛，约束求解器用于生成一个有效的输入来越过复杂的条件<ul><li>作者自己实现的轻量级符号执行器仅执行算数相关的指令，比较逻辑和比特级运算符</li><li>否定最后一个约束条件，将逻辑公式中其余的符号变量替换为已用作触发执行跟踪的具体值，并使用Z3 SMT求解器生成输入以到达开放分支</li><li>实例化减小了公式的复杂度</li><li>将生成的输入加入到变异池中</li></ul></li><li>终止分析：执行路径可能包含输入有效性的反馈，模糊器获得并得知一个输入是否有效、终止分析检查执行路径中表示执行正确和错误的操作码。检查到错误后分析最后一个路径约束，获得导致终止的输入并从池中移除</li><li>漏洞检测：综合以上输出进行漏洞检测，为下述漏洞类型设计了检测器：<ul><li>断言错误</li><li>整数溢出</li><li>重入</li><li>交易顺序依赖</li><li>区块依赖</li><li>未处理异常</li><li>不安全的delegate调用</li><li>ether泄露</li><li>未受保护的自毁</li></ul></li></ul><p>很难不赞同（</p><p><img src="/2023/07/23/ConFuzzius/image-20230725165033079.png" alt="image-20230725165033079"></p><h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><p>回答3个关键问题</p><ul><li>相比于当前的符号执行或者fuzzing的工具，confuzzius是否实现了更高的代码覆盖率？</li><li>相比于当前的符号执行或者fuzzing的工具，confuzzius是否发现更多的漏洞？</li><li>ConFuzzius的不同组件在代码覆盖率和漏洞检测方面的相关性有多强？</li></ul><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><ul><li>测试代码覆盖率 有源码 21147份合约，根据EVM字节码指令个数分为2类（采用标准的k-means分类算法，Elbow and the Silhouette方法确定分类器数量<ul><li>小于3632，17803份合约</li><li><img src="/2023/07/23/ConFuzzius/image-20230725171840387.png" alt="image-20230725171840387"></li><li>3344份合约</li></ul></li><li>测试漏洞检测：128份合约（包含148注释出的漏洞），基于smartbugs，缺失了部分漏洞类型，作者从Smart Contract Weakness Classification进行了扩展</li></ul><h3 id="baseline"><a href="#baseline" class="headerlink" title="baseline"></a>baseline</h3><p><img src="/2023/07/23/ConFuzzius/image-20230725172412638.png" alt="image-20230725172412638"></p><p>因为本工具是模糊测试和符号执行结合的，对比方案分别是符号执行和模糊测试两类</p><p>Smartbugs的结论是Mythril的效果比SmartCheck Securify和Maian更好</p><p>M-PRO采用了类似的交易序列结合策略</p><p>ILF是当前较好的fuzzing工具（比contractfuzzer和ECHIDNA好）</p><p>sFuzz基于AFL，没有和之前工作的对比</p><h3 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h3><p>每个实验进行10次，每次的种子独立</p><ul><li>第一个数据集 10 mins；1 hours<ul><li>初步测试显示，大多数工具在这些时间之后并没有产生更多的覆盖率</li></ul></li><li>第二个数据集每个合约10分钟</li></ul><p>cluster 10个节点，每个128GB，CentOS release 7.6.1810，2个Intel® Gold 6132 CPUs with 14 cores, each clocked at 2.60 GHz.</p><p>代码覆盖率10代不变即种群重新初始化，个体最长长度为5</p><p>Z3 version 4.8.5，时间上限100ms</p><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><ul><li><p>代码覆盖率：ConFuzzius在第一个数据集上大小合约结果均表现最优（91% 81%）</p><ul><li>大小合约差距最小（10%），Mythirl（31%）</li><li><img src="/2023/07/23/ConFuzzius/image-20230725174913977.png" alt="image-20230725174913977"></li><li>更短时间内实现更高的覆盖率，1 second 66% instruction coverage, whereas ILF and<br>SFUZZ achieve solely 12% and 15%, respectively</li><li><img src="/2023/07/23/ConFuzzius/image-20230725175443751.png" alt="image-20230725175443751"></li></ul></li><li><p>漏洞检测：10类漏洞，第二个数据集（真/假）</p><ul><li><img src="/2023/07/23/ConFuzzius/image-20230725175644457.png" alt="image-20230725175644457"></li><li>测出了106/148个漏洞，约71%</li></ul></li><li>组件评估：分别评估约束求解、写后读数据依赖分析和环境实例化三部分组件的重要性，随机选了100个合约<ul><li><img src="/2023/07/23/ConFuzzius/image-20230725180309420.png" alt="image-20230725180309420"></li><li>意义最大的组件可能是Constraint Solving</li></ul></li></ul><h2 id="Realted-work"><a href="#Realted-work" class="headerlink" title="Realted work"></a>Realted work</h2><ul><li>软件模糊测试：AFL是当前最广泛使用的模糊测试器，基于遗传算法；KLEE和SAGE是白盒模糊器，在受限环境中执行代码。Driller同样是混合模糊器，混合了选择性concolic方法</li><li>智能合约模糊测试：<ul><li>ContractFuzzer基于输入种子产生输出，部署了整个定制的测试网来模糊测试交易，Confuzzius仅模拟EVM，更加高效且不依赖用户提供的输入种子</li><li>Echidna是基于性质的智能合约测试工具，利用了基于语法的模糊测试，依赖于用户定义的谓词（solidity的断言），无法自动化检查漏洞</li><li>Harvey基于指令细粒度成本度量指标预测新的输入</li><li>ILF基于 模仿学习（imitation learning），在模糊测试前需要学习阶段，依赖一个神经网络</li><li>sFuzz基于AFL，基于随机策略生成交易序列</li><li>EHTPLOIT是基于模糊测试的智能合约漏洞生成器</li></ul></li><li>智能合约符号执行：<ul><li>MPRO：结合了符号执行和数据依赖分析</li><li>ETHracer采用相反的混合方式，先符号执行再fuzz，完全随机</li></ul></li><li>智能合约静态分析：<ul><li>ZEUS：自动化验证的框架</li><li>Securify：静态分析出语义信息，检查violation和compliance</li><li>VANDAL，类似的工具</li></ul></li></ul><h2 id="攻击检测器设计思路"><a href="#攻击检测器设计思路" class="headerlink" title="攻击检测器设计思路"></a>攻击检测器设计思路</h2><ul><li>Assertion Failure：检查执行路径是否包括ASSERTFAIL or INVALID</li><li>Integer Overflow：由于不是所有的溢出都有害而且编译器可能为了优化引入整数溢出<ul><li>当溢出编辑了合约的状态才认为是有害的，计算的记过写入存储或被用来发钱</li><li>分析执行路径是否包含ADD, MUL or SUB指令</li><li>从栈中提取计算符然后执行算术操作，和栈中的结果比较</li><li>如果不同，将计算结果标记为污点，如果被标记的结果进入<code>SSTORE</code> <code>CALL</code>指令</li></ul></li><li>重入漏洞：检查<code>call</code>的gas是否大于2300，转账金额大于0；如果<code>call</code>之前出现<code>SLOAD</code>,<code>call</code>之后<code>SSTORE</code>，<code>CALL</code>的存储地址和<code>SLOAD</code>一样</li><li>交易顺序依赖：检查是否两条执行路径发送者不同，前一条路径写某一存储位置，后一个读</li><li>区块依赖：检查<code>CREATE</code>, <code>CALL</code>,<code>DELEGATECALL</code>, or <code>SELFDESTRUCT</code>是否包含或依赖<code>BLOCKHASH</code>, <code>COINBASE</code>, <code>TIMESTAMP</code>, <code>NUMBER</code>, <code>DIFFICULTY</code>, or <code>GASLIMIT</code></li><li>未处理异常：检查是否有<code>call</code>，并且压入1；再检查结果是否有对应的<code>JUMP I</code></li><li>不安全的<code>delagatecall</code>：检查DELEGATECALL是否以<code>STOP</code>终止，并且发送的地址是攻击者（fuzzer生成攻击者和善良参与者的地址）</li><li>Ether泄露：检查<code>call</code>指令，接收者是从未在之前交易内向合约发送过ether的攻击地址，并且从来没有被非攻击者地址当做参数发送过</li><li>Ether锁定：检查合约是否能接受但不能发送ether<ul><li>接受ether：检查是否有交易值大于0，以<code>stop</code>终止</li><li>发送ether：检查不包含任何<code>CREATE</code>, <code>CALL</code>, <code>DELEGATECALL</code>, or <code>SELFDESTRUCT</code> instruction</li></ul></li><li>Unprotected Selfdestruct：依赖于攻击者账户，检查执行路径包含<code>SELFDESTRUCT</code>，发起者是攻击者地址，并且之前没有被当参数传递过</li></ul><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>第一个混合的fuzzer/</p><p>解决了三个挑战：</p><ul><li>输入生成：进化模糊算法+约束求解</li><li>状态探索：对状态数据依赖分析，生成交易序列</li><li>环境依赖：建模区块相关的信息作为fuzz的输入</li></ul><p>实验在128 21K的数据集上分别测试了覆盖率、测出漏洞类型和工具组件重要性的结果</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>玩了个孔子的谐音梗<a href="https://github.com/christoftorres/ConFuzzius">christoftorres/ConFuzzius: A data dependency-aware hybrid fuzzer for Ethereum smart contracts (EuroS&amp;P 2021). (github.com)</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull christoftorres/confuzzius</span><br><span class="line">docker run -i -t christoftorres/confuzzius</span><br><span class="line">python3 fuzzer/main.py -s examples/TokenSale/contracts/TokenSale.sol -c TokenSale --solc v0.4.26 --evm byzantium -t 10</span><br></pre></td></tr></table></figure><p>被测试合约为TokenSale.sol，比较简单</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.26;</span><br><span class="line"></span><br><span class="line">interface Token &#123;</span><br><span class="line">  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);</span><br><span class="line">  function allowance(address owner, address spender) external view returns (uint256);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract TokenSale &#123;</span><br><span class="line">  uint256 start = now;</span><br><span class="line">  uint256 end = now + 30 days;</span><br><span class="line">  address wallet = 0xCafEBAbECAFEbAbEcaFEbabECAfebAbEcAFEBaBe;</span><br><span class="line">  Token token = Token(0x1234567812345678123456781234567812345678);</span><br><span class="line"></span><br><span class="line">  address owner;</span><br><span class="line">  bool sold;</span><br><span class="line"></span><br><span class="line">  function Tokensale() public &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function buy() public payable &#123;</span><br><span class="line">    require(now &lt; end);</span><br><span class="line">    require(msg.value == 42 ether + (now - start) / 60 / 60 / 24 * 1 ether);</span><br><span class="line">    require(token.transferFrom(this, msg.sender, token.allowance(wallet, this)));</span><br><span class="line">    sold = true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function withdraw() public &#123;</span><br><span class="line">    require(msg.sender == owner);</span><br><span class="line">    require(now &gt;= end);</span><br><span class="line">    require(sold);</span><br><span class="line">    owner.transfer(address(this).balance);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验结果显示代码覆盖率非常优秀，能够检测出区块信息依赖和以太币泄露漏洞</p><p><img src="/2023/07/23/ConFuzzius/image-20230726161506767.png" alt="image-20230726161506767"></p><p><img src="/2023/07/23/ConFuzzius/image-20230726161452774.png" alt="image-20230726161452774"></p><p>具体产生漏洞的交易序列：</p><p><img src="/2023/07/23/ConFuzzius/image-20230726161536978.png" alt="image-20230726161536978"></p><p><img src="/2023/07/23/ConFuzzius/image-20230726161548380.png" alt="image-20230726161548380"></p><p><img src="/2023/07/23/ConFuzzius/image-20230726161601382.png" alt="image-20230726161601382"></p><h3 id="测试较为复杂的合约WalletLibrary"><a href="#测试较为复杂的合约WalletLibrary" class="headerlink" title="测试较为复杂的合约WalletLibrary"></a>测试较为复杂的合约WalletLibrary</h3><p><img src="/2023/07/23/ConFuzzius/image-20230726161201164.png" alt="image-20230726161201164"></p><p><img src="/2023/07/23/ConFuzzius/image-20230726161215584.png" alt="image-20230726161215584"></p><p>代码覆盖率依然比较优秀，74.99%（2881/3842），单个合约仅10.62s</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>其他人对Confuzzius的复现总结 <a href="https://hackmd.io/@UKzRuqmuT7OSwI3Hjf0tPA/ryg6RkwLF">CONFUZZIUS Comparisons - HackMD</a></li><li><p>会议简要视频介绍<a href="https://www.youtube.com/watch?v=_NuOxLJNJhI&amp;ab_channel=IEEEEuropeanSymposiumonSecurityandPrivacy">IEEE EuroS&amp;P 2021 - ConFuzzius: A Data Dependency-Aware Hybrid Fuzzer for Smart Contracts - YouTube</a></p></li><li><p>后续可以阅读：</p><ul><li>现有工具对比测试：[ICSE20]Smartbugs1.0、2.0</li><li>模糊测试：[CCS19]ILF &gt;[ISSTA20]Echindna</li><li>符号执行：[HITB18]Mythril&gt;[ASE19]Manticore</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;ConFuzzius-A-Data-Dependency-Aware-Hybrid-Fuzzer-for-Smart-Contracts&quot;&gt;&lt;a href=&quot;#ConFuzzius-A-Data-Dependency-Aware-Hybrid-Fuzzer-for-Smart-Contracts&quot; class=&quot;headerlink&quot; title=&quot;ConFuzzius: A Data Dependency-Aware Hybrid Fuzzer for Smart Contracts&quot;&gt;&lt;/a&gt;ConFuzzius: A Data Dependency-Aware Hybrid Fuzzer for Smart Contracts&lt;/h1&gt;&lt;p&gt;这篇工作发表于&lt;code&gt;EuroS&amp;amp;P21&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Torres C F, Iannillo A K, Gervais A, et al. Confuzzius: A data dependency-aware hybrid fuzzer for smart contracts[C]//2021 IEEE European Symposium on Security and Privacy (EuroS&amp;amp;P). IEEE, 2021: 103-119.&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/categories/Blockchain/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="SmartContract" scheme="https://alleysira.github.io/tags/SmartContract/"/>
    
  </entry>
  
</feed>
