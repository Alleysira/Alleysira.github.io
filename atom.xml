<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Alleysira&#39;s blog</title>
  
  
  <link href="https://alleysira.github.io/atom.xml" rel="self"/>
  
  <link href="https://alleysira.github.io/"/>
  <updated>2024-07-05T09:12:54.422Z</updated>
  <id>https://alleysira.github.io/</id>
  
  <author>
    <name>Alleysira</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>EVM: From Solidity to byte code, memory and storage</title>
    <link href="https://alleysira.github.io/2024/07/02/EVM-From-Solidity-to-byte-code-memory-and-storage/"/>
    <id>https://alleysira.github.io/2024/07/02/EVM-From-Solidity-to-byte-code-memory-and-storage/</id>
    <published>2024-07-02T11:08:40.000Z</published>
    <updated>2024-07-05T09:12:54.422Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>学习 EVM 字节码和合约的对应关系</p><p>source：<a href="https://youtu.be/RxL_1AfV7N4?si=oTGjUI0lQWkEqn0t">https://youtu.be/RxL_1AfV7N4?si=oTGjUI0lQWkEqn0t</a></p><span id="more"></span><h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>使用<code>Solidity</code>编写的智能合约已经超过90%</p><p>以太坊交易的接口</p><p><img src="/2024/07/02/EVM-From-Solidity-to-byte-code-memory-and-storage/image-20240702191910946.png" alt="image-20240702191910946"></p><p>对于合约部署的交易，目的地址必须为空且<code>Data</code>字段为<code>init code</code></p><p>对于合约调用的交易，目的地址为合约，<code>Data</code>字段为functioncall和参数</p><p><img src="/2024/07/02/EVM-From-Solidity-to-byte-code-memory-and-storage/image-20240702192319122.png" alt="image-20240702192319122"></p><h1 id="Stack-Memory-Storage-Code-CallData-amp-Logs"><a href="#Stack-Memory-Storage-Code-CallData-amp-Logs" class="headerlink" title="Stack, Memory, Storage, Code, CallData, &amp; Logs"></a>Stack, Memory, Storage, Code, CallData, &amp; Logs</h1><p>EVM是基于栈的处理器，输入从栈中来，输出pop到栈中</p><p>calldata是read-only的memory</p><p>EVM的log是write-only</p><p><img src="/2024/07/02/EVM-From-Solidity-to-byte-code-memory-and-storage/image-20240702192857556.png" alt="image-20240702192857556"></p><h1 id="Yellow-paper"><a href="#Yellow-paper" class="headerlink" title="Yellow paper"></a>Yellow paper</h1><p>操作码在yellow paper中被定义</p><p>操作码的数值越大，语义更可能是以太坊定义的</p><p><img src="/2024/07/02/EVM-From-Solidity-to-byte-code-memory-and-storage/image-20240702195923776.png" alt="image-20240702195923776"></p><p>6080604052是在初始化内存指针</p><p><img src="/2024/07/02/EVM-From-Solidity-to-byte-code-memory-and-storage/image-20240702200704617.png" alt="image-20240702200704617"></p><p>函数调用</p><p>检查calldata是否小于4bytes，涉及到函数选择器function selector</p><p>32bytes右移0xe0比特</p><p>function selector查询网站 <a href="https://www.4byte.directory/signatures/">https://www.4byte.directory/signatures/</a></p><p>solidity是按照函数签名的值排序jump table的，如果自己选择的函数名能够生成数值更小的函数签名，可以节约gas。如果函数签名超过4个，进行二分查找</p><p><img src="/2024/07/02/EVM-From-Solidity-to-byte-code-memory-and-storage/image-20240702203926364.png" alt="image-20240702203926364"></p><p>每次进入函数会push返回地址</p><p>get val1和val2的返回地址是相同的，代码复用（compiler开启代码优化后）</p><p>EVM client通过gas机制防御内存扩张造成的问题</p><p><img src="/2024/07/02/EVM-From-Solidity-to-byte-code-memory-and-storage/image-20240703151924150.png" alt="image-20240703151924150"></p><p>storage overwrite</p><p>solidity内存覆盖攻击</p><p>不同合约的storage是隔离的</p><ul><li>CODECOPY</li><li>EXTCODECOPY</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习 EVM 字节码和合约的对应关系&lt;/p&gt;
&lt;p&gt;source：&lt;a href=&quot;https://youtu.be/RxL_1AfV7N4?si=oTGjUI0lQWkEqn0t&quot;&gt;https://youtu.be/RxL_1AfV7N4?si=oTGjUI0lQWkEqn0t&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/categories/Blockchain/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="SmartContract" scheme="https://alleysira.github.io/tags/SmartContract/"/>
    
  </entry>
  
  <entry>
    <title>csiam2024</title>
    <link href="https://alleysira.github.io/2024/06/22/csiam2024/"/>
    <id>https://alleysira.github.io/2024/06/22/csiam2024/</id>
    <published>2024-06-22T00:29:35.000Z</published>
    <updated>2024-07-05T09:15:27.900Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><strong>2024 CSIAM 区块链技术与应用高峰论坛 </strong></p><p><strong>CSIAM-BTAF 2024: CSIAM Blockchain Technology and Application Forum (Changchun)</strong></p><p>6月21日-23日，长春</p><span id="more"></span><h1 id="6月22日上午"><a href="#6月22日上午" class="headerlink" title="6月22日上午"></a>6月22日上午</h1><p><img src="/2024/06/22/csiam2024/image-20240625183741594.png" alt="image-20240625183741594" style="zoom:80%;"></p><h2 id="马超群-湖南大学-分布式数字金融风险监管技术与方法"><a href="#马超群-湖南大学-分布式数字金融风险监管技术与方法" class="headerlink" title="马超群 湖南大学 分布式数字金融风险监管技术与方法"></a>马超群 湖南大学 分布式数字金融风险监管技术与方法</h2><p>停电了- -</p><p>偏向于经济学</p><h2 id="谭林-湖南-天河国运科技公司-可信数据空间及应用探索"><a href="#谭林-湖南-天河国运科技公司-可信数据空间及应用探索" class="headerlink" title="谭林 湖南 天河国运科技公司 可信数据空间及应用探索"></a>谭林 湖南 天河国运科技公司 可信数据空间及应用探索</h2><p>产业界的代表</p><p>区块链的发展：公有链——联盟链——数据要素2024年4月8日</p><p>可信数据空间解决数据安全流通问题</p><h2 id="李颉-上海交通大学-区块链大数据人工智能融合助力新质生产力发展"><a href="#李颉-上海交通大学-区块链大数据人工智能融合助力新质生产力发展" class="headerlink" title="李颉 上海交通大学 区块链大数据人工智能融合助力新质生产力发展"></a>李颉 上海交通大学 区块链大数据人工智能融合助力新质生产力发展</h2><p>AI  大模型 联邦学习和区块链结合</p><h2 id="圆桌论坛：区块链的发展与展望"><a href="#圆桌论坛：区块链的发展与展望" class="headerlink" title="圆桌论坛：区块链的发展与展望"></a>圆桌论坛：区块链的发展与展望</h2><p>星火链网 火链科技</p><p>香港虚拟资产</p><h1 id="6月22日下午"><a href="#6月22日下午" class="headerlink" title="6月22日下午"></a>6月22日下午</h1><h2 id="分论坛一"><a href="#分论坛一" class="headerlink" title="分论坛一"></a>分论坛一</h2><p><img src="/2024/06/22/csiam2024/image-20240625183824759.png" alt="image-20240625183824759" style="zoom:80%;"></p><h2 id="分论坛二"><a href="#分论坛二" class="headerlink" title="分论坛二"></a>分论坛二</h2><p><img src="/2024/06/22/csiam2024/640-1719016365148-3.png" alt="图片" style="zoom: 80%;"></p><h2 id="分论坛三"><a href="#分论坛三" class="headerlink" title="分论坛三"></a>分论坛三</h2><p><img src="https://mmbiz.qpic.cn/mmbiz_png/Th3OGDN6T8NfRN7GQMRXhHFuIDXH1wapJLXHeH9bJ8ictSBbic8lQZ8mnPEOIusMzsRsYFSXSIViaapg7VIQUFMRw/640?wx_fmt=png&from=appmsg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:80%;"></p><h1 id="6月23日上午"><a href="#6月23日上午" class="headerlink" title="6月23日上午"></a>6月23日上午</h1><p><img src="/2024/06/22/csiam2024/image-20240625184111558.png" alt="image-20240625184111558" style="zoom:80%;"></p><p>张引 合约漏洞检测 来自于重点研发课题</p><p><strong>EFEVD: Enhanced Feature Extraction for Smart Contract Vulnerability Detection</strong></p><p><img src="/2024/06/22/csiam2024/image-20240623091044484.png" alt="image-20240623091044484" style="zoom: 80%;"></p><p>联邦忘却学习 unlearning</p><p>博弈论的方法介绍对双花攻击的建模</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;2024 CSIAM 区块链技术与应用高峰论坛 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CSIAM-BTAF 2024: CSIAM Blockchain Technology and Application Forum (Changchun)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;6月21日-23日，长春&lt;/p&gt;</summary>
    
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>WADIFF</title>
    <link href="https://alleysira.github.io/2024/05/23/WADIFF/"/>
    <id>https://alleysira.github.io/2024/05/23/WADIFF/</id>
    <published>2024-05-23T03:23:34.000Z</published>
    <updated>2024-06-25T03:21:33.854Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Zhou S, Jiang M, Chen W, et al. WADIFF: A Differential Testing Framework for WebAssembly Runtimes[C]//2023 38th IEEE/ACM International Conference on Automated Software Engineering (ASE). IEEE, 2023: 939-950.</p><span id="more"></span><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Wasm运行时的准确率和可靠性很重要</p><p>现有工作的不足：</p><ul><li>测试用例非法，无法通过有效性测试</li><li>合法测试用例是随机生成的，无法探索复杂的runtime实现</li><li>无法系统的建模运行时的状态，语义相关的未触发crash的漏洞可能不会被报告</li></ul><p>挑战</p><ul><li>如何生成测试用例，尽可能多地覆盖spec的内容<ul><li>使用wasm-spec来生成有效的测试用例：设计了DSL transformer将自然语言转化为DSL，基于转化的DSL，设计了符号执行引擎来生成测试用例</li><li>为了达到非法的测试用例，对测试用例进行变异</li></ul></li><li>确定性的差分模糊测试框架：确定需要比对执行结果的哪些内容<ul><li>增加了prologue语句来设置前置状态</li><li>建模wasm运行时，手动插桩哪些属性需要被丢弃，如果被丢弃的属性有difference，怎么存在不一致的指令</li></ul></li></ul><p>生成了1,395,091个测试用例，124,157触发了异常，417个指令触发了异常；仅发现了21个问题，8个被确认或修复了</p><p>贡献</p><ul><li>spec的transformer，将原来的语言转化为DSL，基于dsl进行程序分析</li><li>测试用例生成器：基于dsl采用符号执行生成wasm程序，设计了变异器对wasm进行变异</li><li>wasm运行时的学习和建模</li><li>差分测试框架：测试用例生成+确定性测试引擎</li></ul><h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><p>wasm运行时包括三个步骤</p><ul><li>decoding：字节码被翻译为模块module</li><li>validation：wasm运行时检查module是否有效</li><li>execution：有效后初始化模块，创建模块的实例，调用开始函数</li></ul><p>Wasm操作码会有不同的控制流，需要生成可以覆盖到各个流的测试用例，方法是将SPEC转化为DSL</p><p><img src="/2024/05/23/WADIFF/image-20240523170838410.png" alt="image-20240523170838410"></p><h1 id="Methodlogy"><a href="#Methodlogy" class="headerlink" title="Methodlogy"></a>Methodlogy</h1><p><img src="/2024/05/23/WADIFF/image-20240523180245843.png" alt="image-20240523180245843"></p><h1 id="测试用例生成器"><a href="#测试用例生成器" class="headerlink" title="测试用例生成器"></a>测试用例生成器</h1><p><img src="/2024/05/23/WADIFF/image-20240523180921117.png" alt="image-20240523180921117"></p><h1 id="差分测试引擎"><a href="#差分测试引擎" class="headerlink" title="差分测试引擎"></a>差分测试引擎</h1><p>比较变量的值来确定是否存在不一致性</p><p>差分测试的形式化定义</p><h1 id="其他材料"><a href="#其他材料" class="headerlink" title="其他材料"></a>其他材料</h1><p>开源仓库：<a href="https://github.com/erxiaozhou/WaDiff">https://github.com/erxiaozhou/WaDiff</a></p><h1 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h1><ul><li>生成调用多个指令的测试用例</li><li>覆盖率不高</li><li>生成测试用例的模板较为单一</li></ul><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul><li><p>以太坊操作码对应的spec在哪里</p><ul><li><a href="https://github.com/ethereum/execution-specs">https://github.com/ethereum/execution-specs</a></li><li>分不同版本利用python的语义 <a href="https://github.com/ethereum/execution-specs/blob/master/src/ethereum/shanghai/vm/runtime.py">https://github.com/ethereum/execution-specs/blob/master/src/ethereum/shanghai/vm/runtime.py</a></li><li>操作码的指令：<a href="https://github.com/ethereum/execution-specs/tree/master/src/ethereum/shanghai/vm/instructions">https://github.com/ethereum/execution-specs/tree/master/src/ethereum/shanghai/vm/instructions</a></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Zhou S, Jiang M, Chen W, et al. WADIFF: A Differential Testing Framework for WebAssembly Runtimes[C]//2023 38th IEEE/ACM International Conference on Automated Software Engineering (ASE). IEEE, 2023: 939-950.&lt;/p&gt;</summary>
    
    
    
    <category term="WebAssembly" scheme="https://alleysira.github.io/categories/WebAssembly/"/>
    
    
    <category term="WebAssembly" scheme="https://alleysira.github.io/tags/WebAssembly/"/>
    
  </entry>
  
  <entry>
    <title>PyRTFuzz</title>
    <link href="https://alleysira.github.io/2024/05/13/PyRTFuzz/"/>
    <id>https://alleysira.github.io/2024/05/13/PyRTFuzz/</id>
    <published>2024-05-13T06:44:39.000Z</published>
    <updated>2024-06-26T05:30:47.232Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Li W, Yang H, Luo X, et al. PyRTFuzz: Detecting Bugs in Python Runtimes via Two-Level Collaborative Fuzzing[C]//Proceedings of the 2023 ACM SIGSAC Conference on Computer and Communications Security. 2023: 1645-1659.</p><span id="more"></span><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>Python的runtime包括语言解释器和runtime的库</p><p>PyRTFuzz在编译器层和应用层分别采用了基于生成的fuzzing和基于变异的fuzzing，利用静态分析提取运行时的API，以格式/结构感知应用程序输入生成为导向的自定义类型引导的变异策略</p><p>针对Cpython实现，应用到了3个版本的runtime中，发现了61个可利用的bug</p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>现有的机器学习系统基本采用python实现，安全性和可靠性依赖于Python runtime，包括interpreter和runtime library</p><ul><li>compiler：代码执行之前，负责将一种语言写的源码转换成另一种计算机代码（通常是机器码）</li><li>interpreter：分析并执行代码；把源代码翻译为更高效率的中间码执行；执行解释器内部的编译器预编译后保存的代码</li></ul><p>现有的使用最广泛的CPython过去5年有2000个bug，但是缺乏自动化分析工具</p><h2 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work"></a>Related work</h2><p>现有对compiler和runtime的测试工具确实存在</p><ul><li>fuzzing JVM<ul><li>基于生成的fuzzer：JSfunfuzz，TreeFuzz，Skyfire，学习现有样例的语法特征生成有效的测试用例</li><li>基于变异的fuzzer：Superion、Fuzzil，通过编辑AST或其他IR</li></ul></li></ul><p>Python runtime fuzz的挑战</p><ul><li>对Python运行时进行测试需要同时测试解释器核心和语言的运行时库，只考虑生成有效的测试用例不够，还需要测试用例的输入。全面模糊测试Python运行时将需要两个不同层次（生成程序与具体程序输入）的模糊测试密切协作（即广泛地执行解释器和运行时库之间的交互）。然而，目前对于如何设计这样一个两级协作模糊测试技术的先前知识很少</li><li>测试解释器需要多样性但是语义有效的程序</li><li>为fuzz生成高质量的输入：普遍的挑战，尤其python是动态类型语言，数据类型不可用</li></ul><p>为了解决以上挑战，提出了PYRTFuzz，2层协同式模糊测试解决挑战2</p><p>第一级模糊测试通过基于规范的Python代码生成方法，根据使用静态和动态分析提取的Python运行时中每个API的描述，生成具有不同控制流复杂性的有效且多样化的Python应用程序，以解决挑战2</p><p>第二层，基于变异的fuzzing对给定的runtime进行插桩，收集覆盖率进行反馈，生成具体的python程序的输入。生成输入的过程中利用API的描述进行类型引导，解决挑战3</p><p>基于已有的python fuzzer Atheris和libFuzzer，测试了CPython的3个不同版本：3.7.15/3.8.15/3.9.15</p><p>调整被测试app的大小测试了可扩展性</p><p>测试了5*24小时，发现了61个bugs，分布在3个python版本中</p><p>程序生成部分：4.77 KLoC of code in 40 minutes with a memory usage of 291.71 MB</p><h1 id="Background-and-Motivation"><a href="#Background-and-Motivation" class="headerlink" title="Background and Motivation"></a>Background and Motivation</h1><h2 id="Greybox-fuzzing"><a href="#Greybox-fuzzing" class="headerlink" title="Greybox fuzzing"></a>Greybox fuzzing</h2><p>基于覆盖率的灰盒测试是常采用的技术，针对测试样例的生成方法，可以分为两类：Mutation和generation</p><p>Generation是基于语法和定义的规则生成输入，需要保证语法和语义的有效</p><p>基于变异的容易实施，基于生成的方法发现深层bug更有效</p><h2 id="compiler-testing"><a href="#compiler-testing" class="headerlink" title="compiler testing"></a>compiler testing</h2><p>关键挑战是生成有效且多样的程序，现有方法包括基于语法的和基于程序变异的</p><h2 id="Python-Runtime-Fuzzing"><a href="#Python-Runtime-Fuzzing" class="headerlink" title="Python Runtime Fuzzing"></a>Python Runtime Fuzzing</h2><p>工作动机包括Python的流行和实证研究结果</p><p>CPython是最流行的Python运行时，作者收集了98.3k个历史issue，发现了23.4k个bug相关的，分析了每年上报多少，上报的趋势</p><p>为了理解漏洞是如何检测出的，手工分析了500个issue，超过98%都是开发者发现的，说明确实需要漏洞检测工具；漏洞大多80%分布在library中</p><p>现有代码生成工作的缺陷：</p><ul><li>忽略了多样性</li><li>虽然通过各种Python应用程序覆盖不同领域很重要，但这对于有效地测试Python运行时来说还不够</li><li>缺乏整体性测试：Python应用程序在Python运行时的环境中运行，该环境包括解释器核心和运行时库。分别测试这两个部分对于全面测试来说是不够的。对于测试Python运行时来说，应该同时关注解释器核心、运行时库以及两者之间的交互作用。</li></ul><p>例子，不同输入下报错类型不一样，”%2u” 表示将一个无符号整数（unsigned integer）按照至少两位的宽度进行格式化输出，并在需要时在前面填充空格</p><p><img src="/2024/05/13/PyRTFuzz/image-20240513172117218.png" alt="image-20240513172117218"></p><p>这个例子说明如果我们不为特定的运行时模块（比如locale）生成应用程序，那么该模块内部的Bug可能无法被触发（限制L1）。此外，即使生成了各种不同领域的应用程序，如果不考虑应用程序的各种输入，可能还不足以检测出所有的Bug（限制L2）。最后，不同的结果显示了解释器核心和运行时库之间的相互作用和协作，凸显了对它们进行整体测试的重要性（限制L3）。</p><h1 id="Technique-Design"><a href="#Technique-Design" class="headerlink" title="Technique Design"></a>Technique Design</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>level1: generation-based fuzzing</p><p>level2: mutation-based fuzzing</p><p><img src="/2024/05/13/PyRTFuzz/image-20240513172550927.png" alt="image-20240513172550927"></p><p>输入包括3个，单元测试、和2部分源码</p><ul><li><p>获得Runtime的库的ABI，先是没有类型的，通过执行测试用例得到类型</p></li><li><p>通过声明式规范语言SLang来生成python程序，为每一个API生成一个APP，将所有APP整理为一个序列</p></li><li>为了在每个API的模糊测试深度和在所有API上的模糊测试广度之间取得平衡，L1核心会为每个APP的第2级模糊测试安排一个预算时间。一旦预算用完，L1核心会根据上一次第2级模糊测试的覆盖范围决定是否为相同的API生成另一个（更复杂的）APP，如果是，则触发APP生成，并根据上一次第2级模糊测试迭代中的覆盖情况选择下一个APP进行第2级模糊测试</li><li>L2核心最初会维护一个每个应用程序的种子队列，其中种子是随机生成的。随后，通过基于收集到的覆盖反馈的自定义变异方案，对种子进行变异以获取新的输入值。自定义变异器可以生成适应每个特定应用程序输入格式的值，这得益于在第2阶段应用程序生成过程中插入的探针。这些探针旨在根据应用程序中调用的API的（带类型的）描述，将字节序列解码为单独的参数值。任何触发的Bug以及触发的种子将作为PyRTFuzz的输出产生</li></ul><h2 id="Runtime-API-Description-Extraction"><a href="#Runtime-API-Description-Extraction" class="headerlink" title="Runtime API Description Extraction"></a>Runtime API Description Extraction</h2><p>python的官方文档给出了abi，但是是非结构化的文本形式，手工提取折磨，需要自动化方式</p><p>采用Python的AST parser进行提取，鉴于静态类型推断的不准确性，暂时将类型设置为None，并将在下一步进行细化。因此，静态提取以无类型的API描述结束。</p><p><img src="/2024/05/13/PyRTFuzz/image-20240513191947804.png" alt="image-20240513191947804"></p><p>对于异常字段，会尽可能全面地收集API可能抛出的明确异常以及从导入的模块中隐式抛出的异常。这些信息在应用程序生成期间指导API调用的异常处理，这对于避免在第2级模糊测试期间将异常错误地标识为Bug非常重要</p><p>动态改进：运行测试用例，提取返回值和参数的类型</p><p><img src="/2024/05/13/PyRTFuzz/image-20240513192621523.png" alt="image-20240513192621523"></p><p>算法每次处理一个单元测试，<code>inspect</code> 是 Python 标准库中的一个模块，能够获得对象的信息</p><p>问题：</p><ul><li>动态执行不一定可以覆盖全部的abi</li><li>python的动态特性，每个参数返回类型可能在不同执行中不同<ul><li>argue：只要有一个就足够生成有效的输入</li></ul></li></ul><h2 id="Level-1-fuzzing"><a href="#Level-1-fuzzing" class="headerlink" title="Level-1 fuzzing"></a>Level-1 fuzzing</h2><p>目的：生成多样化的有效的python程序</p><ul><li>API 覆盖率</li><li>APP多样性：测试到API的场景，控制流要复杂</li><li>APP有效性：语义和语法上有效，数据流可达性要从程序入口到call site</li></ul><p>使用SLang简单的声明性规范语言，SLang通过一组生成原语作为最低级语言构造来定义规范的语法和语义。使用SLang，开发人员可以表达规范要求，并通过SLang生成Python应用程序。SLang提供了一种简洁的方式来描述应用程序的要求和行为，以及如何生成满足这些要求的代码。</p><p>一个SLang程序（即APP规范）𝑃是一个语句序列𝑆∗。一个语句𝑆只有一种类型：赋值语句。在每个赋值语句中，右值𝐶(𝑒)∗表示一个取表达式𝑒的原语𝐶；左值𝑐表示𝐶(𝑒)∗的结果。这里的表达式𝑒可以是两种类型之一：一个变量𝑐或者对运行时API 𝐴的调用。</p><p><img src="/2024/05/13/PyRTFuzz/image-20240513195029215.png" alt="image-20240513195029215"></p><h3 id="Primitive-Derivation"><a href="#Primitive-Derivation" class="headerlink" title="Primitive Derivation"></a>Primitive Derivation</h3><p>SLang的原语是根据Python语言参考文档并参考解释器实现而推导出来的，总结了python程序的关键控制流结果，可分为基本原语和扩展原语</p><p>基本原语只接受运行时API的调用作为输入。它用于构建Python程序的基本（控制流）结构，该程序可以是面向对象或面向过程的，并定义程序的入口点。因此一个SLang程序应该以一个且仅有一个基本原语开始。</p><p><img src="/2024/05/13/PyRTFuzz/image-20240513195926563.png" alt="image-20240513195926563"></p><p>算法2的伪代码介绍了基本原语的一般操作，生成的P包含三部分T,D,M  包装ABI调用的D，主函数</p><p>扩展原语：扩展原语将其他原语的结果作为输入。它用于增加APP的复杂性，同时使其多样化。这些原语的推导还受到我们在现实世界中观察到的Python软件中的编程模式的影响。</p><p><img src="/2024/05/13/PyRTFuzz/image-20240513201138530.png" alt="image-20240513201138530"></p><p>通过自上而下的方式将输入程序𝑃包装起来生成新的应用程序。根据表2所示，推导出了七个原语，它们基于相关的Python抽象语法树（AST）操作进行实现。每个原语可以操作任何Python运行时API，而不依赖于特定API的语法或语义，这允许生成覆盖所有API的APP，从而满足需求R1。</p><p><img src="/2024/05/13/PyRTFuzz/image-20240513201204652.png" alt="image-20240513201204652"></p><h1 id="Implementation-and-limitation"><a href="#Implementation-and-limitation" class="headerlink" title="Implementation and limitation"></a>Implementation and limitation</h1><p><a href="https://github.com/awen-li/PyRTFuzz">https://github.com/awen-li/PyRTFuzz</a></p><p><a href="https://figshare.com/s/d5b8d5a7111abe4eafb1">https://figshare.com/s/d5b8d5a7111abe4eafb1</a></p><p>Brief Introduction and setup demonstration: <a href="https://youtu.be/cOhi9eG-IK0?si=p3ef3BDaMGGIwd4r">https://youtu.be/cOhi9eG-IK0?si=p3ef3BDaMGGIwd4r</a></p><h1 id="Ideas"><a href="#Ideas" class="headerlink" title="Ideas"></a>Ideas</h1><ul><li>实证研究，EVM的调研，不同EVM的issue整理</li><li>能否利用github的测试用例</li><li>大模型做abi提取</li><li>solidity的<a href="https://github.com/NomicFoundation/slang">slang</a></li><li>SLang的撰写依赖专家知识</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Li W, Yang H, Luo X, et al. PyRTFuzz: Detecting Bugs in Python Runtimes via Two-Level Collaborative Fuzzing[C]//Proceedings of the 2023 ACM SIGSAC Conference on Computer and Communications Security. 2023: 1645-1659.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Ethereum_in_30mins_from_DEVCON6</title>
    <link href="https://alleysira.github.io/2024/04/25/Ethereum-in-30mins-from-DEVCON6/"/>
    <id>https://alleysira.github.io/2024/04/25/Ethereum-in-30mins-from-DEVCON6/</id>
    <published>2024-04-25T09:45:44.000Z</published>
    <updated>2024-07-05T09:14:20.991Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>From DEVCON 2022</p><span id="more"></span><p><a href="https://archive.devcon.org/archive/watch/6/opening-ceremonies-vitalik/?playlist=Staff%20Picks&amp;tab=YouTube">https://archive.devcon.org/archive/watch/6/opening-ceremonies-vitalik/?playlist=Staff%20Picks&amp;tab=YouTube</a></p><p>在切换到PoS之后，仅出现了26个fail</p><p><img src="/2024/04/25/Ethereum-in-30mins-from-DEVCON6/image-20240425174737652.png" alt="image-20240425174737652"></p><p>Python在美学上比用 {} 的语言更好看（暴论</p><p><img src="/2024/04/25/Ethereum-in-30mins-from-DEVCON6/image-20240425175205207.png" alt="image-20240425175205207" style="zoom: 80%;"></p><p><img src="/2024/04/25/Ethereum-in-30mins-from-DEVCON6/image-20240425175652301.png" alt="image-20240425175652301" style="zoom:67%;"></p><p><img src="/2024/04/25/Ethereum-in-30mins-from-DEVCON6/image-20240425175744850.png" alt="image-20240425175744850"></p><p>目前的priority_fee 用户一般设置为1，如果当交易非常多的时候需要设置为更高的数值，每个区块的交易数量约为30000000/21000=1400，平均是700</p><p><img src="/2024/04/25/Ethereum-in-30mins-from-DEVCON6/image-20240425180018333.png" alt="image-20240425180018333"></p><p><img src="/2024/04/25/Ethereum-in-30mins-from-DEVCON6/image-20240425192121142.png" alt="image-20240425192121142"></p><p><img src="/2024/04/25/Ethereum-in-30mins-from-DEVCON6/image-20240425192258967.png" alt="image-20240425192258967"></p><p><img src="/2024/04/25/Ethereum-in-30mins-from-DEVCON6/image-20240425192748189.png" alt="image-20240425192748189"></p><p>出现sister block，两个区块可能有冲突的交易/相同的交易，目前的机制是计算不同分叉的区块及后续区块的证言数量</p><p>1epoch = 32slots=32*12s=6.4mins</p><p>对于一般的交易，等待一个epoch就足够安全了，等待2个epoch能够达到FFG</p><p><img src="/2024/04/25/Ethereum-in-30mins-from-DEVCON6/image-20240425193446442.png" alt="image-20240425193446442"></p><p>Merkle tree</p><p><img src="/2024/04/25/Ethereum-in-30mins-from-DEVCON6/image-20240425193531803.png" alt="image-20240425193531803"></p><p>Merkle tree是简洁的证明系统</p><p><img src="/2024/04/25/Ethereum-in-30mins-from-DEVCON6/image-20240425193651889.png" alt="image-20240425193651889"></p><p>Ethereum的state大概是40GB</p><p><img src="/2024/04/25/Ethereum-in-30mins-from-DEVCON6/image-20240425193847412.png" alt="image-20240425193847412"></p><p><img src="/2024/04/25/Ethereum-in-30mins-from-DEVCON6/image-20240425193939325.png" alt="image-20240425193939325"></p><p><img src="/2024/04/25/Ethereum-in-30mins-from-DEVCON6/image-20240425194000206.png" alt="image-20240425194000206"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;From DEVCON 2022&lt;/p&gt;</summary>
    
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>GPTScan</title>
    <link href="https://alleysira.github.io/2024/04/02/GPTScan/"/>
    <id>https://alleysira.github.io/2024/04/02/GPTScan/</id>
    <published>2024-04-02T12:10:20.000Z</published>
    <updated>2024-04-30T07:39:04.755Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Sun Y, Wu D, Xue Y, et al. GPTScan: Detecting Logic Vulnerabilities in Smart Contracts by Combining GPT with Program Analysis[C]//2024 IEEE/ACM 46th International Conference on Software Engineering ICSE, 2024. </p><span id="more"></span><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>现有漏洞检测工具主要目标是检测出具有固定控制/数据流模式的漏洞，根据综述，80%的Web3漏洞是无法审计出的逻辑漏洞，采用GPT探索如何检测逻辑漏洞。</p><p>解决思路：静态分析+GPT（直接使用GPT进行漏洞识别误报率过高，受限于预训练知识）</p><p>漏洞划分：scenario property</p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>研究现状</p><ul><li>Do you still need a manual smart contract audit? 使用 GPT3.5（比GPT4便宜20倍） 来为项目范围的“是或否”问题提供高级漏洞描述，已经比典型的函数级漏洞检测更容易了。<ul><li>误报率 96%</li></ul></li><li>本文利用GPT作为代码理解工具，将漏洞类型划分为 code-level scenarios and properties<ul><li>场景描述了在哪些代码功能下可能发生逻辑漏洞，而属性则解释了脆弱代码的特征或操作。</li><li>基于代码层的语义匹配候选函数中的漏洞<ul><li>然而，由于基于GPT的匹配仍然是粗粒度的，GPTScan进一步指示GPT智能识别关键变量和语句，然后通过专门的静态确认模块进行验证。</li></ul></li><li>智能合约项目可能由多个Solidity文件组成，直接将所有文件输入给GPT可能是不可行或成本高昂的。为了解决这个问题，GPTScan采用了多维过滤过程，有效地缩小了用于GPT匹配的候选函数范围。<ul><li>优化后可以使用默认的4k context token size，而不需要更昂贵的16k</li></ul></li></ul></li></ul><p>实现</p><ul><li>大模型：GPT3.5，4K，temperature=0<ul><li>prompt：提出了一种新的mimic-in-the back ground方法，基于 zero-shot chain of- thought prompting</li></ul></li><li>静态分析：<a href="https://www.antlr.org/">ANTLR</a> 和 <a href="https://github.com/crytic/crytic-compile">crytic-compile</a></li><li>数据集：共400个合约项目，3000个sol文件，472k行代码<ul><li>市值最高的 top200</li><li>web3bugs</li><li>Defihacks </li><li>相关实验结果已经开源：<a href="https://sites.google.com/view/gptscan">https://sites.google.com/view/gptscan</a></li><li>rules开源：<a href="https://github.com/MetaTrustLabs/GPTScan">https://github.com/MetaTrustLabs/GPTScan</a></li></ul></li></ul><p>结果</p><ul><li>发现漏洞<ul><li>测试没有漏洞的合约 假阳率4.39%</li><li>测试较大的合约项目，平均精度为57.14%</li><li>Web3Bugs：recall 83.33% ，F1分数 67.8%</li><li>发现了9个审计公司未发现的漏洞</li></ul></li><li>快速 划算<ul><li>每1000行代码平均14.39s 0.01$</li></ul></li><li>可用性<ul><li>已被集成到安全工具 <a href="https://metatrust.io/product/metascan">MetaScan</a> 中</li></ul></li></ul><h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><ul><li>合约漏洞类型：参考综述Demystifying Exploitable Bugs in Smart Contracts<ul><li>难以利用，不直接和项目相关</li><li>使用简单、不和项目逻辑相关的oracle即可检测<ul><li>重入 溢出</li></ul></li><li>业务逻辑相关的漏洞：<ul><li>价格操纵 标识违规 错误状态更新 原子性违反 权限提升 错误accounting</li></ul></li></ul></li><li>GPT在漏洞检测中的应用<ul><li>能够理解源代码，实现zero-shot learning</li><li>Do you still need a manual smart contract audit 用GPT-4-32k，给GPT提供漏洞描述，利用漏洞描述来检测整个项目中的漏洞，但是召回率较差</li></ul></li></ul><h1 id="Motivating-Examples"><a href="#Motivating-Examples" class="headerlink" title="Motivating Examples"></a>Motivating Examples</h1><p>发现GPT对于“before”这个概念的理解存在困难，因此仅依靠GPT可能会将已修复版本的转账函数误报为存在漏洞。因此，静态分析是必要的。</p><p>根据上述例子，发现静态分析无法理解高级语义信息，而GPT可能会忽视一些低级信息，分别可能导致较低的召回率和较高的误报率。将这两种技术结合起来可以互补彼此，并提高检测性能。</p><h1 id="GPTScan"><a href="#GPTScan" class="headerlink" title="GPTScan"></a>GPTScan</h1><p><img src="/2024/04/02/GPTScan/image-20240407160158405.png" alt="image-20240407160158405"></p><ul><li><p>蓝色 GPT模块</p></li><li><p>绿色 静态分析</p></li></ul><p>输入合约/合约项目后，采用静态分析方法进行语法分析、函数调用图来判断可达性、候选函数</p><p>利用GPT将候选函数与相关漏洞类型的预抽象场景和属性进行匹配。对于匹配的函数，GPTScan通过GPT进一步识别关键变量和语句，然后将其传递给专门的静态分析模块进行漏洞确认。</p><p>挑战</p><ul><li>项目中可能有很多函数，直接将所有函数作为GPT输入不现实，挑战是高效缩减候选函数的范围</li><li>现有的基于GPT的漏洞检测工具输入的是高层次的漏洞描述，依赖GPT对漏洞预训练的知识和推理能力，能否将漏洞类型分解，直接从语义层面理解漏洞</li><li>GPT的输出可能是不可信赖的，如何进一步确认 匹配漏洞类型</li></ul><h2 id="Scenario-and-Property-Matching"><a href="#Scenario-and-Property-Matching" class="headerlink" title="Scenario and Property Matching"></a>Scenario and Property Matching</h2><p>现有工具输入的漏洞描述例子</p><p>An attack where an attacker observes pending transactions and creates a new transaction with a higher gas price, enabling it to be processed before the observed transaction. This is often done to gain an unfair advantage in decentralized exchanges or other time-sensitive operations.”</p><p>方法：手动将漏洞分解为场景和属性</p><ul><li>场景：逻辑漏洞可能发生时的函数功能</li><li>属性：漏洞代码的操作</li></ul><p><img src="/2024/04/02/GPTScan/image-20240407162231964.png" alt="image-20240407162231964"></p><p>未来可以利用GPT4，从历史报告中提取场景和属性，利用原有代码验证，不断生成新的语句，直到通过漏洞验证。但是不同漏洞类型的Prompt必须手工设计</p><p><img src="/2024/04/02/GPTScan/image-20240407163615150.png" alt="image-20240407163615150"></p><p>每个scenario and property可以被划分为2类</p><ul><li>对函数功能的描述</li><li>函数行为的描述，与漏洞的根本原因相关（如缺少安全检查）</li></ul><p>如果满足Scenario再次发送给GPT，判断是否满足属性</p><p>匹配候选函数后，首先，仅对通过场景匹配的函数进行属性匹配。这种场景和属性的分离能够在单个提示中查询所有场景，从而节省了GPT的成本。其次，在属性匹配过程中，通过查询场景和属性的组合而不仅仅是属性本身，通过GPT对场景进行了双重确认。</p><p>考虑到GPT模型有时会提供模棱两可的答案或难以解析的文本，场景和属性匹配仅设计为是或否的问题，旨在最大限度地减少非结构化的GPT响应的影响。此外，指示GPT学习多项选择场景匹配的输出JSON格式，利用GPT的指令学习能力。</p><p>如何降低输出的随机性：设置温度，mimic in the background</p><h2 id="多维度函数过滤"><a href="#多维度函数过滤" class="headerlink" title="多维度函数过滤"></a>多维度函数过滤</h2><p>函数可达性分析</p><ul><li>筛选项目文件范围：从项目范围的文件过滤开始，其中包括排除非Solidity文件，例如位于“node_modules”目录下的文件、测试文件（例如各种“test”目录中的文件）和第三方库文件（例如来自诸如“openzeppelin”、“uniswap”和“pancakeswap”等知名库的文件）。一旦这些文件被过滤掉，GPTScan就可以专注于项目的Solidity文件本身</li><li>筛选OpenZeppelin：除了引入lib之外，还有直接cp OpenZeppelin项目代码的部分<ul><li>方法：分析OpenZepplin的源代码提取出API生成白名单，将候选函数和白名单对比，如果符合则筛掉</li><li>未来会加入基于代码克隆的筛选方法</li></ul></li><li>特定漏洞类别的过滤：设计了基于YAML的过滤规则规范</li></ul><p><img src="/2024/04/02/GPTScan/image-20240407171422364.png" alt="image-20240407171422364" style="zoom:67%;"></p><p>这些过滤规则涵盖了基本函数名称（FNK）、详细函数内容（FCE、FCNE、FCCE和FCNCE）、函数参数（FPT）和函数的调用关系（FPNC、FNM、CFN）。不同的漏洞将利用它们特定的过滤规则。过滤规则的选择主要基于对漏洞类型领域知识的理解。“Risky First Deposit”漏洞仅使用FCCE规则类型，选择与“total”、“supply”和“liquidity”的任意组合相关的函数，以确保存款与代币的总供应量或流动性的计算相关。另一方面，“AMM的价格操纵”与代币价格的计算有关。在这个规则中，使用FNK规则选择与价格计算相关的函数，并使用FCE规则选择包含关键字“price”、“value”和“liquidity”的函数。</p><p>可达性分析：利用call graph分析候选函数的可达性，利用ANTLR对智能合约项目的源代码进行解析，并生成抽象语法树（AST）。对于函数可见性进行分类</p><h2 id="GPT识别和静态确认"><a href="#GPT识别和静态确认" class="headerlink" title="GPT识别和静态确认"></a>GPT识别和静态确认</h2><p>GPT对句法可能不敏感，静态分析工具聚焦于变量和陈述</p><p>利用GPT的帮助来提取与提示中描述的特定业务逻辑相关的变量和语句的地方。有了这些变量和语句才可以使用静态分析来确认漏洞是否存在。</p><p><img src="/2024/04/02/GPTScan/image-20240407173445072.png" alt="image-20240407173445072"></p><p>对于每个提取的变量或语句，GPTScan指示GPT提供一个简短的描述。这个描述有助于确定给定的变量是否与问题相关，并有助于避免错误的答案。如果GPT提供的变量或语句在函数的上下文中不存在，或者描述与问题无关，GPTScan将终止判断过程，并认为漏洞不存在。另一方面，如果提供的变量和语句经过验证，GPTScan将将它们输入静态分析工具，使用静态数据流追踪和静态符号执行等方法来确认漏洞的存在。具体而言，设计了以下四种主要类型的静态分析方法</p><ul><li>静态数据流分析</li><li>Value Comparison Check 值比较检查</li><li>Other Check</li><li>函数调用参数检查</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>GPT-3.5-turbo</p><p>ANTLR 可以不需要编译进行源代码分析</p><h1 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h1><p>Top200的数据集和BlockScope类似</p><ul><li>假阳率：在没有漏洞的合约集中进行测试，4.39%，web3bugs的假阳率高一些</li></ul><p><img src="/2024/04/02/GPTScan/image-20240407192440828.png" alt="image-20240407192440828"></p><ul><li>准确率 90% TP/TP+FP<ul><li>12个漏报漏洞是由于缺少别名分析导致的</li><li>和现有静态分析对比<ul><li>Slither发现了124个误报，缺少对函数调用的考虑</li><li>MScan 仅支持一个漏洞类型</li></ul></li><li>和现有GPT工具对比，仅有一篇不开源的</li></ul></li></ul><p>静态分析确认部分的重要性：消融实验</p><ul><li><img src="/2024/04/02/GPTScan/image-20240407200409883.png" alt="image-20240407200409883"></li><li>筛掉了假阳模块，221/647</li><li>也删除了3个假阴性，说明影响较小</li></ul><p>运行时间和经济开销</p><ul><li>tiktoken，每千行代码时间和美元</li><li><img src="/2024/04/02/GPTScan/image-20240407201012352.png" alt="image-20240407201012352"></li></ul><p>漏洞发现：9个新漏洞</p><h1 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h1><p>局限性</p><ul><li>修饰符 过滤是白名单机制，没有利用语义分析（代码克隆）</li><li>对控制流和数据流分析的方法对路径不敏感，可能引入符号执行</li></ul><p>使用其他大模型</p><ul><li>GPT4：提升不明显，开销增加20倍</li><li>调参：temperature = 0？越高越有创造力</li><li>Google Bard, Claude self-trained LLaMA</li></ul><h1 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work"></a>Related work</h1><p>静态分析</p><p>符号执行</p><p>动态分析</p><p>形式化验证</p><p>基于NLP的工作</p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>本文提出了GPTScan，第一个将GPT与静态分析相结合的工具，用于智能合约逻辑漏洞检测。GPTScan利用GPT根据代码级别的场景和属性匹配候选的易受攻击函数，并进一步指导GPT智能识别关键变量和语句，然后通过静态确认进行验证。实验部分在三个不同的数据集上进行了评估，涵盖了约400个合约项目和3K个Solidity文件，结果显示GPTScan对于代币合约实现了高精确度（超过90%），对于大型项目实现了可接受的精确度（57.14%），并且在检测真实逻辑漏洞的召回率超过70% 。GPTScan快速、经济高效，并且能够发现被人工审计人员忽略的新漏洞。</p><h1 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h1><p><img src="/2024/04/02/GPTScan/image-20240408234042748.png" alt="image-20240408234042748"></p><p><img src="/2024/04/02/GPTScan/image-20240408234116856.png" alt="image-20240408234116856"></p><p><img src="/2024/04/02/GPTScan/image-20240408234127034.png" alt="image-20240408234127034"></p><h1 id="学术报告"><a href="#学术报告" class="headerlink" title="学术报告"></a>学术报告</h1><p><img src="/2024/04/02/GPTScan/image-20240430142604762.png" alt="image-20240430142604762"></p><p>Code lama</p><p>知识生成</p><ul><li>没有额外知识</li><li>相关漏洞报告 code4rena比赛</li><li>整理过的漏洞描述</li></ul><p>审计报告一般有代码和描述</p><p>基于代码相似度进行匹配</p><p>Tool former</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Sun Y, Wu D, Xue Y, et al. GPTScan: Detecting Logic Vulnerabilities in Smart Contracts by Combining GPT with Program Analysis[C]//2024 IEEE/ACM 46th International Conference on Software Engineering ICSE, 2024. &lt;/p&gt;</summary>
    
    
    
    
    <category term="SmartContract" scheme="https://alleysira.github.io/tags/SmartContract/"/>
    
    <category term="LLM" scheme="https://alleysira.github.io/tags/LLM/"/>
    
  </entry>
  
  <entry>
    <title>2024-literature-overview</title>
    <link href="https://alleysira.github.io/2024/03/28/202403-literature-overview/"/>
    <id>https://alleysira.github.io/2024/03/28/202403-literature-overview/</id>
    <published>2024-03-28T12:43:25.000Z</published>
    <updated>2024-07-05T09:19:48.762Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>literature review</p><span id="more"></span><p>电子科技大学 hezheyuan 的github仓库：</p><p><a href="https://github.com/hzysvilla/Academic_Smart_Contract_Papers">https://github.com/hzysvilla/Academic_Smart_Contract_Papers</a></p><h1 id="ICSE-2024"><a href="#ICSE-2024" class="headerlink" title="ICSE 2024"></a>ICSE 2024</h1><p>Not available</p><ul><li><a href="https://conf.researchr.org/track/ icse-2024/icse-2024-research-track?#">Improving Smart Contract Security with Contrastive Learning-based Vulnerability Detection</a> ok</li><li><a href="https://conf.researchr.org/track/icse-2024/icse-2024-research-track?#">PrettySmart: Detecting Permission Re-delegation Vulnerability for Token Behaviors in Smart Contracts</a> ok</li><li><a href="https://conf.researchr.org/track/icse-2024/icse-2024-research-track?#">SCVHunter: Smart Contract Vulnerability Detection Based on Heterogeneous Graph Attention Network </a>ok</li><li><a href="https://conf.researchr.org/track/icse-2024/icse-2024-research-track?#">Towards Finding Accounting Errors in Smart Contracts</a> ok</li></ul><h1 id="FSE-2024"><a href="#FSE-2024" class="headerlink" title="FSE 2024"></a>FSE 2024</h1><ul><li>SmartAxe: Detecting Cross-Chain Vulnerabilities in Bridge Smart Contracts via Fine-Grained Static Analysis</li></ul><h1 id="Security-24"><a href="#Security-24" class="headerlink" title="Security 24"></a>Security 24</h1><ul><li>All Your Tokens are Belong to Us: Demystifying Address Verification Vulnerabilities in Solidity Smart Contracts</li></ul><h1 id="INFOCOM24"><a href="#INFOCOM24" class="headerlink" title="INFOCOM24"></a>INFOCOM24</h1><ul><li>ConFuzz: Towards Large Scale Fuzz Testing of Smart Contracts in Ethereum</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;literature review&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>BrokenMetre</title>
    <link href="https://alleysira.github.io/2024/03/07/BrokenMetre/"/>
    <id>https://alleysira.github.io/2024/03/07/BrokenMetre/</id>
    <published>2024-03-07T09:10:55.000Z</published>
    <updated>2024-03-10T13:55:32.196Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>The report from <a href="https://www.ndss-symposium.org/ndss-paper/broken-metre-attacking-resource-metering-in-evm/">NDSS2020</a></p><span id="more"></span><h1 id="Broken-Metre-Attacking-Resource-Metering-in-EVM"><a href="#Broken-Metre-Attacking-Resource-Metering-in-EVM" class="headerlink" title="Broken Metre: Attacking Resource Metering in EVM"></a>Broken Metre: Attacking Resource Metering in EVM</h1><p>研究以太坊中gas测量与dos攻击之间的关系</p><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>由于gas的错误计价，导致了dos攻击，现有的例子</p><p><img src="/2024/03/07/BrokenMetre/image-20240307172446547.png" alt="image-20240307172446547"></p><ul><li><p><a href="https://www.evm.codes/?fork=shanghai">EXTCODESIZE</a>：输入地址，返回地址字节码的字节大小；读这个操作高度占用IO，攻击发生时仅需20gas，视频中20年的计价为700（现在是100~2600）</p></li><li><p>SUICIDE（SELF）：类似，最开始的要价为0，可以任意部署合约并自毁实现DOS，现在的要价为5000起步</p></li></ul><h2 id="Methodology"><a href="#Methodology" class="headerlink" title="Methodology"></a>Methodology</h2><p>研究的方法是fork aleth，记录操作码执执行时的CPU 内存占用情况</p><p>重放交易，研究gas具体和哪些物理资源相关性强。得出的结论</p><p><img src="/2024/03/07/BrokenMetre/image-20240307173221929.png" alt="image-20240307173221929"></p><p>执行时间变化较大的指令依赖于状态，均值和标准差甚至都接近了</p><p><img src="/2024/03/07/BrokenMetre/image-20240307205654017.png" alt="image-20240307205654017"></p><p>标准差大的原因来自于缓存cache，实验结果，如果有页缓存的话，合约运行速度会快28倍，因此可以构造dos攻击，设计一个合约尽可能不命中缓存</p><p><img src="/2024/03/07/BrokenMetre/image-20240307174328557.png" alt="image-20240307174328557"></p><p>本文的设计了资源耗尽攻击，问题转变成了搜索问题</p><p><img src="/2024/03/07/BrokenMetre/image-20240307174735032.png" alt="image-20240307174735032"></p><p>这里同样存在测试用例生成的问题</p><p>需要解决栈平衡，没有栈溢出以及内存合法访问；局限性是没有考虑循环</p><p><img src="/2024/03/07/BrokenMetre/image-20240307174911654.png" alt="image-20240307174911654"></p><p>对于指令初始化的问题，参考了经验研究的结果，通过吞吐量来定义权重和概率</p><p><img src="/2024/03/07/BrokenMetre/image-20240307175156521.png" alt="image-20240307175156521"></p><p>实验结果生成了比平均运行时间慢200倍的合约</p><p><img src="/2024/03/07/BrokenMetre/image-20240307175358841.png" alt="image-20240307175358841"></p><p>有了结果后，如何评估现实影响</p><p><img src="/2024/03/07/BrokenMetre/image-20240307175535332.png" alt="image-20240307175535332"></p><p>因为遗传算法是基于aleth做的，还评估了在其他EVM客户端上的影响</p><p><img src="/2024/03/07/BrokenMetre/image-20240307175951999.png" alt="image-20240307175951999"></p><p>改进方法包括提高gas计价、减少IO操作频率短期方法；长期方法有实现无状态的客户端和分片</p><p><img src="/2024/03/07/BrokenMetre/image-20240307180443576.png" alt="image-20240307180443576"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;The report from &lt;a href=&quot;https://www.ndss-symposium.org/ndss-paper/broken-metre-attacking-resource-metering-in-evm/&quot;&gt;NDSS2020&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>EtherDiffer</title>
    <link href="https://alleysira.github.io/2024/03/01/EtherDiffer/"/>
    <id>https://alleysira.github.io/2024/03/01/EtherDiffer/</id>
    <published>2024-03-01T07:53:45.000Z</published>
    <updated>2024-03-12T13:51:41.824Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Kim S, Hwang S. EtherDiffer: Differential Testing on RPC Services of Ethereum Nodes[C]//Proceedings of the 31st ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering. 2023: 1333-1344.</p><span id="more"></span><p>挑战</p><ul><li>测试用例生成<ul><li>语义有效的测试用例</li><li>语义无效但是可执行的测试用例：变异生成</li></ul></li><li>执行交易前的初始状态一致</li></ul><p>测试对象是4个客户端的RPC服务，意图是根据已有的SPEC规范来生成测试用例，实际贡献非常solid</p><p>项目开源：<a href="https://github.com/JosephK95/EtherDiffer-public">https://github.com/JosephK95/EtherDiffer-public</a></p><p>数据集：<a href="https://solidity-by-example.org/hello-world/">https://solidity-by-example.org/hello-world/</a></p><p>依赖：<a href="https://figshare.com/articles/software/EtherDiffer_Differential_Testing_on_RPC_Services_of_Ethereum_Nodes_Code_/23913096/1">https://figshare.com/articles/software/EtherDiffer_Differential_Testing_on_RPC_Services_of_Ethereum_Nodes_Code_/23913096/1</a></p><p>实验数据：<a href="https://figshare.com/articles/dataset/EtherDiffer_Differential_Testing_on_RPC_Services_of_Ethereum_Nodes_Data_/21936555/1">https://figshare.com/articles/dataset/EtherDiffer_Differential_Testing_on_RPC_Services_of_Ethereum_Nodes_Data_/21936555/1</a></p><h1 id="Methodolody"><a href="#Methodolody" class="headerlink" title="Methodolody"></a>Methodolody</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>针对4个客户端geth Nethermind Erigon Besu，每4个节点组成一个私链</p><p>测试用例生成依赖web3.js</p><p>定义了DSL，用于捕捉函数参数的语法和语义要求，并将库规范转换为$spec_{DSL}$。EtherDiffer首先从specDSL中选择一个方法，然后Generator生成符合语义要求的模板代码，其中所有参数都满足其要求。此外，Mutator以随机方式将其中一个参数更改为语义无效的值，同时保持其类型。最后，Test Case Converter通过将模板代码与每个目标节点绑定来实例化一组四个测试用例。一旦执行完成，Error Checker报告只有一部分节点引发错误，而其他节点返回值，并且Value Checker报告返回值是否彼此不一致。</p><p>测试用例使用try-catch语句包装，以正确识别错误，同时保持EtherDiffer的执行</p><h2 id="测试用例生成"><a href="#测试用例生成" class="headerlink" title="测试用例生成"></a>测试用例生成</h2><p>基于web3.js</p><p>为了自动化处理库规范，定义了一个领域特定语言，用于捕捉函数参数的类型和语义要求。规范s包括类型定义、子类型关系、属性定义和方法声明。类型t可以是基本类型t_p，对象类型，数组类型或两个类型的并集。对象类型是一组键-类型对的集合，其中一些可以是可选的。</p><p><img src="/2024/03/01/EtherDiffer/image-20240312155349225.png" alt="image-20240312155349225"></p><p>这部分能用solidity的声明吗？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Kim S, Hwang S. EtherDiffer: Differential Testing on RPC Services of Ethereum Nodes[C]//Proceedings of the 31st ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering. 2023: 1333-1344.&lt;/p&gt;</summary>
    
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>consensus_fuzz</title>
    <link href="https://alleysira.github.io/2024/02/26/consensus-fuzz/"/>
    <id>https://alleysira.github.io/2024/02/26/consensus-fuzz/</id>
    <published>2024-02-26T01:48:02.000Z</published>
    <updated>2024-03-29T03:33:22.004Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>配置区块链共识漏洞检测工具</p><span id="more"></span><h1 id="Fluffy"><a href="#Fluffy" class="headerlink" title="Fluffy"></a>Fluffy</h1><p>Yang Y, Kim T, Chun B G. Finding consensus bugs in ethereum via multi-transaction differential fuzzing[C]//15th USENIX Symposium on Operating Systems Design and Implementation (OSDI 21). 2021: 349-365.</p><p>项目地址：<a href="https://github.com/snuspl/fluffy">https://github.com/snuspl/fluffy</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone  https://github.com/snuspl/fluffy</span><br><span class="line">sudo docker build -t fuzzer . </span><br></pre></td></tr></table></figure><p>发现存在ethereum-forkid和aes包的依赖问题</p><p>修改Cargo.toml，增加</p><p><code>ethereum-forkid = &quot;0.12.0&quot;</code></p><p>以及</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[patch.crates-io]</span><br><span class="line">syn = &#123; git = &quot;https://github.com/johnyangk/syn&quot;, branch = &quot;fix&quot;, optional = true &#125;</span><br><span class="line">aes = &#123; git = &quot;https://github.com/RustCrypto/block-ciphers&quot;,rev=&quot;aes-v0.3.2&quot;&#125;</span><br><span class="line">aes-soft = &#123; git = &quot;https://github.com/RustCrypto/block-ciphers&quot;,rev = &quot;aes-soft-v0.3.0&quot;&#125;</span><br><span class="line">aesni = &#123; git = &quot;https://github.com/RustCrypto/block-ciphers&quot;,rev = &quot;aesni-v0.6.0&quot;&#125;</span><br><span class="line">block-cipher-trait = &#123; git = &quot;https://github.com/RustCrypto/traits&quot;, rev = &quot;block-cipher-trait-v0.6.0&quot; &#125;</span><br><span class="line">stream-cipher = &#123; git = &quot;https://github.com/RustCrypto/traits&quot;, rev = &quot;stream-cipher-v0.3.0&quot;&#125;</span><br></pre></td></tr></table></figure><p>问题诸多，相关问题已经在<a href="https://github.com/snuspl/fluffy/issues/2">issue</a>中提出</p><h1 id="LOKI"><a href="#LOKI" class="headerlink" title="LOKI"></a>LOKI</h1><p><a href="https://github.com/ConsensusFuzz/LOKI/tree/main">https://github.com/ConsensusFuzz/LOKI/tree/main</a></p><p>缺少对Geth的实现以及与本地冲突</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;配置区块链共识漏洞检测工具&lt;/p&gt;</summary>
    
    
    
    
    <category term="consensus" scheme="https://alleysira.github.io/tags/consensus/"/>
    
  </entry>
  
  <entry>
    <title>ITYFuzz</title>
    <link href="https://alleysira.github.io/2024/02/22/ITYFuzz/"/>
    <id>https://alleysira.github.io/2024/02/22/ITYFuzz/</id>
    <published>2024-02-22T02:48:06.000Z</published>
    <updated>2024-03-11T16:56:56.426Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Shou C, Tan S, Sen K. Ityfuzz: Snapshot-based fuzzer for smart contract[C]//Proceedings of the 32nd ACM SIGSOFT International Symposium on Software Testing and Analysis. 2023: 322-333.</p><span id="more"></span><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>作者个人主页：<a href="https://scf.so/">https://scf.so/</a></p><p>代码仓库：<a href="https://github.com/fuzzland/ityfuzz">https://github.com/fuzzland/ityfuzz</a></p><p>对应的slides：<a href="https://docs.google.com/presentation/d/1Z7fQMSs-fMCpoYDIVE3iQv-I18rGuk7m8tOR3IFg8mU/edit?usp=sharing">https://docs.google.com/presentation/d/1Z7fQMSs-fMCpoYDIVE3iQv-I18rGuk7m8tOR3IFg8mU/edit?usp=sharing</a></p><p>因为智能合约依赖于复杂的区块链状态，难以fuzz。对交易序列进行变异很复杂，并且通常会导致对输入和程序空间的次优探索空间。</p><p>创新点：</p><ul><li><p>ItyFuzz是基于快照的模糊测试器，对状态和单个交易进行快照。</p></li><li><p>引入了数据流路径点（waypoint）机制来辨认更有潜力的状态。</p></li><li>利用比较航点机制来删减状态空间。</li></ul><p>结论：通过维护状态快照，ITYFUZZ能够综合考虑具体的漏洞（重入），响应时间快，支持对链上合约及时验证</p><p>实验：对真实世界合约和被黑的Defi项目进行了实验，指令覆盖率和发现的漏洞均优于现有fuzzer。</p><p>项目开源地址：<a href="https://github.com/fuzzland/ityfuzz">https://github.com/fuzzland/ityfuzz</a></p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>智能合约审计现在是十亿美元规模的行业，审计的目的是确保合约没有漏洞，不会导致存储在合约内的资产损失。目前的模糊测试工具仅支持在本地环境中模糊测试，而不是直接在区块链上。链上模糊测试的挑战在于对给定状态的探索要足够快，因为链上状态在不断变化；攻击者可能在任何时候发起攻击。现有fuzzer效率不够高，不能即时获得链上状态并迅速完成审计。</p><p>链上审计的必要性可以通过以下场景来说明：</p><ul><li>特定代码只能在特定的链上状态下才能到达（确实），本地执行永远无法到达</li><li>目前的合约依赖外部的合约作为信息来源，链上审计可以即时获得信息（如预言机）</li></ul><p>链上审计的挑战在于必须要在攻击者执行攻击前暂停合约</p><ul><li>链上审计需要的时间需要是秒级，现有的工具对时间优化不足，覆盖合约的全部指令需要若干小时<ul><li>ITYFuzz能在几秒内达到较高的覆盖率</li></ul></li><li>fuzz合约的挑战在于：合约依赖状态，合约的依赖复杂<ul><li>为了解决状态的问题，一些之前的工作每次fuzz均从全新状态开始，以一系列交易作为输入；变异阶段部分交易序列被变异，因此现有工具在重新执行交易以返回到先前状态时存在较高的开销。对于需要通过多个交易建立的深层状态进行探索，重新执行的成本呈线性增长。此外，现有工具只针对交易具有反馈机制，而不针对状态，然而状态和交易具有不同的探索难度。</li><li>作者认为，对于具有状态的模糊测试，状态的有趣性与事务的有趣性同样重要，而当前的状态模糊测试工具中不存在选择有趣状态进行探索的反馈机制。（即不再从fresh state开始）</li></ul></li></ul><p>快照（Snapshot）本质上是某些交易触发的中间状态的复制，通过将所有有趣的快照存储在状态语料库（corpus）中，能够以O(1)的复杂度“时间穿越”到先前的状态，支持对交易和状态空间的高效探索</p><p>重构了一个现有的EVM实现来支持快速的快照</p><p>由于运行时内存资源有限，将所有快照存储到语料库中仍然不现实，而快照的数量随着总执行时间的增加而线性增加。存储的快照大小可能在几秒钟内增长到几个千兆字节。为了解决这个问题并优先探索最有趣的状态，作者设计了两种反馈机制（即路径点）来对有趣的状态进行分类，并设计了一种语料库修剪技术，在必要时减少有趣状态的数量。</p><p>同样可以适用到其他领域，如现代硬件设计</p><p>贡献</p><ul><li>提出一种基于快照的模糊测试算法，以减少有状态智能合约模糊测试的重新执行开销</li><li>提出了新的路径点机制，支持高效程序探索<ul><li>数据流路径点：基于未来加载的内存</li><li>对比路径点：概率性采样和固定采样结合</li></ul></li><li>开发了模糊测试工具，展示了其有效性</li><li>提出了一种新的智能合约审计方法，该方法基于从区块链上获取的状态进行测试，检测和复现了价值数百万美元的在线项目的漏洞。</li></ul><h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><h2 id="fuzzing"><a href="#fuzzing" class="headerlink" title="fuzzing"></a>fuzzing</h2><p>为了提高探索效率，模糊测试器一般会采用启发式方法或反馈机制来变异已有的输入生成新的输入</p><p>算法例子：初始时的语料库为空，如果某次执行覆盖了新的点则该执行</p><p>这里的伪代码多少有点问题：</p><ul><li><code>if</code>后面一行应该是 $I\gets I\  \cup \ i_m$</li><li>corpus可能会变为空</li></ul><p><img src="/2024/02/22/ITYFuzz/image-20240222163752301.png" alt="image-20240222163752301"></p><p>合约的fuzzer必须输入为一系列的交易</p><h2 id="waypoint"><a href="#waypoint" class="headerlink" title="waypoint"></a>waypoint</h2><p>FuzzFactory[OOPSLA19]引入了一般化的反馈机制waypoint。路径点是在执行目标程序后提供有趣反馈的中间输入。例如，在覆盖引导的模糊测试算法中，如果运行目标程序产生新的覆盖，就会记录新的输入（路径点）。然而，路径点不仅限于覆盖点，其他常见的路径点还包括执行时间、内存使用和两个比较值之间的距离等。为了实现定制的路径点，需要在程序执行过程中收集其他目标动态信息，并提供一个新的谓词函数 <code>is_interesting</code>替换图1中的 第9行</p><h1 id="Motivating-Example"><a href="#Motivating-Example" class="headerlink" title="Motivating Example"></a>Motivating Example</h1><p><img src="/2024/02/22/ITYFuzz/image-20240223110801874.png" alt="image-20240223110801874"></p><p>对于上面的合约，调用inc 0, inc 1, buggy() 即可出发漏洞</p><p>现实世界中的交易序列可能会相当复杂和长，当T增大时，现有的漏洞检测工具 如SMARTIAN不能即时检测出漏洞</p><p>直观来想，如果随机调用函数，抵达某个指定深度的时间是指数级的，重复执行来到达某个指定状态的（比如目标是10，到达8）的操作架重执行。SMARTIAN中，重新执行占据了总模糊测试时间的90%以上。</p><p>如果在执行一系列交易后到达的状态可以被记忆，那么重新执行的时间可以被消除。然而，记忆化需要保存的状态数量与交易序列的指数成正比。ItyFuzz的关键在于是只能记忆化一组“有趣的状态”，称为快照，而不是记忆化所有中间状态，并且仅使用这些有趣的状态来探索新状态而无需重新执行。一个状态的“有趣程度”是通过两个新颖的航点概念来定义的。</p><p><img src="/2024/02/22/ITYFuzz/image-20240223112037082.png" alt="image-20240223112037082"></p><h1 id="Methodology"><a href="#Methodology" class="headerlink" title="Methodology"></a>Methodology</h1><h2 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h2><p><img src="/2024/02/22/ITYFuzz/image-20240225101344843.png" alt="image-20240225101344843"></p><p>可以把EVM理解为$S\times T \to S$，状态在输入交易下发生变化</p><p>和现有工具一样，ITYFuzz的输入是<strong>种子输入语料库</strong>，每次从库中选一个种子（交易和状态）作为输入交给EVM执行，执行后使用 <strong>执行路径点</strong> 来判断当前执行是否增加了覆盖率，如果增加了把(s,t)就加入到语料库中。(会记录当前的执行状态$s$，这就是快照的含义)</p><h2 id="snapshot-based-fuzzing"><a href="#snapshot-based-fuzzing" class="headerlink" title="snapshot-based fuzzing"></a>snapshot-based fuzzing</h2><p>为了返回到某个中间状态，现有方法是重新执行交易。本文直接记录状态并保存</p><p>由于快照仅记录执行交易前的状态s和交易，丢失了执行交易后的状态$s’$，本文设计了另外一个语料库infant state corpus”，来记录执行后的状态，以判断当前状态是否能导致未来的有趣的执行。</p><p><img src="/2024/02/22/ITYFuzz/image-20240225111932947.png" alt="image-20240225111932947"></p><p>变异有两种可能，变异后的st永远是sound的（交易可以随便造，状态是从历史状态中得到的，意味着可能从一个交易序列到达记录的状态）</p><ul><li>变异交易：变异器来执行</li><li>变异状态，从$C_s$ 中选一个</li></ul><p>执行完交易后进行两个路径点判断</p><h2 id="Dataflow-Waypoint"><a href="#Dataflow-Waypoint" class="headerlink" title="Dataflow Waypoint"></a>Dataflow Waypoint</h2><p>目前有了对输入有趣程度进行度量的waypoint机制（FuzzFactory），没有对状态的路程点定义。设置航点的目标是判断从这些状态出发的的未来执行是否有趣，因此设计需要获得关于状态有趣程度的语义信息。</p><p>主要从两个方面来思考</p><ul><li><p>如果内存是未来的load指令的目标，可能是有趣的</p></li><li><p>如果状态变化包括了对某些特殊内存位置的写</p></li></ul><p>作者利用字节码插桩来进行动态数据流分析，通过观察运行时的load和store指令。由于传统的数据流分析是通过对源代码进行静态分析来实现的。然而，静态分析工具在智能合约模糊测试中效果不佳，因为智能合约可能会动态地调用外部合约。然而，仅从目标合约获取的静态数据流信息是不够的。</p><p>由于决定内存位置的“有趣程度”的load指令发生在未来，因此目前无法确定store指令的“有趣程度”。为了解决这个问题，本文提出了利用过去的load来估计未来可能的有趣的地址。</p><p>ItyFuzz跟踪过去加载过的内存位置以及被加载的值的抽象。如果当前执行中的值存储操作写入了这样一个内存位置，并且被写入的值的抽象与该位置之前存储的所有抽象值都不同，那么我们称这个存储操作是有趣的，并且在存储之后产生的状态也是有趣的。</p><p>插桩算法维护了两个map，分别记录是否执行过load和是否执行过store以及store的值</p><p><img src="/2024/02/22/ITYFuzz/image-20240225164440432.png" alt="image-20240225164440432"></p><p>Loc % MAP_SIZE是对Loc的粗略抽象，为了创建一个较小的抽象地址空间。较小的抽象地址空间有助于降低存储和查找开销。</p><p>桶抽象是类似于AFL中使用的分桶机制。分桶有助于减少插入映射的总值量，从而减少存储和评估成本，以换取插入数据的粒度损失。每个桶是实际值域的一个分区，在EVM的上下文中，实际值是一个256位整数。使用桶来避免存储所有状态。执行Store(Loc, Value)时，首先抽象出值该在的桶，再检查S(loc%size)(bucket(v))是否为true。</p><p>执行后，如果存储map中的一个桶从false变为true，并且L(Loc % MAP_SIZE)的相应位置也为true（算法2的第2行），则认为新状态是有趣的。每个桶的大小和范围可以作为超参数进行调整。每个槽中的桶数量越多，评估为有趣的状态就越多，$C_s$的大小也会增加。随着$C_s$的增大，选择下一个要探索的状态变得更加困难，并且会引起存储开销。</p><p><img src="/2024/02/22/ITYFuzz/image-20240225164449714.png" alt="image-20240225164449714"></p><h2 id="Comparison-Waypoint"><a href="#Comparison-Waypoint" class="headerlink" title="Comparison Waypoint"></a>Comparison Waypoint</h2><p>只采用dataflow航点存在的问题，由于过于抽象，如果桶2-4已经有了2,3的状态就不再被认为是有趣的了。如果只使用数据流航点，如果域的划分（即桶）对于目标智能合约来说不够精细，那么可能无法包含某些状态。</p><p>细粒度划分的问题在于初始状态语料库中的状态数量庞大，这会导致对于大型智能合约而言，随着时间的推移内存使用开销巨大。为了有效地解决这个开销问题，本文提出使用比较航点。比较航点只考虑所有<strong>中间状态</strong>，其中一些比较指令的操作数相比之前的执行更接近彼此，这对于达到更高的覆盖率是必需的，被认为是有趣的。</p><p><img src="/2024/02/22/ITYFuzz/image-20240225174337363.png" alt="image-20240225174337363"></p><p>ItyFuzz使用最大可能值初始化一个局部映射$C_{local}$，该映射仅针对当前执行。在执行过程中，对于每个比较指令，ItyFuzz根据程序计数器%MAP_SIZE（即比较指令的位置）更新键值对应的距离（第4行less than和第6行）。距离反映了两个值在比较中实现平衡的接近程度，由它们之间差值的绝对值确定。例如，如果ItyFuzz处理EQ(1, 3)操作，距离将为2。当执行中的任何比较指令更有可能为真时，执行被认为是有趣的。换句话说，在算法4中描述的方式，如果当前执行在local映射中显示的距离比记录在先前执行中最小距离的映射（）中的距离更小，则认为该执行是有趣的。</p><p>比较点能够用于判断是否该将状态从$C_s$中移除，算法4是具体的投票算法，票数反应了状态的有趣程度。</p><p><img src="/2024/02/22/ITYFuzz/image-20240225192248662.png" alt="image-20240225192248662"></p><h1 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h1><p>基于LibAFL，revm作为EVM的执行引擎；支持从支持Geth的链的某个状态开始fuzz</p><p>开源地址：<a href="https://github.com/fuzzland/ityfuzz">https://github.com/fuzzland/ityfuzz</a></p><h1 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h1><p>考虑</p><ul><li>覆盖率：在3个数据集上，对比1个工具</li><li>能否发现现实世界中的漏洞<ul><li>36/42个项目中已知的漏洞</li><li>45000个合约项目（BSC和以太坊，均有&gt;100个交易），1384项目发现了漏洞</li></ul></li><li>存储快照带来的内存开销，以及能否被waypoint解决</li><li>链上审计对发现合约漏洞的帮助<ul><li>研究了两个被黑的defi项目，给出的实例证明了，仅仅在开发环境中测试室不够的，还需要链上审计</li><li><img src="/2024/02/22/ITYFuzz/image-20240305205240351.png" alt="image-20240305205240351"></li></ul></li><li>效率是否支持链上审计</li></ul><p>数据集</p><ul><li>论文里的数据集 57个合约<ul><li>Sunbeom So, Myungho Lee, Jisu Park, Heejo Lee, and Hakjoo Oh. 2020. VERISMART: A Highly Precise Safety Verier for Ethereum Smart Contracts. In 2020 IEEE Symposium on Security and Privacy, SP 2020, San Francisco, CA, USA, May 18-21, 2020. IEEE, 1678–1694. <a href="https://doi.org/10.1109/SP40000.2020.00032">https://doi.org/10.1109/SP40000.2020.00032</a></li></ul></li><li>以太坊收集的572个合约</li></ul><p>对比工作</p><ul><li>SMARTIAN：比较了覆盖率</li></ul><p>时间优势来源于快照缩减了re-execution时间；comparison waypoints能够快速提高覆盖率</p><p><img src="/2024/02/22/ITYFuzz/image-20240305203726288.png" alt="image-20240305203726288"></p><p><img src="/2024/02/22/ITYFuzz/image-20240305203735599.png" alt="image-20240305203735599" style="zoom:67%;"></p><p>对比实验不够，做消融实验ablation study</p><p><img src="/2024/02/22/ITYFuzz/image-20240305204523492.png" alt="image-20240305204523492"></p><p>为了研究对内存开销的依赖</p><p><img src="/2024/02/22/ITYFuzz/image-20240305204653257.png" alt="image-20240305204653257"></p><h1 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work"></a>Related work</h1><h2 id="反馈驱动的模糊测试"><a href="#反馈驱动的模糊测试" class="headerlink" title="反馈驱动的模糊测试"></a>反馈驱动的模糊测试</h2><ul><li>基于覆盖率的模糊测试：AFL HonggFuzz FairFuzz</li><li>自定义的waypoint：<ul><li>Validity fuzzing利用输入的有效性作为反馈</li><li>采用程序执行的深度；</li><li>FuzzFatory形式化了waypoint机制</li></ul></li></ul><h2 id="带状态的模糊测试"><a href="#带状态的模糊测试" class="headerlink" title="带状态的模糊测试"></a>带状态的模糊测试</h2><ul><li>SMARTIAN 从0状态开始，发送一系列交易到达目的状态</li><li>Nyx采用了操作系统层面的快照策略 Nyx-Net</li><li>CorbFuzz对web应用程序进行fuzz，对状态进行了建模</li></ul><h2 id="智能合约安全工具"><a href="#智能合约安全工具" class="headerlink" title="智能合约安全工具"></a>智能合约安全工具</h2><ul><li><p>ContractFuzzer</p></li><li><p>Echidna Harvey 工业界的fuzzer</p></li><li>SMARTIAN hybrid，混合了静态分析和动态 数据流分析</li></ul><h1 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h1><ul><li>什么是链上审计？如果链上进行模糊测试，支持的每秒测试次数是多少</li><li>快照带来的额外存储代价评估，有</li><li>从语料库中选择种子的算法</li><li>每个桶的大小和范围如何设置和调节<ul><li>参考了AFL的设计，AFL的桶是1-2,2-4,4-8</li></ul></li><li>本文的覆盖率和其他工作的覆盖率对比</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Shou C, Tan S, Sen K. Ityfuzz: Snapshot-based fuzzer for smart contract[C]//Proceedings of the 32nd ACM SIGSOFT International Symposium on Software Testing and Analysis. 2023: 322-333.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>conference deadlines</title>
    <link href="https://alleysira.github.io/2024/01/21/ddl/"/>
    <id>https://alleysira.github.io/2024/01/21/ddl/</id>
    <published>2024-01-21T08:30:43.000Z</published>
    <updated>2024-02-29T11:25:53.438Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>ddl是第一生产力</p><span id="more"></span><h1 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h1><ul><li><p>NDSS24</p><ul><li>开会时间：26 February to 1 March 2024</li><li>summer: Wed, 19 Apr 2023</li><li><strong>fall: Wed, 28 Jun 2023</strong></li></ul></li><li><p>USENIX Security24 </p><ul><li>开会时间：AUGUST 14–16, 2024</li><li><strong>Summer Deadline: Tuesday, June 6, 2023</strong></li><li><strong>Fall Deadline: Tuesday, October 17, 2023</strong></li><li>Winter Deadline: Thursday, February 8, 2024</li></ul></li><li><p>CCS 2024 </p><ul><li>开会时间：October 14-18</li><li>Jan 28, 2024 </li><li>April 29th Deadline</li></ul></li><li><p>S&amp;P 2024 </p><ul><li>开会时间：MAY 20-23</li><li>April 13 2023</li><li><strong>August 3 2023</strong></li><li><strong>December 6, 2023</strong></li></ul></li><li><p>ESORICS 2024</p><ul><li>开会：September 16-20, 2024</li><li>January 8, 2024</li><li>Sat Apr 20th 2024 19:59:59 CST (2024-04-19 23:59:59 UTC-12)</li></ul></li></ul><h1 id="Software-engineering"><a href="#Software-engineering" class="headerlink" title="Software engineering"></a>Software engineering</h1><ul><li>ICSE 2025 <ul><li>开会：April 26-May 4 2025 </li><li>Mar 22, 2024</li><li><strong>Aug 2, 2024</strong></li></ul></li><li>ASE 2024<ul><li>开会：Sun 27 October - Fri 1 November 2024</li><li><strong>Fri 7 Jun 2024</strong></li></ul></li><li>ESEC/FSE 2024<ul><li>开会：Mon 15 - Fri 19 July 2024</li><li><strong>Thursday, September 28, 2023</strong></li></ul></li><li>ISSTA 2024<ul><li>开会： Mon 16 - Fri 20 September 2024</li><li><strong>Fri 15 Dec 2023</strong></li><li>Fri 12 Apr 2024</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;ddl是第一生产力&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>WRTester</title>
    <link href="https://alleysira.github.io/2024/01/13/WRTester/"/>
    <id>https://alleysira.github.io/2024/01/13/WRTester/</id>
    <published>2024-01-13T14:33:54.000Z</published>
    <updated>2024-01-13T15:14:31.327Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Cao S, He N, She X, et al. WRTester: Differential Testing of WebAssembly Runtimes via Semantic-aware Binary Generation[J]. arXiv preprint arXiv:2312.10456, 2023.</p><span id="more"></span><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>现有的测试框架受到测试用例质量的限制，即它们在生成语义丰富和语法正确的Wasm二进制文件方面面临挑战，因此无法触发复杂的错误。对真实世界Wasm二进制文件的反汇编和汇编来生成复杂的Wasm测试用例，从而触发Wasm运行时之间的隐藏不一致性。为了进一步确定意外行为的根本原因，我们设计了一种与运行时无关的根本原因定位方法，可以准确地定位错误。广泛的评估表明，WRTester在效率和效果方面优于现有技术。</p><p>在流行的Wasm运行时中发现了33个漏洞，其中25个已经得到确认。</p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>尽管最近的自动化测试方法通过Wasm二进制生成在识别Wasm运行时错误方面取得了有希望的结果，但它们受到无法生成语义丰富二进制文件的限制，因此无法触发复杂的错误。</p><p>例如，WADIFF只能测试单个指令级别的实现错误，因为它无法生成具有大量指令的测试用例，而真实世界的Wasm二进制文件实际上要复杂得多。具体而言，Wasm中存在超过430种指令和13种具有不同功能的部分类型，这表明Wasm是一种具有丰富语义的字节码格式。为了进行全面的测试，确保生成的Wasm二进制文件尽可能涵盖多样的语义是至关重要和必要的。</p><p>此外，不可能任意生成Wasm二进制文件，因为每个Wasm二进制文件在执行之前都应该经过语法正确性验证，包括堆栈平衡验证等，这确保了生成的Wasm二进制文件应该是符合语法的。</p><p>主要工作：从真实世界的Wasm二进制文件中提取基本元素，并将它们随机组装成具有有效语法和丰富语义的Wasm二进制文件的算法。</p><p>NeoDiff是随机在已有字节码后拼接、翻转比特、插入字节或进行特殊操作</p><p><img src="/2024/01/13/WRTester/image-20240113223841937.png" alt="image-20240113223841937"></p><p>对应的CVE，确认时间</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Cao S, He N, She X, et al. WRTester: Differential Testing of WebAssembly Runtimes via Semantic-aware Binary Generation[J]. arXiv preprint arXiv:2312.10456, 2023.&lt;/p&gt;</summary>
    
    
    
    
    <category term="Wasm" scheme="https://alleysira.github.io/tags/Wasm/"/>
    
    <category term="Differential Testing" scheme="https://alleysira.github.io/tags/Differential-Testing/"/>
    
  </entry>
  
  <entry>
    <title>minGasPoc</title>
    <link href="https://alleysira.github.io/2024/01/13/minGasPoc/"/>
    <id>https://alleysira.github.io/2024/01/13/minGasPoc/</id>
    <published>2024-01-13T13:32:42.000Z</published>
    <updated>2024-01-13T15:12:38.043Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>尝试构造out of gas的攻击</p><span id="more"></span><h1 id="攻击概述"><a href="#攻击概述" class="headerlink" title="攻击概述"></a>攻击概述</h1><p>目的：使得jsevm run out of gas</p><p>方法：设置geth pyevm jsevm当前交易的gaslimt为0xccc，jsevm需要0x168a</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># geth 修改调用evm的gas不起作用，只能修改genesis.json中的gaslimit</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;gasLimit&quot;</span>: <span class="string">&quot;0xccc&quot;</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment"># pyevm runBytecode.py</span></span><br><span class="line">    call_txn = new_transaction(</span><br><span class="line">        chain.get_vm(),</span><br><span class="line">        SENDER,</span><br><span class="line">        simple_contract_address,</span><br><span class="line">        private_key=SENDER_PRIVATE_KEY,</span><br><span class="line">        gas=0xffff,</span><br><span class="line">        <span class="comment"># data=function_selector,</span></span><br><span class="line">        data=decode_hex(args.signature),</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line"><span class="comment"># runBytecode.js</span></span><br><span class="line">const results = await evm.runCall(&#123;</span><br><span class="line">gasLimit: BigInt(<span class="string">&#x27;0x&#x27;</span>+<span class="string">&#x27;ccc&#x27;</span>),</span><br><span class="line">data: hexToBytes(sig),</span><br><span class="line">to: contractAddress,</span><br><span class="line"><span class="built_in">caller</span>: new Address(hexToBytes(<span class="string">&quot;0x1c7cd2d37ffd63856a5bd56a9af1643f2bcf545f&quot;</span>))</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>给定输入<code>data=0xfe575a87000000000000000000000000bffd98ec9ba3dc965b8a97d876670bb367fa84c2</code>，执行函数<code>isBlacklisted()</code>，成功</p><p><img src="/2024/01/13/minGasPoc/image-20240113213936348.png" alt="image-20240113213936348"></p><p>但是目前的问题是geth和pyevm均是revert，交易没有真正执行</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># geth</span><br><span class="line">&#123;<span class="attr">&quot;pc&quot;</span>:<span class="number">23471</span>,<span class="attr">&quot;op&quot;</span>:<span class="number">253</span>,<span class="attr">&quot;gas&quot;</span>:<span class="string">&quot;0x2fe312&quot;</span>,<span class="attr">&quot;gasCost&quot;</span>:<span class="string">&quot;0x0&quot;</span>,<span class="attr">&quot;memSize&quot;</span>:<span class="number">192</span>,<span class="attr">&quot;stack&quot;</span>:[<span class="string">&quot;0xfe575a87&quot;</span>,<span class="string">&quot;0xcaf&quot;</span>,<span class="string">&quot;0xbffd98ec9ba3dc965b8a97d876670bb367fa84c2&quot;</span>,<span class="string">&quot;0x0&quot;</span>,<span class="string">&quot;0x3f94&quot;</span>,<span class="string">&quot;0x80&quot;</span>,<span class="string">&quot;0x80&quot;</span>,<span class="string">&quot;0x0&quot;</span>,<span class="string">&quot;0x7018&quot;</span>],<span class="attr">&quot;depth&quot;</span>:<span class="number">1</span>,<span class="attr">&quot;refund&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;opName&quot;</span>:<span class="string">&quot;REVERT&quot;</span>,<span class="attr">&quot;error&quot;</span>:<span class="string">&quot;execution reverted&quot;</span>&#125;</span><br><span class="line">&#123;<span class="attr">&quot;output&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="attr">&quot;gasUsed&quot;</span>:<span class="string">&quot;0xcc6&quot;</span>,<span class="attr">&quot;error&quot;</span>:<span class="string">&quot;execution reverted&quot;</span>&#125;</span><br><span class="line"># python</span><br><span class="line">&#123;<span class="attr">&quot;pc&quot;</span>: <span class="number">23471</span>, <span class="attr">&quot;op&quot;</span>: <span class="number">253</span>, <span class="attr">&quot;gas&quot;</span>: <span class="string">&quot;0x9f81&quot;</span>, <span class="attr">&quot;gasCost&quot;</span>: <span class="string">&quot;0x0&quot;</span>, <span class="attr">&quot;stack&quot;</span>: [<span class="string">&quot;0xfe575a87&quot;</span>, <span class="string">&quot;0xaf0c&quot;</span>, <span class="string">&quot;0xc284fa67b30b6776d8978a5b96dca39bec98fdbf&quot;</span>, <span class="string">&quot;0x0&quot;</span>, <span class="string">&quot;0x943f&quot;</span>, <span class="string">&quot;0x80&quot;</span>, <span class="string">&quot;0x8000000000000000000000000000000000000000000000000000000000000000&quot;</span>, <span class="string">&quot;0x0&quot;</span>, <span class="string">&quot;0x1870&quot;</span>, <span class="string">&quot;0x0&quot;</span>, <span class="string">&quot;0x0&quot;</span>], <span class="attr">&quot;depth&quot;</span>: <span class="number">0</span>, <span class="attr">&quot;opName&quot;</span>: <span class="string">&quot;REVERT&quot;</span>, <span class="attr">&quot;error&quot;</span>: <span class="string">&quot;None&quot;</span> &#125;</span><br><span class="line">&#123;<span class="attr">&quot;output&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="attr">&quot;gasUsed&quot;</span>: <span class="string">&quot;0xcc6&quot;</span>&#125;</span><br><span class="line"># jsevm</span><br><span class="line">&#123;<span class="attr">&quot;pc&quot;</span>:<span class="number">16225</span>,<span class="attr">&quot;gas&quot;</span>:<span class="string">&quot;0x107&quot;</span>,<span class="attr">&quot;gasCost&quot;</span>:<span class="string">&quot;0x0&quot;</span>,<span class="attr">&quot;memory&quot;</span>:<span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012800000000000000000000000000000000254879013500000000000019125315223615516322015091138151216118103111791032501321940000000000000000000000000000&quot;</span>,<span class="attr">&quot;memsize&quot;</span>:<span class="string">&quot;6&quot;</span>,<span class="attr">&quot;stack&quot;</span>:[<span class="string">&quot;0xfe575a87&quot;</span>,<span class="string">&quot;0xcaf&quot;</span>,<span class="string">&quot;0xbffd98ec9ba3dc965b8a97d876670bb367fa84c2&quot;</span>,<span class="string">&quot;0x0&quot;</span>,<span class="string">&quot;0x0&quot;</span>,<span class="string">&quot;0xfe575a87&quot;</span>,<span class="string">&quot;0xa4&quot;</span>,<span class="string">&quot;0x20&quot;</span>,<span class="string">&quot;0x80&quot;</span>,<span class="string">&quot;0x24&quot;</span>,<span class="string">&quot;0x80&quot;</span>,<span class="string">&quot;0x0&quot;</span>,<span class="string">&quot;0x107&quot;</span>],<span class="attr">&quot;depth&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;opName&quot;</span>:<span class="string">&quot;STATICCALL&quot;</span>&#125;</span><br><span class="line">&#123;<span class="attr">&quot;output&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="attr">&quot;gasUsed&quot;</span>:<span class="string">&quot;0xccc&quot;</span>,<span class="attr">&quot;error&quot;</span>:&#123;<span class="attr">&quot;error&quot;</span>:<span class="string">&quot;out of gas&quot;</span>,<span class="attr">&quot;errorType&quot;</span>:<span class="string">&quot;EvmError&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>问题似乎在于ethereumjs的staticcall的gas被计算了，而gas和pyevm执行staticcall的gas消耗被忽略了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// initializer is not initialized</span><br><span class="line">function isBlacklisted(address account) external view returns (bool) &#123;</span><br><span class="line"></span><br><span class="line">    return initializer.isBlacklisted(account);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在remix上不支持过长的合约，只能开启optimizer（200），然后调用isBlacklisted函数，注意到remix VM的gas消耗为5366</p><p><img src="/2024/01/13/minGasPoc/image-20240113220635216.png" alt="image-20240113220635216"></p><p>remix报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;error&quot;</span>: <span class="string">&quot;Failed to decode output: Error: hex data is odd-length (argument=&quot;</span>value<span class="string">&quot;, value=&quot;</span>0x0<span class="string">&quot;, code=INVALID_ARGUMENT, version=bytes/5.7.0)&quot;</span></span><br></pre></td></tr></table></figure><p>尝试了不同的地址依然存在问题</p><p>在remix中先执行setInitializer，依然执行错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function setInitializer(address init) public onlyOwner &#123;</span><br><span class="line"></span><br><span class="line">    require(!tradingEnabled);</span><br><span class="line"></span><br><span class="line">    require(init != address(this), &quot;Can&#x27;t be self.&quot;);</span><br><span class="line"></span><br><span class="line">    initializer = Initializer(init);</span><br><span class="line"></span><br><span class="line">    try initializer.getConfig() returns (address router, address constructorLP) &#123;</span><br><span class="line"></span><br><span class="line">        dexRouter = IRouter02(router); lpPair = constructorLP; lpPairs[lpPair] = true; </span><br><span class="line"></span><br><span class="line">        _approve(_owner, address(dexRouter), type(uint256).max);</span><br><span class="line"></span><br><span class="line">        _approve(address(this), address(dexRouter), type(uint256).max);</span><br><span class="line"></span><br><span class="line">    &#125; catch &#123; revert(); &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/01/13/minGasPoc/image-20240113222653503.png" alt="image-20240113222653503"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;尝试构造out of gas的攻击&lt;/p&gt;</summary>
    
    
    
    
    <category term="EVM" scheme="https://alleysira.github.io/tags/EVM/"/>
    
  </entry>
  
  <entry>
    <title>chainmaker</title>
    <link href="https://alleysira.github.io/2024/01/11/chainmaker/"/>
    <id>https://alleysira.github.io/2024/01/11/chainmaker/</id>
    <published>2024-01-11T06:03:35.000Z</published>
    <updated>2024-06-05T08:49:08.911Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>配置长安链</p><span id="more"></span><h1 id="长安链部署和配置"><a href="#长安链部署和配置" class="headerlink" title="长安链部署和配置"></a>长安链部署和配置</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装kubectl"><a href="#安装kubectl" class="headerlink" title="安装kubectl"></a>安装kubectl</h3><ul><li><a href="https://kubernetes.io/zh-cn/docs/reference/kubectl/">https://kubernetes.io/zh-cn/docs/reference/kubectl/</a></li><li>在根目录 <code>mkdir .kube</code>，将config文件cp到该目录下</li></ul><h3 id="本地安装长安链2-3-1"><a href="#本地安装长安链2-3-1" class="headerlink" title="本地安装长安链2.3.1"></a>本地安装长安链2.3.1</h3><ul><li><p>官方文档：<a href="https://docs.chainmaker.org.cn/v2.3.1/html/">https://docs.chainmaker.org.cn/v2.3.1/html/</a></p></li><li><p>安装go</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">wget https://golang.google.cn/dl/go1.18.10.linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">sudo rm -rf /usr/<span class="built_in">local</span>/go </span><br><span class="line">sudo tar -C /usr/<span class="built_in">local</span> -xzf go1.16.13.linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">vi /etc/profile</span><br><span class="line"><span class="comment"># 加入配置</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/go/bin</span><br><span class="line"><span class="comment"># 配置生效</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 换源</span></span><br><span class="line">go env GO11MODULE=on</span><br><span class="line">go env -w GOPROXY=https://goproxy.cn</span><br></pre></td></tr></table></figure></li><li><p>安装7.3版本以上的gcc</p></li><li><p>安装7zip </p><ul><li>```bash<br>sudo apt-get install p7zip-full p7zip-rar<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 安装docker，参考https://docs.docker.com/engine/install/ubuntu/#install-using-the-repository</span><br><span class="line">- 下载gitlab的pre仓库</span><br><span class="line">  - https://gitlab.distribute-compute.cn/chenzhu/pre</span><br><span class="line">- 安装完毕后测试智能合约是否能部署</span><br><span class="line"></span><br><span class="line">## 部署到云</span><br><span class="line"></span><br><span class="line">- 修改改k8sconfg/4.yml和Makefile里面的版本/命名空间</span><br><span class="line">- build docker </span><br><span class="line">  - `make docker-solo`</span><br><span class="line"></span><br><span class="line">- 提交docker，这部分需要</span><br><span class="line">  - `docker login -u xxx -p xxx xxx.myhuaweicloud.com`</span><br><span class="line"></span><br><span class="line">  - `make push`</span><br><span class="line"></span><br><span class="line">- 进入docker执行命令</span><br><span class="line">  - `kubectl exec docker-name -it /bin/bash -n mj`</span><br><span class="line"></span><br><span class="line">- 停止运行</span><br><span class="line">  - `make configFdown`</span><br><span class="line">- 在dockerfile中设置需要打包为docker的文件</span><br><span class="line"></span><br><span class="line"># SealEVM</span><br><span class="line"></span><br><span class="line">长安链EVM有两个开源仓库，不尽相同</span><br><span class="line"></span><br><span class="line">- github：https://github.com/SealSC/SealEVM</span><br><span class="line">- gitlab：https://git.chainmaker.org.cn/chainmaker/vm-evm</span><br><span class="line"></span><br><span class="line">gitlab的报错且没有文档</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line"># chainmaker.org/chainmaker/vm-evm/v2/evm-go/storage</span><br><span class="line">evm-go/storage/contractStorage.go:92:36: too many arguments in call to c.Ctx.CallContract</span><br><span class="line">        have (*common.Contract, *common.Contract, string, nil, map[string][]byte, number, common.TxType)</span><br><span class="line">        want (*common.Contract, string, []byte, map[string][]byte, uint64, common.TxType)</span><br><span class="line">evm-go/storage/contractStorage.go:206:13: undefined: &quot;chainmaker.org/chainmaker/utils/v2&quot;.NameToAddrInt</span><br><span class="line">evm-go/storage/contractStorage.go:351:36: too many arguments in call to c.Ctx.CallContract</span><br><span class="line">        have (*common.Contract, *common.Contract, string, []byte, map[string][]byte, uint64, common.TxType)</span><br><span class="line">        want (*common.Contract, string, []byte, map[string][]byte, uint64, common.TxType)</span><br><span class="line">evm-go/storage/contractStorage.go:359:36: too many arguments in call to c.Ctx.CallContract</span><br><span class="line">        have (*common.Contract, *common.Contract, string, []byte, map[string][]byte, uint64, common.TxType)</span><br><span class="line">        want (*common.Contract, string, []byte, map[string][]byte, uint64, common.TxType)</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>github的SealEVM能运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">go mod download </span><br><span class="line"><span class="built_in">cd</span> example</span><br><span class="line">./example</span><br><span class="line">go get: added chainmaker.org/chainmaker/common/v2</span><br></pre></td></tr></table></figure><ul><li><p>不支持PUSH0，因此虚拟机不支持shanghai分叉，支持使用solc 0.8.23 设定evm version为paris</p><ul><li>目前的sealevm已经支持</li></ul></li><li><p>gas计价混乱，只出现了0x3和SSTORE的两个值</p><ul><li>STOP计价为0x3</li><li><img src="/2024/01/11/chainmaker/image-20240204144319468.png" alt="image-20240204144319468"></li></ul></li><li>存在stack underflow at <a href="https://github.com/SealSC/SealEVM/issues/21">issue</a></li></ul><h2 id="vm-evm"><a href="#vm-evm" class="headerlink" title="vm-evm"></a>vm-evm</h2><p>单测可以通过</p><p><img src="/2024/01/11/chainmaker/image-20240204143844766.png" alt="image-20240204143844766"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;配置长安链&lt;/p&gt;</summary>
    
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>sp23_find_spec_blind_spots_via_fuzz_testing</title>
    <link href="https://alleysira.github.io/2024/01/10/sp23-find-spec-blind-spots-via-fuzz-testing/"/>
    <id>https://alleysira.github.io/2024/01/10/sp23-find-spec-blind-spots-via-fuzz-testing/</id>
    <published>2024-01-10T09:22:21.000Z</published>
    <updated>2024-01-19T07:21:16.556Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Ji R, Xu M. Finding Specification Blind Spots via Fuzz Testing[C]//2023 IEEE Symposium on Security and Privacy (SP). IEEE Computer Society, 2023: 2708-2725.</p><span id="more"></span><p>形式化验证能够证明保持验证过的程序和声明的spocifications(SPEC)保持一致，但是如何保证SPEC是完备的 没有逻辑漏洞？本文使用Fuzzing-Assisted Specification Testing来解决这个问题。</p><p>核心思路是利用形式化验证过的程序的冗余性和多想想进行交叉检查。 </p><p>具体来讲，在同一个代码库中，SPEC（规范）、实现（CODE）和测试套件都是从同一组业务需求中派生出来的。因此，如果某个意图在CODE和测试用例中被捕捉到，但在SPEC中没有，则这表明SPEC存在盲点。</p><p>FAST以自动化的方式检查SPEC中的不完整性问题：它首先通过变异测试来定位SPEC的缺口gap，即通过检查CODE变体是否符合原始的SPEC来确定是否存在缺口。如果是这样，FAST进一步利用测试套件来推断缺口是由意图引起还是由错误引起的。根据代码库的大小，FAST可以选择以枚举方式还是进化方式生成CODE变体。FAST被应用于两个具有形式验证特性的开源代码库，并且分别帮助确认了它们SPEC中的13个和21个盲点。这凸显了SPEC不完整性在真实应用中的普遍存在。</p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>形式验证通过数学方法检查程序的正确性，为计算系统提供高度保证，即程序的行为完全受限于描述为一组期望属性（规范）的形式建模语言。形式验证在硬件和软件系统中已经被广泛采用。典型的应用场景包括可能导致重大损失和不可逆后果的情况（例如航空领域），或者传统的滚动式程序升级模型不可行的情况，如区块链上的智能合约。</p><p>形式化验证可以分解为两步</p><ul><li>1 设计目标系统的一系列规范 SPEC</li><li>2 证明实际的实现 CODE 和规范 SPEC是否符合，即$SPEC \sqsubseteq CODE$</li></ul><p>目前学术界在2方面进展迅速，但是1被关注较少。这就存在着严重的问题，即使一个程序经过完善的验证工具链进行了彻底的验证，该程序的正确性也仅限于其规范，程序中可能存在着盲点。由于目前形式化验证的成本较高、技术门槛较高，进行SPEC编写的人员一般不是写代码发的，作者想传达的思想是不能盲目的相信形式化验证后的代码，还需要去理解SPEC完备性的重要性</p><p> 硬件领域对SPEC完整性的研究比较多，现有的工作基于mutation testing，即将CODE或者SPEC进行变异，检查变异体是否依然符合旧的内容，因此，任何存活的变异体都会引发一个信号，表明规范可能是不完整的</p><p>因此去可以去研究：</p><ul><li>变异测试 mutation testing 是否能够应用于软件安全</li><li>如果不能，可以采用怎样的改进</li><li>优化后来解决成熟的代码库中是否普遍存在规范不完备的问题</li></ul><p>本文的主要工作是首先确认了采用变异测试能够高效地发现SPEC的漏洞，但是对于复杂的程序，基于变异的测试不够有效</p><h2 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h2><ul><li>当mutant通过了验证，如何证明SPEC之间的gap是故意而为还是错误<ul><li>解决思路：利用形式化验证程序中的冗余性和多样性，即代码 SPEC和测试套件都是从一组需求来的，但是以不同的思维方式进行编程：例如，使用不同的编程语言（甚至是编程范式）实现的，具有不同的演进路径，一般不同且独立的团队进行编写。因此，这三个不太可能出现相同的错误。</li><li>可以通过相互比较来发现错误</li></ul></li><li>如何构造一个更容易通过验证的mutant<ul><li>解决思路：fuzzer的遗传算法，计算每个mutant的fitness，只有高质量的mutant才可能被多次变异，fitness的标准就是验证后触发的错误（这也太trivial了）</li></ul></li></ul><p>FAST无法保证一定没有完备性问题，但可以用于说明程序中不存在明显的逻辑漏洞</p><h2 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h2><p>本文的贡献包括</p><ul><li>概念：我们指出形式验证程序中规范、代码和测试套件的“冗余性”和“多样性”，并利用这种冗余性（通过将测试套件作为“裁判”）来解决判断规范中缺陷是故意还是错误的问题，。</li><li>设计：采用基于遗传的进化，每个新的mutant会更难被杀死<ul><li>如何保证输入的多样性</li></ul></li><li>影响：分别发现了DPN和S2N中13个和21个盲点</li></ul><h1 id="Background-and-related-work"><a href="#Background-and-related-work" class="headerlink" title="Background and related work"></a>Background and related work</h1><p>介绍形式验证和规范不完整性问题以及变异测试和模糊测试</p><h2 id="形式化验证"><a href="#形式化验证" class="headerlink" title="形式化验证"></a>形式化验证</h2><p>已经被广泛应用在软件和硬件、密码学库(HACL*)、编译器、网络协议和智能合约(diem)中</p><p>步骤</p><ul><li>采用抽象逻辑语言设计SPEC</li><li>开发形式化工具来推理SPEC和目标代码实现之间的关系</li></ul><p>矛盾在于，一个理想的规范集需要足够完整，能够捕捉到所有利益相关者的意图，同时又需要足够抽象，以便在实施选择方面具有灵活性。例如，如果需求是对数组排序，SPEC需要足够完备能够理解排序的语义，然而需要足够抽象能够支持快排和归并排序的实现</p><p>然而，开发一个高质量的规范集是困难的。一个与代码相对应的规范集在实际价值上几乎没有意义，只会使代码库臃肿，导致代码更改的摩擦和更高的维护成本。另一方面，如果规范过于抽象，可能无法捕捉到一些基本的设计要求，在代码中可能存在未被发现的潜在漏洞。</p><p>目前的工作都是基于启发式手动调整的checklist</p><h2 id="自动化函数验证"><a href="#自动化函数验证" class="headerlink" title="自动化函数验证"></a>自动化函数验证</h2><p>本文主要聚焦于具有前置条件和后置条件的函数正确性验证，有时也被称为“按设计实现”的验证</p><p>在函数验证中，规范的目标通常是构成单个函数的代码，开发人员以SPEC谓词的形式为函数体提供前置条件和后置条件，这些谓词通常包括对函数参数和/或可以由函数中的代码引用的环境状态的条件。规范可能包含没有具体可执行语义的构造，例如对无界域的量化。虽然针对单个函数进行规定的,前置条件和后置条件不仅限于仅确立一个函数的正确性，它们对整个程序正确性的确立作出贡献，因为前置条件在调用方验证，从而可以在调用后假设后置条件。</p><p><img src="/2024/01/10/sp23-find-spec-blind-spots-via-fuzz-testing/image-20240111192543156.png" alt="image-20240111192543156"></p><p>例子中的ensures是一个后置条件，验证工具的任务是将代码和规范融合为可以交给后端求解器（通常是SMT求解器）处理的证明义务。</p><h2 id="规范SPEC的完备性"><a href="#规范SPEC的完备性" class="headerlink" title="规范SPEC的完备性"></a>规范SPEC的完备性</h2><p>图1中的代码符合SPEC，但是SPEC忽略了一个问题，如果add1函数的实现方式与图2a中所示，在原始循环之后还有一个额外的pop()操作。当前的规范只检查向量中每个剩余元素的值是否增加了一，忽略了对数据长度的校验。完整的规范如图2b所示，其中还有一个额外的ensures子句，进一步限制了add1函数修改输入向量的能力。这个缺失的ensures子句代表了原始规范的不完整性问题。</p><p><img src="/2024/01/10/sp23-find-spec-blind-spots-via-fuzz-testing/image-20240111193038531.png" alt="image-20240111193038531"></p><p>这里的问题出现在写SPEC实际上是另一种形式的编程，如何保证SPEC没有bug也很重要。这个问题被称为<em>gauging the completeness of SPEC</em>，在硬件领域受到了较多的关注，硬件领域主要采用的方法是mutation testing。</p><h2 id="Mutation-testing"><a href="#Mutation-testing" class="headerlink" title="Mutation testing"></a>Mutation testing</h2><p>mutation testing的idea来自于对软件测试的测试用例的怀疑主义，代码的安全性由测试保证，测试用例的安全性如何保证呢？这与FAST旨在解决的规范不完整性问题类似。</p><p>其实mutation based testing是从1970年代就开始被研究的一种方法</p><p>代码测试可以分为</p><ul><li>单元测试</li><li>集成测试</li><li>端到端测试</li></ul><p>用于测试不同测试组件的质量</p><p>同样可以用于测试没有具体语义的程序</p><p>硬件测试中，变异测试的目的是通过引入功能变换来评估给定的硬件SPEC的完整性。</p><h2 id="fuzzing中的遗传策略"><a href="#fuzzing中的遗传策略" class="headerlink" title="fuzzing中的遗传策略"></a>fuzzing中的遗传策略</h2><p>由于输入的状态空间较大，完全随机的输入生成实际作用不大。</p><p>在现代模糊测试研究中，处理状态探索问题的一种方式是模拟自然选择过程，结合随机变异和适者生存。具体而言，在每个变异轮次中，随机变异被用于增加探索尚未探索的路径的机会。适者生存的过程通过根据反馈（例如，在大多数模糊测试中的代码或路径覆盖）有效地对不同的种子进行排序，并给予排名较高的种子更好的机会来生成未来测试轮次的输入。</p><p>在模糊测试器的所有构建模块中（例如变异规则、种子调度、反馈机制），提供对种子质量的客观评估的度量标准对于模糊测试器的有效性至关重要。</p><p>AFL用了代码覆盖率，FAST提出了一种新的度量标准：利用求解器中的验证错误数量和多样性。</p><p>Language fuzzing好像和目前的虚拟机比较接近？语言模糊测试旨在发现编译器或解释器（例如虚拟机或JIT引擎）中的问题，这几篇可以再看一看</p><p><img src="/2024/01/10/sp23-find-spec-blind-spots-via-fuzz-testing/image-20240113193234749.png" alt="image-20240113193234749"></p><ul><li>Superion: Grammar-aware Greybox Fuzzing.</li><li>Soyeon Park, Wen Xu, Insu Yun, Daehee Jang, and Taesoo<br>Kim. Fuzzing Javascript Engines with Aspect-preserving<br>Mutation. In Proceedings of the 41st IEEE Symposium on<br>Security and Privacy (Oakland), San Francisco, CA, May<br>2020.</li><li>JQF: Coverage-guided Property-based Testing in Java.</li></ul><h1 id="The-Tale-SPEC-CPDE-and-Tests"><a href="#The-Tale-SPEC-CPDE-and-Tests" class="headerlink" title="The Tale SPEC CPDE and Tests"></a>The Tale SPEC CPDE and Tests</h1><p>生成多样的mutant不是挑战，评价生成的mutant的有效性是更重要的问题，本文中指通过了SPEC的mutant，在这里还需要判断这个mutant是否故意设计的gap</p><p>核心idea或者假设是：SPEC（来自于spec团队）、CODE（来自于开发者）、test suites（来自于QA质量保证团队）、三者不太可能犯同样的错，可以通过运行其中一个，和另外两个交叉对比检查正确性，实际上在测试用例中运行并检查SPEC就是一个例子</p><h1 id="变异"><a href="#变异" class="headerlink" title="变异"></a>变异</h1><ul><li><p>类型保留的变异：为了产生有效的CODE变异体，保证至少应该能够编译和执行，不具有参考价值</p></li><li><p>枚举变异：根据表1中讨论的有限的变异规则集合，对于在原始CODE中没有太多指令的小型代码，即使用算法1中描述的算法尝试所有可能的变异策略</p><ul><li>不支持一次修改多个运算符</li><li>改变循环结构的方法<ul><li>if else对换</li><li>continue break对换</li><li>三目运算符 对换</li></ul></li></ul></li></ul><p><img src="/2024/01/10/sp23-find-spec-blind-spots-via-fuzz-testing/image-20240113194902827.png" alt="image-20240113194902827"></p><p><img src="/2024/01/10/sp23-find-spec-blind-spots-via-fuzz-testing/image-20240113201033819.png" alt="image-20240113201033819"></p><h2 id="案例：Diem-支付网络"><a href="#案例：Diem-支付网络" class="headerlink" title="案例：Diem 支付网络"></a>案例：Diem 支付网络</h2><p>居然是区块链的例子，泪目了</p><p><img src="/2024/01/10/sp23-find-spec-blind-spots-via-fuzz-testing/image-20240113201711218.png" alt="image-20240113201711218"></p><ul><li>首先，静态分析AST，寻找所有可能的变异的地方</li><li><p>迭代地检查每个变异点，并按照表1中的通用变异规则生成CODE mutant。对于常量变异，CODE随机选择表1中列出的三个变异规则之一作为变异目标</p></li><li><p>对于每个生成的CODE突变，FAST将其传递给证明器，与原始的SPEC一起进行验证，并检查Move证明器的验证结果。Move证明器将报告验证状态以及验证错误的详细说明，即在CODE的哪一行违反了哪个SPEC属性</p></li></ul><p>结果：发现了404个可以进行变异的地方</p><h1 id="基于遗传策略的CODE变异"><a href="#基于遗传策略的CODE变异" class="headerlink" title="基于遗传策略的CODE变异"></a>基于遗传策略的CODE变异</h1><p>问题：当代码规模过大时，不适合将所有可能的突变点进行变异</p><p>遗传算法需要回答的两个问题：</p><ul><li>变异的对象<ul><li>solution：在进化开始之前，预先收集CODE中的潜在变异点。在这个信息收集步骤中，FAST从头到尾扫描给定的CODE，并将每个指令与表1中定义的可能的变异模式进行匹配</li></ul></li><li>哪个mutant更加适合作为下一轮的种子<ul><li>适度fitness评估：出现更少的错误，发现先前未知的验证错误均是好的mutant的表现</li><li>SPEC覆盖率是通过CODE变异体触发的验证错误来衡量的。对于每个未通过验证的CODE变异体，FAST期望从验证器那里得到一个报告来描述失败的原因。这个报告可以是一个简单的二进制通过/失败信号，也可以是一个包含 $SPEC \ X$ 在 $CODE$ 位置 $Y$ 由于原因 $Z$ 失败的记录的元组$(X, Y, Z)$列表。信息越详细，FAST对变异体的“适应度”测量就越好。</li><li>幸运的是，在实践中，大多数形式化验证工具都可以给出非常详细的验证错误解释，甚至包括可以具体执行以确定错误的反例。</li><li>CODE变异体都被分配了一个初始分数，该分数与两个因素成反比：1）剩余的验证错误数量和2）变异trace的长度。对于相同的验证错误集，FAST偏向于较小的变异体（即与原始CODE的编辑距离较小，类似于NeoDiff）</li></ul></li></ul><h2 id="fuzz的流程"><a href="#fuzz的流程" class="headerlink" title="fuzz的流程"></a>fuzz的流程</h2><p>seed pool保存着有意义来进行后续变异的种子code，种子都是根据分数排序的，每轮首先是种子选择算法，排序给出当前轮的种子并进行变异</p><ul><li>如果验证通过，分析是否为误报</li><li>如果验证失败，评估新code的适度，如果适合则保存该种子。同时，更新父种子的分数，并将父种子也加回到池子中<ul><li>如何保证种子的多样性？多给一些CODE，初始权重一样</li></ul></li></ul><p>值得一提的是，与可以从具有许多测试用例的种子池中启动的传统模糊测试不同，FAST的种子池在开始时只有一个种子，即没有任何变异的原始CODE。FAST给予这个创世种子足够高的分数，以便快速填充种子池中大量的单变异种子。但是在引导期之后，从FAST的角度来看，这个创世种子与其他种子没有区别。</p><p><img src="/2024/01/10/sp23-find-spec-blind-spots-via-fuzz-testing/image-20240113204315985.png" alt="image-20240113204315985"></p><h1 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h1><ul><li>测试套件的有效性</li><li>遗传算法的有效性：图6显示了在S2N上继续运行进化变异测试时，FAST发现的存活变异体数量的累积情况，大概在2^16秒时饱和</li></ul><p><img src="/2024/01/10/sp23-find-spec-blind-spots-via-fuzz-testing/image-20240113210923890.png" alt="image-20240113210923890" style="zoom:67%;"></p><h1 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h1><ul><li>变异SPEC：目前的方法是变异code而不是SPEC，理论上是可以反过来发现同样的gap<ul><li>然而，CODE和SPEC变异的对称性仅适用于发现SPEC中的差距，并不适用于判断差距是有意的还是错误的过程。在FAST中，可以通过对CODE变异体运行测试来对差距进行分类。但对于SPEC变异体来说，运行测试是徒劳的，因为CODE没有修改。这是FAST不采用SPEC变异方法的主要原因。</li><li>将对称性扩展到差距分类过程的解决方案是SPEC嵌入，即在适当的CODE位置嵌入SPEC并运行测试套件。</li></ul></li><li>基于coverage的SPEC完备性测试工具：<ul><li>目前流行用覆盖度（行覆盖度、指令覆盖度或分支覆盖度）来表示完整性，开源项目的谨慎维护者甚至可能要求任何新的CODE都必须附带测试用例，以保持代码库中的CODE覆盖率高。</li><li>目前没有用于测量SPEC的CODE覆盖度的工具，挑战在于似乎每个CODE片段都会参与到证明一些SPEC属性的过程中，很难解开复杂的逻辑公式。</li></ul></li><li>FAST的应用<ul><li>可应用的对象具备：验证系统是完全自动化的；FAST可以修改某种形式的CODE表示（LLVM IR）</li><li>FAST的普适性受到限制，因为形式验证尚未成为标准的工业实践，大多数软件中缺少SPEC</li></ul></li><li>可能错过一些gap的原因：<ul><li>变异演化方法本质上是不完整的。类似于为什么模糊测试无法找到软件中的所有错误一样，进化变异策略无法产生能够揭示SPEC中所有差距的CODE变异体——搜索空间太大无法枚举。</li><li>某些SPEC差距需要手动确认，特别是在第5种情况下，CODE变异体的验证失败——需要手动检查验证失败是由于不同步的证明提示（隐藏了SPEC差距）还是真正的SPEC违规引起的。</li></ul></li></ul><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>本文介绍了FAST工具，用于揭示形式SPEC中的不完整问题。FAST展示了如何通过交叉检查将形式验证程序（SPEC、CODE和测试套件）中的“冗余”和“多样性”协同起来，并通过枚举和进化变异测试提供了具体的设计和实现，用于检测SPEC中的盲点。本文将FAST应用于DPN和S2N，并分别确认了它们SPEC中的13个和21个盲点。这凸显了SPEC不完整在现实世界应用中的普遍存在。作者希望FAST的发现可以一定程度上呼吁社会，引起更多关于测量和确保形式验证代码库中SPEC质量的关注。</p><h2 id="可参考论文"><a href="#可参考论文" class="headerlink" title="可参考论文"></a>可参考论文</h2><p>mutation testing的</p><ul><li>Assessment of class mutation operators for c++ with the mucpp mutation system</li><li>Users guide to the pilot mutation system</li><li>W Eric Wong. Mutation Testing for the New Century, volume 24. Springer Science &amp; Business Media, 2001.</li><li>Timothy Alan Budd. Mutation Analysis of Program Test Data. Yale University, 1980.</li><li>Pedro Reales Mateo and Macario Polo Usaola. Reducing<br>mutation costs through uncovered mutants. Software Testing, Verification and Reliability, 25(5-7):464–489, 2015.</li><li>Baowen Xu, Xiaoyuan Xie, Liang Shi, and Changhai Nie.<br>Application of genetic algorithms in software testing. In<br>Advances in Machine Learning Applications in Software<br>Engineering, pages 287–317. IGI Global, 2007.</li></ul><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><ul><li>种子选择<ul><li>根据适度进行排序</li></ul></li><li>种子变异<ul><li>可以参考具体的对运算符进行的变异策略、改变循环结构</li><li>evmfuzz是每次变异一个位置后就执行，根据变异造成的效果改变变异器的权重；FAST是每次将所有能变异的地方进行变异，高阶变异是3个点同时变异</li></ul></li><li>种子评估：剩余的验证错误数量和变异trace的长度，倾向于发现新的验证错误、尽可能短</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Ji R, Xu M. Finding Specification Blind Spots via Fuzz Testing[C]//2023 IEEE Symposium on Security and Privacy (SP). IEEE Computer Society, 2023: 2708-2725.&lt;/p&gt;</summary>
    
    
    
    
    <category term="Mutation Testing" scheme="https://alleysira.github.io/tags/Mutation-Testing/"/>
    
  </entry>
  
  <entry>
    <title>Detecting Blockchain (E)VM Flaws</title>
    <link href="https://alleysira.github.io/2024/01/10/blocksec-evm-fuzz/"/>
    <id>https://alleysira.github.io/2024/01/10/blocksec-evm-fuzz/</id>
    <published>2024-01-10T07:50:22.000Z</published>
    <updated>2024-01-11T06:56:59.630Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>BlockSec CEO周亚金教授受邀参加香港Web3学者峰会，阐述了EVM虚拟机存在的潜在安全风险以及如何通过差分测试工具解决该类问题。</p><p>参考链接：<a href="https://mp.weixin.qq.com/s/9ujd7AMmWNHWE6Wujfqz2A">url</a></p><span id="more"></span><h1 id="Detecting-Blockchain-E-VM-Flaws"><a href="#Detecting-Blockchain-E-VM-Flaws" class="headerlink" title="Detecting Blockchain (E)VM Flaws"></a>Detecting Blockchain (E)VM Flaws</h1><p>打打广告</p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110161050085.png" alt="image-20240110161050085"></p><p>目前EVM兼容的链有200+</p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110161224346.png" alt="image-20240110161224346"></p><p>虚拟机是智能合约的foundation</p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110161402073.png" alt="image-20240110161402073"></p><p>virtual ROM中存储的是代码，account storge是持久化存储</p><p>evm如果对同一段代码执行结果不一样，就会导致分叉，有两个重要的事件</p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110161551985.png" alt="image-20240110161551985"></p><p>浅拷贝优化导致的错误</p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110161806004.png" alt="image-20240110161806004"></p><p>实现篡改return data</p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110161835490.png" alt="image-20240110161835490"></p><p>CVE2021 Geth及时修复了，但是其他fork geth的项目未能及时采用该patch </p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110162332986.png" alt="image-20240110162332986"></p><p>如何提前发现类似问题：提前开发系统，但是存在着一下问题</p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110162710450.png" alt="image-20240110162710450"></p><p>差分测试：不同种类的实现</p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110162923402.png" alt="image-20240110162923402"></p><p>输入相同，执行的合约相同，理论上输出应该一样</p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110162913739.png" alt="image-20240110162913739"></p><p>test case的prestate也应该相同</p><p>生成测试用例的方法</p><ul><li>用历史真实数据</li><li>基于覆盖率的fuzz（提到blocksec做了很多其他的维度）</li></ul><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110163219770.png" alt="image-20240110163219770"></p><p>基于种子交易mutate，生成不正常的交易</p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110163332043.png" alt="image-20240110163332043"></p><p>现有的evm存在定制，neo作为layer1，基于neo的链可能定制化</p><p>剔除假阳性的方法</p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110163448295.png" alt="image-20240110163448295"></p><p>blocksec目前支持的链的EVM</p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110163543389.png" alt="image-20240110163543389"></p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110155400899.png" alt="image-20240110155400899"></p><p><a href="https://nvd.nist.gov/vuln/detail/CVE-2020-26241">https://nvd.nist.gov/vuln/detail/CVE-2020-26241</a></p><p>目前zkevm的问题比较多</p><p>eos的问题：新的合约账户可能和已被销毁的合约账户连接起来</p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110155916090.png" alt="image-20240110155916090"></p><p>aurora预编译合约计算gas错误，远远小于实际的gas消耗，导致dos</p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110160130852.png" alt="image-20240110160130852"></p><p><img src="/2024/01/10/blocksec-evm-fuzz/image-20240110160609580.png" alt="image-20240110160609580"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;BlockSec CEO周亚金教授受邀参加香港Web3学者峰会，阐述了EVM虚拟机存在的潜在安全风险以及如何通过差分测试工具解决该类问题。&lt;/p&gt;
&lt;p&gt;参考链接：&lt;a href=&quot;https://mp.weixin.qq.com/s/9ujd7AMmWNHWE6Wujfqz2A&quot;&gt;url&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="EVM" scheme="https://alleysira.github.io/tags/EVM/"/>
    
  </entry>
  
  <entry>
    <title>TOSEM23</title>
    <link href="https://alleysira.github.io/2023/11/28/TOSEM23/"/>
    <id>https://alleysira.github.io/2023/11/28/TOSEM23/</id>
    <published>2023-11-28T11:38:58.000Z</published>
    <updated>2024-01-11T09:20:21.916Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Yixuan Zhang, Shangtong Cao, Haoyu Wang, Zhenpeng Chen, Xiapu Luo, Dongliang Mu, Yun Ma, Gang Huang, and Xuanzhe Liu. 2023. Characterizing and Detecting WebAssembly Runtime Bugs. ACM Trans. Softw. Eng. Methodol. Just Accepted (September 2023). <a href="https://doi.org/10.1145/3624743">https://doi.org/10.1145/3624743</a></p><span id="more"></span><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>首先收集了903个github上wasm bug相关的post，确认了311个真实的bug。基于数据，总结了31类wasm运行时的漏洞并且总结了共同的修复策略。设计了基于pattern的漏洞检测框架来自动检测Wasm中的bug。采用该漏洞检测框架测试了7个WASM运行时，发现了60个漏洞。</p><p>研究对象</p><ul><li>wasmtime</li><li>wasmer</li><li>WAMR</li></ul><p>贡献</p><ul><li>第一篇对Wasm运行时漏洞的系统研究，总结了漏洞的种类和对应的修复措施</li><li>开发了基于模式的漏洞检测框架，对真实世界的wasm运行时进行了检测，能够发现错误</li><li>脚本 数据集和漏洞检测工具已经开源（<a href="https://github.com/bnmcxlzd/TOSEM2023_Complementary_materials）">https://github.com/bnmcxlzd/TOSEM2023_Complementary_materials）</a></li></ul><h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><h2 id="wasm-binary"><a href="#wasm-binary" class="headerlink" title="wasm binary"></a>wasm binary</h2><p>wasm是一种底层的类似汇编的语言，设计目标是高效处理和紧凑表示。对应的二进制文件是.wasm。</p><p>Wasm标准定义了概念性的堆栈虚拟机，用于执行pop和push，并将结果留在堆栈上。</p><h2 id="wat-format"><a href="#wat-format" class="headerlink" title="wat format"></a>wat format</h2><p>.wat 是为开发者提供的漂亮的印刷文本格式，能够用于理解语义和wasm模块、进行测试、调试和优化等等。开发者可以使用wabt工具将wasm binary转换成文本格式</p><p>模块module是wasm代码的基本单元，表现为扁平树的形式；本地变量强类型</p><p><img src="/2023/11/28/TOSEM23/image-20231128201211895.png" alt="image-20231128201211895"></p><h2 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h2><p>Frontend compiler（AssemblyScript, Emscripten, Rustc/WASM-Bindgen）能够把高级语言编译为wasm bin，WASM被设计为高级编程语言的可移植编译目标，能够以接近本地执行的速度在多个平台上执行。wasm runtime是硬件和wasm bin之间的中间层</p><p><img src="/2023/11/28/TOSEM23/image-20231128201749638.png" alt="image-20231128201749638"></p><h2 id="wasm-runtime-architecture"><a href="#wasm-runtime-architecture" class="headerlink" title="wasm runtime architecture"></a>wasm runtime architecture</h2><p><img src="/2023/11/28/TOSEM23/image-20231128201825541.png" alt="image-20231128201825541"></p><p>后端编译器：支持提前编译Ahead-of-time compilation (AOT)和传统的即时编译Just-in-Time compilation</p><p>解释器：交互式执行</p><p>运行时环境：负责内存分配，栈的操作，报错</p><p>API：运行wasm运行时被嵌入到高级语言中作为库来使用</p><p>系统接口：支持类似操作系统的功能</p><h1 id="STUDY-DESIGN"><a href="#STUDY-DESIGN" class="headerlink" title="STUDY DESIGN"></a>STUDY DESIGN</h1><h2 id="研究问题"><a href="#研究问题" class="headerlink" title="研究问题"></a>研究问题</h2><p><img src="/2023/11/28/TOSEM23/image-20231129102622855.png" alt="image-20231129102622855"></p><p>漏洞分类的根本原因；是否存在普遍的修复策略；提出的分类方法对漏洞检测的有效性</p><h2 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h2><p>如何说明实验对象的代表性：</p><ul><li>LOC</li><li>star</li><li>支持的编译模式多</li><li>不同的编程语言实现</li></ul><p>数据来源</p><ul><li>github issue<ul><li>从github issue中提取有bug label的issue，最终304个wasmer的issues，167个wasmtime的issues和333个WAMR的issues（未label，全选）</li></ul></li><li>Stack Overlow<ul><li>Stack Overlow问题有标签，可根据标签爬取对应的post</li><li><img src="/2023/11/28/TOSEM23/image-20231129103818825.png" alt="image-20231129103818825"></li></ul></li></ul><h3 id="数据集的refine"><a href="#数据集的refine" class="headerlink" title="数据集的refine"></a>数据集的refine</h3><ul><li><p>筛去了没有确定性回答的issue和post</p></li><li><p>手工去除了install和build相关的错误，文档错误，用户误用等和wasm运行时无关的bug</p></li></ul><p>结果就是只剩下311个issue，SO全部没了（解释是可能github上wasm专家比较少）</p><p><img src="/2023/11/28/TOSEM23/image-20231129104347208.png" alt="image-20231129104347208"></p><h2 id="标记漏洞和修复策略"><a href="#标记漏洞和修复策略" class="headerlink" title="标记漏洞和修复策略"></a>标记漏洞和修复策略</h2><ul><li>pilot labelling 首先随机选了50%的post，论文前两位作者共同分析，进行分类</li><li>可靠性分析：根据之前的分类，两位作者独立标记剩下的40%的post验证之前对漏洞分类的正确性，采用Cohen’s kappa系数；对于出现的分歧与intercessor进行了讨论，新增了2类漏洞和3类修复措施；</li><li>对于剩下的10%，两位作者独立进行了分类，没有发现新的漏洞种类和修复措施，证明了分类的饱和 saturation</li></ul><h1 id="RQ1-TAXONOMY-OF-WASM-RUNTIME-BUGS"><a href="#RQ1-TAXONOMY-OF-WASM-RUNTIME-BUGS" class="headerlink" title="RQ1: TAXONOMY OF WASM RUNTIME BUGS"></a>RQ1: TAXONOMY OF WASM RUNTIME BUGS</h1><p>根据wasm的架构分析了漏洞种类</p><p><img src="/2023/11/28/TOSEM23/image-20231129110601087.png" alt="image-20231129110601087"></p><p>后端编译部分负责将bin编译为本地机器码，需要OS和CPU的支持，占总共bug的38.3%</p><h1 id="RQ3-PATTERN-BASED-BUG-DETECTOR-FOR-WASM-RUNTIMES"><a href="#RQ3-PATTERN-BASED-BUG-DETECTOR-FOR-WASM-RUNTIMES" class="headerlink" title="RQ3:PATTERN-BASED BUG DETECTOR FOR WASM RUNTIMES"></a>RQ3:PATTERN-BASED BUG DETECTOR FOR WASM RUNTIMES</h1><h2 id="Bug-detectors-for-Backend-Compilation"><a href="#Bug-detectors-for-Backend-Compilation" class="headerlink" title="Bug detectors for Backend Compilation"></a>Bug detectors for Backend Compilation</h2><p>No interest</p><h2 id="Bug-detectors-for-WASI-Robustness"><a href="#Bug-detectors-for-WASI-Robustness" class="headerlink" title="Bug detectors for WASI Robustness"></a>Bug detectors for WASI Robustness</h2><ul><li>文件操作错误：测试是否能重命名文件、是否能判断文件不存在、是否能移动文件、计数目录下的文件</li><li>import错误：不支持多个wasi的版本</li><li>输入输出流错误：用c++写程序编译为wasm bin再检查值和类型是否正确</li><li>OS错误：时间的API不一样，利用QuickJS进行测试</li></ul><h2 id="Bug-detectors-for-Runtime-environment"><a href="#Bug-detectors-for-Runtime-environment" class="headerlink" title="Bug detectors for Runtime environment"></a>Bug detectors for Runtime environment</h2><ul><li>module实例化错误：检查是否支持实例化 空 的wasm模块，短时间内大量实例化是否会内存泄漏</li><li><p>module导入错误：部分runtime省略了检查导入对象序号的步骤</p></li><li><p>Calling host functions：调用函数对象是否正确</p></li><li><p>memory issue：检查内存的增长是否是线性的</p></li><li>trap error：设计了带有不可达指令的module来测试运行时是否能正常跳出执行并且报告不可达代码的位置</li><li>入口错误：wasm运行时可能会不允许入口函数或拒绝没有入口函数的module</li><li>未处理异常</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Yixuan Zhang, Shangtong Cao, Haoyu Wang, Zhenpeng Chen, Xiapu Luo, Dongliang Mu, Yun Ma, Gang Huang, and Xuanzhe Liu. 2023. Characterizing and Detecting WebAssembly Runtime Bugs. ACM Trans. Softw. Eng. Methodol. Just Accepted (September 2023). &lt;a href=&quot;https://doi.org/10.1145/3624743&quot;&gt;https://doi.org/10.1145/3624743&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="Wasm" scheme="https://alleysira.github.io/tags/Wasm/"/>
    
  </entry>
  
  <entry>
    <title>OmniLedger</title>
    <link href="https://alleysira.github.io/2023/11/12/OmniLedger/"/>
    <id>https://alleysira.github.io/2023/11/12/OmniLedger/</id>
    <published>2023-11-12T05:09:50.000Z</published>
    <updated>2024-01-21T06:39:19.453Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Video"><a href="#Video" class="headerlink" title="Video"></a>Video</h1><p>视频链接：<a href="https://www.youtube.com/watch?v=vHVZ2gD8Ie4&amp;ab_channel=AllHackingCons">https://www.youtube.com/watch?v=vHVZ2gD8Ie4&amp;ab_channel=AllHackingCons</a></p><p>github：<a href="https://github.com/dedis/student_18_byzcoin">https://github.com/dedis/student_18_byzcoin</a></p><span id="more"></span><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p><img src="/2023/11/12/OmniLedger/image-20231112132024157.png" alt="image-20231112132024157"></p><p>进行分片时需要考虑的问题：</p><ul><li>验证者如何被分配到不同分片中去</li><li>如何实现跨分片的交易</li></ul><p><img src="/2023/11/12/OmniLedger/image-20231112132216448.png" alt="image-20231112132216448"></p><p>对于第一个问题，显然不能让验证者自己选择进去哪个分片，如果随机选择，需要保证分片大小足够大（失败概率为$10^{-6}$，分片大小在$10^3\to10^4$），符合leopard</p><p><img src="/2023/11/12/OmniLedger/image-20231112132409442.png" alt="image-20231112132409442"></p><p>在SimpleLedger的例子中，每轮有一个可信的random beacon，将验证者分到不同的分片中，且验证者能够验证哪些验证者跟自己在同一个分片</p><p><img src="/2023/11/12/OmniLedger/image-20231112132715120.png" alt="image-20231112132715120" style="zoom:150%;"></p><p>简单的设计，带来了很多问题</p><p><img src="/2023/11/12/OmniLedger/image-20231112133139221.png" alt="image-20231112133139221" style="zoom:150%;"></p><p>安全性方面：</p><ul><li>依赖第三方可信的random beacon</li><li>重配置阶段不支持处理交易</li><li>不支持跨片交易</li></ul><h2 id="OmniLedger"><a href="#OmniLedger" class="headerlink" title="OmniLedger"></a>OmniLedger</h2><p><img src="/2023/11/12/OmniLedger/image-20231112133339611.png" alt="image-20231112133339611" style="zoom:150%;"></p><p>主要有6部分工作，包括DRB 平稳的轮切换等，主要介绍三个</p><h3 id="DRB"><a href="#DRB" class="headerlink" title="DRB"></a>DRB</h3><p><img src="/2023/11/12/OmniLedger/image-20231112133730137.png" alt="image-20231112133730137" style="zoom:150%;"></p><h3 id="原子跨片交易"><a href="#原子跨片交易" class="headerlink" title="原子跨片交易"></a>原子跨片交易</h3><p>参考了数据库领域的工作，2阶段承诺</p><p><img src="/2023/11/12/OmniLedger/image-20231112134014422.png" alt="image-20231112134014422"></p><p>存在问题：2阶段承诺不是时间容忍的，敌手可以abort</p><p><img src="/2023/11/12/OmniLedger/image-20231112134516084.png" alt="image-20231112134516084"></p><p>将分片作为server，client将没有commit的交易输入锁定，等待对应输入分片的证明后解锁</p><h3 id="延迟和吞吐量的trade-off"><a href="#延迟和吞吐量的trade-off" class="headerlink" title="延迟和吞吐量的trade-off"></a>延迟和吞吐量的trade-off</h3><p>增大区块大小可以增加吞吐量，但是发送区块和验证区块的延迟会增加</p><p>Omniledger的思路是牺牲部分安全性来降低延迟</p><p>存在两层验证，一层处理数额较小的输入，安全性为90%，一层处理重要的交易</p><p><img src="/2023/11/12/OmniLedger/image-20231112135746820.png" alt="image-20231112135746820" style="zoom:67%;"></p><h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><p>Go语言编写，<a href="https://github.com/dedis/student_18_byzcoin">https://github.com/dedis/student_18_byzcoin</a></p><p>采用了dedis实验室的代码 <a href="https://github.com/dedis">https://github.com/dedis</a></p><p><img src="/2023/11/12/OmniLedger/image-20231112140022164.png" alt="image-20231112140022164" style="zoom:150%;"></p><p>首先测试scale-out，增加节点数量</p><p><img src="/2023/11/12/OmniLedger/image-20231112141351986.png" alt="image-20231112141351986" style="zoom:150%;"></p><p>1120是分片大小为70，16个分片，考虑敌手比例最多为25%，低于BFT的容错</p><p><img src="/2023/11/12/OmniLedger/image-20231112141855252.png" alt="image-20231112141855252" style="zoom:67%;"></p><p>对于延迟，分别测试了2层验证的耗时</p><p><img src="/2023/11/12/OmniLedger/image-20231112142156625.png" alt="image-20231112142156625" style="zoom:67%;"></p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p><img src="/2023/11/12/OmniLedger/image-20231112142320778.png" alt="image-20231112142320778" style="zoom:67%;"></p><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p>Q: 网络分区的影响</p><p>A: 如果发生网络分区，协议停止，不违反比特币的安全性</p><p>Q: 和Algorand的区别</p><p>A: Algorand没有sharding，可以选择将Algorand作为片内共识算法，Omniledger在Algorand之上，可以得到更好的敌手容忍比例</p><p>Q: 交易如何分配到分片内</p><p>A: Omniledger片内共识是参考比特币的，因此节点本地有UTXO数据库。如果存在跨片交易，依赖于原子承诺的设计，输入分片会commit或者abort</p><p>Q: 表格中安全性仅考虑到了25-30%，失败概率$10^{-6}$，如何实现容忍$10^{-10}$的错误概率</p><p>A: 更大的分片大小，trade-off</p><p>Q: 因为目前矿池集中的算力超过了25%，可能达到30% 40% 45%，作者认为可能会如何</p><p>A: 片内如果用比特币的共识能容忍50%的敌手</p><p>Q: 最坏情况下的性能，如所有交易都是跨片交易</p><p>A: 当所有交易都是跨片交易，不再是线性增长的。采用单个共识算法的效率会比sharding更好</p><p>Q: 敌手能否让所有交易都成为跨片交易？</p><p>A: 交易是由client发起的，不是由敌手选择的，因为交易有手续费，跨片交易的手续费比普通交易更高，如果跨3个片交易费可能是片内交易的三倍</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Video&quot;&gt;&lt;a href=&quot;#Video&quot; class=&quot;headerlink&quot; title=&quot;Video&quot;&gt;&lt;/a&gt;Video&lt;/h1&gt;&lt;p&gt;视频链接：&lt;a href=&quot;https://www.youtube.com/watch?v=vHVZ2gD8Ie4&amp;amp;ab_channel=AllHackingCons&quot;&gt;https://www.youtube.com/watch?v=vHVZ2gD8Ie4&amp;amp;ab_channel=AllHackingCons&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;github：&lt;a href=&quot;https://github.com/dedis/student_18_byzcoin&quot;&gt;https://github.com/dedis/student_18_byzcoin&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="Sharding" scheme="https://alleysira.github.io/tags/Sharding/"/>
    
  </entry>
  
  <entry>
    <title>leopard-bft</title>
    <link href="https://alleysira.github.io/2023/10/31/leopard-bft/"/>
    <id>https://alleysira.github.io/2023/10/31/leopard-bft/</id>
    <published>2023-10-31T06:47:05.000Z</published>
    <updated>2024-05-31T13:35:36.230Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Hu K, Guo K, Tang Q, et al. Leopard: Towards High Throughput-Preserving BFT for Large-scale Systems[C]//2022 IEEE 42nd International Conference on Distributed Computing Systems (ICDCS). IEEE, 2022: 157-167.</p><span id="more"></span><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>安装go，将<code>awesomeProject DKG</code> cp到<code>GOROOT</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alleysira@LAPTOP-M4HO8L6S:~/leopard-bft$ sudo cp -r go/src/awesomeProject /usr/local/go/src</span><br><span class="line">alleysira@LAPTOP-M4HO8L6S:~/leopard-bft$ sudo cp -r go/src/DKG /usr/local/go/src</span><br></pre></td></tr></table></figure><p>经典编不过去</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alleysira@LAPTOP-M4HO8L6S:~/leopard-bft/go/src/awesomeProject$ go build main.go</span><br><span class="line"><span class="meta">#</span><span class="bash"> DKG</span></span><br><span class="line">/usr/local/go/src/DKG/bls.go:6:10: fatal error: bls/bls.h: No such file or directory</span><br><span class="line">    6 | #include &lt;bls/bls.h&gt;</span><br><span class="line">      |          ^~~~~~~~~~~</span><br><span class="line">compilation terminated.</span><br></pre></td></tr></table></figure><h3 id="bn"><a href="#bn" class="headerlink" title="bn"></a>bn</h3><p>论文中bls采用了 <a href="https://github.com/dfinity-side-projects/bn，安装">https://github.com/dfinity-side-projects/bn，安装</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">alleysira@LAPTOP-M4HO8L6S:~/bn-master$ make</span><br><span class="line">make -C mcl UPDATE_ASM=1 lib/libmcl.so CFLAGS_USER=-std=c++11 MCL_MAX_BIT_SIZE=384</span><br><span class="line">make[1]: Entering directory &#x27;/home/alleysira/bn-master/mcl&#x27;</span><br><span class="line">g++ -o src/gen src/gen.cpp -g3 -Wall -Wextra -Wformat=2 -Wcast-qual -Wcast-align -Wwrite-strings -Wfloat-equal -Wpointer-arith -m64 -I include -I test -I ../xbyak -I ../cybozulib/include -std=c++11 -fomit-frame-pointer -DNDEBUG -Ofast -march=native -fPIC -DMCL_MAX_BIT_SIZE=384 -DMCL_USE_LLVM=1 -O0</span><br><span class="line">src/gen -old -f src/func.list &gt; src/base64.ll</span><br><span class="line">opt -O3 -o - src/base64.ll -march=x86-64 | llc -O3 -o src/asm/x86-64.s -march=x86-64 -relocation-model=pic  -pre-RA-sched=list-ilp -max-sched-reorder=128</span><br><span class="line">opt: src/base64.ll:16:26: error: expected comma after getelementptr&#x27;s type</span><br><span class="line"><span class="meta">%</span><span class="bash">r5 = getelementptr i64* %r2, i64 %r4</span></span><br><span class="line">                         ^</span><br><span class="line">g++ -c src/asm/x86-64.s -o obj/x86-64.o -g3 -Wall -Wextra -Wformat=2 -Wcast-qual -Wcast-align -Wwrite-strings -Wfloat-equal -Wpointer-arith -m64 -I include -I test -I ../xbyak -I ../cybozulib/include -std=c++11 -fomit-frame-pointer -DNDEBUG -Ofast -march=native -fPIC -DMCL_MAX_BIT_SIZE=384 -DMCL_USE_LLVM=1</span><br><span class="line">src/gen -old -f src/func.list -s bmi2 &gt; src/base64.bmi2.ll</span><br><span class="line">opt -O3 -o - src/base64.bmi2.ll -march=x86-64 | llc -O3 -o src/asm/x86-64.bmi2.s -march=x86-64 -relocation-model=pic  -pre-RA-sched=list-ilp -max-sched-reorder=128 -mattr=bmi2</span><br><span class="line">opt: src/base64.bmi2.ll:16:26: error: expected comma after getelementptr&#x27;s type</span><br><span class="line"><span class="meta">%</span><span class="bash">r5 = getelementptr i64* %r2, i64 %r4</span></span><br><span class="line">                         ^</span><br></pre></td></tr></table></figure><p><code>make clean</code>之后<code>sudo make</code>依然出错，目测是llvm的版本的问题</p><p>github 上相关的issue</p><ul><li><p><a href="https://github.com/dfinity-side-projects/bn/issues/10">https://github.com/dfinity-side-projects/bn/issues/10</a></p></li><li><p><a href="https://github.com/dfinity-side-projects/bn/issues/3">https://github.com/dfinity-side-projects/bn/issues/3</a></p></li></ul><p>opt是llvm的优化器，问题原因是采用的llvm是10.0版本，.ll文件的语法不相同，但是能编译出libbls的两个库和一个libmcl</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">g++ -o src/gen src/gen.cpp -g3 -Wall -Wextra -Wformat=2 -Wcast-qual -Wcast-align -Wwrite-strings -Wfloat-equal -Wpointer-arith -m64 -I include -I test -I ../xbyak -I ../cybozulib/include -std=c++11 -fomit-frame-pointer -DNDEBUG -Ofast -march=native -fPIC -DMCL_MAX_BIT_SIZE=384 -DMCL_USE_LLVM=1 -O0</span><br><span class="line">src/gen -old -f src/func.list &gt; src/base64.ll</span><br><span class="line">opt -O3 -o - src/base64.ll -march=x86-64 | llc -O3 -o src/asm/x86-64.s -march=x86-64 -relocation-model=pic  -pre-RA-sched=list-ilp -max-sched-reorder=128</span><br><span class="line">opt: src/base64.ll:16:26: error: expected comma after getelementptr&#x27;s type</span><br><span class="line"><span class="meta">%</span><span class="bash">r5 = getelementptr i64* %r2, i64 %r4</span></span><br><span class="line">                         ^</span><br><span class="line">g++ -c src/asm/x86-64.s -o obj/x86-64.o -g3 -Wall -Wextra -Wformat=2 -Wcast-qual -Wcast-align -Wwrite-strings -Wfloat-equal -Wpointer-arith -m64 -I include -I test -I ../xbyak -I ../cybozulib/include -std=c++11 -fomit-frame-pointer -DNDEBUG -Ofast -march=native -fPIC -DMCL_MAX_BIT_SIZE=384 -DMCL_USE_LLVM=1</span><br><span class="line">src/gen -old -f src/func.list -s bmi2 &gt; src/base64.bmi2.ll</span><br><span class="line">opt -O3 -o - src/base64.bmi2.ll -march=x86-64 | llc -O3 -o src/asm/x86-64.bmi2.s -march=x86-64 -relocation-model=pic  -pre-RA-sched=list-ilp -max-sched-reorder=128 -mattr=bmi2</span><br><span class="line">opt: src/base64.bmi2.ll:16:26: error: expected comma after getelementptr&#x27;s type</span><br><span class="line"><span class="meta">%</span><span class="bash">r5 = getelementptr i64* %r2, i64 %r4</span></span><br></pre></td></tr></table></figure><p>应该是缺一个mcl库，因为报错编不出来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/tmp/go-build/cgo-gcc-prolog:1354: undefined reference to `mclBn_precomputedMillerLoop&#x27;</span><br><span class="line">/usr/bin/ld: $WORK/b002/_x004.o: in function `_cgo_7ee38b8fbf18_Cfunc_mclBn_precomputedMillerLoop2&#x27;:</span><br><span class="line">/tmp/go-build/cgo-gcc-prolog:1370: undefined reference to `mclBn_precomputedMillerLoop2&#x27;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure><p>尝试把16.04的库直接拿过来用，不行，有一些函数的接口变了，卒</p><p>尝试修改mcl的Makefile文件，跳过对.ll的报错，失败</p><p><img src="/2023/10/31/leopard-bft/image-20231031180355543.png" alt="image-20231031180355543"></p><p>一个逆天bug，/*cgo xxx*/后面不能有空行，必须直接跟着import “C”</p><p>将存放4个库文件的<code>/usr/local/lib</code>加入到LD路径中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=/lib:/usr/lib:/usr/local/lib</span><br></pre></td></tr></table></figure><p>屈服了，下载3.9版本的llvm用cmake build</p><p>如何build的教程 <a href="https://releases.llvm.org/3.9.0/docs/CMake.html">https://releases.llvm.org/3.9.0/docs/CMake.html</a></p><p><img src="/2023/10/31/leopard-bft/image-20231031221526742.png" alt="image-20231031221526742"></p><p><code>make bn</code>没有报错</p><p>库都正确编译了，但是依然有问题，是fp.cpp文件的6个函数存在undefined reference（不应该啊）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">alleysira@LAPTOP-M4HO8L6S:~/leopard-bft/go/src/awesomeProject$ go build main.go</span><br><span class="line"><span class="meta">#</span><span class="bash"> DKG</span></span><br><span class="line">/usr/bin/ld: /usr/local/lib/libbls384.so: undefined reference to `mcl::fp::copyUnitToByteAsLE(unsigned char*, unsigned long const*, unsigned long)&#x27;</span><br><span class="line">/usr/bin/ld: /usr/local/lib/libbls384.so: undefined reference to `mcl::fp::copyAndMask(unsigned long*, void const*, unsigned long, mcl::fp::Op const&amp;, bool)&#x27;</span><br><span class="line">/usr/bin/ld: /usr/local/lib/libbls384.so: undefined reference to `mcl::fp::arrayToStr(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;&amp;, unsigned long const*, unsigned long, int)&#x27;</span><br><span class="line">/usr/bin/ld: /usr/local/lib/libbls384.so: undefined reference to `mcl::fp::hash[abi:cxx11](unsigned long, void const*, unsigned long)&#x27;</span><br><span class="line">/usr/bin/ld: /usr/local/lib/libbls384.so: undefined reference to `mcl::fp::streamToArray(bool*, unsigned long*, unsigned long, std::istream&amp;, int)&#x27;</span><br><span class="line">/usr/bin/ld: /usr/local/lib/libbls384.so: undefined reference to `mcl::fp::Op::init(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;, unsigned long, mcl::fp::Mode, unsigned long)&#x27;</span><br><span class="line">collect2: error: ld returned 1 exit status </span><br></pre></td></tr></table></figure><p>猜测是bn库的版本不对（并不是）</p><p>是因为忘记删除之前<code>\usr\lib\</code>下尝试的新版的mcl编出来的libbslxx.so</p><p>以下是最终能通过build的bls.go</p><p><img src="/2023/10/31/leopard-bft/image-20231031231943209.png" alt="image-20231031231943209"></p><p>把<code>simulateUnderNode\network</code>文件夹cp到<code>GOROOT</code>下即可运行</p><h2 id="第二次环境配置"><a href="#第二次环境配置" class="headerlink" title="第二次环境配置"></a>第二次环境配置</h2><h3 id="安装bn库"><a href="#安装bn库" class="headerlink" title="安装bn库"></a>安装bn库</h3><p>先安装llvm3.9</p><p>编译教程：<a href="https://releases.llvm.org/3.9.0/docs/CMake.html">https://releases.llvm.org/3.9.0/docs/CMake.html</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -DCMAKE_INSTALL_PREFIX=/path -P cmake_install.cmake</span><br></pre></td></tr></table></figure><p>在./.bashrc中修改环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PATH=/home/majie/llvm-3.9/lib/bin:$PATH</span><br><span class="line">llvm-as --version</span><br></pre></td></tr></table></figure><p>安装好llvm后，修改bn make install时的指定位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">make install PREFIX=/home/majie/lib</span><br><span class="line">修改 ~/.bashrc</span><br><span class="line">export GOPATH=/home/majie</span><br><span class="line">export PATH=/home/majie/llvm-3.9/lib/bin:$PATH</span><br><span class="line">export LD_LIBRARY_PATH=/home/majie/lib/lib:/lib:/usr/lib:/usr/local/lib</span><br><span class="line">export LIBRARY_PATH=$LIBRARY_PATH:/home/majie/lib/lib</span><br><span class="line">export CPLUS_INCLUDE_PATH=$CPLUS_INCLUDE_PATH:/home/majie/lib/include</span><br><span class="line">export C_INCLUDE_PATH=$C_INCLUDE_PATH:/home/majie/lib/include</span><br></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/src/awesomeProject$: bash a.sh</span><br><span class="line">~/src/simulateUnderNode$: go run main.go 1</span><br><span class="line">~/src/client$: bash client.sh</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>4个terminal对应4个节点</p><p><img src="/2023/10/31/leopard-bft/image-20231031233119579.png" alt="image-20231031233119579"></p><p><img src="/2023/10/31/leopard-bft/image-20231031233148849.png" alt="image-20231031233148849"></p><p><img src="/2023/10/31/leopard-bft/image-20231031233209582.png" alt="image-20231031233209582"></p><p><img src="/2023/10/31/leopard-bft/image-20231031233217854.png" alt="image-20231031233217854"></p><p><img src="/2023/10/31/leopard-bft/image-20231031233204879.png" alt="image-20231031233204879"></p><p><img src="/2023/10/31/leopard-bft/image-20231031233312013.png" alt="image-20231031233312013"></p><h1 id="报告笔记"><a href="#报告笔记" class="headerlink" title="报告笔记"></a>报告笔记</h1><p>胡可欣老师详细介绍了工作</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Hotstuff是diem链底层的共识</p><p>半同步网络模型下，已经被证明支持的恶意敌手上界是1/3</p><p>传统的BFT类共识，当节点规模扩大，吞吐量急剧下降</p><ul><li>PBFT &gt;100</li></ul><p><img src="/2023/10/31/leopard-bft/image-20231102141032382.png" alt="image-20231102141032382"></p><p>提升可扩展性的方法</p><ul><li>横向扩展 scale out：共识节点分组，各组对交易并行，分片属于横向方案<ul><li>安全性要求组的大小为600 1000，和想要得到大规模节点的需求之间存在矛盾关系</li></ul></li><li>纵向扩展scale up：给每个节点增加物理资源，存在瓶颈</li></ul><p>发现瓶颈存在于领导者</p><ul><li>错误概率的问题<ul><li>组合</li><li>项目指标安全性要求是单片$10^{-18}$</li></ul></li><li>网络模型<ul><li>半同步 影响活性，一致性与网络模型无关</li><li>Dumbo系列共识是异步</li></ul></li></ul><p>Hotstuff降低了通信复杂度，存在轮数增加的问题；实验结果显示Hotstuff确实提高了性能和规模 </p><h2 id="协议设计"><a href="#协议设计" class="headerlink" title="协议设计"></a>协议设计</h2><ul><li><p>数据传输与共识解耦：先分摊交易，由领导者决定哪些交易当前轮打包</p><ul><li>怎么保证 交易分散没有交集 每个节点都拥有全集，发送时可能 mod 4</li><li>发 Hash(datablock) ，通过调整尺寸来保证复杂度不是n^2</li><li>复杂度是摊销的结果，实际没有降低复杂度</li></ul></li><li><p>纠删码</p><ul><li>法定人数2f+1，一定能收到f+1个好的纠删码片段</li><li>如何判断收到纠删码的完整性：带线性长度的证明</li><li>设计没有考虑proposal可能是交易，实际场景可能存在双花问题</li></ul></li></ul><h2 id="协议实现"><a href="#协议实现" class="headerlink" title="协议实现"></a>协议实现</h2><ul><li><p>实现</p><ul><li>信道 reliable and auth：不是工业界的实现</li><li>execution engine<ul><li>bls需要额外进行DKG</li><li>rate-limiter : 限制数据块分散交易的频率，利用到了半同步</li><li>双通道 go channel（共识优先级高于数据）</li></ul></li></ul></li><li><p>实验</p><ul><li>增加节点数量：600个节点，吞吐量仍然在10w</li><li>增加节点资源：斜率更高</li><li>杭州：一个机器 一个核，1个核能否带多个节点（docker）</li><li>软件所资源目前能使用的资源200个CPU</li><li>具体系统实现用的签名：<ul><li>猎豹采用的是bls门限签名</li><li>Schnorr（复旦大学李强老师）</li><li>ecdsa（pipelined Hotstuff）</li></ul></li><li>规模运行到600时，一笔交易确认已经非常困难了，由于databa</li></ul></li><li><p>安全性</p><ul><li>目前$n=600,Pr_{error}&lt;10^{-6},n=1000,Pr_{error}&lt;10^{-9}$，指标要求的是$10^{-18}$</li></ul></li><li><p>后续工作</p><ul><li>尽快将分片共识的框架搭起来，缺少经验可以学习一下刘老师团队的工作</li><li>明确能否在1个核上运行2个节点</li><li>实现安全性可以考虑gearbox，目前leopard BFT代码里是有一条底层链的实现的</li><li>leopard BFT有后续引用工作：Hu Z, Guan S, Xu W, et al. A Data Flow Framework with High Throughput and Low Latency for Permissioned Blockchains[C]//2023 IEEE 43rd International Conference on Distributed Computing Systems (ICDCS). IEEE, 2023: 1-12.</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Hu K, Guo K, Tang Q, et al. Leopard: Towards High Throughput-Preserving BFT for Large-scale Systems[C]//2022 IEEE 42nd International Conference on Distributed Computing Systems (ICDCS). IEEE, 2022: 157-167.&lt;/p&gt;</summary>
    
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="Consensus" scheme="https://alleysira.github.io/tags/Consensus/"/>
    
    <category term="Sharding" scheme="https://alleysira.github.io/tags/Sharding/"/>
    
  </entry>
  
</feed>
