<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Alleysira&#39;s blog</title>
  
  
  <link href="https://alleysira.github.io/atom.xml" rel="self"/>
  
  <link href="https://alleysira.github.io/"/>
  <updated>2023-06-20T14:01:18.808Z</updated>
  <id>https://alleysira.github.io/</id>
  
  <author>
    <name>Alleysira</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>blockchain security survey</title>
    <link href="https://alleysira.github.io/2023/06/20/blockchain-security-survey/"/>
    <id>https://alleysira.github.io/2023/06/20/blockchain-security-survey/</id>
    <published>2023-06-20T03:48:28.000Z</published>
    <updated>2023-06-20T14:01:18.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="智能合约漏洞检测研究综述-李雷孝-计算机科学与探索"><a href="#智能合约漏洞检测研究综述-李雷孝-计算机科学与探索" class="headerlink" title="智能合约漏洞检测研究综述-李雷孝-计算机科学与探索"></a>智能合约漏洞检测研究综述-李雷孝-计算机科学与探索</h1><p>介绍了重入攻击漏洞、整数溢出以及访问控制漏洞的分析</p><p>给出了形式化验证、符号执行、机器学习等方法和工具的现状以及优缺点</p><p>复现了部分工具，给出了检测速度、准确率、漏洞数量等性能对比</p><h2 id="区块链和智能合约"><a href="#区块链和智能合约" class="headerlink" title="区块链和智能合约"></a>区块链和智能合约</h2><p>安全问题出现的原因主要有:</p><ul><li><p>智能合约一旦部署不可修改</p></li><li><p>合约执行后不可逆</p></li><li><p>编程语言自身问题或程序员的逻辑问题</p></li></ul><p>智能合约的设计准则：</p><ul><li>可观察性</li><li>客观可核查</li><li>相对性</li><li>可执行性</li></ul><p>智能合约一般采用高级语言Solidity编写，智能合约应用采用EVM字节码编码后存储在区块链上</p><h2 id="智能合约的漏洞"><a href="#智能合约的漏洞" class="headerlink" title="智能合约的漏洞"></a>智能合约的漏洞</h2><p><img src="/2023/06/20/blockchain-security-survey/image-20230620164027253.png" alt="image-20230620164027253"></p><ul><li><p>重入漏洞：<code>fallback</code>函数在调用结束前让攻击者有机会再执行被调用的函数，类似于递归调用</p><ul><li><code>fallback</code>在合约调用没有匹配到函数签名，或者调用没有带任何数据时被自动调用。</li></ul></li><li><p>整数溢出：以太坊提供了SafeMath库，会提前检测整数溢出</p><ul><li>乘法</li><li>加法</li><li>减法</li></ul></li><li><p>访问控制漏洞：合约中函数的权限设置不合理，如未定义类型的函数默认为public</p></li><li>交易顺序依赖攻击：算出PoW的矿工可以选择打包哪些交易，攻击者可以观察交易池中存在哪些可能对自己不利的交易，攻击者可以创建包含更高gas的交易，使得自己被优先打包，核心问题是矿工根据gas交易来选择打包的交易</li><li>对可预测变量的依赖：以太坊的随机数通过区块的某些属性来生成，攻击者可能能够预测到随机数的生成</li><li>tx-origin滥用：<code>tx-origin</code>作为一个全局变量，能够回溯整个调用栈被返回租出发起交易的合约地址，当合约使用该变量进行验证或授权，可能能够绕过某些判断语句</li><li>DoS：可能导致合约被锁定，用户的加密货币无法取回</li><li>动态数组双重访问攻击：不同变量可能存储在同一个位置，可能导致变量被覆盖，目前没有有效的工具<ul><li>绕过</li><li>提权</li></ul></li></ul><h2 id="智能合约漏洞检测方法"><a href="#智能合约漏洞检测方法" class="headerlink" title="智能合约漏洞检测方法"></a>智能合约漏洞检测方法</h2><p>不可篡改性：上链前</p><h3 id="形式化验证"><a href="#形式化验证" class="headerlink" title="形式化验证"></a>形式化验证</h3><ul><li>BAN逻辑</li><li>模型检验</li><li>密码学原语代数属性的形式化方法</li><li><p>基于定理证明</p></li><li><p>形式化验证包括</p><ul><li>模型检验：列举出所有可能的状态主义检验</li><li>演绎验证</li></ul></li><li>形式化验证的工具：<ul><li>ZEUS. KALRA S, GOEL S, DHAWAN M, et al. ZEUS: analyzing safety of smart contracts[C]//Proceedings of the 25th Annual Network and Distributed System Security Symposium, San Diego, Feb 18-21, 2018: 1-15.<ul><li>无法检测重入攻击和跨功能的分析策略</li></ul></li><li>Isabelle/HOL：针对EVM 字节码进行检测</li></ul></li></ul><h3 id="符号执行的审计方法"><a href="#符号执行的审计方法" class="headerlink" title="符号执行的审计方法"></a>符号执行的审计方法</h3><p>将代码中的变量符号化符号化程序输入，符号执行能够为所有的执行路径维护一组约束，执行之后，约束求解<br>器将用于求解约束并确定该执行的输入，最后利用约束求解器得到新的测试输入，检测符号值是否可以产生漏洞。</p><p><img src="/2023/06/20/blockchain-security-survey/image-20230620173459648.png" alt="image-20230620173459648"></p><p>步骤：符号化、逐条解释、更新状态搜集路径约束，完成所有路径的探索（安全问题）</p><ul><li><p>Oyente 第一个用于以太坊上的漏洞检测支持重入漏洞、交易顺序依赖以及伪随机等安全漏洞的检测，但是该工具对于自杀合约和<code>tx-origin</code> 的滥用问题并不能做到有效的检测</p></li><li><p>Mythril <a href="https://pypi.org/project/mythril/">mythril · PyPI</a><a href="https://pypi.org/project/mythril/">mythril · PyPI</a></p></li><li>MythX <a href="https://mythx.io/">MythX: Smart contract security service for Ethereum</a></li></ul><h3 id="利用模糊测试的审计方法"><a href="#利用模糊测试的审计方法" class="headerlink" title="利用模糊测试的审计方法"></a>利用模糊测试的审计方法</h3><p>提供非预期输入监视异常结果来发现软件漏洞。</p><p>核心思想是将自动或半自动生成的随机数输入程序并检测到程序的异常。</p><p>工具：</p><ul><li>ContractFuzzer 分析日志进行分析检测  JIANG B, LIU Y, CHAN W K. ContractFuzzer: fuzzing smart contracts for vulnerability detection[C]//Proceedings of the 33rd ACM/IEEE International Conference on Automated Software Engineering, Montpellier, Sep 3-7, 2018. New York: ACM, 2018: 259-269.</li><li>SoliAudit 机器学习和模糊测试结合  LIAO J W, TSAI T T, HE C K, et al. SoliAudit: smart contract<br>vulnerability assessment based on machine learning and fuzz testing[C]//Proceedings of the 6th International Conference on Internet of Things: Systems, Management and Security, Granada, Oct 22-25, 2019. Piscataway: IEEE, 2019: 458-465.</li><li>GasFuzzer 检测交易中有较高gas 消耗异常的工具</li></ul><h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><p>多将代码转换为控制流图，利用CFG进行切片，对切片矩阵建立了机器学习的决策模型</p><p>准确率较高，研究丰富</p><h3 id="其他方法的漏洞检测技术"><a href="#其他方法的漏洞检测技术" class="headerlink" title="其他方法的漏洞检测技术"></a>其他方法的漏洞检测技术</h3><p>以太坊中，透明公开的智能合约占了总交易量和总交易金额的2/3 左右，但是有大约77.3%的智<br>能合约是不透明非开源的</p><ul><li><p>Erays 采用逆向工程进行漏洞检测，难以实现高自动化，更适合于手动分析并且高度依赖专家经验 ZHOU Y, KUMAR D, BAKSHI S, et al. Erays: reverse engineering Ethereum’s opaque smart contracts[C]//Proceedings of the 27th USENIX Security Symposium, Baltimore, Aug 15-17, 2018. Berkeley: USENIX Association, 2018: 1371-1385.</p></li><li><p>Dc-Hunter 计算待检测合约和已知合约的相似性</p></li><li>Slither 将智能合约转化为中间表示SlithIR  FEIST J, GREICO G, GROCE A. Slither: a static analysis<br>framework for smart contracts[C]//Proceedings of the 2nd International Workshop on Emerging Trends in Software Engineering for Blockchain, Montreal, May 27, 2019. Piscataway: IEEE, 2019: 8-15.</li><li>EASYFLOW  GAO J B, LIU H, LIU C, et al. EASYFLOW: keep Ethereum away from overflow[C]//Proceedings of the 41st International Conference on Software Engineering: Companion Proceedings, Montreal, May 25-31, 2019. Piscataway: IEEE, 2019: 23-26.</li><li>SmartCheck  TIKHOMIROV S, VOSKRESENSKAYA E, IVANITSKIY I, et al. SmartCheck: static analysis of ethereum smart contracts [C]//Proceedings of the 1st IEEE/ACM International Workshop on Emerging Trends in Software Engineering for Blockchain, Gothenburg, May 27-Jun 3, 2018. New York:ACM, 2018: 9-16.</li></ul><h3 id="各类方案存在的问题"><a href="#各类方案存在的问题" class="headerlink" title="各类方案存在的问题"></a>各类方案存在的问题</h3><ul><li>形式化验证：数学推导和证明门槛高，自动化程度低</li><li>符号执行：涉及到路径遍历和约束问题，耗时</li><li>模糊测试：随机种子难以设计</li><li>机器学习方法：检测结果最好，依赖于开源的智能合约；需要对每种漏洞进行建模，降低了通用性</li><li>特征匹配：依赖开源代码，误报率高</li></ul><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p>450个智能合约</p><p>对VaaS、Oyente、ContractFuzzer、DR-GCN、Slither进行了对比，主要测试可重入和可预测变量的依赖两种类型漏洞进行检测</p><p><img src="/2023/06/20/blockchain-security-survey/image-20230620193254180.png" alt="image-20230620193254180"></p><p>实验结果显示机器学习的准确率最高，效率较高，但是支持的漏洞少，通用性差</p><p>Vaas 是商用级别的漏洞检测工具</p><h2 id="未来研究方向"><a href="#未来研究方向" class="headerlink" title="未来研究方向"></a>未来研究方向</h2><ul><li>符号执行的路径优化</li><li>提高自动化程度：深度学习</li><li>提高漏洞类型覆盖率：目前众多漏洞检测工具个体支持检测的漏洞类型最多不超过10 种，但现有常见的漏洞类型多达 20 多种。机器学习实现通用模型</li><li>准确率和效率：解决假阳等问题</li><li>智能合约开源程度较低</li><li>机器学习方法构建通用模型</li><li>跨平台的漏洞检测工具</li><li>缺乏统一的评价指标</li></ul><h1 id="区块链安全问题-研究现状与展望-袁勇-自动化学报"><a href="#区块链安全问题-研究现状与展望-袁勇-自动化学报" class="headerlink" title="区块链安全问题: 研究现状与展望-袁勇-自动化学报"></a>区块链安全问题: 研究现状与展望-袁勇-自动化学报</h1><p>定义了区块链系统设计追求的安全目标, 从机制漏洞、攻击手段和安全措施三方面对区块链各层级的安全问题进行全面分析, 提出了区块链的平行安全概念框架, 并总结未来区块链安全问题的研究重点.</p><h2 id="区块链的安全目标"><a href="#区块链的安全目标" class="headerlink" title="区块链的安全目标"></a>区块链的安全目标</h2><p><img src="/2023/06/20/blockchain-security-survey/image-20230620200830216.png" alt="image-20230620200830216" style="zoom:67%;"></p><ul><li><p>实现保密性需要设计三类机制</p></li><li><p>共识安全部分主要参考了backbone，需要阅读这篇</p></li><li><p>强一致性不会出现分叉，确认快，前向安全</p></li><li><p>隐私保护</p><ul><li>身份隐私保护身份信息、物理地址、IP和链上的公私钥不关联</li><li>交易隐私保护：交易本身对非授权节点匿名，交易之间的关联被切断</li></ul></li><li><p>智能合约安全</p><ul><li>编写安全<ul><li>设计没问题</li><li>代码安全</li></ul></li><li>运行安全：合约执行出现漏洞或被攻击后，不会对节点和本地设备造成影响，不会影响调用合约的其他合约异常<ul><li>模块化：智能合约的高内聚低耦合</li><li>隔离运行：运行在虚拟化等隔离环境中</li></ul></li></ul></li></ul><h2 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h2><p>数据层、网络层、共识层、激励层、合约层和应用层六层</p><p><img src="/2023/06/20/blockchain-security-survey/image-20230620203308163.png" alt="image-20230620203308163"></p><ul><li>数据层：<ul><li>量子计算</li><li>密钥管理：区块链应用中的主流密钥管理方法包括本地存储、离线存储、托管钱包和门限钱包. <ul><li>密钥保护秘密分享[CCS11]</li></ul></li><li>交易联系：环签名、零知识证明、zk-SNARK</li><li>代码漏洞：</li></ul></li><li></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;智能合约漏洞检测研究综述-李雷孝-计算机科学与探索&quot;&gt;&lt;a href=&quot;#智能合约漏洞检测研究综述-李雷孝-计算机科学与探索&quot; class=&quot;headerlink&quot; title=&quot;智能合约漏洞检测研究综述-李雷孝-计算机科学与探索&quot;&gt;&lt;/a&gt;智能合约漏洞检测研究综</summary>
      
    
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>Sharding_Blockchain_Consensus</title>
    <link href="https://alleysira.github.io/2023/05/31/Sharding-Blockchain-Consensus-lyj/"/>
    <id>https://alleysira.github.io/2023/05/31/Sharding-Blockchain-Consensus-lyj/</id>
    <published>2023-05-31T08:23:34.000Z</published>
    <updated>2023-06-04T12:56:42.642Z</updated>
    
    <content type="html"><![CDATA[<p>云南创新研究院研讨会 刘懿中老师分片共识研究分享</p><span id="more"></span><h1 id="分片区块链共识机制研究"><a href="#分片区块链共识机制研究" class="headerlink" title="分片区块链共识机制研究"></a>分片区块链共识机制研究</h1><h2 id="区块链共识机制"><a href="#区块链共识机制" class="headerlink" title="区块链共识机制"></a>区块链共识机制</h2><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531163125372.png" alt="image-20230531163125372"></p><p>1982年提出了拜占庭将军问题</p><p>FLP提出异步环境下没有确定性一致算法</p><p>2016年ELASTICO是首个分片共识，结合数据库领域的分片技术</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531163950433.png" alt="image-20230531163950433"></p><p>分片的基本流程</p><ul><li>选出块者<ul><li>随机出块</li></ul></li><li>生成区块并广播</li><li>节点验证更新区块链</li></ul><p>一致性consistency：指诚实节点输出的交易互为前缀</p><ul><li>强一致性：PBFT</li><li>弱一致性：PoW PoS</li></ul><p>活性liveness：交易一定会被处理</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531164356367.png" alt="image-20230531164356367"></p><p>性能+安全性都取决于共识机制</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531164845023.png" alt="image-20230531164845023"></p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531164926354.png" alt="image-20230531164926354"></p><p>经典的分布式一致算法能够容忍宕机错误（crash）</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531165205097.png" alt="image-20230531165205097"></p><p>现在研究工作集中于异步网络环境下，信工所路远老师 清华段斯斯老师等均有相关研究工作</p><p>异步DKG，如何在动态环境下更新委员会，实现动态门限签名</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531165353683.png" alt="image-20230531165353683"></p><p>PoW的能防止女巫攻击</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531165444310.png" alt="image-20230531165444310"></p><p>PoW和PoS的安全性已经足够好了，但是性能比较低，设计混合共识的动机</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531165609984.png" alt="image-20230531165609984"></p><p>先用PoW和PoS选委员会，委员会内跑PBFT等</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531165938027.png" alt="image-20230531165938027"></p><p>多个委员会，每个委员会并行处理交易，分片登场了</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531170048237.png" alt="image-20230531170048237"></p><h2 id="分片区块链技术"><a href="#分片区块链技术" class="headerlink" title="分片区块链技术"></a>分片区块链技术</h2><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531170221192.png" alt="image-20230531170221192"></p><p>如果在安全性上妥协，可以提高可扩展性</p><p>分片的思想就是将节点划分到不同的子集，每个分片负责维护本分片区块链</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531170346117.png" alt="image-20230531170346117"></p><p>共识节点分片，交易分片</p><ul><li><p>计算分片：分片内只验证分片内的交易</p></li><li><p>存储分片：片内节点只存片内的区块链</p></li><li>通信分片：大多数情况不需要和分片外节点通信</li></ul><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531170603682.png" alt="image-20230531170603682"></p><p>时期epoch是为了防止节点的腐化攻击设置的，进行重新配置</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531170753693.png" alt="image-20230531170753693"></p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531171408957.png" alt="image-20230531171408957"></p><p>完整的分片区块链系统</p><ul><li>节点选择<ul><li>permissionless：PoW/PoS</li><li>permissioned：CA</li></ul></li><li>随机数生成与节点分配：节点划分为不同分片过程中一般需要随机化分配（不随机的方案需要考虑敌手控制的节点低于某个阈值）<ul><li>VRF 门限签名 VSS TEE</li></ul></li><li>分片内共识：都可以<ul><li>PBFT PoW</li><li>有的交易需要跨片协同交易</li></ul></li><li>跨片交易处理</li><li>分片重配置：应对敌手corruption</li><li>激励机制：有一些博弈论的结论</li></ul><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531171805722.png" alt="image-20230531171805722"></p><p>公平性是节点选中的概率相同，鲁棒性指一定能选出来</p><p>委员会中心化问题后续可以再了解了解</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531171935276.png" alt="image-20230531171935276"></p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531172038191.png" alt="image-20230531172038191"></p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531172228946.png" alt="image-20230531172228946"></p><p>BLS签名不管签名的 $t$ 个人是谁，签名是unique，需要DKG，实际上DKG</p><p>随机数生成复杂度一般是$O(n^2)$，因此需要先选一部分节点来做</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531173107903.png" alt="image-20230531173107903"></p><p>利用概率来考虑如何进行节点分配</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531173338979.png" alt="image-20230531173338979"></p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531173458813.png" alt="image-20230531173458813"></p><p>一致性的定义基于backbone protocol </p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531173630844.png" alt="image-20230531173630844"></p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531173726776.png" alt="image-20230531173726776"></p><p>2 phase commitment</p><ul><li>准备阶段 两个分片运行片内共识，确认交易可用性，锁定输入（防止双花，直到第二轮片内共识结束）</li><li>承诺阶段 </li></ul><p>多输入输出拆分后不需要跨片吗，没理解</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531174150817.png" alt="image-20230531174150817"></p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531174655816.png" alt="image-20230531174655816"></p><p>替换的方法：</p><ul><li>随机</li><li>时间规则（rapid chain）</li><li>有界布谷鸟</li></ul><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531174810883.png" alt="image-20230531174810883"></p><p>基于博弈论的思想，分片+博弈+reputation的研究很少，有研究价值</p><p>以上研究内容发表在computer science review，中科院Q1的综述</p><h2 id="Fleetchain"><a href="#Fleetchain" class="headerlink" title="Fleetchain"></a>Fleetchain</h2><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531175230991.png" alt="image-20230531175230991"></p><p>分片内签名可以聚合$O(n^2)\to O(n)$，是否可以在分片内签名聚合</p><p>片间复杂度同样降低$O(m^2)\to O(m)$</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531175429371.png" alt="image-20230531175429371"></p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531175438271.png" alt="image-20230531175438271"></p><p>共识协议的安全性一般依赖于数字签名的安全性</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531175529500.png" alt="image-20230531175529500"></p><p>将hotstuff每轮换leader改成stable leader</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531175600846.png" alt="image-20230531175600846"></p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531175612448.png" alt="image-20230531175612448"></p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531175639194.png" alt="image-20230531175639194"></p><p>两部分都是线性复杂度</p><h2 id="跨片交易处理"><a href="#跨片交易处理" class="headerlink" title="跨片交易处理"></a>跨片交易处理</h2><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531175713097.png" alt="image-20230531175713097"></p><p>交易输入地址可能是共有的，众筹服务器！</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531175835847.png" alt="image-20230531175835847"></p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531175944598.png" alt="image-20230531175944598"></p><p>由用户将每个分片给的证明再转发</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531180116957.png" alt="image-20230531180116957"></p><p>分片直接互相广播，用户无感知</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531180154281.png" alt="image-20230531180154281"></p><p>1个交易2个BFT，如果2次BFT处理1k个交易，输入merkle树根，输出树的路径证明</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531180335584.png" alt="image-20230531180335584"></p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531180437719.png" alt="image-20230531180437719"></p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531180507265.png" alt="image-20230531180507265"></p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531180613883.png" alt="image-20230531180613883"></p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531180625949.png" alt="image-20230531180625949"></p><h2 id="跨片视图转换"><a href="#跨片视图转换" class="headerlink" title="跨片视图转换"></a>跨片视图转换</h2><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531180651927.png" alt="image-20230531180651927"></p><p>不同分片的领导者片间可能作恶，片内诚实</p><p>比如片间不发送证明，领导者censor</p><p>思想是本分片监控其他分片领导者是否作恶，作恶则运行BFT给出作恶的证明，发送给作恶分片进行视图转换</p><p><img src="/2023/05/31/Sharding-Blockchain-Consensus-lyj/image-20230531180923215.png" alt="image-20230531180923215"></p><ul><li>记得扒一下老师的工作</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;云南创新研究院研讨会 刘懿中老师分片共识研究分享&lt;/p&gt;</summary>
    
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="Consensus" scheme="https://alleysira.github.io/tags/Consensus/"/>
    
    <category term="Sharding" scheme="https://alleysira.github.io/tags/Sharding/"/>
    
  </entry>
  
  <entry>
    <title>FSS</title>
    <link href="https://alleysira.github.io/2023/05/06/FSS/"/>
    <id>https://alleysira.github.io/2023/05/06/FSS/</id>
    <published>2023-05-06T06:53:58.000Z</published>
    <updated>2023-06-06T09:50:06.382Z</updated>
    
    <content type="html"><![CDATA[<p>Elette Boyle’s lecture on FSS from <a href="[The 12th BIU Winter School on Cryptography | BIU Cyber Center](https://cyber.biu.ac.il/event/the-12th-biu-winter-school-on-cryptography/">12th BIU Winter School</a>)</p><span id="more"></span><h1 id="Function-Secret-Sharing"><a href="#Function-Secret-Sharing" class="headerlink" title="Function Secret Sharing"></a>Function Secret Sharing</h1><p><img src="/2023/05/06/FSS/image-20230506145622804.png" alt="image-20230506145622804"></p><p>简单介绍加性秘密分享</p><p>考虑分享一个秘密的函数，份额通信量非常小（compact）</p><p>FSS is compressing the truth table of additive secret sharing </p><p>3Hours：</p><ul><li>定义和性质</li><li>构造</li><li>扩展和应用</li></ul><h2 id="definition"><a href="#definition" class="headerlink" title="definition"></a>definition</h2><ul><li>$Gen(1^\lambda,f)\to(f_0,f_1)$ some times $k_0,k_1$</li><li><p>$Eval(b,k_b,x)\to y_b$, $x$ is the public input,$y_b$ is the output share </p><p>satisfying</p></li><li><p>secrecy (semantic security): $\forall f,f’ \in \mathcal{F}, \{k_b \in f\} \approx \{ k_b \in f’\}$</p><ul><li>statistically close</li><li>relaxed bond: relaxed on hardness problem</li><li>simulation security</li></ul></li><li><p>reconstruction: $y_0+y_1=f(x)$</p><ul><li>other forms are acceptable</li></ul></li><li><p>FSS For All functions(truth table)</p><ul><li>using additive secret sharing but the share size is  $O(2^n),where \ input\ len\ is\ nbits$</li></ul></li><li><p>Linear functions over ring $R$</p><ul><li>using  coefficients additive secret sharing</li></ul></li><li><p>polynomials</p><ul><li>also using  coefficients additive secret sharing</li></ul></li></ul><p>Notes: <em>secret</em> linear combination of <em>public</em> function of x and All the constructions above are information-secure </p><p>for some classes of functions can only get computational security</p><ul><li>Point functions<ul><li>$f_{\alpha,\beta}(x)=\alpha $ only when $x=\alpha$, else eval 0</li></ul></li></ul><h3 id="Sample-Application"><a href="#Sample-Application" class="headerlink" title="Sample Application"></a>Sample Application</h3><p>similar to PIR</p><p><img src="/2023/05/06/FSS/image-20230506154438168.png" alt="image-20230506154438168"></p><p> <img src="/2023/05/06/FSS/image-20230506154931929.png" alt="image-20230506154931929"></p><p>2服务器 计算安全的PIR的结果和FSS结果不谋而合 （<strong>corollary</strong>）</p><p>AES is unbreakable, means lightweight crypto</p><p>FSS for points Functions \to 2- server PIR</p><p><img src="/2023/05/06/FSS/image-20230506155829634.png" alt="image-20230506155829634"></p><p>正确显然成立，黑色框是0的秘密分享，$y_A\  y_B$求和后只剩下$val[i]$</p><p> FSS for Point Functions ⇒ Private Increment satisifying p</p><p>Q: garble circuits as a weak case of FSS</p><p>A: yes, reconstruction is not additive, former applications won’t go directly </p><p>Q: how to complete private read and write an the same time</p><p>A: Not possible. reading needs server to store same data, writing needs server to hold shared data, changing sever numbers may </p><p>Q: point functions can’t be described as low degree <strong>polynomial</strong> having FSS for low degree polynomials and FSS for distributed point function</p><h2 id="Construction"><a href="#Construction" class="headerlink" title="Construction"></a>Construction</h2><h3 id="point-functions"><a href="#point-functions" class="headerlink" title="point functions"></a>point functions</h3><p>DPF的第一个构造来自于[CG99]对PIR的构造，$n$是函数输入的bits</p><p><img src="/2023/05/06/FSS/image-20230606164441993.png" alt="image-20230606164441993"></p><h3 id="comparison-functions"><a href="#comparison-functions" class="headerlink" title="comparison functions"></a>comparison functions</h3>]]></content>
    
    
    <summary type="html">&lt;p&gt;Elette Boyle’s lecture on FSS from &lt;a href=&quot;[The 12th BIU Winter School on Cryptography | BIU Cyber Center](https://cyber.biu.ac.il/event/the-12th-biu-winter-school-on-cryptography/&quot;&gt;12th BIU Winter School&lt;/a&gt;)&lt;/p&gt;</summary>
    
    
    
    <category term="Crypto" scheme="https://alleysira.github.io/categories/Crypto/"/>
    
    
    <category term="Crypto" scheme="https://alleysira.github.io/tags/Crypto/"/>
    
  </entry>
  
  <entry>
    <title>Rabin81</title>
    <link href="https://alleysira.github.io/2023/04/14/Rabin81/"/>
    <id>https://alleysira.github.io/2023/04/14/Rabin81/</id>
    <published>2023-04-14T08:37:35.000Z</published>
    <updated>2023-04-16T13:39:14.075Z</updated>
    
    <content type="html"><![CDATA[<p>Michael O. Rabin. How to exchange secrets with oblivious transfer. Technical Report TR-81, Aiken Computation Lab, Harvard University, 1981.</p><span id="more"></span><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Alice和Bob分别拥有一个对方想要解密的加密文件，密钥为1 bit秘密$SA\ SB$，因此两人想要交换$SA\ SB$</p><p>但是存在问题，如果密钥错误，文件会损坏不能再解密。因此Alice和Bob都想要保证能够正确解密文件</p><p>如果Bob给了Alice错误的密钥$S\neq SB$，交换得到了正确的$SA$，这是Alice不希望发生的情况</p><p>如果Bob发送一条消息， <strong>My secret is S, signed Bob.</strong> Alice可以收到$S$后不发给Bob $SA$，这是Bob不希望发生的情况，Alice也可以耍赖 <strong>“I gave Bob the password SA and he has not used it; I am willing to reveal it again right now.”</strong> 尽管Bob最终能够得到$SA$，Alice已经占据了时间优势</p><p>进行归纳，协议的流程总是分为$Alcie \to^{I_i} Bob, Bob \to^{J_i} Alice $，总会存在一个$k$满足Bob可以从$\{I_1,\dots,I_k\}$中得知$SA$，而Alice不能从$\{J_1,\dots,J_{k-1}\}$中得知$SB$，因此需要设计一种协议保证：</p><p>当Bob得知$SA$时，Alice一定可以得知$SB$</p><p>假设：当Bob发送$SA$去读文件时，Alice能够知道这一情况；反之亦然</p><h1 id="Exchange-of-Secrets-Protocol"><a href="#Exchange-of-Secrets-Protocol" class="headerlink" title="Exchange of Secrets Protocol"></a>Exchange of Secrets Protocol</h1><p>假设Alice和Bob目前分别有了公钥$K_A,K_B$可以进行公钥加密与签名。为了简洁，后续的流程中省略了签名</p><ul><li><p>Alice选择两个大素数$p,q$并计算一次性密钥$n_A=pq$，发送给Bob</p></li><li><p>类似地，Bob选择两个大素数$p_1,q_1$并计算一次性密钥$n_B=p_1q_1$，发送给Alice</p></li><li><p>Bob随机选$x\leq n_A$，计算$c \equiv x^2 \bmod n_A$，发送$c$给Alice</p></li><li><p>Alice已知$p,q$，计算出$x_1^2\equiv c \bmod n_A$，发送$x_1$给Bob</p><ul><li>可能会有四个解$\pm x,\pm y$</li><li>Bob可能作弊，发送自己无法求根的$c$，可能会允许R分解$n$，可以通过添加零知识证明来防御 [GMR85]</li></ul></li><li><p>Bob计算$gcd(x-x_1,n_A)=d$，有$Pr(d=p\ or\ q)=1/2$</p><ul><li>如果$x_1\neq \pm x,x_1^2 -x^2\equiv 0 \bmod n_A,(x_1-x)(x_1+x)\equiv0 \bmod n_A$</li><li>即得知 $p,q$，所以概率$Pr(d=p\ or\ q)=1/2$</li></ul></li><li><p>Bob同样执行 $3-4$ 步，定义</p></li><li><script type="math/tex; mode=display">v_B=\begin{cases}0 & if\ gcd(x-x_1,n_A)=p\ or \ q\\1 & otherwise\end{cases}</script></li><li><p>Bob发送$\varepsilon_B=S_B\oplus v_B$</p></li><li><p>同样地，Alice发送$\varepsilon_A=S_A\oplus v_A$</p></li><li><p>Alice将秘密$S_A$放在消息$m_A$中，采用公钥加密$E_{n_A}(m_A)=C$并发送给Bob</p><ul><li>提供$m_A$的一小段前缀来区分4个根</li><li>公钥加密算法采用依赖整数分解的算法即可</li></ul></li><li><p>Bob将秘密$S_B$放在消息$m_B$中，采用公钥加密$E_{n_B}(m_B)=C’$并发送给Bob</p></li></ul><h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p>定理：任何参与方都不能获得秘密的概率为$1/4$</p><p>证明：如果任何参与方在协议正常结束前终止交互，另一方也会停止，两方都无法获得对方的秘密。</p><p>不妨设Alice已经发给了Bob$E_{n_A}(m_A)$，Bob成功解密并对比得到$SA$，当Bob尝试使用$SA$进行文件解密时，根据假设，Alice能够得知$v_B=0$，因此Alice能够计算出$S_B=\varepsilon_B \oplus v_B$；Bob发送$E_{n_B}(m_B)$的情况同理；</p><p>因此任何参与方都不能获得秘密的概率为两方都不能计算出$p,q,p_1,q_1$的概率，即$(1/2)^2=1/4$</p><h2 id="Remark"><a href="#Remark" class="headerlink" title="Remark"></a>Remark</h2><ul><li><p>协议不能迭代执行，考虑当Alice已经知道$SB$，但是直到第二轮结束才查询文件，Bob可能不知道第二轮的$v_A=0$是否成立</p></li><li><p>可以通过修改OT子协议实现正确率</p><ul><li>收到$n_A$后，Bob随机选$x,y\leq n_A$，发送$x^2,y^2 \bmod n_A$，收到解$x_1,y_1$后不知道$p,q$的概率为$1/4$</li><li>协议总的失败率为$(1/4)^2=1/16$</li><li>但是这种方法存在一个上限，如果$Pr[v_B=0]\to0$，则Alice很可能认为Bob知道p，q，即$Pr[\varepsilon_B=S_B]\to 1$</li></ul></li></ul><h1 id="Future-work"><a href="#Future-work" class="headerlink" title="Future work"></a>Future work</h1><ul><li>OT子协议在没有假设的前提下也是有效的，是否能找到其他应用场景</li><li>对EOS协议的假设能否变弱、</li><li>能否构造永远能终止的EOS，或者有人能证明非零的不终止概率是必要的？</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Michael O. Rabin. How to exchange secrets with oblivious transfer. Technical Report TR-81, Aiken Computation Lab, Harvard University, 1981.&lt;/p&gt;</summary>
    
    
    
    
    <category term="MPC" scheme="https://alleysira.github.io/tags/MPC/"/>
    
    <category term="OT" scheme="https://alleysira.github.io/tags/OT/"/>
    
  </entry>
  
  <entry>
    <title>SV21</title>
    <link href="https://alleysira.github.io/2023/04/13/SV21/"/>
    <id>https://alleysira.github.io/2023/04/13/SV21/</id>
    <published>2023-04-13T10:46:04.000Z</published>
    <updated>2023-05-07T12:49:54.631Z</updated>
    
    <content type="html"><![CDATA[<p>[SV21 ISIT]Private Data Access in Blockchain Systems Employing Coded Sharding</p><p>面向编码分片的区块链（PolyShard），数据采用RS码编码后保存，采用PIR保护余额查询</p><span id="more"></span><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>区块链的共识主要包含两方面：</p><ul><li>谁拥有出块的权利</li><li>谁对链的视图将被所有人认可</li></ul><p>在比特币中分别为PoW和最长链原则</p><p>区块链系统的三个性能指标：</p><ul><li>security threshold：区块链系统能容忍的恶意节点数量，取决于共识算法</li><li>吞吐量：每个时间单元的交易量，区块大小固定时，可以根据验证通过的区块数量衡量</li><li>存储效率：每个节点存储完整区块链数据的比例</li></ul><p>比特币和以太坊采用完整复制的思想，导致存储效率为最低值1</p><p>水平扩展（horizontal scaling）：随着网络规模线性地增加吞吐量、降低存储效率</p><p>编码分片（coded sharding）被认为是解决不可能三角的方案之一</p><p>区块链的分片是指将将网络划分为小的子网，每个子网掌握不相交的交易集合和不相交的账户</p><p>编码的分片中，区块链是一个编码的块形成的链，是对跨分片的块进行编码得到的</p><h1 id="Privacy-in-Blockchain"><a href="#Privacy-in-Blockchain" class="headerlink" title="Privacy in Blockchain"></a>Privacy in Blockchain</h1><p>假名（pseudonym）：公钥</p><p>钱包：与发送方和接收方相关联的一对假名</p><p>交易的隐私包含：</p><ul><li>被记录到区块里的过程</li><li>上链后从区块里读：如果客户端下载了完整的账本，敌手无法发现与客户端相关的账户<ul><li>但是随着区块链规模增加，会影响客户端的存储</li><li>采用SPV，只需要存储区块头，但是只能验证支付，无法验证</li></ul></li></ul><p>目前保护<em>余额查询</em> 这一过程隐私的方法：</p><ul><li>钱包假名机制是暂时的，即可以更换公钥</li><li>公钥无法追踪到用户身份</li></ul><p>It is not difficult to realize that transaction-privacy based on ephemeral nature of wallets is an illusion. （好有哲理）</p><p>因此有了中心化的混币机构（可能作恶，可能滥用财产，容易受到去匿名攻击）</p><p>如果采用PIR，可以实现余额查询的隐私保护</p><h2 id="Private-Information-Retrieval"><a href="#Private-Information-Retrieval" class="headerlink" title="Private Information Retrieval"></a>Private Information Retrieval</h2><p>$n$个服务器，每个服务器都有完整的$k$个比特的字符串$(x_1,x_2,\dots,x_k)$，获取$x_i$，但是任何服务器都不知道哪个比特被查询了</p><p>评价PIR的标准之一是rate，是指取回的符号/下载的符号，类似有效率</p><h2 id="Contribution"><a href="#Contribution" class="headerlink" title="Contribution"></a>Contribution</h2><ul><li>形式化了使用PIR在编码分片区块链上进行交易隐私保护</li><li>构造了从RS码存储的数据中进行查询的PIR</li><li>容忍最多$n-k$半诚实服务器合谋</li></ul><h1 id="Transaction-Privacy-with-Coded-Sharding"><a href="#Transaction-Privacy-with-Coded-Sharding" class="headerlink" title="Transaction Privacy with Coded Sharding"></a>Transaction Privacy with Coded Sharding</h1><h2 id="Private-Data-Access-System-model"><a href="#Private-Data-Access-System-model" class="headerlink" title="Private Data Access: System model"></a>Private Data Access: System model</h2><p>节点个数为$n$，分片个数为$k$，每个分片内账户总数为$m$</p><p>同步网络，网络可以是动态的，但是假设网络规模永远为$n$个节点</p><p>主要考虑$T$个epoch，$B_j(t)$表示第$j$个分片内的区块，$j\in[k],t\in[T]$，假设没有跨片交易，$X_j(t)$为$B_j(t)$包含的交易</p><p>$X_j(t)=(X_j^{send}(t),X_j^{receive}(t))$</p><p>$X_j^{send}(t),X_j^{receive}(t)$每个元素都属于$\mathbb{F}_q^m$，即$(1\times m)$向量，$q$的值取决于单个交易的最大单元</p><p>账户$p$向账户$q$发送b个单位密码货币，记为</p><script type="math/tex; mode=display">X_j^{send}(t,p)=-b,X_j^{receive}(t,q)=b</script><p>$X_j^{send}(t,p)$是$X_j^{send}$的第$p$个分量</p><p>只考虑线性码，第$i$个节点在epoch $t$存储$Y_i(t)$的是$\{X_j(t),j\in[k]\}$的线性组合</p><script type="math/tex; mode=display">Y_i(t)=\sum^k_{j=1}g_{ij}X_j(t),i\in[n]</script><p>$g_i=[g_{i1},\dots,g_{ik}]^T$是第$i$个节点的生成向量，$X_j(t)$为$1\times 2m$向量，考虑$T$个epoch后节点$i$的内容$Z_i(T)$</p><script type="math/tex; mode=display">Z_i =\left[\begin{matrix}Y_i(1)\\Y_i(2)\\\vdots\\Y_i(T)\end{matrix}\right]= \left[\begin{matrix}X_1(1) &\dots & X_k(1) \\X_1(2) &\dots  &X_k(2)  \\\vdots  &\ddots  &\vdots \\X_1(T) & \dots & X_k(T) \end{matrix}\right]\left[\begin{matrix}g_{i1}\mathbb{1}_{2m}  \\g_{i2}\mathbb{1}_{2m} \\\vdots  \\g_{ik}\mathbb{1}_{2m}  \end{matrix}\right]=U \cdot(g_i \otimes\mathbb{1}_{2m})\\</script><p>$\mathbb{1}_{2m}$是$2m\times1$维的全1向量，$U:(T\times 2km)$包含了$T$个epoch内所有分片，涉及总用户$km$的交易历史</p><p>考虑$j$个分片内的用户$p$，会想知道自己付的钱是否被打包，即$X_j(t),U(t,2(j-1)m)$</p><p>每一行为一个epoch，出块$k$个，第$j$个块的范围为$[2(j-1)m,2mj]$，则$p$对应的send位置为$2(j-1)m+p$;</p><p>同理，可以查询receive位置$2(j-1)m+p+m=2j+p-m$</p><p>如果服务器对send位置和receiver位置（即p）不知情（oblivious），能够防御恶意服务器将假名和用户的真实网络地址联系起来</p><p>统计账户可以记作$\sum_{t=1}^T U(t,2(j-1)m+p)+U(t,2j-m+p)$</p><p>服务器可以分为：</p><ul><li>curious-but-honest：想要猜出$p$，但是会正确响应</li><li>stragglers：拖延很久争取时间猜出$p$，之后正确响应</li><li>malicious：尝试猜出$p$，可能返回错误结果</li></ul><p>当用户$p$想要读取$X_j(t,p)=U(t,2(j-1)m+p)$时，生成$n$个随机的$1\times 2m$向量$\{q_i(j,p)\in\mathbb{F}_q^{2m}|i=1,2,\dots,n \}$，向第$i$个节点发送$(t,q_i(j,p))$</p><p>每个节点返回$\mathcal{A}(Y_i(t),q_i(j,p)):=a_i=q_i(j,p)^TY_i(t)$，扩张n倍</p><p>收到所有$a_i$后，计算$\hat{X}_j(t,p)=\sum^n_{i=1} a_i$</p><p>协议需要满足：</p><ul><li>正确性：$\hat{X}_j(t,p)=X_j(t,p)$对所有$j,p$均成立</li><li>隐私性：信息论安全 对在$\{1,\dots,2m\}$均匀随机的$P$和curious-but-honest的服务器集合$\mathcal{D}$，满足 $I(P:\cup_{i\in\mathcal{D}}q_i(j,p))=0$</li></ul><h2 id="Overiew-of-Reed-Solomon-Codes"><a href="#Overiew-of-Reed-Solomon-Codes" class="headerlink" title="Overiew of Reed-Solomon Codes"></a>Overiew of Reed-Solomon Codes</h2><p>假设采用广义RS码 (generalized Reed-Solomon code, GRS) 对区块进行编码</p><h3 id="复习信息论"><a href="#复习信息论" class="headerlink" title="复习信息论"></a>复习信息论</h3><p>$(n,k)$ 线性码：n是码长，k是线性空间维数</p><p><img src="/2023/04/13/SV21/image-20230415101504909.png" alt="image-20230415101504909" style="zoom:50%;"></p><p>生成矩阵：$G:k\times n$，每一行是生成向量</p><p>校验矩阵：$H: (n-k)\times n$，每一行是一个n元线性方程组的系数，$n-k$ 行确定了一个n维线性空间</p><p>若c为码字，有$Hc^T=0$</p><p><img src="/2023/04/13/SV21/image-20230415101709876.png" alt="image-20230415101709876" style="zoom:50%;"></p><p><img src="/2023/04/13/SV21/image-20230415102007666.png" alt="image-20230415102007666" style="zoom:50%;"></p><p>$C_{GRS}$是MDS码，最小距离$n-k+1$</p><p><img src="/2023/04/13/SV21/image-20230415103611131.png" alt="image-20230415103611131" style="zoom: 67%;"></p><p>$H_{(n-k)\times A},A\leq n-k$ 列满秩，说明$H$内 存在$A\times A$可逆矩阵</p><h2 id="Private-Data-Access-with-Curious-but-honest-Servers"><a href="#Private-Data-Access-with-Curious-but-honest-Servers" class="headerlink" title="Private Data Access with Curious-but-honest Servers"></a>Private Data Access with Curious-but-honest Servers</h2><p>如果敌手是malicious，可以通过固定查询检测出，所有回复$q^TY_1(t)\dots q^TY_n(t)$是一个码字，则$q^TY_1(t)\in \mathbb{F}_q$</p><p>因此从敌手的角度来说保持curious but honest是更加明智的选择</p><p>假设curious but honest服务器的数量 $d\leq n-k$</p><h3 id="PIR-protocol"><a href="#PIR-protocol" class="headerlink" title="PIR protocol"></a>PIR protocol</h3><p>构造查询向量的思想：混合</p><ul><li>$\mathcal{C}_{GRS}$的奇偶校验向量（思想来自于[TIT18]）</li><li>半随机向量(q)</li><li>生成矩阵的逆矩阵的行向量</li></ul><p>最终用户$p$构造的查询向量为$\{q_i(j,p)\in \mathbb{F}^{2m}_q|i=1,\dots,n\}$</p><p>分别向每个服务器$i$发送查询$q_i(j,p),t$</p><p>收到回复$\mathcal{A}(Y_i(t),q_i(j,p))=a_i=q_i(j,p)^TY_i(t)$后，客户端计算$X_j(t,p)=\sum^n_{i=1} a_i$</p><p>以下给出查询向量$q_i(j,p)$的构造方式：</p><p>分别记GRS码的校验矩阵和生成矩阵为：</p><script type="math/tex; mode=display">H_{GRS}=\left [\begin{matrix}h_1^T\\h_2^T\\\vdots \\h^T_{n-k}\end{matrix}\right ]_{(n-k) \times n} G_{GRS}=\left [\begin{matrix}G_1 \  G_2\end{matrix}\right ]_{k \times n}</script><p>其中$G_1:k\times k,G_2:k\times(n-k)$，$G_1$是$G_{GRS}$可逆的子矩阵，$h^T_l=[h_{l1},h_{l2},\dots,h_{ln}],1\leq l\leq(n-k)$</p><p>$G_1^{-1}=[\tilde\phi_1,\dots,\tilde\phi_k],\tilde\phi_i:k\times 1,\phi_j^T=[\tilde\phi_j \ 0]_{1\times n}$，即$\tilde\phi_j$后面补$n-k$ 个$0$</p><p>假设curious but honest服务器的数量为$d$</p><p>均匀随机选择$d$个向量$r_1,\dots,r_d \in \mathbb{F}^{2m}_q$，计算$r_{d+1}=(\sum^d_{i=1} r_i)+e_p$，其中$e_p=[0\ 0\ \dots\ 1_p\ \dots\ 0]_{2m \times 1}$</p><script type="math/tex; mode=display">R_p=[r_1 \  r_2\  \dots \ r_{d+1}]_{2m \times (d+1)}\\\Psi_j=\left [\begin{matrix}h_1^T + \phi_j^T\\h_2^T+\phi_j^T \\\vdots\\h_d^T+\phi_j^T\\\phi_j^T\end{matrix}\right ]_{(1+d)\times n}\\Q=R_p\Psi _j:2m\times n</script><p>此时矩阵$Q$的每一列分别为$q_i(j,p)$，令$\varphi_{i}=\phi^T_{ji},i\in[n]$</p><script type="math/tex; mode=display">q_1(j,p)=\left[\begin{matrix}\sum^{d}_{k=1} r_{k,1}(h_{k,1}+\varphi_1 )+r_{d+1,1}\varphi_{1}\\\sum^{d}_{k=1} r_{k,2}(h_{k,1}+\varphi_1 )+r_{d+1,2}\varphi_{1}\\\vdots \\\sum^{d}_{k=1} r_{k,2m}(h_{k,1}+\varphi_1 )+r_{d+1,2m}\varphi_{1}\end{matrix}\right ]\\q_i(j,p)=\left[\begin{matrix}\sum^{d}_{k=1} r_{k,1}(h_{k,i}+\varphi_i )+r_{d+1,1}\varphi_{i}\\\sum^{d}_{k=1} r_{k,2}(h_{k,i}+\varphi_i )+r_{d+1,2}\varphi_{i}\\\vdots \\\sum^{d}_{k=1} r_{k,2m}(h_{k,i}+\varphi_i )+r_{d+1,2m}\varphi_{i}\end{matrix}\right ],i\in[n]</script><p>接下来证明这种构造满足正确性和隐私性</p><h3 id="Privacy"><a href="#Privacy" class="headerlink" title="Privacy"></a>Privacy</h3><p>设作恶的服务器为$d\leq n-k,\mathcal{D}={i_1,\dots,i_d}$，则发送给所有作恶节点的查询向量组成$2m\times d$的矩阵$Q_D$</p><p>对$R=[r_1 \ r_2 \cdots \ r_d ]_{2m\times d},E_p=[e_p \ \cdots \  e_p]_{2m\times d},rank-one,\Phi=[h_1 \ h_2 \ \cdots \ h_d]_{d\times d}$</p><script type="math/tex; mode=display">\Delta_D=\left[\begin{matrix}\hat\phi_{j1} \\& \hat\phi_{j2} \\& & \ddots\\& & & \hat\phi_{jd}\end{matrix}\right ]_{d\times d}</script><p>有$Q_D=R_p \cdot\Psi_{j,D}=R\Phi+ E_p\Delta _D$</p><h3 id="Correctness"><a href="#Correctness" class="headerlink" title="Correctness"></a>Correctness</h3><p>根据$a_i=q_i(j,p)^TY_i(t),Y_i(t)=\sum^k_{j=1}g_{ij}X_j(t),i\in[n]$</p><script type="math/tex; mode=display">\begin{align}X_j(t,p) &=\sum^n_{i=1} a_i \\& = \sum_{i=1}^n q_i(j,p)^TY_i(t) \\& = (\sum_{l=1}^dr_l^T\sum^n_{i=1}(h_{l_i}+\phi_{ji})Y_i(t))+r_{d+1}\sum^n_{i=1}\phi_{ji}Y_i(t)\end{align}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;[SV21 ISIT]Private Data Access in Blockchain Systems Employing Coded Sharding&lt;/p&gt;
&lt;p&gt;面向编码分片的区块链（PolyShard），数据采用RS码编码后保存，采用PIR保护余额查询&lt;/p&gt;</summary>
    
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="PIR" scheme="https://alleysira.github.io/tags/PIR/"/>
    
  </entry>
  
  <entry>
    <title>SecretFlow隐语PSI实验环境配置与测试</title>
    <link href="https://alleysira.github.io/2023/04/08/SecretFlow%E9%9A%90%E8%AF%ADPSI%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%B5%8B%E8%AF%95/"/>
    <id>https://alleysira.github.io/2023/04/08/SecretFlow%E9%9A%90%E8%AF%ADPSI%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%B5%8B%E8%AF%95/</id>
    <published>2023-04-08T14:03:51.000Z</published>
    <updated>2023-04-11T13:59:19.700Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SecretFlow隐语PSI实验环境配置与测试"><a href="#SecretFlow隐语PSI实验环境配置与测试" class="headerlink" title="SecretFlow隐语PSI实验环境配置与测试"></a>SecretFlow隐语PSI实验环境配置与测试</h1><p>配置SecretFlow 并测试两方PSI的效率</p><p>官方文档 <a href="https://www.secretflow.org.cn/docs/secretflow/zh_CN/developer/benchmark/psi_benchmark.html#">隐语PSI Benchmark白皮书 — SecretFlow 文档</a></p><span id="more"></span><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><p>配置conda</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install wget</span><br><span class="line">wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh</span><br><span class="line">bash Miniconda3-latest-Linux-x86_64.sh</span><br><span class="line"><span class="comment"># choose miniconda3 location</span></span><br><span class="line">~/.miniconda3</span><br><span class="line">Do you wish the installer to initialize Miniconda3 by running conda init? [yes|no]</span><br><span class="line">[no] &gt;&gt;&gt; yes</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"></span><br><span class="line">conda --version</span><br></pre></td></tr></table></figure><p>新建conda环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conda create -n sf-benchmark python=3.8</span><br><span class="line">conda activate sf-benchmark</span><br><span class="line">pip install -U secretflow</span><br><span class="line">mkdir sf-benchmark</span><br><span class="line">cd sf-benchmark</span><br></pre></td></tr></table></figure><p>生成.csv集合数据脚本，调用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 gene_psi.py 1000000</span><br></pre></td></tr></table></figure><p>脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python3 gene_psi.py</span></span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> sample</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_with_N_digits</span>(<span class="params">n</span>):</span></span><br><span class="line">    range_start = <span class="number">10</span> ** (n - <span class="number">1</span>)</span><br><span class="line">    range_end = (<span class="number">10</span>**n) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> randint(range_start, range_end)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">row_list = []</span><br><span class="line">len1 = <span class="number">10</span>**<span class="number">2</span></span><br><span class="line">len2 = <span class="number">10</span></span><br><span class="line">len3 = <span class="number">10</span></span><br><span class="line">len4 = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &gt; <span class="number">1</span>:</span><br><span class="line">    len1 = <span class="built_in">int</span>(sys.argv[<span class="number">1</span>])</span><br><span class="line">    len2 = <span class="built_in">int</span>(len1 / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &gt; <span class="number">2</span>:</span><br><span class="line">    len3 = <span class="built_in">int</span>(sys.argv[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">len4 = <span class="built_in">int</span>(len3 / <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(len1, len2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(len1):</span><br><span class="line">    data_list = [random_with_N_digits(<span class="number">38</span>)] <span class="comment"># should use 10^38 equals 2^128</span></span><br><span class="line">    row_list.append(data_list)</span><br><span class="line"></span><br><span class="line">row_list2 = sample(row_list, len2)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(len2, len1):</span><br><span class="line">    data_list = [random_with_N_digits(<span class="number">38</span>)]</span><br><span class="line">    row_list2.append(data_list)</span><br><span class="line"></span><br><span class="line">row_list3 = sample(row_list, len4)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(len4, len3):</span><br><span class="line">    data_list = [random_with_N_digits(<span class="number">38</span>)]</span><br><span class="line">    row_list3.append(data_list)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(row_list2))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(row_list3))</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;psi_1.csv&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    writer = csv.writer(file)</span><br><span class="line">    writer.writerow([<span class="string">&quot;id&quot;</span>])</span><br><span class="line">    writer.writerows(row_list)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;psi_2.csv&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    writer = csv.writer(file)</span><br><span class="line">    writer.writerow([<span class="string">&quot;id&quot;</span>])</span><br><span class="line">    writer.writerows(row_list2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;psi_3.csv&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    writer = csv.writer(file)</span><br><span class="line">    writer.writerow([<span class="string">&quot;id&quot;</span>])</span><br><span class="line">    writer.writerows(row_list3)</span><br></pre></td></tr></table></figure><h2 id="测试安装是否成功"><a href="#测试安装是否成功" class="headerlink" title="测试安装是否成功"></a>测试安装是否成功</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python3 foot.py</span></span><br><span class="line"><span class="keyword">import</span> secretflow <span class="keyword">as</span> sf</span><br><span class="line">sf.init([<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;carol&#x27;</span>], address=<span class="string">&#x27;local&#x27;</span>)</span><br><span class="line">dev = sf.PYU(<span class="string">&#x27;alice&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"></span><br><span class="line">data, target = load_iris(return_X_y=<span class="literal">True</span>, as_frame=<span class="literal">True</span>)</span><br><span class="line">data[<span class="string">&#x27;uid&#x27;</span>] = np.arange(<span class="built_in">len</span>(data)).astype(<span class="string">&#x27;str&#x27;</span>)</span><br><span class="line">data[<span class="string">&#x27;month&#x27;</span>] = [<span class="string">&#x27;Jan&#x27;</span>] * (<span class="number">2</span>^<span class="number">20</span>) + [<span class="string">&#x27;Feb&#x27;</span>] * (<span class="number">2</span>^<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># generate data, notice the content ./data</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.makedirs(<span class="string">&#x27;./data&#x27;</span>, exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">da, db, dc = data.sample(frac=<span class="number">0.9</span>), data.sample(frac=<span class="number">0.8</span>), data.sample(frac=<span class="number">0.7</span>)</span><br><span class="line"></span><br><span class="line">da.to_csv(<span class="string">&#x27;data/alice.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br><span class="line">db.to_csv(<span class="string">&#x27;data/bob.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br><span class="line">dc.to_csv(<span class="string">&#x27;data/carol.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">alice, bob = sf.PYU(<span class="string">&#x27;alice&#x27;</span>), sf.PYU(<span class="string">&#x27;bob&#x27;</span>)</span><br><span class="line">spu = sf.SPU(sf.utils.testing.cluster_def([<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;bob&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">input_path = &#123;alice: <span class="string">&#x27;data/alice.csv&#x27;</span>, bob: <span class="string">&#x27;data/bob.csv&#x27;</span>&#125;</span><br><span class="line">output_path = &#123;alice: <span class="string">&#x27;data/alice_psi.csv&#x27;</span>, bob: <span class="string">&#x27;data/bob_psi.csv&#x27;</span>&#125;</span><br><span class="line">spu.psi_csv(<span class="string">&#x27;uid&#x27;</span>, input_path, output_path, <span class="string">&#x27;alice&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = da.join(db.set_index(<span class="string">&#x27;uid&#x27;</span>), on=<span class="string">&#x27;uid&#x27;</span>, how=<span class="string">&#x27;inner&#x27;</span>, rsuffix=<span class="string">&#x27;_bob&#x27;</span>, sort=<span class="literal">True</span>)</span><br><span class="line">expected = df[da.columns].astype(&#123;<span class="string">&#x27;uid&#x27;</span>: <span class="string">&#x27;int64&#x27;</span>&#125;).reset_index(drop=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">da_psi = pd.read_csv(<span class="string">&#x27;data/alice_psi.csv&#x27;</span>)</span><br><span class="line">db_psi = pd.read_csv(<span class="string">&#x27;data/bob_psi.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pd.testing.assert_frame_equal(da_psi, expected)</span><br><span class="line">pd.testing.assert_frame_equal(db_psi, expected)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(da_psi)</span><br></pre></td></tr></table></figure><h2 id="实际实验测试脚本"><a href="#实际实验测试脚本" class="headerlink" title="实际实验测试脚本"></a>实际实验测试脚本</h2><p>启动节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RAY_DISABLE_REMOTE_CODE=<span class="literal">true</span> </span><br><span class="line">ray start --head --node-ip-address=<span class="string">&quot;192.168.31.128&quot;</span> --port=<span class="string">&quot;9394&quot;</span> --resources=<span class="string">&#x27;&#123;&quot;alice&quot;: 2&#125;&#x27;</span> --include-dashboard=False   </span><br><span class="line">ray start --address=<span class="string">&quot;192.168.31.128:9394&quot;</span> --resources=<span class="string">&#x27;&#123;&quot;bob&quot;: 2&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>通过更换reports的protocol参数进行3个两方PSI协议的测试，脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python3 benchmark.py</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> absl <span class="keyword">import</span> app</span><br><span class="line"><span class="keyword">import</span> spu</span><br><span class="line"><span class="keyword">import</span> secretflow <span class="keyword">as</span> sf</span><br><span class="line"></span><br><span class="line"><span class="comment"># init log</span></span><br><span class="line">logging.basicConfig(stream=sys.stdout, level=logging.INFO)</span><br><span class="line"></span><br><span class="line"><span class="comment"># SPU settings</span></span><br><span class="line">cluster_def = &#123;</span><br><span class="line">    <span class="string">&#x27;nodes&#x27;</span>: [</span><br><span class="line">        <span class="comment"># listen_address and address should have the same port</span></span><br><span class="line">        <span class="comment"># &lt;&lt;&lt; !!! &gt;&gt;&gt; replace &lt;192.168.0.1:12945&gt; to alice node&#x27;s local ip &amp; free port</span></span><br><span class="line">        <span class="comment"># 192.168.31.128 is my own ip address </span></span><br><span class="line">        &#123;<span class="string">&#x27;party&#x27;</span>: <span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;local:0&#x27;</span>, <span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;192.168.31.128:12345&#x27;</span>, <span class="string">&#x27;listen_address&#x27;</span>: <span class="string">&#x27;0.0.0.0:12345&#x27;</span>&#125;,</span><br><span class="line">        <span class="comment"># &lt;&lt;&lt; !!! &gt;&gt;&gt; replace &lt;192.168.0.2:12946&gt; to bob node&#x27;s local ip &amp; free port</span></span><br><span class="line">        &#123;<span class="string">&#x27;party&#x27;</span>: <span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;local:1&#x27;</span>, <span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;192.168.31.128:12333&#x27;</span>, <span class="string">&#x27;listen_address&#x27;</span>: <span class="string">&#x27;0.0.0.0:12333&#x27;</span>&#125;,</span><br><span class="line">        <span class="comment"># &lt;&lt;&lt; !!! &gt;&gt;&gt; if you need 3pc test, please add node here, for example, add carol as rank 2</span></span><br><span class="line">        <span class="comment"># &#123;&#x27;party&#x27;: &#x27;carol&#x27;, &#x27;id&#x27;: &#x27;local:2&#x27;, &#x27;address&#x27;: &#x27;127.0.0.1:12347&#x27;&#125;,</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&#x27;runtime_config&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;protocol&#x27;</span>: spu.spu_pb2.SEMI2K,</span><br><span class="line">        <span class="string">&#x27;field&#x27;</span>: spu.spu_pb2.FM128,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">_</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># sf init</span></span><br><span class="line">    <span class="comment"># &lt;&lt;&lt; !!! &gt;&gt;&gt; replace &lt;192.168.0.1:9394&gt; to your ray head</span></span><br><span class="line">    <span class="comment"># two parties secretflow&gt;=0.7.18b3 need to add &lt;sf.init(parties=[&#x27;alice&#x27;, &#x27;bob&#x27;]&gt;</span></span><br><span class="line">    sf.init(parties=[<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;bob&#x27;</span>], address=<span class="string">&#x27;192.168.31.128:9394&#x27;</span>,log_to_driver=<span class="literal">True</span>)</span><br><span class="line">    alice = sf.PYU(<span class="string">&#x27;alice&#x27;</span>)</span><br><span class="line">    bob = sf.PYU(<span class="string">&#x27;bob&#x27;</span>)</span><br><span class="line">    <span class="comment"># carol = sf.PYU(&#x27;carol&#x27;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># &lt;&lt;&lt; !!! &gt;&gt;&gt; replace path to real parties local file path.</span></span><br><span class="line">    input_path = &#123;</span><br><span class="line">        alice: <span class="string">&#x27;./psi_1.csv&#x27;</span>,</span><br><span class="line">        bob: <span class="string">&#x27;./psi_2.csv&#x27;</span>,</span><br><span class="line">        <span class="comment"># if run with `ECDH_PSI_3PC`, add carol</span></span><br><span class="line">        <span class="comment"># carol: &#x27;/data/psi_3.csv&#x27;,</span></span><br><span class="line">    &#125;</span><br><span class="line">    output_path = &#123;</span><br><span class="line">        alice: <span class="string">&#x27;./psi_output.csv&#x27;</span>,</span><br><span class="line">        bob: <span class="string">&#x27;./psi_output.csv&#x27;</span>,</span><br><span class="line">        <span class="comment"># if run with `ECDH_PSI_3PC`, add carol</span></span><br><span class="line">        <span class="comment"># carol: &#x27;/data/psi_output.csv&#x27;,</span></span><br><span class="line">    &#125;</span><br><span class="line">    select_keys = &#123;</span><br><span class="line">        alice: [<span class="string">&#x27;id&#x27;</span>],</span><br><span class="line">        bob: [<span class="string">&#x27;id&#x27;</span>],</span><br><span class="line">        <span class="comment"># if run with `ECDH_PSI_3PC`, add carol</span></span><br><span class="line">        <span class="comment"># carol: [&#x27;id&#x27;],</span></span><br><span class="line">    &#125;</span><br><span class="line">    spu = sf.SPU(cluster_def)</span><br><span class="line">    <span class="comment"># spu = sf.SPU(sf.utils.testing.cluster_def([&#x27;alice&#x27;, &#x27;bob&#x27;]))</span></span><br><span class="line">    <span class="comment"># prepare data</span></span><br><span class="line">    start = time.time()</span><br><span class="line"></span><br><span class="line">    reports = spu.psi_csv(</span><br><span class="line">        key=select_keys,</span><br><span class="line">        input_path=input_path,</span><br><span class="line">        output_path=output_path,</span><br><span class="line">        receiver=<span class="string">&#x27;alice&#x27;</span>,  <span class="comment"># if `broadcast_result=False`, only receiver can get output file.</span></span><br><span class="line">        <span class="comment"># all the possible protocols: ECDH_PSI_2PC KKRT_PSI_2PC BC22_PSI_2PC ECDH_PSI_3PC</span></span><br><span class="line">        protocol=<span class="string">&#x27;ECDH_PSI_2PC&#x27;</span>,<span class="comment"># psi protocol</span></span><br><span class="line">        precheck_input=<span class="literal">False</span>,  <span class="comment"># will cost ext time if set True</span></span><br><span class="line">        sort=<span class="literal">False</span>,  <span class="comment"># will cost ext time if set True</span></span><br><span class="line">        broadcast_result=<span class="literal">False</span>,  <span class="comment"># will cost ext time if set True</span></span><br><span class="line">    )</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;psi reports: <span class="subst">&#123;reports&#125;</span>&quot;</span>)</span><br><span class="line">    logging.info(<span class="string">f&quot;cost time: <span class="subst">&#123;time.time() - start&#125;</span>&quot;</span>) <span class="comment"># units： second</span></span><br><span class="line"></span><br><span class="line">    sf.shutdown()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(main)</span><br></pre></td></tr></table></figure><h2 id="SKY-PSI测试"><a href="#SKY-PSI测试" class="headerlink" title="SKY-PSI测试"></a>SKY-PSI测试</h2><p>./bin/PSI_test -r 0 -ss 20 -rs 20 -w 621 -h 20 -hash 10  &amp; ./bin/PSI_test -r 1 -ss 20 -rs 20 -w 621 -h 20 -hash 10</p><p>./bin/PSI_test -r 0 -ss 22 -rs 22 -w 627 -h 22 -hash 10  &amp; ./bin/PSI_test -r 1 -ss 22 -rs 22 -w 627 -h 22 -hash 10</p><p>./bin/PSI_test -r 0 -ss 23 -rs 23 -w 630 -h 23 -hash 10  &amp; ./bin/PSI_test -r 1 -ss 23 -rs 23 -w 630 -h 23 -hash 10</p><p>./bin/PSI_test -r 0 -ss 24 -rs 24 -w 633 -h 24 -hash 11  &amp; ./bin/PSI_test -r 1 -ss 24 -rs 24 -w 633 -h 24 -hash 11</p><p>./bin/PSI_test -r 0 -ss 25 -rs 25 -w 636 -h 25 -hash 11  &amp; ./bin/PSI_test -r 1 -ss 25 -rs 25 -w 636 -h 25 -hash 11</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">alleysira@ubuntu:~/SKY-PSI$ cmake .</span><br><span class="line">alleysira@ubuntu:~/SKY-PSI$ make</span><br><span class="line">alleysira@ubuntu:~/SKY-PSI$ ./bin/PSI_test -r 0 -ss 20 -rs 20 -w 621 -h 20 -<span class="built_in">hash</span> 10 -ip 127.0.0.1  -ck 0 -gm 0 &amp; ./bin/PSI_test -r 1 -ss 20 -rs 20 -w 621 -h 20 -<span class="built_in">hash</span> 10 -ip 127.0.0.1 -ck 0 -gm 0</span><br><span class="line">alleysira@ubuntu:~/SKY-PSI$ ./bin/PSI_test -r 0 -ss 20 -rs 20 -w 621 -h 20 -<span class="built_in">hash</span> 10 -ip 127.0.0.1  -ck 0 -gm 0 &amp; ./bin/PSI_test -r 1 -ss 20 -rs 20 -w 621 -h 20 -<span class="built_in">hash</span> 10 -ip 127.0.0.1 -ck 0 -gm 0</span><br><span class="line">[1] 4988</span><br><span class="line">Receiver matrix sent and transposed <span class="built_in">hash</span> input computed</span><br><span class="line">Label                                     Time (ms)  diff (ms)</span><br><span class="line">__________________________________</span><br><span class="line">Sender base OT finished                       155.1    155.071  ******</span><br><span class="line">Sender <span class="built_in">set</span> transformed                        645.4    490.352  *******</span><br><span class="line">Sender transposed <span class="built_in">hash</span> input computed        6863.1   6217.686  **********</span><br><span class="line">Sender <span class="built_in">hash</span> outputs computed and sent        8659.7   1796.587  *********</span><br><span class="line">Receiver intersection computed,Intersection size:500000</span><br><span class="line">Label                                                       Time (ms)  diff (ms)</span><br><span class="line">__________________________________</span><br><span class="line">Receiver base OT finished                                       135.9    135.929  ******</span><br><span class="line">Receiver initialized                                            216.6     80.709  *****</span><br><span class="line">Receiver <span class="built_in">set</span> transformed                                        620.4    403.792  *******</span><br><span class="line">Receiver matrix sent and transposed <span class="built_in">hash</span> input computed        6829.3   6208.850  **********</span><br><span class="line">Receiver intersection computed                                 9250.8   2421.508  *********</span><br><span class="line">Receiver sent communication: 77.631 MB</span><br><span class="line">Receiver received communication: 4.813 MB</span><br><span class="line">Receiver total communication: 82.445 MB</span><br><span class="line">[1]+  Done                    ./bin/PSI_test -r 0 -ss 20 -rs 20 -w 621 -h 20 -<span class="built_in">hash</span> 10 -ip 127.0.0.1 -ck 0 -gm 0</span><br></pre></td></tr></table></figure><p>cm20 支持到$2^{22},2^{23} $</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">alleysira@ubuntu:~/OPRF-PSI-backup$ ./bin/PSI_test -r 0 -ss 22 -rs 22 -w 627 -h 22 -hash 11  &amp; ./bin/PSI_test -r 1 -ss 22 -rs 22 -w 627 -h 22 -hash 11 -ip 127.0.0.1</span><br><span class="line">[2] 5249</span><br><span class="line">Receiver matrix sent and transposed hash input computed</span><br><span class="line">Label                                     Time (ms)  diff (ms)</span><br><span class="line">__________________________________</span><br><span class="line">Sender base OT finished                       688.9    688.936  ******</span><br><span class="line">Sender set transformed                       2053.2   1364.259  *******</span><br><span class="line">Sender transposed hash input computed       28745.7  26692.532  **********</span><br><span class="line">Sender hash outputs computed and sent       38459.4   9713.711  *********</span><br><span class="line">Begin</span><br><span class="line">Receiver intersection computed,Intersection size:532 Proportion of intersection:0.382% correct!</span><br><span class="line">Label                                                       Time (ms)  diff (ms)</span><br><span class="line">__________________________________</span><br><span class="line">Receiver base OT finished                                       690.1    690.110  ******</span><br><span class="line">Receiver initialized                                            874.8    184.698  *****</span><br><span class="line">Receiver set transformed                                       2005.0   1130.157  *******</span><br><span class="line">Receiver matrix sent and transposed hash input computed       28747.9  26742.969  **********</span><br><span class="line">Receiver intersection computed                                41609.8  12861.827  *********</span><br><span class="line">Receiver sent communication: 313.506 MB</span><br><span class="line">Receiver received communication: 10.016 MB</span><br><span class="line">Receiver total communication: 323.522 MB</span><br><span class="line"></span><br><span class="line">alleysira@ubuntu:~/OPRF-PSI-backup$ ./bin/PSI_test -r 0 -ss 23 -rs 23 -w 627 -h 23 -hash 11  &amp; ./bin/PSI_test -r 1 -ss 23 -rs 23 -w 627 -h 23 -hash 11 -ip 127.0.0.1</span><br><span class="line">[1] 5273</span><br><span class="line">Receiver matrix sent and transposed hash input computed</span><br><span class="line">Label                                     Time (ms)  diff (ms)</span><br><span class="line">__________________________________</span><br><span class="line">Sender base OT finished                       150.6    150.579  *****</span><br><span class="line">Sender set transformed                       2884.4   2733.777  *******</span><br><span class="line">Sender transposed hash input computed       67371.3  64486.946  **********</span><br><span class="line">Sender hash outputs computed and sent       90574.5  23203.154  *********</span><br><span class="line">Begin</span><br><span class="line">Receiver intersection computed,Intersection size:536 Proportion of intersection:0.191% correct!</span><br><span class="line">Label                                                       Time (ms)  diff (ms)</span><br><span class="line">__________________________________</span><br><span class="line">Receiver base OT finished                                       148.4    148.435  *****</span><br><span class="line">Receiver initialized                                            517.2    368.812  *****</span><br><span class="line">Receiver set transformed                                       2835.7   2318.477  *******</span><br><span class="line">Receiver matrix sent and transposed hash input computed       67371.8  64536.073  **********</span><br><span class="line">Receiver intersection computed                                97432.1  30060.339  *********</span><br><span class="line">Receiver sent communication: 627.006 MB</span><br><span class="line">Receiver received communication: 20.016 MB</span><br><span class="line">Receiver total communication: 647.022 MB</span><br></pre></td></tr></table></figure><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>4Core/12GB </p><p>hard drive: 30GB，实验过程中硬盘空间不足，可能影响效率</p><p>cm20的元素大小为$2^{128}$，隐语默认为$10^{18}$（已修改为$10^{38}$）</p><p>cm20设置了交集个数为100（已修正为50 0000），隐语交集个数设置为集合大小一半</p><p>分别限制网络带宽为30Mbps 20ms、100Mbps 20ms和LAN进行测试，对secretflow的测试需要限制环回地址lo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ifconfig </span><br><span class="line"></span><br><span class="line"><span class="comment">#100Mbps 20ms</span></span><br><span class="line">sudo tc qdisc add dev lo root handle 1: tbf rate 100mbit burst 256kb latency 800ms                                   </span><br><span class="line">sudo tc qdisc add dev lo parent 1:1 handle 10: netem delay 20msec <span class="built_in">limit</span> 8000 </span><br><span class="line"></span><br><span class="line"><span class="comment">#清除限制</span></span><br><span class="line">sudo tc qdisc del dev lo root</span><br><span class="line"><span class="comment">#查看已有配置</span></span><br><span class="line">sudo tc qdisc show dev lo</span><br></pre></td></tr></table></figure><h3 id="30Mbps-20ms结果"><a href="#30Mbps-20ms结果" class="headerlink" title="30Mbps 20ms结果"></a>30Mbps 20ms结果</h3><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><div class="table-container"><table><thead><tr><th>数量级</th><th>KKRT/s</th><th>ECDH/s</th><th>BC22/s</th><th>SKY-PSI/s</th></tr></thead><tbody><tr><td>百万 1000000 $2^{20}$</td><td>40.00+40.81=40.405</td><td>159.15+161.22=160.185</td><td>58.23+60.14=59.18</td><td>26.47+26.76+26.81=26.68</td></tr><tr><td>千万 10000000</td><td>369.75</td><td>1558.04</td><td>537.13</td></tr></tbody></table></div><h3 id="100Mbps-20ms结果"><a href="#100Mbps-20ms结果" class="headerlink" title="100Mbps 20ms结果"></a>100Mbps 20ms结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(base) jie@jie-virtual-machine:~$ sudo  tc qdisc add dev lo root handle 1: tbf rate 100mbit burst 256kb latency 800ms </span><br><span class="line">(base) jie@jie-virtual-machine:~$ sudo tc qdisc add dev lo parent 1:1 handle 10: netem delay 20msec limit 8000 </span><br><span class="line">(base) jie@jie-virtual-machine:~$ sudo tc qdisc show dev lo</span><br><span class="line">qdisc tbf 1: root refcnt 2 rate 100Mbit burst 256Kb lat 800ms </span><br><span class="line">qdisc netem 10: parent 1:1 limit 8000 delay 20ms</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>数量级</th><th>KKRT/s</th><th>ECDH/s</th><th>BC22/s</th><th>SKY-PSI/s</th></tr></thead><tbody><tr><td>百万 1000000 $2^{20}$</td><td>18.80+18.29=18.545</td><td>151.927</td><td>16.86+16.176=16.518</td><td>10.52+10.51+ 10.57=10.53</td></tr><tr><td>千万 10000000</td><td>138.21+139.47=138.84</td><td>1544.09</td><td>106.89+111.60=109.245</td></tr></tbody></table></div><h3 id="LAN实验结果"><a href="#LAN实验结果" class="headerlink" title="LAN实验结果"></a>LAN实验结果</h3><div class="table-container"><table><thead><tr><th>数量级</th><th>KKRT/s</th><th>ECDH/s</th><th>BC22/s</th><th>SKY-PSI/s</th></tr></thead><tbody><tr><td>百万 1000000 $2^{20}$</td><td>12.85+10.65+12.63+10.19+13.11+9.57+9.82+9.68+9.93=9.84</td><td>137.29+142.37+141.59+147.97+143.38=142.52</td><td>10.33+10.318=10.324</td><td>9.2508+9.002+10.941+9.0912+9.036+9.663+10.935+10.154=9.75</td></tr><tr><td>千万 10000000</td><td>76.24+72.58+74.83+70.75+70.83=73.046</td><td>1374.78</td><td>79.94+78.78+81.13+78.40+78.62=79.374</td></tr></tbody></table></div><p>蚂蚁给出的结果</p><p><img src="/2023/04/08/SecretFlow%E9%9A%90%E8%AF%ADPSI%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%B5%8B%E8%AF%95/7629c228-bc51-4ef7-93e9-9f0c465d025d.png" alt="img"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;SecretFlow隐语PSI实验环境配置与测试&quot;&gt;&lt;a href=&quot;#SecretFlow隐语PSI实验环境配置与测试&quot; class=&quot;headerlink&quot; title=&quot;SecretFlow隐语PSI实验环境配置与测试&quot;&gt;&lt;/a&gt;SecretFlow隐语PSI实验环境配置与测试&lt;/h1&gt;&lt;p&gt;配置SecretFlow 并测试两方PSI的效率&lt;/p&gt;
&lt;p&gt;官方文档 &lt;a href=&quot;https://www.secretflow.org.cn/docs/secretflow/zh_CN/developer/benchmark/psi_benchmark.html#&quot;&gt;隐语PSI Benchmark白皮书 — SecretFlow 文档&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Crypto" scheme="https://alleysira.github.io/tags/Crypto/"/>
    
    <category term="MPC" scheme="https://alleysira.github.io/tags/MPC/"/>
    
    <category term="PSI" scheme="https://alleysira.github.io/tags/PSI/"/>
    
  </entry>
  
  <entry>
    <title>Intro_to_lattices</title>
    <link href="https://alleysira.github.io/2023/04/07/Intro-to-lattices/"/>
    <id>https://alleysira.github.io/2023/04/07/Intro-to-lattices/</id>
    <published>2023-04-07T10:29:49.000Z</published>
    <updated>2023-04-09T11:53:43.719Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1re411W7vA/?spm_id_from=333.999.0.0&amp;vd_source=fbfceeec0a697a64e4aba2132714eb9d">2012年BIU密码学冬令营-01-Introduction to Lattices</a></p><span id="more"></span><h1 id="2012-BIU-Introduction-to-Lattices"><a href="#2012-BIU-Introduction-to-Lattices" class="headerlink" title="2012 BIU Introduction to Lattices"></a>2012 BIU Introduction to Lattices</h1><p><img src="/2023/04/07/Intro-to-lattices/image-20230407183351420.png" alt="image-20230407183351420"></p><p>基底不唯一</p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407183444805.png" alt="image-20230407183444805"></p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407183505019.png" alt="image-20230407183505019"></p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407183846399.png" alt="image-20230407183846399"></p><p>格密码的安全是worst-case的困难问题</p><p>传统密码学是average-case的困难问题</p><p>格可以实现FHE</p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407184005734.png" alt="image-20230407184005734"></p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407184353209.png" alt="image-20230407184353209"></p><p>安全证明可以给出关于如何选择安全参数的提示</p><p>average-case的困难问题，比如如何选择N？</p><ul><li>大质数$p,q$如何选择</li><li>$p-1,q-1$的素因子应该足够大</li><li>$p+1,q+1$的素因子应该足够大</li><li>实际上现在已经不太重要了</li></ul><p>格不存在这样的问题</p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407185137186.png" alt="image-20230407185137186"></p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407185310415.png" alt="image-20230407185310415"></p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407185523538.png" alt="image-20230407185523538"></p><p>如果1%被破解了，所有格上的困难问题都被破解了，不需要考虑参数的选取</p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407190027295.png" alt="image-20230407190027295"></p><p>现在格密码的效率和RSA接近</p><ul><li>LWE SIS</li><li>RLWE RSIS 特定代数结构，效率非常高，密钥长度KB级别，接近哈希函数的效率</li></ul><p><img src="/2023/04/07/Intro-to-lattices/image-20230407190336753.png" alt="image-20230407190336753"></p><p>两个定义，实际上等价 列就是基底 </p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407190559981.png" alt="image-20230407190559981"></p><p> 等价基底</p><p>如何寻找等价基底，能在基底上做什么</p><ul><li>列变换 $v_i\leftrightarrow v_j$</li><li>取负值 $v_i\gets -v_i$</li><li>$v_i\gets v_i +kv_j,k\in Z$</li></ul><p>相当于右乘 幺模矩阵(unimodular 行列式值为1)，对乘法封闭</p><p>两个格等价的条件</p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407191804198.png" alt="image-20230407191804198"></p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407192045351.png" alt="image-20230407192045351"></p><p>格的一些特征</p><p>一维空间的周期函数$f:\R \to \R$</p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407192624915.png" alt="image-20230407192624915"></p><p>考虑高维空间，类似于循环群，只需要存储陪集</p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407193047743.png" alt="image-20230407193047743"></p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407193204421.png" alt="image-20230407193204421"></p><p>格的基本区域</p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407193341145.png" alt="image-20230407193341145"></p><p>给定基，可以定义基本平行多面体 就是一个基本区域，恰好包含陪集中的每一个元素</p><p>基本空间的等价定义：基本空间内不存在两个等价的空间点，仅包含所有不等价陪集内的点集</p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407193441619.png" alt="image-20230407193441619"></p><p>寻找空间点的一个表示，实际上是在做模 基本平行多面体</p><p>存储的实际是点和格的相关性，当点在格上，模P(B)后得到原点</p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407194218433.png" alt="image-20230407194218433"></p><p>实际上平行多面体的形状无重要，可以用任意多面体标识格，不是所有基本区域都是平行的</p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407194446752.png" alt="image-20230407194446752"></p><p>基本区域的面积必须相同，对平行多面体也成立，可以把平行多面体内的点映射到另一个平行多面体中 </p><p>格的行列式定义为基生成的平行多面体的体积$|det(B)|$</p><p>格的行列式表示了格点的稀疏程度，密度</p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407202440541.png" alt="image-20230407202440541"></p><p>连续极小，最短向量(集合)</p><p>一般距离是欧几里得范数</p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407202709347.png" alt="image-20230407202709347"></p><p>一般指关心$\lambda_1 $</p><p>$\lambda_n $是线性空间的基</p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407202958269.png" alt="image-20230407202958269"></p><p>注意$\tilde{v_2}$并不是格点</p><p>正交基也是基本区域</p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407204323284.png" alt="image-20230407204323284"></p><p>从正交向量集到规范化正交集，是线性代数层面的基而不是格的基</p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407204527658.png" alt="image-20230407204527658"></p><p>QR分解</p><p>可以证明施密特正交区域是基本区域 </p><p><img src="/2023/04/07/Intro-to-lattices/image-20230407204950666.png" alt="image-20230407204950666"></p><p>证明引理1：三角形行列式等于主对角线上元素的乘积</p><p>证明引理2：对最后一列的系数取非0，其他所有项系数取0，则 $\lambda_1\geq \tilde{v_n}$；同理当倒数第二列系数为非0，其他所有列系数为0，$\lambda_1\geq \tilde{v_{n-1}}$ ，永远存在非0系数，实际得到了$\lambda_1$的下界</p><h2 id="Minkowski‘s-theorem"><a href="#Minkowski‘s-theorem" class="headerlink" title="Minkowski‘s theorem"></a>Minkowski‘s theorem</h2><p>袋鼠的面积大于格的行列式</p><p><img src="/2023/04/07/Intro-to-lattices/image-20230409144553627.png" alt="image-20230409144553627"></p><p>S必须是关于0点对称的凸集合，存在一个非0格点，因为0永远在S中</p><p><img src="/2023/04/07/Intro-to-lattices/image-20230409144706671.png" alt="image-20230409144706671"></p><p>证明：将S缩小一半，体积缩小$2^n$，$z_1-z_2\in \Lambda $</p><p>由于$\pm2z_1,\pm2z_2 \in S,2z_1-2z_2$的中点 $z_1-z_2\in S$</p><p><img src="/2023/04/07/Intro-to-lattices/image-20230409145627491.png" alt="image-20230409145627491"></p><p>说明了格中至少有短向量</p><p>等价推论：任意行列式为1的格，必然包含长度不超过$\sqrt{n}$的短向量</p><p>考虑半径为$\sqrt{n}$的球，球的体积大于$2^n$</p><p>现在格中找短向量的方法都是数学方法，基于格的密码学方案假设是不知道如何高效求得格的短向量</p><p>Blichfeld定理是存在性定理，没有给出如何求</p><h2 id="计算困难问题"><a href="#计算困难问题" class="headerlink" title="计算困难问题"></a>计算困难问题</h2><h3 id="简单问题"><a href="#简单问题" class="headerlink" title="简单问题"></a>简单问题</h3><p>给定格基$B$和向量$v$，检查$v$是否在$L(B)$</p><p>解法：高斯消元检查系数是否为整数</p><p>给定格基 $B_1 B_2$，判断$L(B_1)=L(B_2)$</p><p>解法：根据之前的定理，$B_1 = B_2\times U$，$U$是幺模矩阵</p><p>另一个解法：取基$B_1$中任意一个向量，检查是否属于另一个基；如果所有基向量均在$L(B_2)$，再检查$B_2$中所有向量是否在$L(B_1)$</p><p>结论是代数问题很简单，但是几何问题很困难</p><p><img src="/2023/04/07/Intro-to-lattices/image-20230409160126271.png" alt="image-20230409160126271"></p><h3 id="困难问题"><a href="#困难问题" class="headerlink" title="困难问题"></a>困难问题</h3><h4 id="最短向量问题，SVP"><a href="#最短向量问题，SVP" class="headerlink" title="最短向量问题，SVP"></a>最短向量问题，SVP</h4><p>给定基，求最短向量</p><p>密码学常用的是近似最短向量问题，求得最短向量的$\gamma$倍的向量</p><p><img src="/2023/04/07/Intro-to-lattices/image-20230409160404955.png" alt="image-20230409160404955"></p><p>变种：给出近似最短向量的长度即可（类似判定小问题</p><h4 id="最短独立向量问题，SIVP"><a href="#最短独立向量问题，SIVP" class="headerlink" title="最短独立向量问题，SIVP"></a>最短独立向量问题，SIVP</h4><p><img src="/2023/04/07/Intro-to-lattices/image-20230409160855151.png" alt="image-20230409160855151"></p><h4 id="最近向量问题，CVP"><a href="#最近向量问题，CVP" class="headerlink" title="最近向量问题，CVP"></a>最近向量问题，CVP</h4><p><img src="/2023/04/07/Intro-to-lattices/image-20230409160843986.png" alt="image-20230409160843986"></p><p>SVP不比CVP更困难，CVP解决能解决SVP</p><p><img src="/2023/04/07/Intro-to-lattices/image-20230409164706784.png" alt="image-20230409164706784"></p><p><img src="/2023/04/07/Intro-to-lattices/image-20230409171842664.png" alt="image-20230409171842664"></p><p>LLL是多项式时间算法，输出短向量，近似因子接近$2^n$，当$n$接近500，输出向量不够理想</p><p><img src="/2023/04/07/Intro-to-lattices/image-20230409173133959.png" alt="image-20230409173133959"></p><p><img src="/2023/04/07/Intro-to-lattices/image-20230409173530831.png" alt="image-20230409173530831"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1re411W7vA/?spm_id_from=333.999.0.0&amp;amp;vd_source=fbfceeec0a697a64e4aba2132714eb9d&quot;&gt;2012年BIU密码学冬令营-01-Introduction to Lattices&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Crypto" scheme="https://alleysira.github.io/tags/Crypto/"/>
    
    <category term="Lattices" scheme="https://alleysira.github.io/tags/Lattices/"/>
    
  </entry>
  
  <entry>
    <title>Tech_chall_in_bc</title>
    <link href="https://alleysira.github.io/2023/03/15/Tech-chall-in-bc/"/>
    <id>https://alleysira.github.io/2023/03/15/Tech-chall-in-bc/</id>
    <published>2023-03-15T06:02:08.000Z</published>
    <updated>2023-03-15T07:33:55.113Z</updated>
    
    <content type="html"><![CDATA[<p>陈婧，Algorand Inc</p><span id="more"></span><p><img src="/2023/03/15/Tech-chall-in-bc/image-20230315140644953.png" alt="image-20230315140644953"></p><h1 id="Algorand"><a href="#Algorand" class="headerlink" title="Algorand"></a>Algorand</h1><p>不存在分叉，高效</p><p>不采用PoW：用户友好，参与门槛低</p><p>没有软分叉：即时确认</p><p>有了拜占庭协议为什么还需要研究共识：用户数量过高（10亿），效率低</p><p><img src="/2023/03/15/Tech-chall-in-bc/image-20230315141211609.png" alt="image-20230315141211609"></p><p><img src="/2023/03/15/Tech-chall-in-bc/image-20230315141320970.png" alt="image-20230315141320970"></p><p>如此设计不需要用户之间的通信，敌手不知道去攻击哪个节点</p><p>​    Algorand设置了分叉的概率为$10^{-18}$</p><h1 id="Technical-Challenges-in-Blockchains"><a href="#Technical-Challenges-in-Blockchains" class="headerlink" title="Technical Challenges in Blockchains"></a>Technical Challenges in Blockchains</h1><h2 id="Smart-contract"><a href="#Smart-contract" class="headerlink" title="Smart contract"></a>Smart contract</h2><p><img src="/2023/03/15/Tech-chall-in-bc/image-20230315142240113.png" alt="image-20230315142240113"></p><p>智能合约执行和共识执行解耦</p><p><img src="/2023/03/15/Tech-chall-in-bc/image-20230315142455033.png" alt="image-20230315142455033"></p><p>Algorand将复杂的计算放在链下，提供了一定的并行度</p><p><img src="/2023/03/15/Tech-chall-in-bc/image-20230315143455593.png" alt="image-20230315143455593"></p><p>应用中可能不需要递归，攻击者反而容易使用</p><h2 id="Interoperability"><a href="#Interoperability" class="headerlink" title="Interoperability"></a>Interoperability</h2><p>跨链问题，可能最终演变为类似操作系统的现状</p><p>目前的解决方案有</p><ul><li>转换token</li><li>burn-and-mint</li></ul><h2 id="Ecnomics-amp-Finance"><a href="#Ecnomics-amp-Finance" class="headerlink" title="Ecnomics &amp; Finance"></a>Ecnomics &amp; Finance</h2><ul><li>如何设计交易费</li><li>管理token</li><li><p>区块链上新的博弈模型</p></li><li><p>知识不对称：小白可能学习到专业的交易技巧/策略</p></li></ul><h2 id="Privacy-amp-Post-Quantum-Scurity"><a href="#Privacy-amp-Post-Quantum-Scurity" class="headerlink" title="Privacy &amp; Post-Quantum Scurity"></a>Privacy &amp; Post-Quantum Scurity</h2><p>工业界最关心的事是量子算法的可扩展性和效率</p><p><img src="/2023/03/15/Tech-chall-in-bc/image-20230315145047758.png" alt="image-20230315145047758"></p><p>链上可能接受的是对证明的验证，生成还是</p><p><img src="/2023/03/15/Tech-chall-in-bc/image-20230315145123162.png" alt="image-20230315145123162"></p><p><img src="/2023/03/15/Tech-chall-in-bc/image-20230315145507512.png" alt="image-20230315145507512"></p><h2 id="Scalability"><a href="#Scalability" class="headerlink" title="Scalability"></a>Scalability</h2><p><img src="/2023/03/15/Tech-chall-in-bc/image-20230315145743501.png" alt="image-20230315145743501"></p><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p>链下合约的安全性：如何进行授权</p><p>跨链的信任：共识决定了不同链的安全性保证不同，</p><p>被遗忘权：实现编辑权；存加密后的数据；物理网络上结合法律法规进行设计（可编辑区块链技术地位卑微）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;陈婧，Algorand Inc&lt;/p&gt;</summary>
    
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>bc_eco_sys</title>
    <link href="https://alleysira.github.io/2023/03/14/bc-eco-sys/"/>
    <id>https://alleysira.github.io/2023/03/14/bc-eco-sys/</id>
    <published>2023-03-14T08:30:15.000Z</published>
    <updated>2023-04-26T08:48:54.587Z</updated>
    
    <content type="html"><![CDATA[<p>随手记录见到的区块链应用案例</p><span id="more"></span><h1 id="政策"><a href="#政策" class="headerlink" title="政策"></a>政策</h1><ul><li>2021年十部委发文 <a href="http://www.gov.cn/zhengce/zhengceku/2021-10/08/content_5641404.htm"><strong>关于进一步防范和处置虚拟货币交易炒作风险的通知</strong></a></li></ul><h1 id="区块链行业资料"><a href="#区块链行业资料" class="headerlink" title="区块链行业资料"></a>区块链行业资料</h1><ul><li>信通院主导的<a href="http://www.trustedblockchain.cn/#/result/result/index/0">可信区块链推进计划 (trustedblockchain.cn)</a></li><li>信通院白皮书<a href="http://www.caict.ac.cn/kxyj/qwfb/bps/202212/t20221229_413462.htm">中国信通院-科研能力-权威发布-白皮书 (caict.ac.cn)</a></li><li>MEVboost提供了以太坊的四类实体的交易区块的可视化<a href="https://mevboost.pics/">mevboost.pics | MEV-Boost Dashboard</a></li></ul><h1 id="国内的区块链应用"><a href="#国内的区块链应用" class="headerlink" title="国内的区块链应用"></a>国内的区块链应用</h1><ul><li>中国移动的<a href="http://explorer.zhongyi.bsnbase.com/#/browserEos?activeTab=browserEos">中移链浏览器 (bsnbase.com)</a></li><li>中国联通的联通链Baas平台<a href="https://gec.10010.com/p/product/1002639">中国联通政企在线门户 (10010.com)</a></li><li>浙江冷链食品溯源码<a href="http://www.cixi.gov.cn/art/2021/1/5/art_1229036208_59040664.html">购买冷链食品可扫一扫“浙冷链”溯源码 (cixi.gov.cn)</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;随手记录见到的区块链应用案例&lt;/p&gt;</summary>
    
    
    
    
    <category term="Blockchian" scheme="https://alleysira.github.io/tags/Blockchian/"/>
    
  </entry>
  
  <entry>
    <title>scheme_design</title>
    <link href="https://alleysira.github.io/2023/03/10/scheme-design/"/>
    <id>https://alleysira.github.io/2023/03/10/scheme-design/</id>
    <published>2023-03-10T02:59:58.000Z</published>
    <updated>2023-04-04T02:27:38.336Z</updated>
    
    <content type="html"><![CDATA[<p>梳理思路，设计方案</p><span id="more"></span><h1 id="模型定义"><a href="#模型定义" class="headerlink" title="模型定义"></a>模型定义</h1><ul><li>定义方案需要满足的性质<ul><li>安全性<ul><li>链增长</li><li>链质量</li><li>公共前缀</li></ul></li></ul></li><li>定义编辑操作的正确性：不被通过的编辑请求是恶意的，即投票通过的编辑是合法的；具体表现包括<ul><li>不修改金融数据</li><li>[LMW23]定义的编辑正确性：An honest block modified by the adversary without the approval of the committee is malicious.</li></ul></li><li><p>腐化模型：t-温和敌手：是指敌手腐化一个节点需要一定的时间来完成. 敌手发布对目标节点的腐化指令, 经过t时间后, 目标节点被腐化, 受到敌手的控制, 成为恶意节点. 在实施腐化的t 时间内, 节点仍然属于诚实节点. 温和敌手是区块链协议分析中经常采用的腐化模型.</p></li><li><p>敌手模型：$n=2f+1$</p><ul><li><p>[JCH22]的方案要求门限值$t&gt;n/4$</p></li><li><p>[LMW23]如何确定委员会大小n，如何选举第一个委员会的成员（pow）</p></li></ul></li></ul><ul><li><p>网络模型：同步网络，存在已知的最大时延$\delta$</p></li><li><p>追责性：</p><ul><li><p>节点$P_i$发起编辑请求，所有节点收到后投票发送给委员会：</p><ul><li>投票不通过<ul><li>不执行，追责发起编辑的人以及投赞成票的人</li></ul></li><li>投票通过<ul><li>执行编辑之后，其他区块验证编辑不符合格式，追责编辑节点（领导者）</li></ul></li><li>记录发起编辑申请，扣除保证金</li></ul></li><li><p>惩罚投票阶段发送虚假份额的节点</p></li></ul></li></ul><ul><li><p>公平性：</p><ul><li><p>任何节点$P_i$可以通过发起编辑申请，缴纳保证金请求编辑，公平参与性</p></li><li><p>编辑权由编辑者掌握</p><ul><li>编辑者的选择依赖于委员会选择，委员会内可验证随机函数最小值（√）</li><li>投票就是密钥份额，超过门限直接执行（√）</li><li>恢复密钥阶段<ul><li>每个节点都有份额（√）</li><li>委员会成员有份额</li></ul></li><li>委员会选择的方法：相对简单的Pow<ul><li>节点为什么要加入委员会，设计激励制度，执行编辑操作，获得手续费</li></ul></li></ul></li></ul></li></ul><ul><li><p>为什么要设计委员会</p><ul><li>委员会成员进行变色龙哈希函数的密钥生成（√）</li><li>收集编辑请求，同意之后发出编辑的交易（√）</li><li>委员会内选举领导者，执行编辑（√）</li><li>委员会的大小，先定死</li></ul></li><li><p>委员会内投票还是所有节点参与投票</p><ul><li>委员会内投票：需要考虑委员会成员的安全性</li><li>所有节点投票，投票周期长，更加公平，超过门限就可以（√）<ul><li>门限是否设置为50%，保证安全性但是可能没有这么多节点在线</li></ul></li></ul></li></ul><h1 id="协议流程"><a href="#协议流程" class="headerlink" title="协议流程"></a>协议流程</h1><h2 id="选择委员会"><a href="#选择委员会" class="headerlink" title="选择委员会"></a>选择委员会</h2><p>委员会大小$t$</p><p>计算PoW $H(ini_ran|PK|IP|nonce)\leq 2^{-D}$，D是困难系数</p><p>委员会内领导者选举采用VRF</p><h2 id="分布式密钥生成"><a href="#分布式密钥生成" class="headerlink" title="分布式密钥生成"></a>分布式密钥生成</h2><p>暂定使用JCH22的方案</p><p><img src="/2023/03/10/scheme-design/image-20230316153823400.png" alt="image-20230316153823400"></p><h2 id="收集编辑请求"><a href="#收集编辑请求" class="headerlink" title="收集编辑请求"></a>收集编辑请求</h2><p>任何节点$P_i$想要修改区块$B_j$内的第$k$个交易，正常发起交易（上链后才能编辑），支付交易费和保证金</p><p>委员会节点打包交易发现有编辑交易后，在委员会内部发送编辑请求$req=(height,last_hash’,addr_{tx},tx,m_root,seq)$</p><p>委员会节点向所有全节点广播编辑请求，同意编辑的全节点向委员会返回$(ID(P_i),sig(P_i,seq),seq)$</p><p>委员会收集投票总数sum，$sum&gt;0.5n$且$sum&gt;t$则恢复密钥，执行编辑</p><h2 id="执行编辑"><a href="#执行编辑" class="headerlink" title="执行编辑"></a>执行编辑</h2><p>领导者生成区块$B_j$编辑后的区块$B^\star_j$，头部修改为$(prev_hash,last_hash’,acc)$，acc是更新后RSA累加器的值</p><h2 id="节点验证编辑并更新本地链"><a href="#节点验证编辑并更新本地链" class="headerlink" title="节点验证编辑并更新本地链"></a>节点验证编辑并更新本地链</h2><p>验证出块者是否在委员会内，是否为领导者</p><p>检查是否为合法区块</p><h2 id="委员会更新"><a href="#委员会更新" class="headerlink" title="委员会更新"></a>委员会更新</h2><p>更新，类似于定期执行$(t,n)\to(t’,n’)$秘密分享</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul><li>(已完成)JCH22在收集编辑请求过程中存在重放攻击，增加序列号</li><li>[未实现]委员会内的领导者隐藏身份，直到出块时在区块头增加出块者的身份</li><li>委员会的epoch设置为敌手腐化委员会成员需要的时间即可</li><li>为什么不使用公开可验证的秘密分享：采用公钥加密和零知识证明，导致效率更低；安全性上不参与秘密重构的人理应无权投诉。</li></ul><h2 id="论文问题"><a href="#论文问题" class="headerlink" title="论文问题"></a>论文问题</h2><ul><li>形式化撰写困难问题</li></ul><h2 id="后续可以研究的问题"><a href="#后续可以研究的问题" class="headerlink" title="后续可以研究的问题"></a>后续可以研究的问题</h2><ul><li>安全性<ul><li>保护领导者身份，委员会的环签名，如何追踪领导者作恶</li><li>密钥过期问题<ul><li>如果不更新<script type="math/tex">s</script>，存在曾经的密钥份额也可以恢复现在的秘密的情况(需要获得上一轮至少t个份额)</li><li>定期更新s，重新进行dkg即可</li><li>投票结果是否放在链上</li></ul></li><li>领导者作恶无法生成有效的编辑区块</li></ul></li></ul><h2 id="可参考的架构图"><a href="#可参考的架构图" class="headerlink" title="可参考的架构图"></a>可参考的架构图</h2><p><img src="/2023/03/10/scheme-design/image-20230404102733511.png" alt="image-20230404102733511"></p><p><img src="/2023/03/10/scheme-design/image-20230331115108870.png" alt="image-20230331115108870"></p><p><img src="/2023/03/10/scheme-design/image-20230331115138133.png" alt="image-20230331115138133"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;梳理思路，设计方案&lt;/p&gt;</summary>
    
    
    
    <category term="Crypto" scheme="https://alleysira.github.io/categories/Crypto/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>BIU</title>
    <link href="https://alleysira.github.io/2023/03/09/BIU/"/>
    <id>https://alleysira.github.io/2023/03/09/BIU/</id>
    <published>2023-03-09T08:43:56.000Z</published>
    <updated>2023-05-06T06:52:56.942Z</updated>
    
    <content type="html"><![CDATA[<p>13th BIU winter school</p><span id="more"></span><h1 id="What-are-Blockchains-and-What-are-They-For-Dan-Boneh"><a href="#What-are-Blockchains-and-What-are-They-For-Dan-Boneh" class="headerlink" title="What are Blockchains and What are They For? - Dan Boneh"></a>What are Blockchains and What are They For? - Dan Boneh</h1><p><img src="/2023/03/09/BIU/image-20230309164910424.png" alt="image-20230309164910424"></p><p>如果有可信方，不需要区块链技术</p><p><img src="/2023/03/09/BIU/image-20230309165047176.png" alt="image-20230309165047176"></p><p><img src="/2023/03/09/BIU/image-20230309165442867.png" alt="image-20230309165442867"></p><p>比特币的创新：实际的公开可写的数据结构</p><p><img src="/2023/03/09/BIU/image-20230309165717210.png" alt="image-20230309165717210"></p><p>以太坊的创新：可编程的环境，应用可以互相调用</p><p><img src="/2023/03/09/BIU/image-20230309165846240.png" alt="image-20230309165846240"></p><p>区块链通过复制的方法实现只能写的功能</p><ul><li>persistence: 只能写，不能删除</li><li>liveness: 诚实节点可以添加新的交易<ul><li>抗审查</li></ul></li></ul><p><img src="/2023/03/09/BIU/image-20230309170207472.png" alt="image-20230309170207472"></p><p><img src="/2023/03/09/BIU/image-20230309170459366.png" alt="image-20230309170459366"></p><p>和web2的区别是真正的状态存储在链上，而不是数据库</p><p><img src="/2023/03/09/BIU/image-20230309170529887.png" alt="image-20230309170529887"></p><p>资产由DAPP管理，和现实的金融机构不同，具有透明性</p><p><img src="/2023/03/09/BIU/image-20230309170646811.png" alt="image-20230309170646811"></p><h2 id="2-application-areas"><a href="#2-application-areas" class="headerlink" title="2 application areas"></a>2 application areas</h2><h3 id="DeFi"><a href="#DeFi" class="headerlink" title="DeFi"></a>DeFi</h3><p>任何人都可以建立金融基础设施</p><p>应用之间可以交互，只要满足ERC-20标准 6个函数</p><p><img src="/2023/03/09/BIU/image-20230309170833011.png" alt="image-20230309170833011"></p><p>为什么需要DeFi</p><ul><li>垮境手续费</li><li>经济可能不稳定</li><li>经济状况不好时不适合使用银行</li></ul><p><img src="/2023/03/09/BIU/image-20230309171413201.png" alt="image-20230309171413201"></p><p>Time will tell</p><p><img src="/2023/03/09/BIU/image-20230309171601629.png" alt="image-20230309171601629"></p><h3 id="DAOs"><a href="#DAOs" class="headerlink" title="DAOs"></a>DAOs</h3><ul><li>运行在特定地址的的DAPP</li><li>任何人可以给DAO捐钱</li><li>任何人可以发起请求<ul><li>投票（链上投票，链下可以用snapshot.org，如果通过再上链）<ul><li>如何链下投票，安全地把结果转移到链上是个问题</li></ul></li><li>同意，执行</li></ul></li></ul><p><img src="/2023/03/09/BIU/image-20230309171903673.png" alt="image-20230309171903673"></p><p>甚至有全日制员工，自己的博物馆，工资被program支付</p><p><img src="/2023/03/09/BIU/image-20230309172134135.png" alt="image-20230309172134135"></p><p>gitcoin 写开源代码，给开源者打钱</p><p>直接民主，direct governance，导致了参与度非常低</p><p><img src="/2023/03/09/BIU/image-20230309172510515.png" alt="image-20230309172510515"></p><p><img src="/2023/03/09/BIU/image-20230309172614155.png" alt="image-20230309172614155"></p><p>liquid democracy，也就是代理民主</p><p>政治学家可以进行民主实验，而不用建立一个新的国家</p><p><img src="/2023/03/09/BIU/image-20230309172916272.png" alt="image-20230309172916272"></p><p>2021年 Constitution DAO 但是输了</p><p>如何建立一个有secret treasury的DAO</p><p><img src="/2023/03/09/BIU/image-20230309173401581.png" alt="image-20230309173401581"></p><p>一个dapp，管理DAO的集合</p><p>问题是不知道DAO为什么要投资呢</p><p><img src="/2023/03/09/BIU/image-20230309173805546.png" alt="image-20230309173805546"></p><p><img src="/2023/03/09/BIU/image-20230309174355621.png" alt="image-20230309174355621"></p><p><img src="/2023/03/09/BIU/image-20230309174520582.png" alt="image-20230309174520582"></p><p>跨链</p><p>现实生活中有审计员，区块链可能需要对付款能力的零知识证明</p><p><img src="/2023/03/09/BIU/image-20230309174609532.png" alt="image-20230309174609532"></p><h1 id="An-Overview-of-PoW-and-PoS-Consensus-Valeria-Nikoaenko"><a href="#An-Overview-of-PoW-and-PoS-Consensus-Valeria-Nikoaenko" class="headerlink" title="An Overview of PoW and PoS Consensus - Valeria Nikoaenko"></a>An Overview of PoW and PoS Consensus - Valeria Nikoaenko</h1><p><img src="/2023/03/09/BIU/image-20230310160737648.png" alt="image-20230310160737648"></p><h2 id="Definiation-of-blockchian"><a href="#Definiation-of-blockchian" class="headerlink" title="Definiation of blockchian"></a>Definiation of blockchian</h2><p><img src="/2023/03/09/BIU/image-20230310160836195.png" alt="image-20230310160836195"></p><p>consensus不需要协商整个账本的历史，只需要协商最新的区块并达成一致</p><p>safety:</p><p>liveness: means not consoring, malicious </p><p><img src="/2023/03/09/BIU/image-20230310161343926.png" alt="image-20230310161343926"></p><p>实际像是key-value对，每个区块是对币的重新分配</p><p>D是一个状态</p><p><img src="/2023/03/09/BIU/image-20230310161621599.png" alt="image-20230310161621599"></p><p>节点负责打包交易出块</p><p>client作为用户，发送交易，身份可以重合</p><p><img src="/2023/03/09/BIU/image-20230310161742706.png" alt="image-20230310161742706"></p><p><img src="/2023/03/09/BIU/image-20230310161856858.png" alt="image-20230310161856858"></p><p>选举领导者的过程简化了共识的过程（选项更少）</p><p>假设了理想情况下节点对交易的内容是客观的，但实际上节点会有意见</p><h2 id="PoW-vs-PoS"><a href="#PoW-vs-PoS" class="headerlink" title="PoW vs PoS"></a>PoW vs PoS</h2><p>共识机制consensus 包含两部分</p><ul><li>选举出块者</li><li>每个参与者决定是否接收区块</li></ul><p><img src="/2023/03/09/BIU/image-20230310162245983.png" alt="image-20230310162245983"></p><p><img src="/2023/03/09/BIU/image-20230310162331356.png" alt="image-20230310162331356"></p><p>工作量证明增加了成为出块者的门槛，系统更容易选择如何出块</p><p>虽然很浪费资源，但是没有挖金矿浪费资源</p><p>比特币和以太坊占了时长的80%</p><p><img src="/2023/03/09/BIU/image-20230310163425990.png" alt="image-20230310163425990"></p><p>考虑设计密码系统的成本时，可以参考，计算$2^{76}$次哈希的成本约为$150,000$刀</p><p><img src="/2023/03/09/BIU/image-20230310163902166.png" alt="image-20230310163902166"></p><p>如何设计更好地PoW</p><p><img src="/2023/03/09/BIU/image-20230310164124610.png" alt="image-20230310164124610"></p><ul><li>proof-of-useful-work：解决实际问题</li></ul><p>减少PoW使用的频率：PoW选举领导者，每个任期多次出块</p><p><img src="/2023/03/09/BIU/image-20230310164757487.png" alt="image-20230310164757487"></p><p>挖矿的收益和投入之间成比例</p><p>在PoS中矿工的收入和存的钱相关，任期结束后归还，提供了惩罚的方法；和Pow的区别是：在PoW系统中如果想要退出，已经购买的硬件成本无法像PoS一样回收</p><p><img src="/2023/03/09/BIU/image-20230310165126602.png" alt="image-20230310165126602" style="zoom: 80% ;"></p><p><img src="/2023/03/09/BIU/image-20230310165135320.png" alt="image-20230310165135320"></p><p><img src="/2023/03/09/BIU/image-20230310165601334.png" alt="image-20230310165601334"></p><p>在代理PoS中，借出权益也会获得收益</p><p><img src="/2023/03/09/BIU/image-20230310165926265.png" alt="image-20230310165926265"></p><p>非常成功，全球用电量降低了0.2%，ASIC用户可能转向其他Pow的区块链或者零知识证明的</p><p>An application-specific integrated circuit (ASIC) is <strong>an integrated circuit chip designed for a specific purpose</strong>. An ASIC miner is a computerized device that uses ASICs for the sole purpose of “mining” digital currency. Generally, each ASIC miner is constructed to mine a specific digital currency.</p><h2 id="Longest-chain-vs-BFT"><a href="#Longest-chain-vs-BFT" class="headerlink" title="Longest chain vs BFT"></a>Longest chain vs BFT</h2><p><img src="/2023/03/09/BIU/image-20230310170815540.png" alt="image-20230310170815540"></p><p>BFT是为了设计可靠的分布式系统提出的，但是需要预先知道验证者的规模</p><p><img src="/2023/03/09/BIU/image-20230310171044295.png" alt="image-20230310171044295"></p><p><img src="/2023/03/09/BIU/image-20230310171510394.png" alt="image-20230310171510394"></p><p>推荐的学习资料</p><p><img src="/2023/03/09/BIU/image-20230310171756494.png" alt="image-20230310171756494"></p><p><img src="/2023/03/09/BIU/image-20230310171915851.png" alt="image-20230310171915851"></p><p><img src="/2023/03/09/BIU/image-20230312125824805.png" alt="image-20230312125824805"></p><p><img src="/2023/03/09/BIU/image-20230312130251382.png" alt="image-20230312130251382"></p><p><img src="/2023/03/09/BIU/image-20230312130536483.png" alt="image-20230312130536483"></p><p>Latest message-driven greedy heaviest observed sub-tree</p><p>未被选择的区块内的交易重新回到交易池等待被打包</p><p>最长链方案存在的问题：</p><ul><li><p>双花攻击，确认结果是概率的，等待时间越长，确认的正确概率越高</p></li><li><p>对用户不友好，可能需要等待1h-1day</p></li><li><p>在分片下不安全，可能会出现冲突的链</p></li></ul><p><img src="/2023/03/09/BIU/image-20230312132622028.png" alt="image-20230312132622028" style="zoom:67%;"></p><p><img src="/2023/03/09/BIU/image-20230312132644507.png" alt="image-20230312132644507"></p><p><img src="/2023/03/09/BIU/image-20230312132802166.png" alt="image-20230312132802166"></p><p>Responsiveness指网络越快，完成协议越快</p><p>Hotstuff的创新点在于：</p><ul><li><p>将消息重新发回Leader，让Leader再广播，避免了$n^2$的复杂度</p></li><li><p>支持并行</p></li></ul><p><img src="/2023/03/09/BIU/image-20230312132902496.png" alt="image-20230312132902496"></p><p><img src="/2023/03/09/BIU/image-20230312133156905.png" alt="image-20230312133156905"></p><p><img src="/2023/03/09/BIU/image-20230312133251103.png" alt="image-20230312133251103"></p><p>保证了3个区块后就一定会被确认</p><p><img src="/2023/03/09/BIU/image-20230312133301876.png" alt="image-20230312133301876"></p><p>当验证者的数量增加到大于100时，效率会非常低，延迟会很高</p><p>混合的协议</p><p><img src="/2023/03/09/BIU/image-20230312133530407.png" alt="image-20230312133530407"></p><p><img src="/2023/03/09/BIU/image-20230312133629192.png" alt="image-20230312133629192"></p><p><img src="/2023/03/09/BIU/image-20230312133722087.png" alt="image-20230312133722087"></p><p><img src="/2023/03/09/BIU/image-20230312134123486.png" alt="image-20230312134123486"></p><h1 id="An-Overview-of-the-Ethereum-Excecution-Layer-Dan-Boneh"><a href="#An-Overview-of-the-Ethereum-Excecution-Layer-Dan-Boneh" class="headerlink" title="An Overview of the Ethereum Excecution Layer - Dan Boneh"></a>An Overview of the Ethereum Excecution Layer - Dan Boneh</h1><p><img src="/2023/03/09/BIU/image-20230312134233883.png" alt="image-20230312134233883"></p><p>先上一节crash course</p><p><img src="/2023/03/09/BIU/image-20230312134449575.png" alt="image-20230312134449575"></p><p>状态转移函数，什么是world state</p><p><img src="/2023/03/09/BIU/image-20230312134542647.png" alt="image-20230312134542647"></p><p><img src="/2023/03/09/BIU/image-20230312134658166.png" alt="image-20230312134658166"></p><p><img src="/2023/03/09/BIU/image-20230312134732323.png" alt="image-20230312134732323"></p><p><img src="/2023/03/09/BIU/image-20230312134945076.png" alt="image-20230312134945076"></p><p>这次讲座主要介绍execution_layer</p><h2 id="The-Ethereum-Compute-Layer-The-EVM"><a href="#The-Ethereum-Compute-Layer-The-EVM" class="headerlink" title="The Ethereum Compute Layer: The EVM"></a>The Ethereum Compute Layer: The EVM</h2><p>从顶向下进行介绍</p><p><img src="/2023/03/09/BIU/image-20230312135134997.png" alt="image-20230312135134997"></p><p>状态空间很大，$2^{32}$</p><p>人类的代码站在了同一个层次</p><p><img src="/2023/03/09/BIU/image-20230312140316880.png" alt="image-20230312140316880"></p><p>线性计算复杂度</p><p><img src="/2023/03/09/BIU/image-20230312140547577.png" alt="image-20230312140547577"></p><p>四种类型的交易，contract也可以给contract转钱</p><p><img src="/2023/03/09/BIU/image-20230312140928114.png" alt="image-20230312140928114"></p><p>交易的内容</p><p>来自contract的交易不会被签名</p><p>目的地址为0时相当于建立新的账户，输出hash(your address，your notes)</p><p>如何在链上存储secret key？</p><p>nonce机制是为了防御重放攻击，但仍然可能存在跨链重放，设计了chain_id字段</p><p>如果同一个nonce被使用多次，只有其中一个交易会被接受，其他会被拒绝 </p><p><img src="/2023/03/09/BIU/image-20230312141920486.png" alt="image-20230312141920486"></p><p>提交的代码占的空间越少越好</p><p><img src="/2023/03/09/BIU/image-20230312142831254.png" alt="image-20230312142831254"></p><p><img src="/2023/03/09/BIU/image-20230312143543518.png" alt="image-20230312143543518"></p><p><img src="/2023/03/09/BIU/image-20230312143649117.png" alt="image-20230312143649117"></p><p>archival 存储了所有的历史</p><p>log message for：记录了合约做了什么，如果发起了一个换钱交易，log可能记录了将多少转换为多少</p><p><img src="/2023/03/09/BIU/image-20230312144409662.png" alt="image-20230312144409662"></p><p><img src="/2023/03/09/BIU/image-20230312145244476.png" alt="image-20230312145244476"></p><p><img src="/2023/03/09/BIU/image-20230312145313760.png" alt="image-20230312145313760"></p><p>存在<a href="[What Is a Front-Running Attack? (halborn.com">front running attack</a>](<a href="https://www.halborn.com/blog/post/what-is-a-front-running-attack">https://www.halborn.com/blog/post/what-is-a-front-running-attack</a>)) </p><p>Front-running attacks take advantage of this process of adding transactions to blocks based on transaction fees. An attacker has the ability to ensure that their transaction is processed before any other transaction by including a higher transaction fee with it. This is called a front-running attack.</p><p><img src="/2023/03/09/BIU/image-20230312150136506.png" alt="image-20230312150136506"></p><p><img src="/2023/03/09/BIU/image-20230312150231761.png" alt="image-20230312150231761"></p><p><img src="/2023/03/09/BIU/image-20230312150338122.png" alt="image-20230312150338122"></p><p>nameLookup函数是为其他智能合约设计的，brain of the contract</p><p>如果把秘密放在链上</p><p>为什么使用name而不是直接使用地址：</p><ul><li>name的代价是付出成本，convenience costs money</li><li>某种意义上将name可能更安全，address可能存在typo</li></ul><p>目前存在系统中的小bug：由于交易的目的地址可以是虚假的地址，造成了不存在的地址却拥有账户余额的情况，如果智能合约的编写假设了余额为0，可能产生bug</p><p><img src="/2023/03/09/BIU/image-20230312173809451.png" alt="image-20230312173809451"></p><p>一般数据存在链下，链上存储承诺</p><p><img src="/2023/03/09/BIU/image-20230312174155419.png" alt="image-20230312174155419"></p><p>log是执行层产生的，但是执行层不能读</p><p><img src="/2023/03/09/BIU/image-20230312174542018.png" alt="image-20230312174542018"></p><p><img src="/2023/03/09/BIU/image-20230312180142873.png" alt="image-20230312180142873"></p><p><img src="/2023/03/09/BIU/image-20230312180429548.png" alt="image-20230312180429548"></p><p><img src="/2023/03/09/BIU/image-20230312180621134.png" alt="image-20230312180621134"></p><p><img src="/2023/03/09/BIU/image-20230312180445905.png" alt="image-20230312180445905"></p><h1 id="CeFi-Versus-DeFi-Arthur-Gervais"><a href="#CeFi-Versus-DeFi-Arthur-Gervais" class="headerlink" title="CeFi Versus DeFi - Arthur Gervais"></a>CeFi Versus DeFi - Arthur Gervais</h1><p><img src="/2023/03/09/BIU/image-20230313151729740.png" alt="image-20230313151729740"></p><p>Defi存在于application logic state层 ，将逻辑编码在应用程序中</p><p>设计的composability使得应用之间能够进行交互</p><p>标准保证了composability</p><p>arbitrage：套利</p><p> What Is a Bear Raid?</p><p>A bear raid is an illegal practice of colluding to push a stock’s price lower through concerted <a href="https://www.investopedia.com/terms/s/shortselling.asp">short selling</a>, while spreading negative rumors about the shorted company. A bear raid is sometimes undertaken by unscrupulous short sellers who want to make a quick buck from their short positions, leveraging social media platforms and online message boards.<img src="/2023/03/09/BIU/image-20230313153521850.png" alt="image-20230313153521850"></p><p>what is stable coin like USDC？A stablecoin is a <strong>digital currency that is pegged to a “stable” reserve asset</strong> like the U.S. dollar or gold. Stablecoins are designed to reduce volatility relative to unpegged cryptocurrencies like Bitcoin.</p><p>由于比特币缺乏接受外界输出的能力，需要使用Oracle和现实世界交互.<strong>区块链外信息写入区块链内的机制，一般被称为预言机 (oracle mechanism)</strong> <a href="[什么是区块链预言机（BlockChain Oracle） - 知乎 (zhihu.com">参考</a>](<a href="https://zhuanlan.zhihu.com/p/52369816">https://zhuanlan.zhihu.com/p/52369816</a>))</p><p>Oracle需要了解实时的汇率</p><p><img src="/2023/03/09/BIU/image-20230313155357802.png" alt="image-20230313155357802"></p><p>custodial就是类似于银行的机构，保管大部分资产</p><p>任何参与者不能有优势来审查交易和协议执行</p><p><img src="/2023/03/09/BIU/image-20230313160105543.png" alt="image-20230313160105543"></p><p><img src="/2023/03/09/BIU/image-20230313160224017.png" alt="image-20230313160224017"></p><p> <img src="/2023/03/09/BIU/image-20230313160417991.png" alt="image-20230313160417991"><img src="/2023/03/09/BIU/image-20230313160353603.png" alt="image-20230313160353603"></p><p>FAFT gives examples but not standards.</p><p>如果有节点能独自审查交易，可能会要求KYC/AML</p><p><img src="/2023/03/09/BIU/image-20230313161156286.png" alt="image-20230313161156286"></p><p>稳定币可以冻结一些地址，减少攻击带来的危害 2周前发生过</p><p>usdt可以销毁 </p><p><img src="/2023/03/09/BIU/image-20230313162127044.png" alt="image-20230313162127044"></p><p><img src="/2023/03/09/BIU/image-20230313162307038.png" alt="image-20230313162307038"></p><p>limit order book</p><p><img src="/2023/03/09/BIU/image-20230313162621936.png" alt="image-20230313162621936"></p><p>买卖订单可以分为市价订单（market order）和限价订单（limit order），市价订单是指当交易者想要尽可能快速地执行目标交易指令，从而以市场最优价格发出的订单指令；限价订单则区别于最优价格，交易者会在订单中指定买入的最高价格或者卖出的最低价格，以及对应的订单规模，等待市场价格变动后到达自己的目标价位，再进行撮合成交。这些限价订单被交易所整合到一起并挂出，就是我们所介绍的限价订单簿。因此，限价订单簿（limit order book, LOB），顾名思义，也就是市场上限价订单的集合簿。</p><p><img src="/2023/03/09/BIU/image-20230313163116934.png" alt="image-20230313163116934"></p><p><a href="https://zhuanlan.zhihu.com/p/446271796">什么是Uniswap? 史上最全新手导读 - 知乎 (zhihu.com)</a></p><p><img src="/2023/03/09/BIU/image-20230313164051858.png" alt="image-20230313164051858"></p><p><img src="/2023/03/09/BIU/image-20230313164734783.png" alt="image-20230313164734783"></p><p>如何免费发送交易，using relayer，如果失败了不需要付款</p><p><img src="/2023/03/09/BIU/image-20230313165108420.png" alt="image-20230313165108420"> </p><p><img src="/2023/03/09/BIU/image-20230313165455850.png" alt="image-20230313165455850"></p><p>在Defi中抵押的价值通常比借的数额更多</p><p>杠杆是导致借贷流行的重要因素</p><p><img src="/2023/03/09/BIU/image-20230313165808193.png" alt="image-20230313165808193"></p><p><img src="/2023/03/09/BIU/image-20230313170926997.png" alt="image-20230313170926997"></p><p><img src="/2023/03/09/BIU/image-20230313172802145.png" alt="image-20230313172802145"></p><p>主要用来交换担保或者套利</p><p><img src="/2023/03/09/BIU/image-20230313172947491.png" alt="image-20230313172947491"></p><p>可能会被拿来进行投票（虚假的权益），makerDAO，已经修复无法进行投票 ；</p><p>可能会被用来套现</p><p><img src="/2023/03/09/BIU/image-20230313173247208.png" alt="image-20230313173247208"></p><p>rational矿工实际可以在打包交易时本地运行程序来检查自己能否复现套现的操作，为自己谋利</p><p><img src="/2023/03/09/BIU/image-20230313174329437.png" alt="image-20230313174329437"></p><p><img src="/2023/03/09/BIU/image-20230313174417558.png" alt="image-20230313174417558"></p><p><img src="/2023/03/09/BIU/image-20230313174436585.png" alt="image-20230313174436585"></p><p><img src="/2023/03/09/BIU/image-20230313174516002.png" alt="image-20230313174516002"></p><p><img src="/2023/03/09/BIU/image-20230313174545417.png" alt="image-20230313174545417"></p><p><img src="/2023/03/09/BIU/image-20230313174634381.png" alt="image-20230313174634381"></p><p><img src="/2023/03/09/BIU/image-20230313174653896.png" alt="image-20230313174653896"></p><p><img src="/2023/03/09/BIU/image-20230313175230630.png" alt="image-20230313175230630"></p><p><img src="/2023/03/09/BIU/image-20230313175347680.png" alt="image-20230313175347680"> </p><p><img src="/2023/03/09/BIU/image-20230313175538566.png" alt="image-20230313175538566"></p><p><img src="/2023/03/09/BIU/image-20230313175555758.png" alt="image-20230313175555758"></p><p>如果钱包的私钥泄露，可能存在跨链的安全性问题</p><p><img src="/2023/03/09/BIU/image-20230313175832184.png" alt="image-20230313175832184"></p><p><img src="/2023/03/09/BIU/image-20230313175946183.png" alt="image-20230313175946183"></p><p>GameStop </p><p><img src="/2023/03/09/BIU/image-20230313180205737.png" alt="image-20230313180205737"></p><p><img src="/2023/03/09/BIU/image-20230313180313425.png" alt="image-20230313180313425"></p><h1 id="Hard-Problems-in-Blockchains-Valeria-Nikolaenko"><a href="#Hard-Problems-in-Blockchains-Valeria-Nikolaenko" class="headerlink" title="Hard Problems in Blockchains - Valeria Nikolaenko"></a>Hard Problems in Blockchains - Valeria Nikolaenko</h1><p><img src="/2023/03/09/BIU/image-20230314091825196.png" alt="image-20230314091825196"></p><h2 id="Long-Range-Attack"><a href="#Long-Range-Attack" class="headerlink" title="Long-Range Attack"></a>Long-Range Attack</h2><p>虽然讲的是困难问题，实际上区块链系统运行的很好，更加高效节约能源（不要被吓到233）</p><p><img src="/2023/03/09/BIU/image-20230314092026596.png" alt="image-20230314092026596"></p><p>出块时锁定了自己的权益，如果作恶会被惩罚</p><p><img src="/2023/03/09/BIU/image-20230314092155928.png" alt="image-20230314092155928"></p><p><img src="/2023/03/09/BIU/image-20230314092213092.png" alt="image-20230314092213092"> </p><p>考虑验证者的生命周期，当不再持有财产后没有保存旧的密钥的动机</p><p><img src="/2023/03/09/BIU/image-20230314092852032.png" alt="image-20230314092852032"></p><p>PoS中敌手很容易做到分叉，PoW中不适用</p><p>当以前的私钥泄露后，敌手可能轻易伪造一条和当前链长度相同的分叉</p><p><img src="/2023/03/09/BIU/image-20230314092917720.png" alt="image-20230314092917720"></p><p><img src="/2023/03/09/BIU/image-20230314093141414.png" alt="image-20230314093141414"></p><p>当验证者密钥最少的时候最容易受到敌手攻击</p><p><img src="/2023/03/09/BIU/image-20230314093304538.png" alt="image-20230314093304538"> </p><p>将主链的区块哈希硬编码在中心化组织，比如github</p><ul><li>如果不中心化，检查点的哈希可能不一样，如何协商/选择</li><li>可以把检查点写在PoW区块链上（目前最实际的做法）<ul><li>如果安全性依赖PoW的链，PoS也没有那么节约电力 </li></ul></li></ul><p><img src="/2023/03/09/BIU/image-20230314094015158.png" alt="image-20230314094015158"></p><p>如果不验证轮换密钥，更加容易攻击。考虑在$t_4$攻击两个节点很困难，但是等价于在$t_2$攻击相同的两个节点</p><p>核心思想是激励验证者更新密钥</p><p><img src="/2023/03/09/BIU/image-20230314094506538.png" alt="image-20230314094506538"></p><p><img src="/2023/03/09/BIU/image-20230314094848617.png" alt="image-20230314094848617"></p><p>公钥不变，更新私钥，但是会泄露部分信息，私钥会变得越来越弱</p><p>假设相信他们会忘记旧的密钥</p><p>如果验证者知道未来可能通过出售私钥获利，无法假设验证者是诚实的，因此无法解决实际问题</p><p><img src="/2023/03/09/BIU/image-20230314095334330.png" alt="image-20230314095334330"></p><p>以太坊建议的解决方案 ，问题是实际上验证者和客户端不会一直查看链的状态</p><p><img src="/2023/03/09/BIU/image-20230314095519060.png" alt="image-20230314095519060"></p><p>开始介绍自己发的文章，引入了第二层共识</p><p><img src="/2023/03/09/BIU/image-20230314095757652.png" alt="image-20230314095757652"></p><p>如果区块链生成区块的速度很快，用户发起的交易的last_block字段很可能落后于当前区块，可以考虑设置此字段为更长的时间间隔，比如epoch</p><p><img src="/2023/03/09/BIU/image-20230314095924108.png" alt="image-20230314095924108"></p><p><img src="/2023/03/09/BIU/image-20230314100013866.png" alt="image-20230314100013866"></p><p><img src="/2023/03/09/BIU/image-20230314100050437.png" alt="image-20230314100050437"></p><p><img src="/2023/03/09/BIU/image-20230314100343805.png" alt="image-20230314100343805"></p><p>第二层共识需要用户在线，实际的场景可能没有这么多用户在线，考虑代理或降低交易费</p><p>验证者可能会更加倾向于打包一些交易，不再客观 </p><p>假设所有用户知道当前正确的链是哪一条，预防了敌手不知道在哪条冲突的链投票的情况</p><p>存在潜在中心化的问题：用户的对链上信息的了解可能来自某些中心化机构，比如交易所；本方案要求用户对比各个信息源的</p><p>方案类似于要求用户参与链的安全性</p><p><img src="/2023/03/09/BIU/image-20230314103006306.png" alt="image-20230314103006306"></p><h2 id="Proposer-Election-in-PoS"><a href="#Proposer-Election-in-PoS" class="headerlink" title="Proposer Election in PoS"></a>Proposer Election in PoS</h2><p><img src="/2023/03/09/BIU/image-20230314103452297.png" alt="image-20230314103452297"></p><p>如果T的值很大，攻击者很容易引诱leader或者进行Dos攻击</p><p><img src="/2023/03/09/BIU/image-20230314105318786.png" alt="image-20230314105318786"></p><p>循环选择显然不满足不可预测性和无偏性</p><p><img src="/2023/03/09/BIU/image-20230314105713753.png" alt="image-20230314105713753"></p><p>使用RB的问题在于出现了循环依赖关系，一般的解决方案是当前轮固定proposer的schedule</p><p>以太坊采用的drb</p><p><img src="/2023/03/09/BIU/image-20230314110033912.png" alt="image-20230314110033912"></p><p>节点可以选择提交$v_i$或者保存，但是VDF保证了无法预先计算随机数的值，不具备提前进行判断的优势</p><p>问题是目前的实践部分，VDF的理论构造很好，但是实际的构造基于class group，很多人不看好；</p><p>以太坊的构造是对同一个函数的多次计算并给出证明，未来很可能会出现可用的</p><p>为了保证VDF无法被加速，需要在ASIC进行验证（很贵）</p><p><img src="/2023/03/09/BIU/image-20230314111602084.png" alt="image-20230314111602084"></p><p>ethereum</p><p><img src="/2023/03/09/BIU/image-20230314111615701.png" alt="image-20230314111615701"></p><p><img src="/2023/03/09/BIU/image-20230314113106896.png" alt="image-20230314113106896"></p><h2 id="Post-quantum-blockchains"><a href="#Post-quantum-blockchains" class="headerlink" title="Post-quantum blockchains"></a>Post-quantum blockchains</h2><p><img src="/2023/03/09/BIU/image-20230314144442669.png" alt="image-20230314144442669"></p><p><img src="/2023/03/09/BIU/image-20230314144521529.png" alt="image-20230314144521529"></p><p>PoW机制也存在问题，量子矿工能在$T$时间搜索$T^2$的空间，可能传统矿工挖矿的动机会消失</p><p>hash函数的困难性依然得到保证</p><p><img src="/2023/03/09/BIU/image-20230314144857476.png" alt="image-20230314144857476"></p><p><img src="/2023/03/09/BIU/image-20230314144932739.png" alt="image-20230314144932739"></p><p>后量子签名的大小显著增加</p><p><img src="/2023/03/09/BIU/image-20230314145205986.png" alt="image-20230314145205986"></p><p><img src="/2023/03/09/BIU/image-20230314145215000.png" alt="image-20230314145215000"></p><p><img src="/2023/03/09/BIU/image-20230314145249133.png" alt="image-20230314145249133"></p><p><img src="/2023/03/09/BIU/image-20230314145409065.png" alt="image-20230314145409065"></p><p>可以采用零知识证明证明自己拥有seed来宣称所有权</p><p><img src="/2023/03/09/BIU/image-20230314150230758.png" alt="image-20230314150230758"></p><p><img src="/2023/03/09/BIU/image-20230314150248652.png" alt="image-20230314150248652"></p><p><img src="/2023/03/09/BIU/image-20230314150316944.png" alt="image-20230314150316944"></p><h1 id="The-Risk-of-Censorship-and-De-anonymization-Arthur-Gervais"><a href="#The-Risk-of-Censorship-and-De-anonymization-Arthur-Gervais" class="headerlink" title="The Risk of Censorship and De-anonymization - Arthur Gervais"></a>The Risk of Censorship and De-anonymization - Arthur Gervais</h1><p>define censorship:</p><ul><li>某个矿工忽略某个交易，属于censor吗</li><li>许多矿工故意不传播某个交易，属于对该交易censor</li><li>如果网络发生了分片，可能是一种censor</li></ul><p><img src="/2023/03/09/BIU/image-20230329095555113.png" alt="image-20230329095555113"></p><p><img src="/2023/03/09/BIU/image-20230329095714528.png" alt="image-20230329095714528"></p><p><img src="/2023/03/09/BIU/image-20230329103715524.png" alt="image-20230329103715524"></p><p><img src="/2023/03/09/BIU/image-20230329103750638.png" alt="image-20230329103750638"></p><p>Q：为什么tornado cash只实现输入1eth拿出1eth而不支持1.1eth进1.1出</p><p>A：如果进入的输入不固定为1,10,100，敌手容易观察出身份</p><p>Q：who pays for the gas？</p><p>A：存在一个第三方，需要混币的人向第三方发送证明，第三方负责给mixer支付gas，然后从需要混币的人从池子中拿回的钱里取一部分做补偿</p><ul><li>或许可以拿存的钱来挖矿，类似于银行</li></ul><p>mixer的用户足够多时，才能够保护用户的隐私。同时还需要浏览器，ip地址可能泄露隐私的保护。</p><p><img src="/2023/03/09/BIU/image-20230329105756930.png" alt="image-20230329105756930"></p><p>相当一部分来自TC自己，说明可能经过多次混币</p><p><img src="/2023/03/09/BIU/image-20230329105847587.png" alt="image-20230329105847587"></p><p>制裁之后TC的存款量减少为以前的20%</p><p>多次混币</p><p><img src="/2023/03/09/BIU/image-20230410101127788.png" alt="image-20230410101127788"></p><p><img src="/2023/03/09/BIU/image-20230329110006218.png" alt="image-20230329110006218"></p><p>但是从矿池角度来看，制裁之后包含TC交易的矿池几乎没有了</p><p><img src="/2023/03/09/BIU/image-20230329110214688.png" alt="image-20230329110214688"></p><p><img src="/2023/03/09/BIU/image-20230329110825537.png" alt="image-20230329110825537"></p><p>以太坊目前有四类实体</p><ul><li>searchers 逐利，可能在套利/清算，将交易发给builder</li><li>builder负责将交易打包为有序的区块，发给relayer</li><li>relayer选择出价最高的交易交给validator出块</li></ul><p>究竟谁在参与censor？</p><p><img src="/2023/03/09/BIU/image-20230329111257477.png" alt="image-20230329111257477"></p><p>图中的绿色区块是包含TC交易的区块，即认为是没有被审查过的</p><p>该网站提供了以太坊的四类实体的交易区块的可视化<a href="https://mevboost.pics/">mevboost.pics | MEV-Boost Dashboard</a></p><p>Maximal Extractable Value (MEV) is a method for miners or validators to increase their profits by changing the order of transactions before approving a new block on the network. MEV refers to profits that can be made by extracting value from Ethereum users by reordering, inserting, or censoring transactions within blocks being produced. It is one of Ethereum’s biggest issues, with more than $689 million extracted from users of the network year-to-date.</p><p>TC交易被ban掉的这一现象可能就是一种censorship</p><p><img src="/2023/03/09/BIU/image-20230329112311713.png" alt="image-20230329112311713"></p><p>blender.io不是智能合约，由第三方实体提供混币服务，当OFAC开始后，服务几乎停止了（相对于智能合约，代码开源，更难容易关停）</p><p><img src="/2023/03/09/BIU/image-20230329112322049.png" alt="image-20230329112322049"></p><p>Q：security implications of censorship?</p><p><img src="/2023/03/09/BIU/image-20230329113530464.png" alt="image-20230329113530464"></p><p>如何判断交易确认延迟：引入挖矿矿池之外的节点spy node</p><p><img src="/2023/03/09/BIU/image-20230329113645178.png" alt="image-20230329113645178"></p><p>实验结果显示censor 交易确认时间出现了变化15.8s-29.3s</p><p>但是实验无法区分是sanction导致了变化还是ethereum的proposer builder(M PBS)区分导致的</p><p><img src="/2023/03/09/BIU/image-20230329113942951.png" alt="image-20230329113942951"> </p><p>接下来考虑DOS的部分，核心思想是让节点执行工作却不付gas ，前提条件是发起交易比验证更廉价</p><p><img src="/2023/03/09/BIU/image-20230329114409396.png" alt="image-20230329114409396"></p><p>如何设计攻击：交易前面都是复杂的逻辑，但是最后是TC，由于节点想要监管，并不会将交易包含在区块内，类似于让validator打白工了</p><p><img src="/2023/03/09/BIU/image-20230329115047150.png" alt="image-20230329115047150"></p><p>存在问题：如何得知哪个validator在执行交易</p><p>已经解决：查看每个块的coinbase交易，可以区分执行censoring和不censoring的miner</p><p>后续可以设计更加精巧的攻击方案：如果可能得知下一个validator会censor再攻击</p><p><img src="/2023/03/09/BIU/image-20230329141242534.png" alt="image-20230329141242534"></p><p><img src="/2023/03/09/BIU/image-20230329141353038.png" alt="image-20230329141353038"></p><p>通过这个问题，提出了Censor可能引入被Dos攻击这一问题</p><p><img src="/2023/03/09/BIU/image-20230329165410233.png" alt="image-20230329165410233"></p><p>Q：如果所有的validator开始审查，是否可以通过硬分叉来实现先拿到fee再执行</p><p>A：可能存在的</p><h1 id="What-Are-Snarks-and-What-Are-They-Good-for-Dan-Boneh"><a href="#What-Are-Snarks-and-What-Are-They-Good-for-Dan-Boneh" class="headerlink" title="What Are Snarks and What Are They Good for? - Dan Boneh"></a>What Are Snarks and What Are They Good for? - Dan Boneh</h1><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p><img src="/2023/03/09/BIU/image-20230329170654067.png" alt="image-20230329170654067"></p><p>40年发展，第一行是提供snark的公司，第二行是使用snark的公司，第三行是研究snark硬件加速的</p><p><img src="/2023/03/09/BIU/image-20230329170940528.png" alt="image-20230329170940528"></p><p>ZNARK发展快速的原因</p><p><img src="/2023/03/09/BIU/image-20230329171633196.png" alt="image-20230329171633196"></p><p>what is layer1 blockchain</p><p>Layer 1 refers to a base network, such as Bitcoin, BNB Chain, or Ethereum, and its underlying infrastructure. Layer-1 blockchains can validate and finalize transactions without the need for another network. Making improvements to the scalability of layer-1 networks is difficult, as we’ve seen with Bitcoin. As a solution, developers create layer-2 protocols that rely on the layer-1 network for security and consensus. Bitcoin’s Lightning Network is one example of a layer-2 protocol. It allows users to make transactions freely before recording them into the main chain.</p><p>讨论两类区块链：</p><ul><li>外包计算的：没有隐私，不需要ZK，但是链上存储非常昂贵，交易需要快速被验证<ul><li>跨链：对旧链资产进行证明，B链证明</li><li>如何实现资产的跨链？在旧链上lock资产，新链得知存在被locked的资产</li></ul></li><li>需要保护隐私的链<ul><li>证明加密的交易有效</li><li>证明交易是可偿还的，证明资产</li></ul></li></ul><p>研究的目的：证明更短，验证更快，生成证明更快</p><p><img src="/2023/03/09/BIU/image-20230329173006577.png" alt="image-20230329173006577"></p><p><img src="/2023/03/09/BIU/image-20230329173516102.png" alt="image-20230329173516102"></p><p>区块链驱动了SNARKS的发展，许多其他的与区块链无关的应用收益</p><p><img src="/2023/03/09/BIU/image-20230329173756175.png" alt="image-20230329173756175"></p><p><img src="/2023/03/09/BIU/image-20230329173820719.png" alt="image-20230329173820719"></p><p><a href="https://a16zcrypto.com/content/article/zero-knowledge-canon/">Zero Knowledge Canon, part 1 &amp; 2 - a16z crypto</a></p><h2 id="what-is-SNARK"><a href="#what-is-SNARK" class="headerlink" title="what is SNARK?"></a>what is SNARK?</h2><p><img src="/2023/03/09/BIU/image-20230329174411327.png" alt="image-20230329174411327"></p><p>算术电路，n元多项式的评估方法</p><p><img src="/2023/03/09/BIU/image-20230329174551593.png" alt="image-20230329174551593"></p><p>pp is prover parameter，vp is verifier parameter.</p><p><img src="/2023/03/09/BIU/image-20230329174843720.png" alt="image-20230329174843720"></p><p>next</p><p><img src="/2023/03/09/BIU/image-20230330154239398.png" alt="image-20230330154239398"></p><p>NARK is trivial </p><p>NARK with succint</p><p>任何比trivial NARK更好的方法都很有意义，比如当证明的长度为sub-linear</p><p><img src="/2023/03/09/BIU/image-20230330155356530.png" alt="image-20230330155356530"></p><p>目前有的SNARK证明的长度和验证的时间都是常数</p><p>比较有趣的地方：验证者甚至不能完全读入C就要做出验证？实际上VP是C的一个总结</p><p><img src="/2023/03/09/BIU/image-20230330155833321.png" alt="image-20230330155833321"></p><p>这次讲座主要讲SNARK，存在从SNARK到zk-SNARK的通用构造，因此困难的部分在构造SNARK</p><p><img src="/2023/03/09/BIU/image-20230330160047589.png" alt="image-20230330160047589"></p><p>zero-knowledge可能不公开witness</p><p><img src="/2023/03/09/BIU/image-20230330160155218.png" alt="image-20230330160155218"></p><p><img src="/2023/03/09/BIU/image-20230330160333294.png" alt="image-20230330160333294"></p><p> 现实中使用snark并不需要写算术电路，已经有了domain-specific的语言，建议学习</p><p>采用dsl写好后编辑器编译为SNARK友好的形式：circuit/EVM</p><p>给定输入x和witness产生证明的过程可能需要很多的计算</p><p>但是输出很可能是简单的几百个字节，DB建议打印在T恤上</p><p>问题是谁来执行高昂的运算？现在有专门的公司</p><p><img src="/2023/03/09/BIU/image-20230330161158370.png" alt="image-20230330161158370"></p><p>未来可能会有证明市场，证明者选算力提供者来产生证明，臭打游戏的显卡空闲时也可以用来产生证明</p><p><img src="/2023/03/09/BIU/image-20230330161724731.png" alt="image-20230330161724731"></p><p>存在树形的递归证明，prover3不证明交易，证明prover1和prover2</p><p>non-interactive表现在verifier的验证阶段</p><p>think：who gets paid？</p><p>为什么不能哪个节点先响应就把证明任务交给哪个节点？如果这样设计，永远都是硬件最强的节点进行证明，存在中心化的风险，因此市场需要<strong>指派</strong>由哪个节点来证明，这里需要设计界复杂的机制，可能会有密码的应用</p><p>为什么要去中心化？出于对效率的考虑而不是安全的考虑，现有的算力是分布式的现状</p><p>如果witness是保密的，可以采用秘密分享，分拆后的份额分别进行证明</p><p>证明的交易之前可能存在一致性的问题，tx1的输出可能会影响tx3</p><h2 id="applications-of-SNARKs-Tornado"><a href="#applications-of-SNARKs-Tornado" class="headerlink" title="applications of SNARKs-Tornado"></a>applications of SNARKs-Tornado</h2><p><img src="/2023/03/09/BIU/image-20230330163311245.png" alt="image-20230330163311245"></p><p>只有名字里没写zk的Tornado使用了零知识证明（乐</p><p>Q：目前zkRollup在实际的full contract中运行，效率如何</p><p>A：硬件问题，是可以并行的，需要更多GPU即可</p><p>DAI是稳定币，1000dai约为1000刀乐</p><p><img src="/2023/03/09/BIU/image-20230330164309241.png" alt="image-20230330164309241"></p><p>看起来人畜无害（benign）</p><p>coin merkle tree存了当前存储的所有coin，链上存储过于昂贵，链上只存merkle root</p><p>nullifier </p><p><img src="/2023/03/09/BIU/image-20230330164728293.png" alt="image-20230330164728293"></p><p>当Alice想要存100DAI时，给出<code>MerkleProof(4)</code>和<code>C_4</code>，发送的证明必须和当前的<code>next</code>字段值相同</p><p><img src="/2023/03/09/BIU/image-20230330164853379.png" alt="image-20230330164853379"></p><p>合约检查证明，计算更新后的<code>merkle_root</code>，更新状态</p><p>Alice保存hash的原像即可作为取钱的凭证</p><p><img src="/2023/03/09/BIU/image-20230330165249850.png" alt="image-20230330165249850"></p><p>存在的问题：observer知道谁存在哪个叶节点</p><p><img src="/2023/03/09/BIU/image-20230330165742310.png" alt="image-20230330165742310"></p><p>当Bob要取钱时证明自己有nf，不泄露存的是哪个币</p><p><img src="/2023/03/09/BIU/image-20230330165928639.png" alt="image-20230330165928639"></p><p>(i)在10年前是不可能高效证明的，但是由于zkSNARK的发展，现在浏览器的JavaScript几秒内就能够完成</p><p><img src="/2023/03/09/BIU/image-20230330170212615.png" alt="image-20230330170212615"></p><p>A作为输入但是没有使用：在假设敌手不能扩展的情况下，用来防御重放攻击</p><p>一般的论文会证明soundness，但是实际上不可延展性非常重要</p><p><img src="/2023/03/09/BIU/image-20230330170623789.png" alt="image-20230330170623789"></p><p><img src="/2023/03/09/BIU/image-20230330170934504.png" alt="image-20230330170934504"></p><p><img src="/2023/03/09/BIU/image-20230330171004406.png" alt="image-20230330171004406"></p><p>取完钱后需要新加上nf</p><p><img src="/2023/03/09/BIU/image-20230330173051993.png" alt="image-20230330173051993"></p><p><img src="/2023/03/09/BIU/image-20230330173334189.png" alt="image-20230330173334189"></p><p><img src="/2023/03/09/BIU/image-20230330173416547.png" alt="image-20230330173416547"></p><p>设计的很好，然后被别人拿来洗钱了</p><p>吃一堑长一智：支付系统中完全的匿名化问题多多</p><p><img src="/2023/03/09/BIU/image-20230330173819854.png" alt="image-20230330173819854"></p><p>如何设计</p><p><img src="/2023/03/09/BIU/image-20230330174951441.png" alt="image-20230330174951441"></p><p>显然不可以，攻击者可以使用proxy</p><p>Tornado的匿名性可以通过存储的时间来增强，存的时间越长越不容易被链接起来</p><p><img src="/2023/03/09/BIU/image-20230330180629504.png" alt="image-20230330180629504"></p><h1 id="Permissionless-Consensus-I-Rafael-Pass"><a href="#Permissionless-Consensus-I-Rafael-Pass" class="headerlink" title="Permissionless Consensus I - Rafael Pass"></a>Permissionless Consensus I - Rafael Pass</h1><p><img src="/2023/03/09/BIU/image-20230419161535218.png" alt="image-20230419161535218"></p><p><img src="/2023/03/09/BIU/image-20230419161808584.png" alt="image-20230419161808584"></p><p>future self-consistency sometimes are neglected</p><p>$\Delta$ should be polynomial，比特币假设为10s（非常悲观的取值），实际可能2s已经到达了99%的网络节点</p><p><img src="/2023/03/09/BIU/image-20230419162759632.png" alt="image-20230419162759632"></p><p><img src="/2023/03/09/BIU/image-20230419163838156.png" alt="image-20230419163838156"></p><p>传统的许可链，参与者很少（10），参与者的数量固定，身份已知</p><p>协议执行期间节点不会掉线</p><p>节点之前存在认证信道/PKI </p><p><img src="/2023/03/09/BIU/image-20230419164236072.png" alt="image-20230419164236072"></p><p>实际上认证信道和PKI的区别分长达</p><p><img src="/2023/03/09/BIU/image-20230419165548671.png" alt="image-20230419165548671"></p><p>为什么加一个节点就能保证consistency and liveness</p><p><img src="/2023/03/09/BIU/image-20230419170618762.png" alt="image-20230419170618762"></p><p><img src="/2023/03/09/BIU/image-20230419171411032.png" alt="image-20230419171411032"></p><p>economic robostness指因为节点可能随时离开或加入网络，需要设计激励机制</p><p><img src="/2023/03/09/BIU/image-20230419171626796.png" alt="image-20230419171626796"></p><p><img src="/2023/03/09/BIU/image-20230419171805125.png" alt="image-20230419171805125"></p><p><img src="/2023/03/09/BIU/image-20230419172036888.png" alt="image-20230419172036888"></p><p><img src="/2023/03/09/BIU/image-20230419172355148.png" alt="image-20230419172355148"></p><p>敌手能够伪装为good guy的代价太低了</p><p><img src="/2023/03/09/BIU/image-20230419172503929.png" alt="image-20230419172503929"></p><p>不再依赖于诚实节点的占比，依赖于计算能力</p><p><img src="/2023/03/09/BIU/image-20230419173713048.png" alt="image-20230419173713048"></p><p>考虑一个人恶意</p><p><img src="/2023/03/09/BIU/image-20230419174143595.png" alt="image-20230419174143595"></p><p><img src="/2023/03/09/BIU/image-20230419184223312.png" alt="image-20230419184223312"></p><p><img src="/2023/03/09/BIU/image-20230419184829074.png" alt="image-20230419184829074"></p><p>诚实节点遵循最长链原则</p><p><img src="/2023/03/09/BIU/image-20230419184955890.png" alt="image-20230419184955890"></p><p><img src="/2023/03/09/BIU/image-20230419185118029.png" alt="image-20230419185118029"></p><p><img src="/2023/03/09/BIU/image-20230419185135769.png" alt="image-20230419185135769"></p><p><img src="/2023/03/09/BIU/image-20230419185358888.png" alt="image-20230419185358888"></p><p><img src="/2023/03/09/BIU/image-20230419185502328.png" alt="image-20230419185502328"></p><p>chain quality: get paid for their work</p><p><img src="/2023/03/09/BIU/image-20230419185700177.png" alt="image-20230419185700177"></p><p><img src="/2023/03/09/BIU/image-20230419185806657.png" alt="image-20230419185806657"></p><p>如果有了一个区块链系统，如何得到consensus？</p><ul><li>去掉最后k个区块，实现consistency</li><li>chain is going… even bad guys are censoring</li></ul><p><img src="/2023/03/09/BIU/image-20230419190147884.png" alt="image-20230419190147884"></p><p>看上去chain quality不是最优的：诚实节点比例为1-p，但是得到的链质量为$(1-p/(1-p))$</p><p>实际上这已经是最优的</p><p>敌手可以获得比恶意算力更多的收益：自私挖矿</p><p><img src="/2023/03/09/BIU/image-20230419190705377.png" alt="image-20230419190705377"></p><p>比特币看起来是一个半同步的网络假设，没有用到$\Delta$，但是挖矿的难度$d$隐含了这一条件</p><p>如果网络中的最大时延超过10mins，协议不再安全</p><h1 id="Decentralized-Exchanges-Sandwich-Arbitrage-Arthur-Gervais"><a href="#Decentralized-Exchanges-Sandwich-Arbitrage-Arthur-Gervais" class="headerlink" title="Decentralized Exchanges, Sandwich, Arbitrage - Arthur Gervais"></a>Decentralized Exchanges, Sandwich, Arbitrage - Arthur Gervais</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;13th BIU winter school&lt;/p&gt;</summary>
    
    
    
    <category term="Crypto" scheme="https://alleysira.github.io/categories/Crypto/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>Dumbo</title>
    <link href="https://alleysira.github.io/2023/03/09/Dumbo/"/>
    <id>https://alleysira.github.io/2023/03/09/Dumbo/</id>
    <published>2023-03-09T02:08:27.000Z</published>
    <updated>2023-03-09T07:39:57.538Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1ns4y1Y7yo/?share_source=copy_web&amp;vd_source=4487439a1220fa77bb4a6f0079c98794">区块链异步共识——超速小飞象共识协议</a></p><span id="more"></span><h1 id="超速小飞象共识协议"><a href="#超速小飞象共识协议" class="headerlink" title="超速小飞象共识协议"></a>超速小飞象共识协议</h1><h2 id="健壮的区块链系统需要异步共识"><a href="#健壮的区块链系统需要异步共识" class="headerlink" title="健壮的区块链系统需要异步共识"></a>健壮的区块链系统需要异步共识</h2><ul><li><p>公共账本</p><ul><li><p>保证可以正确写入</p></li><li><p>保证可以正确读取</p></li></ul></li><li><p>智能合约</p><ul><li><p>正确执行</p></li><li><p>条件执行</p></li></ul></li></ul><h3 id="拜占庭共识"><a href="#拜占庭共识" class="headerlink" title="拜占庭共识"></a>拜占庭共识</h3><p>有效性规定了输出具有一定意义：输出是诚实节点的输出</p><p><img src="/2023/03/09/Dumbo/image-20230309100604319.png" alt="image-20230309100604319"></p><h3 id="区块链共识"><a href="#区块链共识" class="headerlink" title="区块链共识"></a>区块链共识</h3><p>BFA是一次性共识，区块链需要的是持续运行的共识协议</p><p><img src="/2023/03/09/Dumbo/image-20230309100647097.png" alt="image-20230309100647097"></p><p><img src="/2023/03/09/Dumbo/image-20230309101037056.png" alt="image-20230309101037056"></p><p>交换机出错6分钟，认为Raft的不够科学</p><p><img src="/2023/03/09/Dumbo/image-20230309101059583.png" alt="image-20230309101059583"></p><p>最终同步网络模型：已知分片有限，不知道什么时候可以恢复</p><p>异步网络模型：刻画了TCP的模型</p><p><img src="/2023/03/09/Dumbo/image-20230309101203507.png" alt="image-20230309101203507"></p><p><img src="/2023/03/09/Dumbo/image-20230309101417682.png" alt="image-20230309101417682"></p><p><img src="/2023/03/09/Dumbo/image-20230309101536669.png" alt="image-20230309101536669"></p><p><img src="/2023/03/09/Dumbo/image-20230309101705780.png" alt="image-20230309101705780"></p><h2 id="性能瓶颈"><a href="#性能瓶颈" class="headerlink" title="性能瓶颈"></a>性能瓶颈</h2><p>确定性算法无法解决异步共识问题</p><p><img src="/2023/03/09/Dumbo/image-20230309101801067.png" alt="image-20230309101801067"></p><p><img src="/2023/03/09/Dumbo/image-20230309101835990.png" alt="image-20230309101835990"></p><p><img src="/2023/03/09/Dumbo/image-20230309101945208.png" alt="image-20230309101945208"></p><p>蜜罐100个节点需要10分钟进行共识</p><p>小飞象主要在轮复杂度进行了优化</p><p><img src="/2023/03/09/Dumbo/image-20230309102125976.png" alt="image-20230309102125976"></p><p>P2P网络中如何实现广播通信：RBC协议，最终获得相同的消息或者都不获得消息</p><p>ABA:对0/1实现共识，保证输出一定来自于至少一个诚实节点，随机化算法，并行的多个实例的停机时间影响效率</p><p>RBC结束了就投票0，未结束投票1</p><p><img src="/2023/03/09/Dumbo/image-20230309102321412.png" alt="image-20230309102321412"></p><p><img src="/2023/03/09/Dumbo/image-20230309102450800.png" alt="image-20230309102450800"></p><p><img src="/2023/03/09/Dumbo/image-20230309102527408.png" alt="image-20230309102527408"></p><p>1个MVBA替换n个ABA，实际只需要2-3个ABA</p><p>思想是实现MVBA的输出是RBC是否完成的投票</p><p><img src="/2023/03/09/Dumbo/image-20230309102708864.png" alt="image-20230309102708864"></p><p><img src="/2023/03/09/Dumbo/image-20230309102814021.png" alt="image-20230309102814021"></p><p><img src="/2023/03/09/Dumbo/image-20230309102836473.png" alt="image-20230309102836473"></p><h2 id="超速小飞象"><a href="#超速小飞象" class="headerlink" title="超速小飞象"></a>超速小飞象</h2><p>解决提到的两个问题</p><p><img src="/2023/03/09/Dumbo/image-20230309102944264.png" alt="image-20230309102944264"></p><p><img src="/2023/03/09/Dumbo/image-20230309103021991.png" alt="image-20230309103021991"></p><p>Totality要求一个节点收到消息，其他节点也必须要收到</p><p>PB 即发送者收到足够多的签名时即可保证f+1个诚实节点收到相同的广播消息</p><p><img src="/2023/03/09/Dumbo/image-20230309103254589.png" alt="image-20230309103254589"></p><p><img src="/2023/03/09/Dumbo/image-20230309103358760.png" alt="image-20230309103358760"></p><p><img src="/2023/03/09/Dumbo/image-20230309103431821.png" alt="image-20230309103431821"></p><p>MVBA是导致延迟的主要原因</p><p><img src="/2023/03/09/Dumbo/image-20230309103519817.png" alt="image-20230309103519817"></p><p><img src="/2023/03/09/Dumbo/image-20230309103557798.png" alt="image-20230309103557798"></p><p><img src="/2023/03/09/Dumbo/image-20230309103645643.png" alt="image-20230309103645643"></p><p><img src="/2023/03/09/Dumbo/image-20230309103720267.png" alt="image-20230309103720267"></p><p><img src="/2023/03/09/Dumbo/image-20230309103800950.png" alt="image-20230309103800950"></p><p><img src="/2023/03/09/Dumbo/image-20230309103946281.png" alt="image-20230309103946281"></p><p><img src="/2023/03/09/Dumbo/image-20230309104051895.png" alt="image-20230309104051895"></p><p><img src="/2023/03/09/Dumbo/image-20230309104129598.png" alt="image-20230309104129598"></p><p><img src="/2023/03/09/Dumbo/image-20230309104210694.png" alt="image-20230309104210694"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1ns4y1Y7yo/?share_source=copy_web&amp;amp;vd_source=4487439a1220fa77bb4a6f0079c98794&quot;&gt;区块链异步共识——超速小飞象共识协议&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="Consensus" scheme="https://alleysira.github.io/tags/Consensus/"/>
    
  </entry>
  
  <entry>
    <title>LXY+22</title>
    <link href="https://alleysira.github.io/2023/03/07/LXY-22/"/>
    <id>https://alleysira.github.io/2023/03/07/LXY-22/</id>
    <published>2023-03-07T03:35:13.000Z</published>
    <updated>2023-03-12T13:05:10.624Z</updated>
    
    <content type="html"><![CDATA[<p>Li X Y, Xu J, Yin L Y, et al. Escaping from consensus: Instantly redactable blockchain protocols in permissionless setting[J]. IEEE Transactions on Dependable and Secure Computing, 2022.</p><span id="more"></span><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="主要工作"><a href="#主要工作" class="headerlink" title="主要工作"></a>主要工作</h2><ul><li>基于[DMT19]的思想进行改进，将投票机制和共识机制解耦，从而提高编辑的确认速度，实现即时编辑<ul><li>即节点对是否编辑的投票不再记录在区块上而是直接发送给委员会</li><li>由于安全性不依赖于共识，对恶意敌手的要求从小于1/3，降低为1/2</li><li>实现编辑性的方法是类似于[DMT19]，在区块头保存被编辑区块的$merkle_root$，验证区块的有效性时首先检查前一个区块的哈希，如果不满足则检查编辑策略和旧状态是否满足条件<ul><li>实际工程实现可以在新节点和旧节点之间可以保持一样的区块结构，新节点分别保存原区块链和修改</li><li>所有编辑请求和投票都可以用现有的插入OP RETURN等脚本码来实现</li><li>目前编辑功能只局限于修改非金融字段，提出可以像Reparo一样，在更新UTXO的情况下修改金融数据</li></ul></li></ul></li><li>给出了形式化的可编辑区块链理想模型和基于模拟的安全证明<ul><li>现有方案一般仅分析编辑带来的影响</li><li>证明了满足链质量、链增长和可编辑共同前缀</li></ul></li><li>提供了方案在PoS和PoW区块链中的具体构造<ul><li>实验使用c语言针对采用PoS的Cardano Settlement Layer进行实现</li></ul></li></ul><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><ul><li>利用$Cmt$随机选举委员会，保证委员会超过一定比例的委员一定诚实，恶意敌手无法生成足够投票</li><li>用户想要修改区块$B_j$就生成候选区块$B_j^\star$并广播</li><li>委员对候选区块投票</li></ul><h3 id="委员会选举实现方法"><a href="#委员会选举实现方法" class="headerlink" title="委员会选举实现方法"></a>委员会选举实现方法</h3><p>分析在PoS中实现的$Cmt$算法，使用VRF进行选择（包括Algorand、Cardano、Internet Computer和Polkadot在内的许多L1区块链都在共识机制中使用了VRF来随机选择出块节点）</p><p>$hash$的输出表明了$P_i$有多少投票，每个权益为$s_i$的用户相当于有$s_i$个子用户，每个子用户被选中的概率是$p=\frac{T}{S}$,T是当前委员会投票阶段的权益的和，S是区块链系统权益的和</p><p>$s_i$中$q$个子用户被选中的概率服从二项分布$B(p;q,s_i)=C_{s_i}^q p^q(1-p)^{s_i-q}$</p><p>将区间[0,1)分为连续的区间</p><script type="math/tex; mode=display">I^c=[\sum^c_{q=0}B(p;q,s_i),\sum_{q=0}^{c+1} B(p;q,s_i)),c\in\{1,\dots,s_i\}</script><p>如果$\frac{hash}{2^{hashlen} }$落在$I_c$，证明$c$个用户为$P_i$投票</p><p><img src="/2023/03/07/LXY-22/image-20230309113111623.png" alt="image-20230309113111623"></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li><p>一般将每个出块者任期称为一个epoch，每个epoch由多个slot/round组成，每次生成一个区块</p></li><li><p>本文的slot是怎么定义的没有明确给出</p></li><li><p>共识和投票的区别</p><ul><li>共识是输入状态，得到0,1</li><li>投票是将已经有的0,1进行收集</li></ul></li></ul><p><a href="https://blog.csdn.net/A33280000f/article/details/120683353?spm=1001.2014.3001.5502">参考师兄的博客</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Li X Y, Xu J, Yin L Y, et al. Escaping from consensus: Instantly redactable blockchain protocols in permissionless setting[J]. IEEE Transactions on Dependable and Secure Computing, 2022.&lt;/p&gt;</summary>
    
    
    
    <category term="Crypto" scheme="https://alleysira.github.io/categories/Crypto/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="Redactable Blockchain" scheme="https://alleysira.github.io/tags/Redactable-Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>LMW23</title>
    <link href="https://alleysira.github.io/2023/03/01/LMW23/"/>
    <id>https://alleysira.github.io/2023/03/01/LMW23/</id>
    <published>2023-03-01T09:49:14.000Z</published>
    <updated>2023-03-10T02:49:45.289Z</updated>
    
    <content type="html"><![CDATA[<p>Li J, Ma H, Wang J, et al. Wolverine: A Scalable and Transaction-Consistent Redactable Permissionless Blockchain[J]. IEEE Transactions on Information Forensics and Security, 2023.</p><span id="more"></span><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>区块链中有两种链接关系：hash链接和签名链接</p><ul><li>哈希链接存在于不同区块的区块头之间</li><li>签名链接存在于不同区块的区块体的交易之间，签名链接是满足了之前交易的challenge script的见证</li></ul><p><img src="/2023/03/01/LMW23/image-20230302095926899.png" alt="image-20230302095926899" style="zoom:67%;"></p><p>考虑删除区块$B_2$内的交易$tx^1_2$，可能导致四条交易链接失效$tx^0_0\gets tx^1_2,tx_0^1\gets tx^1_2,tx^1_2\gets tx_3^1 ,tx^1_2\gets tx_3^2 $</p><p>其中交易$tx^0_0\gets tx^1_2,tx_0^1\gets tx^1_2$可能被双花</p><p>交易$tx^1_2\gets tx_3^1 ,tx^1_2\gets tx_3^2$可能会失效</p><h2 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work"></a>Related work</h2><p>[DMT19]为了实现追责，扩展了区块头增加了$old_merkle_root$字段，Reparo相当于将这个字段单独存储在数据库中而不修改区块结构，存在投票周期长和$n=3f+1$；这两篇文章都考虑+了交易的一致性问题，因此将编辑操作限制在非金融字段，不适用于UTXO</p><h2 id="Preliminary"><a href="#Preliminary" class="headerlink" title="Preliminary"></a>Preliminary</h2><h3 id="DRB"><a href="#DRB" class="headerlink" title="DRB"></a>DRB</h3><p>对于参与者$\{P_1,\dots,P_n\}$，$(t,n)$去中心化随机信标包含如下算法：</p><ul><li>$Setup(1^\lambda)\to pp$</li><li>$CmteGen(pp,t,n)\to(cpk,sk_1,\dots,sk_n)$:交互式协议，输出委员会的公钥和参与方对应的私钥</li><li>$PartialRand(cpk,sk_i,st_{l-1})\to s_i$：输入$l-1$轮状态$st_{l-1}$，计算部分值$\sigma_{l,i}$和对应的证明$\pi_{l,i}$，并且$s_i=(i,\sigma_{l,i},\pi_{l,i})$</li><li>$CombRand(cpk,st_{l-1},\varepsilon)\to (\sigma_l,\pi_l)$：输入$\varepsilon=\{s_i\}_{i\in I},|I|\geq t+1$</li><li>$VerifyRand(cpk,st_{l-1},\sigma_l,\pi_l)\to d\in\{0,1\}$</li><li>$UpdState(cpk,st_{l-1},\sigma_l,\pi_l)\to st_l$：输入上一轮的状态，输出更新后的当前轮的状态</li></ul><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><h2 id="System-model"><a href="#System-model" class="headerlink" title="System model"></a>System model</h2><p>考虑在$N$个节点的p2p网络中，存在监管委员会$R$人数$n\ll N$</p><p>假设委员会大多数诚实，委员会成员之间共享变色龙哈希函数密钥</p><ul><li><p>区块链节点首先通过抗女巫攻击的方式生成身份（$pk，sk$）</p></li><li><p>执行去中心化自举协议协商委员会的大小（开销很大但是只执行一次）</p></li><li>网络中任何人都可以将编辑指令放进区块中来发起编辑请求</li><li>委员会成员根据编辑策略验证编辑指令</li><li>如果满足策略，委员会成员投票并作为交易广播</li><li>矿工检查投票并且将有效投票打包进下一个区块</li><li>来自不同委员会成员的投票超过$n/2$之后，每个参与者本地组合份额恢复变色龙哈希函数私钥，执行编辑</li><li>每轮epoch重新选举委员会，重新分发陷门密钥</li></ul><h2 id="Network-and-Threat-model"><a href="#Network-and-Threat-model" class="headerlink" title="Network and Threat model"></a>Network and Threat model</h2><p>同步网络，公有链广泛采用的假设，诚实节点之间的信道延迟至多为$\delta$</p><p>存在同步广播信道（区块链本身）</p><p>考虑PPT的拜占庭敌手，任意时刻腐化的敌手数量满足$\rho &lt; 1/2$，被腐化的敌手可以任意偏离协议，发送错误的消息或者保持沉默</p><p>假设敌手slowly adaptive，敌手可以在每一轮开始或中间选择腐化的集合，但是直到该轮结束腐化才能生效</p><h1 id="NITCH"><a href="#NITCH" class="headerlink" title="NITCH"></a>NITCH</h1><p>给出非交互式变色龙哈希函数的构造和在RO下的安全证明</p><ul><li>部分更新算法$Partial\ Adapt(sk_i,vk_i,m,m’)\to s_i=(i,c_i,\pi_i)$，输出更新后的份额$c_i$和对应的证明</li><li>部分验证算法$Partial \ Verify(pk,vk_i,s_i,m,m’)\to 0/1$ </li><li>$Combine(VK,(h,m,r),m’,\varepsilon) \to r’$，其中$\varepsilon=\{s_{i_1},\dots,s_{i_{ |I| } } \}$输出新的随机数或者空<ul><li>奇怪的是恢复密钥采用的不是原始的私钥份额，而是执行部分更新算法后份额</li></ul></li></ul><p>verification keys的作用</p><h2 id="Instantiation"><a href="#Instantiation" class="headerlink" title="Instantiation"></a>Instantiation</h2><ul><li><p>系统模型阶段</p><ul><li>每个节点建议自己的身份并广播</li><li>协商出大小为$n$的委员会</li><li><p>任何人可以发起RI并广播到区块中</p><ul><li><p>如何发布RI</p><ul><li>存储在区块中的话，相当于需要发起一笔交易</li><li>如果不存在区块，需要一个单独的数据结构存储RI，因此节点本地有</li></ul></li><li><p>如果编辑交易和普通交易不可区分，不需要考虑</p></li><li>如果出块者在打包交易时发现了编辑交易，为什么要打包进编辑交易呢<ul><li>设计激励机制</li></ul></li></ul></li></ul></li><li><p>DKG采用如下方案，只需要一轮通信，但无法保证均匀，用到了RO假设</p><ul><li><img src="/2023/03/01/LMW23/image-20230303170611136.png" alt="image-20230303170611136"></li><li>Non-interactive and information-theoretic secure verifiable secret sharing</li><li>此处第二个生成元的作用：公开可验证常数项的正确性，每个份额的正确性只有拿到份额的人可以验证</li><li>$sk=\sum a_{i,0},sk_j=\sum s_{i,j}=\sum f_i(j),pk=g_2^{\sum a_{i,0}},vk_j=g_1^{\sum s_{i,j} }=g_1^{sk_j},i\in QUAL$</li><li>私钥份额$sk_j$即所有参与者多项式在$j$处的求值</li><li>此处的$l_i^I(0)=\prod\frac{x}{x-x’} \bmod q$<ul><li>参考一篇博客 <a href="https://medium.com/nethermind-eth/a-tour-of-verifiable-secret-sharing-schemes-and-distributed-key-generation-protocols-3c814e0d47e1">https://medium.com/nethermind-eth/a-tour-of-verifiable-secret-sharing-schemes-and-distributed-key-generation-protocols-3c814e0d47e1</a></li><li>DKG使用私钥而不泄露私钥是非常重要的</li></ul></li></ul></li></ul><p>利用NITCH构造DRB</p><p><img src="/2023/03/01/LMW23/image-20230304145041604.png" alt="image-20230304145041604"></p><h1 id="Construction"><a href="#Construction" class="headerlink" title="Construction"></a>Construction</h1><h2 id="Shadow-Transaction-stx"><a href="#Shadow-Transaction-stx" class="headerlink" title="Shadow Transaction(stx)"></a>Shadow Transaction(stx)</h2><ul><li>目的：实现交易级的修改</li><li>将可修改的、能够插入任意数据的字段称为admissible fields $AF(tx,out.script,tx.wit)$</li><li>实际就是复制原来的交易，将AF字段设置为对应的变色龙哈希的值</li><li>带来两个性质<ul><li>可编辑性：交易的AF字段可以被委员会编辑</li><li>不可篡改性：交易的stable fields无法修改（H是抗碰撞的）</li></ul></li></ul><p><img src="/2023/03/01/LMW23/image-20230304153332166.png" alt="image-20230304153332166"></p><h2 id="The-redactable-blockchain-Protocol"><a href="#The-redactable-blockchain-Protocol" class="headerlink" title="The redactable blockchain Protocol"></a>The redactable blockchain Protocol</h2><ul><li>Update local chain：每轮开始选择最长链进行本地更新</li><li>从链去掉末尾k个区块后，收集所有编辑请求<ul><li>将请求加入到RIP(research instruction pool)</li><li>对编辑请求投票，更新RIP中的$(RI,\phi)\to (RI,\{vote\})$</li></ul></li><li>收集投票：更新$(RI,shares\cup s_i)$</li><li>编辑交易：如果$len(shares)&gt;n/2$，执行$NITCH.Combine$算法</li><li>扩展链：产生新区块并广播</li><li>编辑结束之后，其他用户可以提出新的编辑请求</li></ul><h2 id="Committee-Evolution"><a href="#Committee-Evolution" class="headerlink" title="Committee Evolution"></a>Committee Evolution</h2><h3 id="随机数生成"><a href="#随机数生成" class="headerlink" title="随机数生成"></a>随机数生成</h3><p>$R^e$执行DRB为下一轮生成随机数串$\tau^{e+1}$，当前轮结束后揭示$\tau^{e+1}$</p><h3 id="下一轮委员会选举"><a href="#下一轮委员会选举" class="headerlink" title="下一轮委员会选举"></a>下一轮委员会选举</h3><p>下一轮$e+1$开始时，每个参与者本地选择公钥和地址$(PK,IP)$作为身份</p><ul><li>引进IP为了防止女巫攻击</li></ul><p>能够发现PoW的解的参与者作为下一轮委员会的成员（公平性）</p><p>经过$\Delta$时间后，停止选举（如何保证委员会人数正确）</p><h3 id="分布式密钥再分享"><a href="#分布式密钥再分享" class="headerlink" title="分布式密钥再分享"></a>分布式密钥再分享</h3><ul><li><p>处理阶段</p><ul><li>每个$R^e$中的参与者$P_i^e$随机选择多项式$f_i(x)=sk_i^e+\sum_{j=1}^{t^{e+1} } a_{i,j}x^j$（注意此时用的是下一轮的$t$）</li><li>$P_i^e$广播$A_{i,k}=g_1^{a_{i,k}},k=0,\dots,t$</li><li>$P_i^e$计算份额$s_{i,j}=f_i(j),j=1,\dots,n^{e+1}$，发送$f_i(j)\to j$</li></ul></li><li><p>验证阶段：验证发送的秘密份额是否正确，实现对委员会参与者的追责</p><ul><li>参与者$P_j^{e+1}$计算</li><li><script type="math/tex; mode=display">g_1^{ s_{i,j} } \mathop{=}\limits^{?} \prod_{k=0}^{t^{e+1} } (A_{i,j})^{j^k}</script></li><li><p>如果不成立，广播对参与者$P_i^e$的投诉</p></li></ul></li><li><p>投诉阶段（抱怨2333）</p><ul><li>如果每个参与者收到超过$t^{e+1}$个投票就失去委员会资格，$P_i^e$收到投诉时需要重新发送$s_{i,j}$的份额，如果新的份额依然不通过则失去资格</li></ul></li><li><p>恢复阶段 </p><ul><li>计算公共验证密钥</li><li><script type="math/tex; mode=display">\mathrm{vk}_j=\prod_{i \in U} \prod_{k=0}^{t^{(e+1)}} A_{i, k}^{\ell_i^U(0) \cdot j^k}, j \in \mathcal{R}^{(e+1)}</script></li></ul></li><li><p>每个参与者本地计算私钥份额</p><ul><li><script type="math/tex; mode=display">\mathrm{sk}_j=\sum_{i\in U} (\ell^U_i(0)\cdot s_{i,j})</script></li></ul></li></ul><h1 id="目的-amp-收获"><a href="#目的-amp-收获" class="headerlink" title="目的&amp;收获"></a>目的&amp;收获</h1><ul><li>学习如何构造非交互式的门限变色龙哈希<ul><li>显然还是需要交互的</li></ul></li><li>刷新委员会和密钥份额的区别<ul><li>抗女巫攻击的身份生成方案</li></ul></li><li>shadow transaction如何实现交易一致性</li><li>实现多项式插值的算法的加速</li><li>学习 decentralized bootstrapping protocol</li><li>记得学习<a href="https://missing-semester-cn.github.io/2020/">https://missing-semester-cn.github.io/2020/</a></li><li><p>本方案要求本地存储两个数据库</p><ul><li>redaction instruction pool：储存当前的编辑请求，超过门限就恢复秘密执行编辑<ul><li>如何保证这个数据库的同步性，可能有敌手宣称已经超过1/2</li></ul></li><li>check value revocation list：存储区块最新的$r’$<ul><li>为了保证这个字段的一致性，区块头增加了$h=HASH(CVRL)$</li></ul></li></ul></li><li><p>方案的轮数是如何定义的</p></li><li><p>无法实现对区块的删除</p></li><li><p>具体出块者是谁</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Li J, Ma H, Wang J, et al. Wolverine: A Scalable and Transaction-Consistent Redactable Permissionless Blockchain[J]. IEEE Transactions on Information Forensics and Security, 2023.&lt;/p&gt;</summary>
    
    
    
    <category term="Crypto" scheme="https://alleysira.github.io/categories/Crypto/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="Redactable Blockchain" scheme="https://alleysira.github.io/tags/Redactable-Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>ZZL22</title>
    <link href="https://alleysira.github.io/2023/03/01/ZZL22/"/>
    <id>https://alleysira.github.io/2023/03/01/ZZL22/</id>
    <published>2023-03-01T07:15:59.000Z</published>
    <updated>2023-03-06T09:22:52.986Z</updated>
    
    <content type="html"><![CDATA[<p>赵晓琦,张正昊,李勇.可编辑且可追责的区块链方案[J].信息安全学报,2022,7(5):19-28</p><span id="more"></span><h1 id="方案构造"><a href="#方案构造" class="headerlink" title="方案构造"></a>方案构造</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>存在Leader将陷门作为秘密，进行可验证的秘密分享，附带证明。</p><p>链中用户对编辑请求进行投票，利用公钥和Leader的随机数进行哈希并排序选择具有编辑权的用户。</p><p>用户向leader发送密钥并附带证明，编辑者收到t个份额后恢复密钥并进行编辑。</p><p>用户可对编辑后的区块进行验证，对相关方追责。</p><h2 id="秘密分享阶段"><a href="#秘密分享阶段" class="headerlink" title="秘密分享阶段"></a>秘密分享阶段</h2><ul><li>Share：Dealer计算<ul><li>计算$Y_i=(y_i)^{f(i)},i\in [n],C_j=g^{a_j},j\in\{0,t-1\}$<ul><li>这里为什么不能用g，用公钥类似于公钥加密</li></ul></li><li>承诺$c=H(g^{f(i)},y^{f(i)}_i,g^{w_i},y^{w_i}_i)$</li><li>应答$r_i\equiv w_i-f(i)c \bmod q$</li><li>证明$\pi=(c,r_1,\dots,r_n)$</li><li>广播$(Y_1,\dots,Y_n,C_0,\dots,C_{t-1},\pi)$</li></ul></li><li><p>Verify：用户计算</p><ul><li>$g^{w_i}\mathop{=}\limits^{?}g^{r_i}(\prod_{j=0}^{t-1} (C_j)^{i^j})^c$</li><li>$y_i^{w_i}\mathop{=}\limits^{?}y_i^{r_i}(\prod_{j=0}^{t-1} (C_j)^{i^j})^c$</li></ul></li><li><p>Dec：用户计算</p><ul><li>计算$s_i=Y_i^{x_i^{-1}},c_2=H(h^{t_i}|s_i^{t_i})$</li><li>证明$\pi_i=(c_2,t_i-x_ic_2)$（用于对编辑的追责，可能使用虚假的公钥）</li></ul></li></ul><h2 id="投票阶段"><a href="#投票阶段" class="headerlink" title="投票阶段"></a>投票阶段</h2><p>用户对编辑请求投票，需要保证修改的不是金融数据，同意则生成一个随机数加密发给Leader</p><h2 id="寻找编辑者阶段"><a href="#寻找编辑者阶段" class="headerlink" title="寻找编辑者阶段"></a>寻找编辑者阶段</h2><p>$hash_i=H(upk_i,r_{sum})$，用户计算并广播$hash_i$，其中$r_{sum}$相当于是参与者都提供了部分随机性，排序后选择最小的公钥对应的编辑者即可</p><h2 id="编辑阶段"><a href="#编辑阶段" class="headerlink" title="编辑阶段"></a>编辑阶段</h2><p>恢复秘密生成新的随机数即可</p><h2 id="验证追责阶段"><a href="#验证追责阶段" class="headerlink" title="验证追责阶段"></a>验证追责阶段</h2><ul><li>检查$r_{sum}$正确性</li><li>判断编辑权用户的公钥是不是最小的哈希值的输入<ul><li>还要考虑Leader的公钥与随机数的哈希值是否小于最小哈希，如果不满足说明Dealer可能作恶</li></ul></li><li>计算变色龙哈希值成立</li><li><strong>验证子密钥是否正确，即$\pi_i$</strong></li></ul><h1 id="追责性"><a href="#追责性" class="headerlink" title="追责性"></a>追责性</h1><p>定义：编辑后的内容广播到区块链中，用户可验证是否可被接受，出现错误时可以向相关责任方进行追责</p><p>分别考虑验证追责阶段的四个条件：</p><ul><li>Leader可能更改随机数的和来内定编辑者，计算和可以追责到leader</li><li>如果用户的公钥不是最小哈希值，可以追责到编辑者</li><li>如果哈希值不同，用户发送的子密钥正确，追责编辑者</li><li>子密钥错误，追责子密钥拥有者</li></ul><p>如果编辑发布后经公共验证不被接受，追责所有相关者</p><h1 id="目的-amp-收获"><a href="#目的-amp-收获" class="headerlink" title="目的&amp;收获"></a>目的&amp;收获</h1><ul><li>了解可追责的定义，学习可追责的方案设计思路，追责部分详细分析如何追责的思路和方法</li><li>寻找编辑者阶段的设计，每个人生成随机数，Dealer求和再下发和，将随机数的和以及公钥作为哈希输入，对结果排序</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;赵晓琦,张正昊,李勇.可编辑且可追责的区块链方案[J].信息安全学报,2022,7(5):19-28&lt;/p&gt;</summary>
    
    
    
    <category term="Crypto" scheme="https://alleysira.github.io/categories/Crypto/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="Redactable Blockchain" scheme="https://alleysira.github.io/tags/Redactable-Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>JCH22</title>
    <link href="https://alleysira.github.io/2023/02/27/JCH22/"/>
    <id>https://alleysira.github.io/2023/02/27/JCH22/</id>
    <published>2023-02-27T03:18:09.000Z</published>
    <updated>2023-03-10T02:59:04.663Z</updated>
    
    <content type="html"><![CDATA[<p>Jia M, Chen J, He K, et al. Redactable Blockchain From Decentralized Chameleon Hash Functions[J]. IEEE Transactions on Information Forensics and Security, 2022, 17: 2771-2783.</p><span id="more"></span><h1 id="去中心化变色龙哈希函数的构造"><a href="#去中心化变色龙哈希函数的构造" class="headerlink" title="去中心化变色龙哈希函数的构造"></a>去中心化变色龙哈希函数的构造</h1><p>包含五个算法：</p><ul><li><p>$Key\ generation$ 密钥生成算法：需要$t$个参与者$\{P_1,\dots,P_t\}$在线合作共同生成密钥，$g$是循环群生成元，参与者$P_i$ 如下执行</p><ul><li><p>随机生成$t-1$阶多项式：$f_i(x)=\sum_{j=0}^{t-1}a_{i,j}x^j$，秘密为常数项$f_i(0)$</p></li><li><p>给参与者$P_j$发送$f_i(ID(P_j)),(g^{f_i(ID(P_1))},\dots,g^{f_i(ID(P_t))}),g^{f_i(0)}$，类似于拉格朗日插值法，把秘密放在了幂指数上</p><ul><li>$f_i(x)$是否有必要放在幂指数上？如果不放在指数上任何参与者都可以拿到输出私钥的值了</li><li>$f_i(ID(P_j))$的意义在于构建系统的私钥，由于私钥是$s_i=\sum^t_{j=1}f_j(ID(P_i))$，需要其他人的多项式在自己身份处的取值</li></ul></li><li><p>参与者$P_i$收到参与者$P_j$发送的$f_j(ID(P_i)),(g^{f_j(ID(P_1))},\dots,g^{f_j(ID(P_t))}),g^{f_j(0)}$后，计算拉格朗日插值判断是否正确，即计算是否成立</p><ul><li><script type="math/tex; mode=display">f_j(0)=\sum_{k=1}^tf_j(ID(P_k))\prod^t_{l=1,l\neq k}\frac{ID(P_l)}{ID(P_l)-ID(P_k)}</script></li></ul></li><li><p>输出公钥$g^s=\prod_{j=1}^t f_j(0),s=\sum^t_{j=1}a_{j,0}$，相当于$t$个参与者每个人私钥的和，但任何参与者都无法计算出公钥的$s$；输出私钥$s_i=\sum^t_{j=1}f_j(ID(P_i))$，私钥可以用来恢复公钥</p><ul><li>公私钥生成体现了公平性，$t$个参与者</li><li>考虑敌手$P_j$偷听，尝试恢复$P_i$的私钥$s_i=\sum^t_{k=1}f_i(ID(P_k))$缺一个份额$f_i(ID(P_i)$，以下秘密分享同理，缺少对自己的取值</li></ul></li><li>密钥生成阶段通信复杂度为$O(t^2)$</li></ul></li><li><p>$Hashing$ 哈希算法：输入公钥$g^s$，任意长度消息m，先计算$\mu\gets H(g^s,m)$，$H$是密码学哈希函数，满足$H:\mathbb{G} \times \{0,1\}^{\star} \to \mathbb{G} $，随机选择$e\in \mathbb{Z}_p^*$，输出随机数$r=(g^e,g^{se})$，输出哈希$h=g^e\mu^m$</p><ul><li>此处的$H$选择会影响安全性</li><li>哈希算法里用到了两次m，密码学哈希函数的输入m相当于提供随机性，$\mu^m$保证难以寻找碰撞，m在外面方便计算，实际上并不是想要修改的内容，用的是$header$</li></ul></li><li><p>$Rehashing$算法：给定公钥$g^s$和原始的消息-随机数对$(m,r=g^e,g^{se})$，计算哈希$h\gets g^e\mu^m$并输出</p></li><li><p>$Adaptation$算法：输入私钥份额$s_i$，原始的消息-随机数对$(m,r=g^e,g^{se})$，新的消息$m’\in\{0,1\}^\star$，参与者$P_i,i\in[t]$如下执行：</p><ul><li><p>计算$g^{e’}\gets g^e\mu ^{m-m’}$</p></li><li><p>计算$\eta_i\gets(g^{e’})^{\lambda_i \cdot s_i },\lambda_i=\prod^t_{l=1,l\neq i}\frac{ID(P_l)}{ID(P_l)-ID(P_i)}$，把$\eta_i$发送给参与者$P_j,j\in[t],j\neq i$</p></li><li><p>参与者$P_i$收到$\eta_1,\dots,\eta_{i-1},\eta_{i+1},\dots,\eta_{t}$后，计算$g^{se’}\gets\prod^t_{j=1}\eta_j$，输出更新后的随机数$r’=(g^{e’},g^{se’})$</p></li><li><p>其实就是用$t$个私钥恢复出公钥的指数</p><ul><li><script type="math/tex; mode=display">g^{e'}\to (g^{e'})^s\to(g^{e'})^{\sum f_i(0)}\to(g^{e'})^{\sum \lambda_{i} \cdot s_i} \to \prod (g^{e'})^{\lambda_i \cdot s_i }</script></li></ul></li><li><p>通信复杂度为$O(t^2)$</p></li></ul></li><li><p>$Verification$：输入公钥$g^s$和原始的消息-随机数对$(m,r=g^e,g^{se})$以及修改后的消息-随机数对$(m’,r’=g^{e’},g^{se’})$，如果计算的哈希值$g^e\mu^m=g^{e’}\mu^{m’}$相等且$(g,g^s,g^{e’},g^{se’})$是DH组，输出1，否则输出0</p></li></ul><h2 id="密钥更新阶段"><a href="#密钥更新阶段" class="headerlink" title="密钥更新阶段"></a>密钥更新阶段</h2><p>目的：节点可能动态加入或离开，敌手可能掌握超过$t$个份额，需要在不改变秘密的情况下扩大门限到$t’$</p><p>目前已经有n个节点掌握多项式$F(ID(i),y)$，需要$t$个份额就能恢复秘密</p><ul><li><p>全节点$\{P_i,\dots,P_{2t’}\}$执行$Zero(\{F(ID(P_i),y),t’-1\}^{t})$</p><ul><li><p>随机选择$(t’-1,2t’-1)$阶多项式$R(x,y)$，满足$R(0,0)=0$</p></li><li><p>$\{F(x,ID(i))\}^{2t’} \gets Handout\{F(ID(i),y)\}^t$</p></li><li><p>$\{R(ID(i),y)\}^{2t’}\gets Transform\{R_i(x,ID(i))\}^{2t’},R_i(x,ID(i)$是$t’-1$阶</p></li><li><p>$\{R(x,ID(i))\}^{2t’} \gets Handout\{R(ID(i),y)\}^{2t’}$</p></li><li><p>实现了对份额的更新，新的$t’-1$阶多项式满足$F’(x,ID(P_i))=F(x,ID(P_i))+R(x,ID(i))$</p></li></ul></li><li><p>现在分发给$n’$即可，执行$\{F’(ID(i),y\}^{n’} \gets Handout\{F’(x,ID(i))\}^{2t’}$</p><ul><li>$F’(x,y)=F(x,y)+R(x,y),F’(0,0)=F(0,0)=s$</li><li>更新份额相较于重新生成私钥再分配的区别在于，省去了执行$DCH.KeyGen()$的时间</li></ul></li></ul><h1 id="RSA累加器"><a href="#RSA累加器" class="headerlink" title="RSA累加器"></a>RSA累加器</h1><p>主要参考知乎<a href="https://zhuanlan.zhihu.com/p/158976773">这篇文章</a>理解，本文写的不够清楚</p><ul><li>acc字段存当前RSA累加器的值，RSA累加器把所有区块的$last_hash$编码进去，同一高度的区块acc值一样<ul><li>当区块2内的编辑请求$tx_{req1}$修改$tx1$为$tx1’$后，生成区块3，区块2内的acc值更新</li></ul></li></ul><p><img src="/2023/02/27/JCH22/image-20230227165109508.png" alt="image-20230227165109508"></p><h2 id="一致性检查"><a href="#一致性检查" class="headerlink" title="一致性检查"></a>一致性检查</h2><p>编辑会导致同一区块高度可能存在不同的区块，客户端需要检查是否区块被编辑过</p><ul><li>客户端发送想要查询的区块$header,hash(header)$给任意节点，节点本地查询RSA累加器</li><li>节点收到成员证明或者非成员证明后验证即可</li></ul><h1 id="安全性分析"><a href="#安全性分析" class="headerlink" title="安全性分析"></a>安全性分析</h1><h2 id="Decentralization"><a href="#Decentralization" class="headerlink" title="Decentralization"></a>Decentralization</h2><p>如果敌手试图通过$(m,r=g^e,g^{se})$来恢复$s$实现高效寻找碰撞，考虑到在系统稳定时，密钥作为常数项</p><p>$F(x,0)=s+\sum_{i=1}^{t-1}a_ix^i$被分享给$n$个节点，节点拥有份额$(IP(P_i),F(IP(P_i),0))$，超过$t$个节点同意即可恢复私钥。由于敌手只能控制$t-1$个节点，无法恢复私钥</p><p>在私钥更新阶段，每个节点最多同时掌握$2t-1$阶多项式$F(i,y)$和$t-1$阶$F(x,i)$，节点能够获得$t-1$阶多项式</p><p>敌手最多获得$t-1$份$F(x,0)$和$F’(x,0)$，无法恢复私钥</p><h2 id="Traceability"><a href="#Traceability" class="headerlink" title="Traceability"></a>Traceability</h2><p>考虑到同一高度所有被编辑的区块组成一条编辑链，所有编辑可以被高效审计（RSA累加器的必要性体现在一致性检查）</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li>提到新的创世区块，应该是是自己新建一条链，如何集成到现有的区块链系统中</li><li>最初$t$个掌握变色龙哈希函数私钥的节点怎么选，安全性<ul><li>直接用节点身份的哈希值，属于半中心化信标</li></ul></li><li>在包含修改请求的交易上链后，其他区块链上的节点如何修改$header \to header’$</li><li>修改区块头的结构后，增加的3个字段会带来额外的存储开销</li><li>RSA累加器的必要性在哪里<ul><li>将编辑后的区块加入到RSA累加器中</li><li>每次生成新的区块，节点本地更新RSA累加器的值</li><li>节点验证区块的有效性时想要知道该区块是否被编辑过</li><li>如果不是使用RSA累加器，其他方案如何解决区块的区分问题</li><li>RSA累加器的值能保证同步吗？可能存在某个恶意节点的未即时更新acc，客户端向恶意节点查询本已经被修改过的区块，该恶意节点返回该区块未被编辑。如果不同步，下一次生成区块的acc计算会错误；如果编辑对自己不利，可能在出块时才更新acc<ul><li>[LMW+23]提到了扩展头部的作用是保证类似的本地数据结构的同步</li></ul></li></ul></li><li>初始化的RSA的$N$和$g_1$也需要分布式生成，论文给了参考的算法，没有仔细了解</li><li><p>需要的映射哈希函数，将$x$映射为素数$SH(x)$，这种映射怎么找</p><ul><li>github的RSA accumulator已找到</li></ul></li><li><p>last_hash字段是新产生区块更新后的头部的哈希，如果是对之前区块的编辑，$last_hash$是该区块的头部哈希，不是编辑的区块是否该字段为空？</p></li><li>每次秘密分享都是可验证的，不是公开可验证</li><li>如果将RSA累加器替换为bloom filter？<ul><li>思考可行性：布隆过滤器提供高效的成员证明，非成员证明很可能不出错</li><li>如何保证参与者的bloom filter一致，区块头加上布隆过滤器的哈希值？类似于RSA的acc</li><li><a href="https://zhuanlan.zhihu.com/p/601973839">https://zhuanlan.zhihu.com/p/601973839</a></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Jia M, Chen J, He K, et al. Redactable Blockchain From Decentralized Chameleon Hash Functions[J]. IEEE Transactions on Information Forensics and Security, 2022, 17: 2771-2783.&lt;/p&gt;</summary>
    
    
    
    <category term="Crypto" scheme="https://alleysira.github.io/categories/Crypto/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="Redactable Blockchain" scheme="https://alleysira.github.io/tags/Redactable-Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>overview on blockchain consensus mechanism</title>
    <link href="https://alleysira.github.io/2022/11/28/overview-on-blockchain-consensus-mechanism/"/>
    <id>https://alleysira.github.io/2022/11/28/overview-on-blockchain-consensus-mechanism/</id>
    <published>2022-11-28T01:46:11.000Z</published>
    <updated>2023-02-28T02:59:12.239Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>共识机制作为区块链技术的核心，从根本上决定了整个系统的安全性、可用性和系统性能等</p><span id="more"></span><h2 id="区块链概述"><a href="#区块链概述" class="headerlink" title="区块链概述"></a>区块链概述</h2><p>特点</p><ul><li>去中心化：网络中没有可信第三方</li><li>去信任化：节点之间不需要彼此信任，通过共识机制达成对账本的一致认识</li><li>公开透明性：任何节点可以随时加入退出，可以获得区块链的历史账本数据，接收到新生成的区块</li><li>不可篡改性：区块链中的历史数据不能被非法篡改</li><li>匿名性：保护隐私数据</li></ul><h2 id="共识概述"><a href="#共识概述" class="headerlink" title="共识概述"></a>共识概述</h2><p>决定参与节点以何种方式对某些特定的数据达成一致</p><p>分为经典的分布式共识机制和区块链共识机制</p><p>区块链共识机制：</p><ul><li><p>授权共识：网络节点通过了PKI身份认证后才能参与后续共识机制</p></li><li><p>非授权共识：节点随时加入退出，节点数量动态变化，通过特定算法完成出块者选举、区块生成和节点验证、更新</p></li></ul><p>区块链共识机制的基本流程</p><ul><li>选举出块者：目前的出块者可以分为两种，一种是单一节点作为出块者，另一种是多个节点构成委员会，整个委员会作为出块者。选举过程中需要考虑女巫攻击，需要完成一定的任务或者条件才能够成为出块者。目前大多数采用Pow和Pos</li><li>生成区块：出块者将一段时间内网络中的交易打包放进当前区块中，为了使区块链成为链状结构，在其中包含其他内容。区块分为区块头和区块体。区块头包含了上个区块的哈希值、时间戳；区块体包含完整的交易数据。目前可以按照出块者与区块的对应关系将区块生成过程分为两类：一类是一对一关系，一个出块者对应一个区块；一对多关系意味着一个出块者在其任期期间能够生成多个区块，一般将一个出块者的任职时间称为一个时期(epoch)，每个任期由多轮组成，每轮生成一个区块</li><li>节点验证更新区块链：出块者生成区块后，将区块在网络中广播，收到区块的节点验证区块正确性并更新本地区块链。部分共识机制中节点需要验证区块交易合法性和出块者的身份合法性</li></ul><p>评价标准</p><ul><li>安全性：考虑敌手存在且操纵一定的网络资源和其他资源的情况下，诚实用户在不可信的网络环境下达成一致</li><li>交易吞吐率：区块链系统的交易处理速度，一般采用每秒钟处理交易的数量作为评判标准，一般受到区块产生间隔、区块大小和网络延时等因素的影响</li><li>可扩展性：网络处理交易的性能是否随着节点的增多而增强，网络处理能力的可增长性，一般采用分片来实现，每个分片并行处理网络内部的数据</li><li>交易确认时间：交易被提交至网络到最终被完全确认所需要的时间，完全确认是指交易被写入区块且大概率不会被篡改，以此作为凭证完成交易过程。比特币中大概为60分钟。确定性共识中交易确认时间降低</li><li>去中心化：区块链采用的共识机制没有可信第三方，区块由参与公式的节点共同决定，而不是集中在少数几个节点上，网络中的权力应当分散化而不是集中化，矿池一定程度上影响了比特币的去中心化</li><li>资源占用：节点间的通信复杂度和节点的计算复杂度</li></ul><h1 id="模型和定义"><a href="#模型和定义" class="headerlink" title="模型和定义"></a>模型和定义</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>状态机复制：存在一组节点且所有节点共同维护一个线性增长的日志，就日志内容达成一致<ul><li>节点中存在一个主机。在可容忍的范围内，允许一定比例的节点出现故障或遭受敌手攻击。需要满足一致性和活性</li><li>一致性：满足诚实节点最终输出日志一致</li><li>活性：在一定时间内出现在所有诚实节点的日志中</li><li>常用于大型数据库的同步</li></ul></li><li>快速响应特性：交易确认时间与网络真实时延有关，与网络时延上限无关</li><li>授权共识：授权网络中PKI存在且为每个节点实施身份认证。注册完成后，每个节点都能活着所有参与者节点数量和身份。运行共识机制，实现状态机复制，完成账本的生成和维护，并将账本以区块链的形式实现。</li><li>非授权共识：节点不需要身份认证，无身份认证，由于网络动态变化，节点无法获知所有参与者节点数量和身份；通过一定的共识机制实现状态机复制</li><li>公共账本：能够满足一致性和活性的可信公告牌，任何人都能在上面存放消息，任何人都能读账本；对状态机复制的延伸，保证了在非授权网络中公开透明、任何节点能够随时访问、添加信息。满足以下两个安全特性<ul><li>持续性：诚实用户在某个位置上传了合法交易，则最终所有诚实用户的张本忠该位置一定存在该交易</li><li>活性：某个时间诚实用户上传了交易至公开账本，等待若干时间后，该交易一定出现在每个诚实用户账本中</li></ul></li><li>共同前缀：$Q_{cp}$表示。任意两个诚实节点提交的节点在去掉末尾k个区块后一定具有前缀关系</li><li><p>链质量：安全参数$\mu \in \mathbb{R},k,k_0 \in \mathbb{N}$，任何城市节点P的链C中除去最新的$k_0$区块后，任意k个连续的区块中，恶意区块的比例不超过$\mu$</p><ul><li>链质量属性是指连续的区块中必定有足够比例的区块由诚实用户产生</li></ul></li><li><p>链增长：安全参数为$\tau \in \mathbb{R},s,r_0 \in \mathbb{N}$，对于任意轮r（r&gt;$r_0$)，城市节点P在第r轮输出的区块链为$C_1$，在第$r+s$轮输出的区块链为链C_2，满足$|C_2|-|C_1|\geq \tau \cdot s$</p></li><li>弱一致性：根据出块者选举的方式，同一个时期可能有两个甚至以上合法的出块者，区块链可能出现分叉，但是很长一段时间后最终的区块链是确定的</li><li>强一致性：生成的区块是确定的，确定性共识方案。通过选择一个确定的委员会，再由委员会内部运行的分布式一致性算法生成新区块，每一轮的区块都是确定的，一般不会分叉<ul><li>无分叉，节点无需花费大量算力</li><li>交易确认速度快，上传的交易写入区块中便可以确保合法性</li><li>前向安全性（forward security），只要区块被写入到区块链上，可以确保区块不会被篡改，将一直保持在链上</li></ul></li><li><p>容错类型</p><ul><li><p>拜占庭容错：分布式系统中发生了任意类型的错误，错误的节点少于一定比例都能保证可靠性</p><ul><li>PBFT BFT-Smart</li><li>联盟链、公链</li></ul></li><li><p>非拜占庭容错：只能保证节点宕机等错误发生时系统的可靠性</p><ul><li>Paxos、Raft</li><li>私有链（没有恶意节点）</li></ul></li></ul></li></ul><h2 id="模型分类"><a href="#模型分类" class="headerlink" title="模型分类"></a>模型分类</h2><h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><ul><li>同步网络：诚实节点之间的消息按照轮来传播，在每一轮中诚实用户发出的消息能够在下一轮之前到达所有其他诚实用户。比较强的网络模型</li><li>部分同步网络：网络中的消息传输存在一定的上限$\Delta$，时延上限不能作为协议的参数使用，能够确保诚实用户发出的消息在$\Delta$时间后到达所有诚实用户；属于区块链协议分析中常用的网络模型</li><li>异步网络：敌手能够任意拖延诚实用户的消息或者打乱顺序，只需要保证最终诚实用户的消息能够到达彼此</li></ul><h3 id="腐化模型"><a href="#腐化模型" class="headerlink" title="腐化模型"></a>腐化模型</h3><p>腐化指敌手通过向目标节点发动攻击，获取目标节点的秘密信息，进而控制目标节点的输入输出消息，使其完全受到自身的控制</p><ul><li>静态敌手：敌手只能在协议开始前选定其腐化的目标，一旦协议开始运行便不能腐化诚实节点。敌手控制的节点数量在协议运行期间不会改变</li><li>$\tau-$温和敌手：敌手腐化一个节点需要一定的时间$\tau$，在该时间内节点仍然属于诚实节点。属于区块链协议分析中常用的腐化模型</li><li>适应性敌手：是指敌手能够根据协议运行过程中手机的信息，动态且适应性地对目标节点完成腐化</li></ul><h3 id="敌手模型"><a href="#敌手模型" class="headerlink" title="敌手模型"></a>敌手模型</h3><p>对敌手能够掌握的算力或财产占比做出一定的限制，一般用f代表敌手数量，n代表网络中节点总数，利用n与f的关系来刻画敌手模型</p><ul><li>$n=2f+1$：敌手算力占全网算力比例不超过1/2<ul><li>比特币</li></ul></li><li>$n=3f+1$：PBFT等经典分布式共识机制要求敌手模型；一些混合共识也需要这样的约束</li><li>$n=4f+1$：由于自私挖矿导致链质量下降，某些混合共识</li></ul><h1 id="经典分布式共识机制"><a href="#经典分布式共识机制" class="headerlink" title="经典分布式共识机制"></a>经典分布式共识机制</h1><p>在授权网络中，一组节点实现状态机复制。主要面向分布式数据库系统，Paxos针对网络中可能出现的崩溃节点；PBFT能够容忍一定的拜占庭错误节点。</p><p>根据网络模型可以分为：</p><ul><li>部分同步网络分布式一致算法</li><li>异步网络分布式一致算法</li><li>同步网络分布式一致算法</li></ul><h2 id="部分同步网络分布式一致算法"><a href="#部分同步网络分布式一致算法" class="headerlink" title="部分同步网络分布式一致算法"></a>部分同步网络分布式一致算法</h2><h3 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h3><p>包含了主节点和备份节点的概念，允许多个主节点同时进行提议，赋予不同的等级；等级高的主节点的提议可以打断低等级的主节点提议（即使低等级的主节点已经得到了备份节点的承诺消息）。广泛应用于分布式系统中数据库的维护，只能对恶意节点容错，无法对拜占庭节点（恶意节点）实现容错</p><ul><li>主节点向全网超过1/2的备份节点发送准备消息</li><li>备份节点验证消息合法性，通过后向主节点返回承诺信息</li><li>主节点收集足够多的承诺消息，组成承诺凭证，主节点向备份节点发送包含承诺凭证的accept消息</li><li>备份节点验证接受消息的合法性，通过后向主节点发送accepted消息</li></ul><p><img src="/2022/11/28/overview-on-blockchain-consensus-mechanism/v2-8d4eaf5fdeb145e8bdf5e3bb1af408c9_1440w.webp" alt="img"></p><p><a href="https://zhuanlan.zhihu.com/p/31780743">参考1</a>，<a href="https://www.cnblogs.com/linbingdong/p/6253479.html">参考2</a></p><h3 id="PBFT"><a href="#PBFT" class="headerlink" title="PBFT"></a>PBFT</h3><p>$n=3f+1$，网络模型为部分同步网络</p><p>分布式共识达成过程：</p><ul><li>请求：客户端上传请求消息m至网络中的节点，包括主节点和其他备份节点</li><li>预准备：主节点收到客户端上传的请求消息m，赋予消息序列号s，计算得到预准备消息$(pre-prepare,H(m),s,v)$</li><li>准备：备份节点收到主节点的预准备消息，验证$H(m)$的合法性，即对于视图v和序列号s来说，备份节点先前未收到其他消息。验证通过后，备份节点计算准备消息并广播。所有节点收集准备消息，大于2f+1则组成certificate发送</li><li>执行：</li></ul><h1 id="To-do"><a href="#To-do" class="headerlink" title="To do"></a>To do</h1><p>继续阅读</p><p>需要补充学习的经典机制：Paxos PBFT</p><p>学习女巫攻击 DOUCEUR J R. The Sybil attack[C]. In: Peer-to-Peer Systems—IPTPS 2002. Springer Berlin Heidelberg, 2002: 251–260. [DOI: 10.1007/3-540-45748-8_24]</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;共识机制作为区块链技术的核心，从根本上决定了整个系统的安全性、可用性和系统性能等&lt;/p&gt;</summary>
    
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="Consensus" scheme="https://alleysira.github.io/tags/Consensus/"/>
    
  </entry>
  
  <entry>
    <title>Decentralizing Privacy: Using Blockchain to Protect Personal Data</title>
    <link href="https://alleysira.github.io/2022/11/15/Decentralizing-Privacy-Using-Blockchain-to-ProtectPersonal-Data/"/>
    <id>https://alleysira.github.io/2022/11/15/Decentralizing-Privacy-Using-Blockchain-to-ProtectPersonal-Data/</id>
    <published>2022-11-15T07:21:40.000Z</published>
    <updated>2022-11-18T02:36:44.907Z</updated>
    
    <content type="html"><![CDATA[<p>本文的实质贡献是提出了在仅区块链存储加密数据的指针，结合数字签名提供认证性，使用去中心化的数据存储结构存储加密数据提供保密性</p><p><a href="https://ieeexplore.ieee.org/abstract/document/7163223">文献</a></p><p>Users should own and control their data without compromising security or limiting companies’ and authorities’ ability to provide personalized services.</p><span id="more"></span><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>用户对于企业收集的个人信息没有控制权、对于企业如何使用信息不知情</p><p>相关工作：</p><ul><li><p>OpenPDS，在密文上直接操作</p></li><li><p>$k$匿名要求每条记录中的敏感信息至少和其他$k-1$条记录不可区分，跟进工作有l-diversity，t-closeness</p></li><li><p>差分隐私</p></li><li>FHE</li></ul><p>本文贡献：</p><ul><li>将区块链与链下存储相结合，构造了一个聚焦于隐私的个人信息管理平台</li><li>阐述了未来区块链可能成为一种重要的可信计算资源</li></ul><h1 id="The-Privacy-Problem"><a href="#The-Privacy-Problem" class="headerlink" title="The Privacy Problem"></a>The Privacy Problem</h1><p>聚焦于移动平台用户使用第三方服务时在隐私方面的忧虑，这些第三方持续收集用户信息，用户不知情也无权掌控，因此主要解决的隐私问题有以下三类：</p><ul><li>数据拥有权：用户拥有并且控制个人数据，系统将用户作为数据的拥有者，服务作为委托权限的客体</li><li>数据透明性和可审计性：用户可以了解数据如何收集并且如何加工</li><li>细粒度的访问控制：任何时刻用户都可以更改权限集或者撤回之前已经收集的数据的权限；该方案的一个应用就是改善移动端应用程序现有的权限日志，用户接口依然相同，访问控制策略将会在区块链上安全地存储，只有用户可以更改</li></ul><h1 id="Proposed-Solution"><a href="#Proposed-Solution" class="headerlink" title="Proposed Solution"></a>Proposed Solution</h1><p>本方案有3类实体：</p><ul><li>手机用户：下载并且使用应用</li><li>服务：应用程序的提供者，为商业目的请求对用户个人数据进行处理</li><li>节点：维护区块链和一个分布式的私有键值对形式的数据库以换取奖励</li></ul><p>尽管用户在系统中仍然是匿名的，可以将服务配置文件存储在区块链上并且验证身份；</p><p>区块链接受两种类型的交易：</p><ul><li>$T_{access}$用于访问控制管理</li><li>$T_{data}$用于数据存储和取回</li></ul><p><img src="/2022/11/15/Decentralizing-Privacy-Using-Blockchain-to-ProtectPersonal-Data/image-20221116093213863.png" alt="image-20221116093213863" style="zoom: 50%;"></p><p>考虑以下实例：用户安装使用本平台保护隐私的应用程序，用户第一次登录，一个新的共享的身份将会被建立并且和相关联的权限一起通过$T_{access}$交易发送给区块链。手机手机的敏感信息在用共享的密钥加密后通过$T_{data}$发送给区块链，随后路由到链下的键值存储数据库，链上只保留了一个指向数据的指针</p><p>服务和用户都可以通过$T_{data}$上的数据指针来访问数据，区块链验证数字签名属于用户还是服务。用户可以通过发出$T_{access}$交易和新的权限集来更改已经授予服务的权限或者收回对之前存储的数据的访问权。可以开发dashboard提供了对数据和权限的概览</p><p>链下键值存储是Kademilia的实现，一个分布式的哈希表（DHT），使用LevelDB增加了一致性和区块链的接口。DHT由一个网络中的节点维护（大概率和区块链网络中的节点不重合），执行检验过的读/写交易。数据在节点之间充分地随机化并且复制，来确保高可用性。值得注意的是，可以考虑替代链下的存储解决方案。中心化的云服务器可能可以用来存储数据，虽然增加了对第三方可信度的要求，但是带来了扩展性和易于部署的好处</p><h1 id="The-Network-Protocol"><a href="#The-Network-Protocol" class="headerlink" title="The Network Protocol"></a>The Network Protocol</h1><h2 id="Building-Blocks"><a href="#Building-Blocks" class="headerlink" title="Building Blocks"></a>Building Blocks</h2><h3 id="Identities"><a href="#Identities" class="headerlink" title="Identities"></a>Identities</h3><p>在区块链中用户可以生成任意多个匿名身份来保护隐私。</p><p><em>复合身份</em>是两方或者更多人共享的身份，其中至少一个参与者属于拥有者，其他人权限受限，作为客体。协议1阐述了对于一个拥有者和一个客体的实现，实际就是两者共享同一个对称加密私钥，拥有各自的签名公私钥；同时此时要求了两者之间是secure channel</p><p><img src="/2022/11/15/Decentralizing-Privacy-Using-Blockchain-to-ProtectPersonal-Data/image-20221116103317693.png" alt="image-20221116103317693"></p><p>对外来看，复合身份是一个2元组</p><script type="math/tex; mode=display">Compound_{u,s}^{(public)}=(pk_{sig}^{u,s},pk_{sig}^{s,u})</script><p>完整的身份包括</p><script type="math/tex; mode=display">Compound_{u,s}=(pk_{sig}^{u,s},pk_{sig}^{s,u},sk_{sig}^{u,s},sk_{sig}^{s,u},sk_{enc}^{u,s})</script><h3 id="Blockchain-Memory"><a href="#Blockchain-Memory" class="headerlink" title="Blockchain Memory"></a>Blockchain Memory</h3><p>区块链的存储空间$L:\{0,1\}^{256}\to \{0,1\}^N$，假设存储在其他区块链中的标准敌手模型下是不可篡改的</p><h3 id="Policy"><a href="#Policy" class="headerlink" title="Policy"></a>Policy</h3><p>用户$u$给予服务$s$的的一系列权限记作$POLICY_{u,s}$，当服务忠实执行协议且正确地标记数据，任何类型的数据都可以进行安全地存储。</p><h3 id="Auxiliary-Functions"><a href="#Auxiliary-Functions" class="headerlink" title="Auxiliary Functions"></a>Auxiliary Functions</h3><p>$Parse(x)$将发送给交易的消息进行反序列化，该消息包含了$CheckPolicy(pk^{k}_{sig},x_p)$</p><p>首先将给定消息的公钥做哈希寻找到数据指针，在存储上找到该指针对应的消息，将找到的消息反序列化后如果公钥确实是主体公钥或者客体公钥，但是该客体的权限属于权限集中，则返回1；此处暗示了$L[\mathcal{H}(pk^{u,s}_{sig})]=L[\mathcal{H}(pk^{s,u}_{sig})]$</p><p><img src="/2022/11/15/Decentralizing-Privacy-Using-Blockchain-to-ProtectPersonal-Data/image-20221117090454251.png" alt="image-20221117090454251"></p><h2 id="Blockchain-Protocols"><a href="#Blockchain-Protocols" class="headerlink" title="Blockchain Protocols"></a>Blockchain Protocols</h2><p>协议3是链上节点收到$T_{access}$时执行的，类似的，协议4是链上节点收到$T_{data}$时执行的</p><p>$T_{access}$交易允许用户通过发送$POLICY_{u,s}$更改已经赋予服务的权限集，发送空集撤销所有之前赋予的权限。当发送一条新的复合身份的$T_{access}$交易时，该消息将被理解为用户注册服务</p><p>具体来看，将消息反序列化之后得到的主体公钥和收到的公钥对比，若相同则修改对应的指针位置存储的消息，相当于修改了权限</p><p><img src="/2022/11/15/Decentralizing-Privacy-Using-Blockchain-to-ProtectPersonal-Data/image-20221117091230415.png" alt></p><p>对于$T_{data}$交易执行读写操作，有了之前的$CheckPolicy(pk^{k}_{sig},x_p)$，可以判断该用户或服务能够获得数据访问权。</p><p>将收到的消息反序列化之后得到了加密后的数据，权限和读写标识；进行权限判断：如果此时判断为真，则取出对应的两个公钥以及权限集，私以为原文伪代码有误，此处应为$\gets Parse(L[\mathcal{H}(pk^{k}_{sig})])$，若此时需要写，则计算$c$对应的指针并添加到之前的指针集合内，再修改$DHT$对应的位置为$c$；若此时只读，可能只传一个指针，判断$h_c\in L[a_{xp}]$（此处记号和伪代码不同）</p><p><img src="/2022/11/15/Decentralizing-Privacy-Using-Blockchain-to-ProtectPersonal-Data/image-20221117091642675.png" alt="image-20221117091642675"></p><h2 id="Privacy-and-Security-analysis"><a href="#Privacy-and-Security-analysis" class="headerlink" title="Privacy and Security analysis"></a>Privacy and Security analysis</h2><p>假设：</p><ul><li><p>区块链不可随意篡改</p></li><li><p>假设需要足够大的互不信任的平等网络</p></li><li>假设用户安全地保管密钥</li></ul><p>在以上模型下，只有用户能够控制自己的数据，区块链去中心化的本质结合了数字签名的交易确保了敌手无法伪装为用户或者腐化网络，否则暗示了敌手能够伪造数字签名或者控制网络中的大多数资源。类似地，敌手无法获得公开账本上的任何信息，因为链上只存储了指针。</p><p>敌手控制1个或多个DHT节点无法学习到任何原始数据，因为被对称密钥加密了，该密钥的拥有者和DHT节点不重合。注意到尽管数据完整性无法保证，因为单个节点可以修改本次的复制或者以拜占庭的方式修改，本方案仍然可以通过对数据进行充分的分布和复制来最小化风险。</p><p>为每个符合身份生成新的密钥对保证了在敌手获得了加密和签名密钥后，只有一小部分数据会被损害。获得这两个密钥其中一个，数据仍然是安全的。注意在实践中我们可以进一步将身份分开来限制该复合身份密钥泄露带来的影响。比如每1k条消息换一次密钥。</p><h1 id="Discussion-of-future-extensions"><a href="#Discussion-of-future-extensions" class="headerlink" title="Discussion of future extensions"></a>Discussion of future extensions</h1><p>稍微偏题来呈现可能的未来区块链的扩展</p><h2 id="From-storage-to-Processing"><a href="#From-storage-to-Processing" class="headerlink" title="From storage to Processing"></a>From storage to Processing</h2><p>本文的实质贡献是提出了在仅区块链存储加密的数据的指针，该方案适合于存储和随机查询。对于处理数据效率不高。存在的问题是服务可以存储之前查询过的信息来进行未来的分析。</p><p>为解决上述问题可以采用秘密分享结合MPC的方法来计算任何函数[BGW88]，下图展示了在本文框架下MPC如何与区块链结合。考虑电子选举和投票的一个例子。投票结束后提交了后端的代码来聚合结果。网络随机选取节点的子集和一个解释程序来将代码转化为MPC协议，结果将被存储在公开账本上无法被篡改但是任何人可以看到选举结果。</p><p>左上角的方案是不安全的方案；本文提出的方案实际是一部分随机节点先计算正确的结果再把结果采用秘密分享广播出去，存储在链上（感觉没有任何意义）</p><p><img src="/2022/11/15/Decentralizing-Privacy-Using-Blockchain-to-ProtectPersonal-Data/image-20221117103847654.png" alt="image-20221117103847654"></p><p>比特币假设所有节点都是平等不可信的，节点在合作决策过程中的能力取决于算力，节点$n$的权重$trust_n \propto resources(n)$，导致了女巫攻击（PoW是抵抗女巫攻击的吧）、过度的能源消耗和高时延。PoW的思想是投入了大部分资源的节点不太可能作弊，采用类似的思想可以设计出方案来使得好的行为得到奖励。将每个节点好的和坏的行为统计起来采用sigmoid function转换为一个概率：</p><script type="math/tex; mode=display">trust_n^{(i)}=\frac{1}{1+e^{-\alpha(good-bad)}}</script><p>其中$\alpha$是步长。采用这样的思想可以给可信的节点更多权重并且更高效地计算区块。因为在该系统中获取权限花费很多时间，该设计应当抵抗女巫攻击。当然还存在其他攻击，比如节点增加信誉只为了日后作恶。可以采用随机选择一些绝点来对每个区块投票，采用相同权重多数赢得方式投票。可以防止某些节点权重过高。</p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>个人信息和敏感信息不应该被第三方来掌握，用户可以拥有自己的数据而不损害安全或者限制自己在企业获得个性化服务的能力。</p><p>法律法规应该在区块链中编程并被自然执行，账本可以作为法律证据。</p><h1 id="Thoughts"><a href="#Thoughts" class="headerlink" title="Thoughts"></a>Thoughts</h1><ul><li>链上存储公钥和加密后的指针<ul><li>公钥用于进行签名认证</li><li>指针用于读取加密后的数据</li></ul></li><li>链下采用分布式数据结构DHT存储加密数据</li><li>面向移动端，提供了应用权限管理和撤销的机制</li><li>对于未来的看法比较有启发性<ul><li>目前的系统服务读了原始数据之后可以自行保存用于后续分析<ul><li>采用MPC，服务只能得到函数结果，无法得到原始数据</li></ul></li><li>提出了采用信用管理来替代PoW</li></ul></li></ul><p>To be done</p><ul><li>后续的论文跟进</li><li>找一下具体实现</li><li>伪代码的一些问题<ul><li>$L[\mathcal{H}(pk^{u,s}_{sig})]=L[\mathcal{H}(pk^{s,u}_{sig})]$</li><li>标蓝的部分</li></ul></li><li>PoW和sybil</li><li>文献的实验类型和工程实践</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文的实质贡献是提出了在仅区块链存储加密数据的指针，结合数字签名提供认证性，使用去中心化的数据存储结构存储加密数据提供保密性&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://ieeexplore.ieee.org/abstract/document/7163223&quot;&gt;文献&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Users should own and control their data without compromising security or limiting companies’ and authorities’ ability to provide personalized services.&lt;/p&gt;</summary>
    
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>An Overview of Blockchain Technology：Architecture, Consensus, and Future Trends</title>
    <link href="https://alleysira.github.io/2022/11/15/An-Overview-of-Blockchain-Technology/"/>
    <id>https://alleysira.github.io/2022/11/15/An-Overview-of-Blockchain-Technology/</id>
    <published>2022-11-15T02:57:39.000Z</published>
    <updated>2022-12-04T09:53:58.884Z</updated>
    
    <content type="html"><![CDATA[<p>不学区块链的都该枪毙</p><span id="more"></span><h1 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h1><ul><li>非对称密码学</li><li>分布式共识算法</li></ul><p>存在的挑战</p><ul><li>scalability：每个块1MB，每10分钟出块，每秒7个交易<ul><li>无法处理高频交易</li><li>区块越大，存储空间越大，产生速度越慢，更少的用户愿意维护大型的链</li><li>tradeoff between block size and security</li></ul></li><li>selfish mining带来的区块分支较多<ul><li>前提矿工具备算力优势，挖出节点后不立刻公布，继续在私有链挖矿，当其他人公布1个新的节点时，立即公布2个节点</li></ul></li><li>privacy leakage</li><li>pow or pos 存在的问题：浪费电力/富者愈富</li></ul><h1 id="BLOCKCHAIN-ARCHITECTURE"><a href="#BLOCKCHAIN-ARCHITECTURE" class="headerlink" title="BLOCKCHAIN ARCHITECTURE"></a>BLOCKCHAIN ARCHITECTURE</h1><h2 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h2><p>每一个区块包含两部分：</p><ul><li>区块头<ul><li>block version：主要用于确定遵循的区块验证规则</li><li>Merkle树根节点的哈希</li><li>Timestamp：时间戳</li><li>nBits：有效的区块哈希的长度</li><li>Nonce：4字节，从0开始随每次哈希计算增加</li><li>父区块的哈希：256bit，指向前一个区块</li></ul></li><li>区块主体<ul><li>交易：可以容纳的交易的最大数量取决于区块的大小和每个交易的大小</li><li>交易计数器</li></ul></li></ul><p><img src="/2022/11/15/An-Overview-of-Blockchain-Technology/image-20221111095427304.png" alt="image-20221111095427304"></p><h2 id="Digital-signature"><a href="#Digital-signature" class="headerlink" title="Digital signature"></a>Digital signature</h2><p>每个用户都有一对公私钥，私钥用于签名并向整个网络公布</p><p>经典方案是ECDSA</p><h2 id="key-Characteristics-of-Blockchain"><a href="#key-Characteristics-of-Blockchain" class="headerlink" title="key Characteristics of Blockchain"></a>key Characteristics of Blockchain</h2><ul><li>去中心化：传统的中心化交易系统每笔交易都需要可信机构来验证，不可避免地带来了额外开销和中央服务器的性能瓶颈的问题；区块链中的共识算法取代了第三方来提供数据一致性</li><li>持久性：交易可以快速验证，无效的交易不会被诚实的节点接受，当交易添加到区块链之后几乎不可能删除或者回滚交易；包含无效交易的区块会被立即发现</li><li><p>匿名性：用户使用生成的地址与区块链交互，不会泄露用户真实身份；区块链无法保证完美的隐私保护</p></li><li><p>可审计性：比特币区块链使用Unspent Transaction Output（UTX-O）存储用户的余额，任何交易需要涉及到之前未使用的交易，一旦当前的交易被记录在区块链中，涉及到的未使用的交易的状态就从未使用转换为已使用，因此交易可以容易地验证和跟踪</p></li></ul><h2 id="Taxonomy-of-blockchain-systems"><a href="#Taxonomy-of-blockchain-systems" class="headerlink" title="Taxonomy of blockchain systems"></a>Taxonomy of blockchain systems</h2><p>粗略地分为：</p><ul><li>公开链：所有数据公开，每个人都可以参与共识过程</li><li>私有链：中心化，仅仅那些来自特定组织的节点将会被允许加入共识过程</li><li>联盟链：半中心化，只有一部分预先选择的节点参与共识过程</li></ul><p><img src="/2022/11/15/An-Overview-of-Blockchain-Technology/image-20221111105103019.png" alt="image-20221111105103019"></p><ul><li>共识决定：在联盟链中只有一部分节点对验证区块负责，私有链全部由一个组织决定</li><li>读权限：联盟链和私有链具体分析</li><li>不变性：记录保存在节点处，因此在联盟链和私有链上可以轻易篡改</li><li>效率：由于公链节点数量多因此导致了交易量受限、延迟较高</li><li>中心化：是最大的不同，只有公开链是去中心化的</li><li>共识过程：公链所有用户均可加入；私有链和联盟链需要权限</li></ul><p>公开链对全世界开放，能够吸引众多用户，活跃；联盟链可以应用在商业场景</p><h1 id="CONSENSUS-ALGORITHMS"><a href="#CONSENSUS-ALGORITHMS" class="headerlink" title="CONSENSUS ALGORITHMS"></a>CONSENSUS ALGORITHMS</h1><p>在互不信任和节点中达成共识是Byzantine Generals（BG）问题的同义转换</p><h2 id="Proof-of-Work"><a href="#Proof-of-Work" class="headerlink" title="Proof of Work"></a>Proof of Work</h2><p>比特币网络使用的共识策略，在去中心化的网络中需要选择一个节点来记录交易；随机选取是一种自然的方法，但是容易受到攻击，因此需要在发布交易之前证明节点不准备作恶</p><p>每个节点计算一个区块头的的hash值，必须满足小于某个值（前面有多少个0），header包含一个nonce</p><p>当一个节点计算出了hash值，将广播这个区块，其他所有节点需要验证这个节点的正确性；被验证后其他矿工会把该节点加入到自己的区块链中</p><p>矿工是指计算hash值的节点，PoW的过程叫做挖矿</p><p>在去中心化的网络中，当许多节点几乎同时发现了合适的nonce时，有效的区块可能被同时产生，导致了可能存在许多分支，协议的设计使得两个相互竞争的分支不会同时产生下一个区块。在POW中，较长的链被认为是可信的链(authentic chain)</p><p>在PoW中矿工需要做许多计算机计算，然而这些运算浪费了很多资源。为了减少损失，一些PoW协议中的运算可以有额外的应用。比如Primecoin中的PoW可以被用作数学研究</p><h2 id="Proof-of-Stake"><a href="#Proof-of-Stake" class="headerlink" title="Proof of Stake"></a>Proof of Stake</h2><p>PoS是PoW的节约能源的替代，矿工需要证明拥有一定数量的货币。<strong>我们相信拥有更多货币的人不太可能攻击网络。</strong>这样的选择是不公平的，最富有的人会统治网络。结果是许多方案都结合了权益大小来决定谁来产生下一个块。与PoW相比，PoS节约了能源并且更加高效。但是由于挖矿成本几乎为0，后果是可能存在攻击。许多Pow的链正在逐渐向PoS转变，ethereum已经于2022年全面弃用了PoW。</p><h2 id="PBFT"><a href="#PBFT" class="headerlink" title="PBFT"></a>PBFT</h2><p>可实现拜占庭容错(Practical byzantine fault tolerance)是一种拜占庭容错算法的复现。Hyperledger Fabric使用了PBFT作为共识算法，因为PBFT可以处理多达1/3的恶意节点。</p><p>每轮产生一个新区块，将按照一定规则选出每轮的候选人，候选人对交易排序负责，整个过程可以分为预准备、准备和执行三个阶段。在每个阶段如果节点获得了超过2/3的节点的投票，因此PBFT要求每个节点对网络都是已知的。</p><p>与PBFT类似，Stellar Consensus Protocol（SCP）同样是拜占庭共识协议。在PBFT中1每个节点需要询问其他节点，然而SCP给了参与者权利来选择相信哪些参与者的子集。dBFT（delegated）中一些专业的节点被投票选出来记录交易。</p><h2 id="DPOS"><a href="#DPOS" class="headerlink" title="DPOS"></a>DPOS</h2><p>代理权益证明（Delegated proof of stake）和Pos的区别在于代表民主和直接民主。权益持有者选举他们的代表来产生有效的区块。由于参与确认的区块显著减少，认证的过程更加快速，带来了交易的快速交易。同时，代表也可以调整网络的参数，例如区块大小和区块时间间隔。此外，用户不需要担心不诚实的代表因为他们可以被轻易地投票淘汰</p><h2 id="Ripple"><a href="#Ripple" class="headerlink" title="Ripple"></a>Ripple</h2><p>Ripple共识算法利用了在大规模网络中相互信任的子网。在网络中节点被分为两类：服务端和客户端。服务端参与共识过程，客户端只传递资金，每个服务端都有一个唯一节点列表Unique Node List (UNL)，当觉得是否将交易放进账本时，服务端将询问UNL中节点如果接受到一致的节点超过了80%，交易将被打包进入账本。对于一个节点，只要在UNL中的恶意节点少于20%，账本将会保证正确</p><h2 id="Tendermint"><a href="#Tendermint" class="headerlink" title="Tendermint"></a>Tendermint</h2><p>拜占庭共识协议，每轮产生一个新的区块，申请人将被选出来广播一个未经确认的区块。可以分为3个步骤：</p><ul><li>预投票步：验证者选择是否为提议的区块广播预投票</li><li>预执行步：如果节点收到了提议的区块的超过2/3预投票，为该区块广播预执行；如果节点收到超过超过2/3的预执行，进入执行阶段</li><li>执行步：节点验证区块并广播对区块的执行，如果节点收到了2/3的执行，就接受该区块。和PBFT相比，节点需要锁定他们的币来成为验证者；如果一个验证者被发现是不诚实，将会被惩罚</li></ul><h2 id="Consensus-algorithms-comparison"><a href="#Consensus-algorithms-comparison" class="headerlink" title="Consensus algorithms comparison"></a>Consensus algorithms comparison</h2><p><img src="/2022/11/15/An-Overview-of-Blockchain-Technology/image-20221114104559314.png" alt="image-20221114104559314"></p><ul><li>PBFT需要在每轮选择候选人；Tendermint需要提前了解验证者来选举每轮的申请人。两者更适用于商业场景而不是公开场景</li><li><p>Pos同样需要做hash，对区块头做哈希来搜索目标值，但是工作量受限；</p></li><li><p>consensus speed</p></li><li>blocks generation rate &amp; security</li></ul><h1 id="CHALLENGES-amp-RECENT-ADVANCES"><a href="#CHALLENGES-amp-RECENT-ADVANCES" class="headerlink" title="CHALLENGES &amp; RECENT ADVANCES"></a>CHALLENGES &amp; RECENT ADVANCES</h1><h2 id="Scalability"><a href="#Scalability" class="headerlink" title="Scalability"></a>Scalability</h2><p>随着交易量增加，区块链变得臃肿。每个节点都需要存储许多交易来确保当前交易确实是未花费的。除此之外，由于对区块大小和出块时间的限制，比特币只能处理大概每秒7个交易，无法满足现实需求。由于区块的容量有限，许多小数值的交易可能会延迟因为矿工更倾向于有高额手续费的交易。解决此类问题的主要由两种方法：</p><h3 id="Storage-optimization-of-blockchain"><a href="#Storage-optimization-of-blockchain" class="headerlink" title="Storage optimization of blockchain"></a>Storage optimization of blockchain</h3><p>节点运行账本的完整拷贝变得困难，Bruce提出了网络将旧的交易记录忘记的方案。采用一个叫做account tree的数据库来保存所有非空地址的余额。除此之外轻量的客户端也能够解决这个问题。VerSum允许轻量级客户端外包对于大的输入上昂贵的计算，通过对比多个服务器上的结果来保证结果的正确性</p><h3 id="redesigning-blockchain"><a href="#redesigning-blockchain" class="headerlink" title="redesigning blockchain"></a>redesigning blockchain</h3><p>Bitcoin-NG将传统的区块分离成两部分：key block负责进行领导选举；micro block负责存储交易。协议将时间分为时期，在每个时期，矿工需要哈希生成key block。一旦生成了key block，节点称为leader负责生成micro blocks。Bitcoin-NG同时扩展了最长链的策略，其中micro blocks没有权重。这种设计解决了区块大小和网络的安全的平衡。</p><h2 id="Privacy-leakage"><a href="#Privacy-leakage" class="headerlink" title="Privacy leakage"></a>Privacy leakage</h2><p>区块链无法保证交易的隐私（transactional privacy）因为交易的数值和公钥绑定关系是公开可见的，用户的交易可能泄露用户的个人信息；可能存在和IP之间的映射关系；每个用户都可以被该用户连接的节点来定义。提高区块链匿名性的方法可以分为两类：</p><ul><li>混淆：在区块链中，用户的地址是匿名的，但是当许多用户和同一个地址频繁交易时，仍然可能将地址与真实的身份连接起来。混淆是一种在多个输入地址和多个输出地址之间转移资金提供匿名性的操作<ul><li>存在的问题：<ul><li>输入输出之间的交易必须是等额面值；</li><li>混淆者可能不诚实：混淆者清楚具体的映射关系，可以进行追踪；可能携款而逃，将交易转移到自己的地址上去</li></ul></li></ul></li></ul><p><img src="/2022/11/15/An-Overview-of-Blockchain-Technology/image-20221115093818396.png" alt="image-20221115093818396"></p><ul><li>匿名性：使用零知识证明，矿工只需要验证币属于有效的币的列表即可。<ul><li>Zerocoin Zerocash zero-knowledge Succinct Non-interactive Arguments of Knowledge (zk-SNARKs) 提供这方面的解决思路</li><li>陕西师范大学老师的录屏也可以参考</li></ul></li></ul><h2 id="Selfish-mining"><a href="#Selfish-mining" class="headerlink" title="Selfish mining"></a>Selfish mining</h2><p>区块链容易受到合谋的自私矿工的攻击。在自私挖矿策略中，自私的矿工将已挖出的区块保存起来而不广播，知道满足某些条件时再公布私链，由于私链比其他现有的公开链长，它会被所有矿工承认。在私链公开发布致歉，诚实的矿工都在浪费资源在无用的分支上，然而自私的矿工在自己的私链上挖矿没有竞争者，因此更容易获得更多利润。</p><p>顽固挖矿（stubborn mining）中矿工可以通过不平凡地将挖矿攻击和网络层的日蚀攻击结合起来增加收益。trail-stubbornness是一种顽固挖矿的策略，尽管私链长度已经落后的情况下还继续挖矿。</p><p>如何应对自私挖矿：诚实的矿工选择跟随分支时倾向于选择有更多新鲜的区块的分支（时间戳和beacon，但是可能伪造该时间戳）；ZeroBlock提出每个区块必须在一定时间内被网络接受，此时自私的矿工获益不会超过期望值。</p><h1 id="POSSIBLE-FUTURE-DIRECTIONS"><a href="#POSSIBLE-FUTURE-DIRECTIONS" class="headerlink" title="POSSIBLE FUTURE DIRECTIONS"></a>POSSIBLE FUTURE DIRECTIONS</h1><h2 id="Blockchain-testing"><a href="#Blockchain-testing" class="headerlink" title="Blockchain testing"></a>Blockchain testing</h2><p>截止目前有约700种加密货币，一些开发者可能伪造区块链的性能表现来吸引投资者获益，当用户需要将区块链和业务结合起来时，需要连接哪个区块链符合用户的需求，因此需要区块链测试机制来解决问题</p><p>区块链测试可以被分为两个阶段：标准化阶段和测试阶段。在标准化阶段需要协商设立所有标准，当区块链产生之后，将会被协商好的标准进行测试和验证是否像开发者宣称的那样正常运行。在测试阶段，区块链将会在不同的标准下执行，如吞吐量等。</p><h2 id="Stop-the-tendency-to-centralization"><a href="#Stop-the-tendency-to-centralization" class="headerlink" title="Stop the tendency to centralization"></a>Stop the tendency to centralization</h2><p>区块链被设计为去中心化系统，然而存在矿工在矿池中心化的趋势。迄今为止，前5的矿池拥有Bitcoin超过51%的算力。自私挖矿的策略在算力超过总算力的25%即可获得比平均股权更多的收益，因此理智的矿工将被吸引进入自私的矿池并且最终矿池将轻易超过51%的算力。区块链并不是只为若干组织设计的，因此需要有方法来解决这样的问题。</p><h2 id="Big-data-analytics"><a href="#Big-data-analytics" class="headerlink" title="Big data analytics"></a>Big data analytics</h2><ul><li>data management：区块链可以用来存储重要的数据<ul><li>因为去中心化和安全的特性</li><li>可以保证数据是原始的</li></ul></li><li>data analytics<ul><li>交易可以用来分析用户的交易习惯</li><li>预测用户的交易行为</li></ul></li></ul><h2 id="Block-applications"><a href="#Block-applications" class="headerlink" title="Block applications"></a>Block applications</h2><p>目前多数区块链被应用在金融领域，越来越多在不同领域的应用正在复现。传统企业可以应用区块链来提高系统化，例如可以存储用户信誉。新兴行业可以使用区块链来提高性能。</p><p>智能合约是执行合同内容的计算机化的交易协议，目前已经被区块链实现。在区块链中智能合约是代码碎片可以被矿工自动化执行。智能合约在许多领域都有变革性的潜力。</p><h1 id="CONCLUSION"><a href="#CONCLUSION" class="headerlink" title="CONCLUSION"></a>CONCLUSION</h1><p>本文首先给出区块链技术的概述，包括区块链的体系架构和区块链的关键特征。然后讨论了区块链中使用的典型的共识算法，在不同方面分析和比较了这些协议。此外，列出了一些阻碍区块链开发的挑战和问题，并汇总了一些现有的方法来解决这些问题，也提出了一些可能的未来方向。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;不学区块链的都该枪毙&lt;/p&gt;</summary>
    
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>A Pragmatic Introduction to Secure Multi-Party Computation</title>
    <link href="https://alleysira.github.io/2022/11/09/A-Pragmatic-Introduction-to-Secure-Multi-Party-Computation/"/>
    <id>https://alleysira.github.io/2022/11/09/A-Pragmatic-Introduction-to-Secure-Multi-Party-Computation/</id>
    <published>2022-11-09T03:19:41.000Z</published>
    <updated>2022-11-15T03:04:04.170Z</updated>
    
    <content type="html"><![CDATA[<p>老老实实打基础 <a href="https://securecomputation.org/main/">https://securecomputation.org/main/</a></p><span id="more"></span><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>1980年代提出的安全多方计算理论如今成为了构建密码系统的实用工具</p><p>安全多方计算允许一个群组成员联合进行一次计算，同时任何参与者都不会泄露自己隐私的输入</p><p>用户协商一个需要计算的函数，用户的隐私信息作为输入，函数的结果作为输出</p><p>secure computation：范围更大的概念，包括了所有在数据上执行运算同时保护数据隐私的方法</p><p>verifiable computation：允许参与者确认函数的输出是否是给定输入下的函数输出</p><p>主要有两种满足了安全和可验证的计算：outsourced computation 和 multi-party computation</p><h2 id="Outsourced-Computation"><a href="#Outsourced-Computation" class="headerlink" title="Outsourced Computation"></a>Outsourced Computation</h2><p>一方拥有数据，想要得到对数据进行运算的结果</p><p>另一方接受并存储加密的数据，在加密后的数据上执行运算，将结果返回给数据拥有者，无法得知输入、中间值和最终的结果</p><p>数据拥有者解密后得到正确的输出</p><p>同态加密天然具备在加密数据上进行运算的能力</p><p>部分同态方案：Paillier，Naccache and Stern</p><p>全同态加密能够执行加法和乘法，有常量0/1，可以计算任何有限函数</p><p>Rivest提出了概念，Gentry提出第一个全同态方案，基于格；目前效率仍然不够高</p><p>FHE和MPC在概念上有区别，不能直接比较；但是从功能和实现的角度联系紧密</p><p>目前的MPC比FHE快几千倍</p><h2 id="Multi-Party-Computation"><a href="#Multi-Party-Computation" class="headerlink" title="Multi-Party Computation"></a>Multi-Party Computation</h2><p>MPC的目标是使得一组独立的互不信任的数据拥有者能够共同计算一个依赖各自隐私输入的函数</p><p>MPC和外包计算的区别是所有的协议参与者执行着一个协议</p><p>Andrew Yao在1980s提出了安全多方计算的概念，$m$个参与者拥有隐私数据$x$共同计算$f(x_1,x_2,\cdots,x_m)$</p><p>直到2000年算法的进步才使得安全多方计算实际可用</p><p>Yao的混淆电路协议属于通用协议，可以计算任何离散函数</p><p>专用协议（比如PSI）可能比通用协议更高效</p><h2 id="MPC-Applications"><a href="#MPC-Applications" class="headerlink" title="MPC Applications"></a>MPC Applications</h2><p>主要实现了隐私保护</p><ul><li><p>Yao’s Millionaires Problem</p><ul><li>两个富人想要比较谁更富有但是不想泄露关于财富的信息，相当于完成$boolean \ x_1 \leq x_2$</li></ul></li><li><p>Secure auctions</p><ul><li><p>需要保护出价人和出售人的隐私，以及对已投标的不可延展性</p></li><li><p>Bid privacy：出价人不能得知其他参与者的出价</p></li><li><p>Bid non-malleability：参与者的出价值不能被用来产生一个相关的出价（前者无法推出后者</p></li></ul></li><li><p>Voting</p><ul><li>安全的电子投票即是执行加法，同样需要满足隐私性和不可延展性</li><li>额外的需要标准MPC不具备的性质：coercion resistance，投票人能向第三方证明自己如何投票</li></ul></li><li><p>Secure machine learning</p><ul><li><p>Oblivious model inference允许client向已经有预训练好模型的服务器发送请求，请求和模型均为隐私输入，输出是模型对请求的预测</p></li><li><p>在训练阶段MPC可以使得参与者保护自己的数据</p></li></ul></li></ul><h3 id="Deployments"><a href="#Deployments" class="headerlink" title="Deployments"></a>Deployments</h3><p>实现仍然处于早期阶段，具有若干问题，包括：</p><ul><li>系统是否会执行协议</li><li>从输出推理敏感信息</li><li>没有密码学背景的人如何理解隐患</li></ul><p>当前MPC是为了实现数据共享才得以部署的，而不是为了增加一层隐私保护（可能是未来的方向</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;老老实实打基础 &lt;a href=&quot;https://securecomputation.org/main/&quot;&gt;https://securecomputation.org/main/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="MPC" scheme="https://alleysira.github.io/categories/MPC/"/>
    
    
    <category term="Crypto" scheme="https://alleysira.github.io/tags/Crypto/"/>
    
    <category term="MPC" scheme="https://alleysira.github.io/tags/MPC/"/>
    
  </entry>
  
</feed>
