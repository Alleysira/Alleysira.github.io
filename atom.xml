<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Alleysira&#39;s blog</title>
  
  
  <link href="https://alleysira.github.io/atom.xml" rel="self"/>
  
  <link href="https://alleysira.github.io/"/>
  <updated>2024-12-16T10:50:08.059Z</updated>
  <id>https://alleysira.github.io/</id>
  
  <author>
    <name>Alleysira</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ThreadNeck</title>
    <link href="https://alleysira.github.io/2024/12/10/thread/"/>
    <id>https://alleysira.github.io/2024/12/10/thread/</id>
    <published>2024-12-10T07:59:04.000Z</published>
    <updated>2024-12-16T10:50:08.059Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Wu S, Li Z, Zhou H, et al. Following the “Thread”: Toward Finding Manipulatable Bottlenecks in Blockchain Clients[C]//Proceedings of the 33rd ACM SIGSOFT International Symposium on Software Testing and Analysis. 2024: 1440-1452.</p><span id="more"></span><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>区块链客户端是区块链网络的基础，客户端本身存在性能瓶颈，攻击者可以故意利用瓶颈制造DoS。现有工作关注了少部分瓶颈，且局限于手工分析。本文深入分析了瓶颈的主要原因，开发了Thread-Neck，在客户端运行时检测症状。ThreadNeck 将客户端建模为多个线程，描绘它们之间的相互关系，以准确刻画客户端的行为。对Geth/Besu/Reth/FISCO-BCOS的实验发现了13个可利用的瓶颈，其中6个是未知的。</p><p>代码仓库：Not Available</p><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>区块链应用：供应链、IoT、保险</p><p>客户端存在瓶颈-&gt;DoS-&gt;数量减少-&gt;51%攻击、DApp宕机</p><p>Related Attack: </p><ul><li>DoS相关的工作，NURGLE</li><li>对client插桩可能误差（记录日志对IO的影响）</li></ul><p>挑战</p><ul><li>对客户端的执行的刻画：区块链相比传统软件更加复杂、数据层、网络、共识和合约。每层有独立的设计并且有交互，如何决定划分的细粒度？按层划分可能太粗，按函数划分理解调用的语境</li><li>从正常状态中识别出瓶颈：难以生成对客户端的输入（需要满足密码学和共识的约束），客户端是有状态的并且和网络交互，难以穷尽所有执行。因此可行的方法是检测客户端的正常运行，寻找可能存在瓶颈的地方（好low），由于缺乏异常性能指标，这种方法也存在问题。例如，当内存和 CPU 使用等性能指标在正常操作中保持正常时，很难识别出瓶颈的细微迹象。</li><li>跨客户端的多样性：每个客户端的瓶颈不同，设计和实现也不同，难以用统一框架进行检测</li></ul><p>解决方法：</p><ul><li>将客户端可化为线程，根据线程的生命周期对客户端进行划分，为客户端构建了一个线程等待与唤醒图，以展示线程之间的相互关系</li><li>分析现有的性能诊断和优化的研究，提出了两类的瓶颈的根本原因。记录了发现了与瓶颈相关的症状，后续进行PoC验证</li><li>将不同编程语言的线程模型进行对比，对不同实现提出对应的策略</li></ul><p>测试了4种客户端 （Geth/Besu/Reth/FISCO-BCOS），发现了13个可利用的瓶颈，攻击者可以DoS客户端或者对应的模块，6个未知的问题已经被开发者修复</p><p>贡献</p><ul><li>首个系统研究区块链客户端瓶颈的工作</li><li>设计并实现ThreadNeck，准确刻画了区块链客户端的执行并帮助确认瓶颈</li><li>将ThreadNeck应用到4个主流客户端，发现了13个瓶颈</li></ul><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><p>客户端维护区块链，和其他客户端通信，验证和传播交易/区块</p><p>作者认为Parity和Besu结构一致</p><p>Geth的结构（很有帮助）</p><p><img src="/2024/12/10/thread/image-20241210172247318.png" alt="image-20241210172247318"></p><p>可以划分为</p><ul><li>网络层：管理和P2P网络的通信</li><li>存储层：存储以太坊网络的状态，管理账户余额、合约、合约的状态</li><li>执行引擎：执行交易、运行合约，包括交易池和EVM</li><li>接口层：提供RPC、HTTP和其他接口，外部应用程序可以和客户端交互，发交易和读取区块链数据</li><li>外部的consensus engine：确定规则，处理区块的产生和验证。PoS之后，共识引擎已经被分离了，通过接口层和执行层客户端接触</li></ul><p>用户通过DApp发送交易，首先交易作为RPC发送给客户端，然后通过网络层传播交易，能够出块的节点可以将交易打包进区块，新产生的区块被广播到网络中。其他节点收到区块后使用共识引擎验证区块，在EVM中执行交易，更新状态，结果存储在客户端</p><h3 id="Thread-State"><a href="#Thread-State" class="headerlink" title="Thread State"></a>Thread State</h3><p>线程：程序中的执行路径，可能会存在多个状态</p><ul><li>running：运行</li><li>runnable：可运行</li><li>blocked：阻塞</li></ul><h3 id="Threat-Model"><a href="#Threat-Model" class="headerlink" title="Threat Model"></a>Threat Model</h3><p>大多数编程语言使用操作系统提供的线程，Golang的机制不同，采用goroutine，支持了更高的并发</p><p><img src="/2024/12/10/thread/image-20241210193943478.png" alt="image-20241210193943478"></p><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>瓶颈是软件实现中限制了应用效率的弱点</p><h3 id="Motivating-Example"><a href="#Motivating-Example" class="headerlink" title="Motivating Example"></a>Motivating Example</h3><p>真实事件，调用extcodesize，带来严重IO负载</p><p>cancun中的策略</p><p><img src="/2024/12/10/thread/image-20241211152658856.png" alt="image-20241211152658856"></p><h3 id="Root-Cause"><a href="#Root-Cause" class="headerlink" title="Root Cause"></a>Root Cause</h3><p>分析现有论文，总结方法</p><ul><li>无效同步：用于保证线程以特定顺序执行。无效同步指使用错误，导致某些线程挂起，影响程序性能，已有工作给出了无效同步的三类主要原因<ul><li><img src="/2024/12/10/thread/image-20241211153851788.png" alt="image-20241211153851788"></li><li>锁竞争：主要原因，攻击A，B和C会等待更长时间</li><li>负载不均衡</li><li>IO阻塞</li></ul></li><li>资源耗尽：如CPU和内存</li></ul><p>为了检测无效同步类的瓶颈，需要理解线程间的交互，因此将客户端建模为线程，画出线程等待和唤醒图，分析线程之间的pattern</p><p>为了检测资源类型的瓶颈，测量线程执行路径的资源消耗</p><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p><img src="/2024/12/10/thread/image-20241211163317680.png" alt="image-20241211163317680"></p><p>可以划分为两个阶段</p><ul><li>在运行时刻画客户端，记录线程唤醒时间和其他相关信息，构造线程等待&amp;唤醒图，将线程之间的相互关系可视化</li><li>分析图，监测两类瓶颈对应的症状，检测存在的瓶颈，对于检测出的线程，根据调用栈定位出测试用例。利用开发者提供的模板测试，进行PoC，测试发现的瓶颈是否会导致DoS</li></ul><h2 id="Building-Wait-amp-Wake-Graph"><a href="#Building-Wait-amp-Wake-Graph" class="headerlink" title="Building Wait&amp;Wake Graph"></a>Building Wait&amp;Wake Graph</h2><p>有向图，记录程序执行过程中线程之间等待和唤醒的关系</p><ul><li>点代表线程，包含调用栈，记录了程序的执行路径以及资源消耗<ul><li>磁盘、网络接口认为是 虚拟线程</li></ul></li><li>边代表唤醒关系， A-&gt;b 线程A唤醒了线程B，即B可能等待A的执行</li></ul><p><img src="/2024/12/10/thread/image-20241211165226500.png" alt="image-20241211165226500" style="zoom:67%;"></p><p>接下来讨论如何构造这个图，根据编程语言实现 Thread 的方法</p><h3 id="Native"><a href="#Native" class="headerlink" title="Native"></a>Native</h3><p>基于wPerf[OSDI18]，hook 内核函数 <code>try_to_wake_up</code></p><h3 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h3><p>涉及对go routine的支持</p><p>one OS thread -&gt; multiple go routines</p><p>始终保持OS thread running</p><p>解决办法：阅读go的源码，插桩 <code>goready</code> 函数</p><p><img src="/2024/12/10/thread/image-20241213101314474.png" alt="image-20241213101314474"></p><p>利用go官方的trace和pprof测量资源利用</p><h3 id="Merge-Similar-Threads"><a href="#Merge-Similar-Threads" class="headerlink" title="Merge Similar Threads"></a>Merge Similar Threads</h3><p>区块链客户端运行的线程非常多，为了减小图的规模，将相似的线程进行合并</p><p>因为很多线程实际执行了相同的功能（网络连接多个线程处理网络请求）</p><p>基于call stack鉴定相似的线程</p><p>线程建模为稀疏向量，计算余弦相似度</p><h2 id="Identify-the-Bottlenecks"><a href="#Identify-the-Bottlenecks" class="headerlink" title="Identify the Bottlenecks"></a>Identify the Bottlenecks</h2><p>针对两类，无效同步和资源耗尽类型的瓶颈</p><h3 id="无效同步"><a href="#无效同步" class="headerlink" title="无效同步"></a>无效同步</h3><p>观察出最主要的指标是图中的循环等待，问题转化为在图中检测循环</p><p>重视被NIC（网络接口）调起的线程</p><p><img src="/2024/12/10/thread/image-20241213110330983.png" alt="image-20241213110330983"></p><p>去掉worker和pool之间的边</p><p>注释掉可能会漏掉一些，因此手工代码审计了注释掉的worker和pool</p><p>构造PoC很难：</p><ul><li>松耦合的系统</li><li>需要对源码的深刻理解</li></ul><p>方法：unit test，用class和方法名去检索</p><p>对于已知事件，策略</p><ul><li>增加交易数量</li><li>提升交易复杂度</li><li>区块大小</li></ul><p>未知事件，根据源码分析原因，哪个函数导致了瓶颈，是否被外部输入影响</p><h3 id="资源耗尽"><a href="#资源耗尽" class="headerlink" title="资源耗尽"></a>资源耗尽</h3><p>xxx presents a challenge.</p><p>符号执行无法观察资源占用，路径不敏感的符号执行生成的假阳多，路径敏感的符号执行可扩展性不足（区块链客户端是规模庞大的软件）</p><p>解决方法：通过线程来刻画资源占用，关注了两类线程</p><ul><li>执行时间长或内存占用高</li><li>执行时间或内存分配变化大，表明该类线程容易受到外部输入的影响</li></ul><p>使用标准差刻画变化性</p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p><img src="/2024/12/10/thread/image-20241215100203061.png" alt="image-20241215100203061"></p><p>使用Besu作为例子</p><p>下载区块头，验证，下载区块体，验证交易签名，将区块导入链</p><p>可以观察到存在两个循环，PoC的设计</p><p>观察call stack，找到入口点，构造恶意合约，修改单元测试函数</p><p><img src="/2024/12/10/thread/image-20241215100836809.png" alt="image-20241215100836809"></p><h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><p>回答的研究问题</p><p><img src="/2024/12/10/thread/image-20241215100939772.png" alt="image-20241215100939772"></p><ul><li>能否检测出瓶颈</li><li>是否比已有工作更有效</li><li>额外的开销有多少</li><li>配置会如何影响检测的效果</li></ul><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p><img src="/2024/12/10/thread/image-20241215185902457.png" alt="image-20241215185902457"></p><p>和主网同步，使用现实世界中的交易作为输入</p><p>使用主网数据的原因（多样性，更贴合现实世界）</p><p>GraphQL API是什么？</p><p>运行4天</p><p>env：64-bit machine with 16 cores and 256GB memory</p><p>使用滑动窗口策略，每2小时刻画120s，频率为4000HZ（这是什么）</p><h3 id="RQ1"><a href="#RQ1" class="headerlink" title="RQ1"></a>RQ1</h3><p>7个已知，6个未知，所有都被确认，3个CVE</p><p><img src="/2024/12/10/thread/image-20241215190715896.png" alt="image-20241215190715896"></p><p>case study</p><p><img src="/2024/12/10/thread/image-20241215190930104.png" alt="image-20241215190930104"></p><p>发现IO-2，Peer，Downloader线程之间存在环</p><p>peer可以在节点即将结束同步时恶意地延迟消息</p><p>可能的缓解方法</p><p><img src="/2024/12/10/thread/image-20241215191658700.png" alt="image-20241215191658700"></p><h3 id="RQ2"><a href="#RQ2" class="headerlink" title="RQ2"></a>RQ2</h3><p>9%的CPU消耗，内存可不计</p><h3 id="RQ3"><a href="#RQ3" class="headerlink" title="RQ3"></a>RQ3</h3><p>和已有工作在Besu和C++对比</p><p>wPerf发现了568，未能发现本文工具未发现的</p><p>给出了不能发现的原因</p><h3 id="RQ4"><a href="#RQ4" class="headerlink" title="RQ4"></a>RQ4</h3><p>门限实验，合并同类线程的模块 和 资源占用的门限</p><p><img src="/2024/12/10/thread/image-20241215192539520.png" alt="image-20241215192539520"></p><p>50% 距离时会漏掉一个bug，因此采用了60%和70%</p><p>15 线程</p><h2 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h2><p>可以扩展到其他应用程序中</p><p>为了选择区块链作为研究对象</p><ul><li>对web3社区的重要性</li><li>区块链的开源，有丰富的单元测试用例</li><li>工作原理近似，发现的瓶颈和缺陷可以迁移</li></ul><p>缺陷：无法适用于所有软件</p><ul><li><p>对于多线程软件使用IPC进行通信，无法有效监测</p></li><li><p>如果软件线程数太少，难以发现线程间同步的问题</p></li></ul><h2 id="Threat-to-Validity"><a href="#Threat-to-Validity" class="headerlink" title="Threat to Validity"></a>Threat to Validity</h2><ul><li><p>依赖人工撰写测试用例，消耗时间较长，缺乏可扩展性 </p><ul><li>计划后续使用大模型基于模板生成测试用例</li><li>结合模糊测试增加测试用例的多样性</li></ul></li><li><p>区块链客户端数量较少，未能支持Nethermind，未来计划支持更多客户端</p></li><li>瓶颈并不一定会导致系统性能降低，为了检测这类问题不能直接用现在的方法，需要设计新的oracle</li><li>代码覆盖率不高，可能因为dead code和路径不够丰富</li></ul><h2 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work"></a>Related work</h2><p>On CPU 许多性能测量工具采用 插桩 和 采样方法实现，将代码在总体执行时间内的占比排序，缺少出花费最多时间的部分</p><p>Off CPU 比如等待的事件也可能是瓶颈</p><h3 id="区块链客户端性能测量"><a href="#区块链客户端性能测量" class="headerlink" title="区块链客户端性能测量"></a>区块链客户端性能测量</h3><p>高纬度的参数（吞吐量、延迟）</p><p>插桩，分析时间消耗的分布，研究交易处理中的瓶颈</p><p>每个opcode的耗时</p><p>函数的耗时</p><h3 id="区块链客户端优化"><a href="#区块链客户端优化" class="headerlink" title="区块链客户端优化"></a>区块链客户端优化</h3><p>优化共识算法</p><p>分片</p><p>合约交易并行</p><p>DAG</p><p>新的MPT的设计</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>检测区块链客户端中可利用的瓶颈</p><p>给出了两类瓶颈的根本原因</p><p>将客户端建模为多个线程，研究多个线程的关系</p><h2 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h2><ul><li>GraphQL API</li><li>RPC eth_call is free?</li><li>存储的消耗？</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Wu S, Li Z, Zhou H, et al. Following the “Thread”: Toward Finding Manipulatable Bottlenecks in Blockchain Clients[C]//Proceedings of the 33rd ACM SIGSOFT International Symposium on Software Testing and Analysis. 2024: 1440-1452.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>REVOKE</title>
    <link href="https://alleysira.github.io/2024/12/03/REVOKE/"/>
    <id>https://alleysira.github.io/2024/12/03/REVOKE/</id>
    <published>2024-12-03T08:30:33.000Z</published>
    <updated>2024-12-09T10:41:13.762Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Bhudia A, O’Keeffe D, Hurley-Smith D. Revoke: Mitigating Ransomware Attacks Against Ethereum Validators[C]//European Symposium on Research in Computer Security. Cham: Springer Nature Switzerland, 2024: 333-353.</p><span id="more"></span><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>由于以太坊网络中PoS的机制的设计，受到了勒索病毒攻击的validator（验证者）可能会被处以罚金，验证者成为了勒索病毒的攻击对象，目前缺少对验证者从勒索攻击中恢复的机制。即使是尝试退出网络的验证者，在提取期内也可能被追溯性削减权益。</p><p>本文提出了 <strong>Revoke</strong>，对以太坊协议的扩展，用于缓解验证者遭受勒索软件攻击的影响。Revoke 引入了一种新的去中心化密钥吊销机制，使验证者无需提取质押即可更换其签名密钥。Revoke 面临的一个挑战是，在为单个验证者提供吊销机制的实用性与可能降低整个链的安全性之间寻求平衡。</p><p>Revoke 的设计揭示了一个权衡：验证者在吊销过程中无法提议或验证区块，因此会受到非活跃惩罚，但可以避免更为严重的削减惩罚。本文的设计扩展了以太坊规范，以捕捉 Revoke 核心密钥更换机制对信标链状态转换函数和分叉选择决策的影响。调整了以太坊现有的安全性和活性证明，以涵盖 Revoke 的影响。</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>运行validator需要质押大量资产(32ETH，2024年12月约为$115K)</p><p>为了防止验证者丢失金额，验证者的密钥被划分为：</p><ul><li><p>提款密钥 withdrawal key: 用于读取质押的ETH，常规操作不需要该密钥，可以存储在离线设备</p></li><li><p>签名密钥 signing key: 对于消息进行签名，容易受到攻击</p></li></ul><p>但是，尽管无法获得提款密钥，攻击者会威胁验证者，将会使用签名密钥作恶（为冲突的交易或区块签名）。根据以太坊协议，作恶的验证者会被惩罚，因此验证者更倾向于支付赎金</p><p>通过智能合约确保验证者在支付赎金后免受进一步的削减处罚，从而最大程度地减少受害验证者对勒索软件攻击者的信任需求。</p><p>这里的问题其实是密钥撤销的问题</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Bhudia A, O’Keeffe D, Hurley-Smith D. Revoke: Mitigating Ransomware Attacks Against Ethereum Validators[C]//European Symposium on Research in Computer Security. Cham: Springer Nature Switzerland, 2024: 333-353.&lt;/p&gt;</summary>
    
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="Ethereum" scheme="https://alleysira.github.io/tags/Ethereum/"/>
    
    <category term="PoS" scheme="https://alleysira.github.io/tags/PoS/"/>
    
  </entry>
  
  <entry>
    <title>When Fuzzing Meets LLMs Challenges and Opportunities</title>
    <link href="https://alleysira.github.io/2024/10/07/llm4fuzz/"/>
    <id>https://alleysira.github.io/2024/10/07/llm4fuzz/</id>
    <published>2024-10-07T02:42:08.000Z</published>
    <updated>2024-12-11T08:35:46.825Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>LLM4Fuzz的综述</p><p>本文总结了5个使用LLM辅助模糊测试的挑战，回顾了顶会论文并确认了挑战的广泛存在，提出了解决方案并在DBMS进行了评估，说明了推荐方法的有效性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@inproceedings&#123;jiang2024fuzzing,</span><br><span class="line">  title=&#123;When fuzzing meets llms: Challenges and opportunities&#125;,</span><br><span class="line">  author=&#123;Jiang, Yu and Liang, Jie and Ma, Fuchen and Chen, Yuanliang and Zhou, Chijin and Shen, Yuheng and Wu, Zhiyong and Fu, Jingzhou and Wang, Mingzhe and Li, Shanshan and others&#125;,</span><br><span class="line">  booktitle=&#123;Companion Proceedings of the 32nd ACM International Conference on the Foundations of Software Engineering&#125;,</span><br><span class="line">  pages=&#123;492--496&#125;,</span><br><span class="line">  year=&#123;2024&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>LLM的短板：上下文长度、幻觉</p><p>导致了测试性能退化、误报率、低测试覆盖和有限的可扩展性</p><p>challenges：</p><ul><li>生产的输出质量低，不满足驱动程序要求的精度</li><li>模型的理解和处理能力限制</li><li>在模糊测试过程中难以生成足够多样化的输入</li><li>无法保证保持生成输入的有效性</li><li>对漏洞检测机制的错误理解阻碍了它们有效识别和解决复杂软件漏洞的能力</li></ul><h1 id="CHALLENGES-AND-OPPORTUNITIES"><a href="#CHALLENGES-AND-OPPORTUNITIES" class="headerlink" title="CHALLENGES AND OPPORTUNITIES"></a>CHALLENGES AND OPPORTUNITIES</h1><p><img src="/2024/10/07/llm4fuzz/image-20241006165734039.png" alt="image-20241006165734039"></p><h2 id="Driver-Synthesis"><a href="#Driver-Synthesis" class="headerlink" title="Driver Synthesis"></a>Driver Synthesis</h2><p>驱动程序合成方面的已有工作的思路是利用API文档作为Prompt，要求LLM生成API调用序列作为模糊测试驱动程序</p><p>由于LLM的幻觉和对不在训练数据中的程序效果差，直接使用LLM进行测试驱动程序生成效果不好</p><ul><li>生成的驱动程序容易出错，导致测试过程中的假阳</li><li>多样性不足：对于未知程序的知识有限。LLM会利用其训练知识来填补空白，生成错误的API调用序列。LLM更倾向于对常用的项目生成有效的驱动程序</li></ul><p>建议1：</p><ul><li>如果目标项目的代码和使用案例已经包含在训练语料库中，使用LLM进行驱动程序的自动生成是可行的。基于已识别的错误迭代询问LLM并修复错误是一种实际的措施，有助于应对LLM易出错的挑战</li><li><p>不在语料库中，应该收集有价值的材料（函数原型、示例程序或函数之间的连接规则）构造Prompt。提示工程是可行的方案</p></li><li><p>对于复杂的项目（Linux Kernel），尽管有详细的文档，大模型可能依然无法生成测试程序，此时建议不使用LLM，使用传统方法更加可行</p></li></ul><h2 id="Input-Generation"><a href="#Input-Generation" class="headerlink" title="Input Generation"></a>Input Generation</h2><p>基本方法是用输入的规范和输入样例作为Prompt让LLM生成新的输入</p><p>如果直接使用LLM生成输入可能会无效，受限于训练语料库和长文本的理解能力</p><p>挑战</p><ul><li>生成的输入缺少多样性：给定Prompt，输出类似</li><li>生成的输入有效性不足：目标程序执行时可能提前结束执行，因为LLM无法完全理解输入格式的长文本<ul><li>BGP路由协议超过28000word</li></ul></li></ul><p>建议</p><ul><li><p>如果输入在网络中有很多样例，可以直接使用LLM生成测试用例，但是需要考虑多样性</p><ul><li>Prompt要求使用多样化的特性</li><li>使用基于覆盖的遗传算法</li></ul></li><li><p>LLM训练时缺少相关语料，使用LLM将知识转化为输入的规范 或 建立初始的测试用例，输入规范有助于解决有效性不足的问题，而初始测试用例则有助于解决多样性不足的问题</p><ul><li>例如，对于缺乏机器可读语法的协议实现，自动生成符合必要结构和顺序的有效测试输入变得具有挑战性。在这种情况下，利用LLM已经在已有协议上进行训练的优势，可以通过LLM和记录的消息序列转移这些协议的语法。语法能够增强生成的测试用例的有效性。</li></ul></li></ul><h2 id="Bug-Detection"><a href="#Bug-Detection" class="headerlink" title="Bug Detection"></a>Bug Detection</h2><p>基本方法：将目标程序的功能描述作为Prompt的上下文，然后让LLMs生成实现与目标程序相同功能的代码，比较语义等价的两个程序的执行结果</p><p>Tsz-On Li, Wenxi Zong, Yibo Wang, Haoye Tian, Ying Wang, Shing-Chi Cheung, and Jeff Kramer. 2023. Nuances are the Key: Unlocking ChatGPT to Find Failure-Inducing Tests with Differential Prompting. In 2023 38th IEEE/ACM International Conference on Automated Software Engineering (ASE). IEEE, 14–26.</p><p>挑战：</p><ul><li>对于被测程序的语义理解不准确，可能生成功能和被测程序偏移的代码，假阳率比较高</li></ul><p>建议：</p><ul><li>定义测试oracle高度依赖于具体的目标和场景，是模糊测试中最具挑战性的部分。对于复杂的目标，我们建议避免直接使用LLM来分析结果。相反，可以考虑利用LLM提取与特定漏洞类型相关的特征或模式，借助领域知识。随后，使用这些oracle监控系统，有助于解决理解不准确的挑战。<ul><li>使用LLM来仔细检查日志，识别错误模式，并随后利用这些模式检测逻辑错误。</li></ul></li><li>某些程序包含定义明确的文档，其中清楚地描述了预期行为，比如协议的RFC文件。对于这些情况，我们建议利用LLM的自然语言理解能力，从文档中提取预期行为，以定义测试判定标准。这有助于LLM理解目标程序的意图和设计，从而解决理解不准确的挑战。</li></ul><h1 id="POTENTIAL-SOLUTIONS"><a href="#POTENTIAL-SOLUTIONS" class="headerlink" title="POTENTIAL SOLUTIONS"></a>POTENTIAL SOLUTIONS</h1><p>对DBMS开展LLM-assisted fuzzing</p><p>针对驱动程序生成、输入生成和漏洞检测中的挑战，提出了三种潜在解决方案：状态感知的驱动器合成、跨DBMS的SQL转换以及基于日志的判定标准定义。我们将这些解决方案与直接使用LLM的实现进行了比较。</p><h2 id="LLM-Enhanced-Connector-Synthesis"><a href="#LLM-Enhanced-Connector-Synthesis" class="headerlink" title="LLM-Enhanced Connector Synthesis"></a>LLM-Enhanced Connector Synthesis</h2><p>数据库连接器或数据库驱动程序通过定义的接口（包括函数和参数）将应用程序连接到数据库。模糊测试驱动程序由这些接口序列组成。直接使用LLM生成数据库驱动程序面临两个挑战。</p><p>首先是容易出错：API序列在连接器的状态中包含语义细节，直接生成序列可能会引入错误。其次是范围有限：由于训练数据的限制，LLM缺乏关于连接器状态转换的知识。</p><p>根据建议1.2，提出了LLM增强的状态感知数据库连接器合成。首先收集JDBC函数原型和使用JDBC的示例程序。然后我们将JDBC函数之间的连接关系建模为状态转换规则。接着，我们将函数原型、示例程序和连接规则作为输入提供给LLM。我们给出的提示类似于：“根据状态转换规则和函数的状态描述，请生成长度为15的API序列，要求覆盖与之前不同的状态转换组合。”</p><p><img src="/2024/10/07/llm4fuzz/image-20241006200013351.png" alt="image-20241006200013351"></p><p>将LLM增强的连接器合成实现为<strong>Wingfuzz𝑐𝑜𝑛𝑛</strong>，并将其与<strong>LLM𝑐𝑜𝑛𝑛</strong>进行比较，后者直接利用LLM为MySQL Connector/J、MariaDB Connector/J和AWS JDBC Driver for MySQL生成驱动程序。我们在ClickHouse上对每个工具进行了模糊测试。表1显示了<strong>LLM𝑐𝑜𝑛𝑛</strong>和<strong>Wingfuzz𝑐𝑜𝑛𝑛</strong>在三个选定DBMS上在12小时内的驱动器正确率和分支覆盖率。这些统计数据表明，<strong>Wingfuzz𝑐𝑜𝑛𝑛</strong>在驱动器正确率和分支覆盖率方面始终优于<strong>LLM𝑐𝑜𝑛𝑛</strong>。主要原因在于状态转换规则嵌入了语义信息，帮助LLM生成考虑数据库连接器内不同状态的API序列。</p><h2 id="Cross-DBMS-SQL-Transfer"><a href="#Cross-DBMS-SQL-Transfer" class="headerlink" title="Cross-DBMS SQL Transfer"></a>Cross-DBMS SQL Transfer</h2><p>通过LLM直接生成SQL查询面临两个主要挑战：</p><p>确保语义正确性和促进查询多样性。复杂的SQL语法，包括各种子句、表达式和规则，使得LLM在实现语义正确性方面面临挑战，而语义正确性对于触发复杂的DBMS行为至关重要。</p><p>此外，SQL查询的多样性对于深入探测DBMS逻辑至关重要。然而，LLM的多样性受限，限制了对不同查询结构的探索。</p><p>解决方案：</p><p>不是直接创建SQL查询，而是利用LLM将其他DBMS的测试用例转移为初始种子，以对目标DBMS进行模糊测试。该方法包含三个步骤。首先，在其原生DBMS中执行现有测试用例，以捕获模式信息；其次，将模式信息提供给LLM生成新的测试用例；第三，临时注释掉无法解析的部分，以确保正确解析，然后在变异后取消注释。</p><p><img src="/2024/10/07/llm4fuzz/image-20241006200444284.png" alt="image-20241006200444284"></p><p><strong>Wingfuzz𝑖𝑛𝑝𝑢𝑡</strong>生成的测试用例包含比<strong>LLM𝑖𝑛𝑝𝑢𝑡</strong>多出159.35%、36.65%和112.14%的语义正确SQL语句，并且分别覆盖比<strong>LLM𝑖𝑛𝑝𝑢𝑡</strong>多出55.96%、21.83%和16.41%的分支。这表明，LLM无法直接生成高质量的SQL查询用于DBMS模糊测试。主要原因在于，转移种子提高了变异测试用例的多样性，而模糊测试器的变异器确保了SQL查询的语义正确性。</p><h2 id="Monitor-Based-DBMS-Bug-Detection"><a href="#Monitor-Based-DBMS-Bug-Detection" class="headerlink" title="Monitor-Based DBMS Bug Detection"></a>Monitor-Based DBMS Bug Detection</h2><p>DBMS漏洞检测中最关键的一步是构建测试判定标准，以识别逻辑或性能漏洞。测试判定标准决定了DBMS行为的正确性或有效性。直接使用LLMs来构建测试判定标准具有挑战性，因为LLMs缺乏关于DBMS行为的特定知识。</p><p>为了解决这些挑战，我们提出了基于运行时监控的DBMS漏洞检测方法，遵循REC 3.1，通过分析DBMS的运行时信息来检测异常。DBMS通常包含隐式的异常处理机制，以避免系统崩溃，通常会输出DBMS的关键内部状态。与通过检查SQL查询的执行结果来构建测试判定标准不同，我们的方法使用LLM分析运行时信息以进行漏洞检测。该过程包含两个主要步骤。首先，插入一个代理来提取DBMS的运行时信息。然后，使用LLM通过预定义的错误模式检测异常</p><p><img src="/2024/10/07/llm4fuzz/image-20241006200836511.png" alt="image-20241006200836511"></p><p>结果显示，<strong>Wingfuzz𝑏𝑢𝑔</strong>能检测到更多异常，并且比<strong>LLM𝑏𝑢𝑔</strong>产生的误报更少。这是因为运行时信息包含了DBMS的错误消息，有助于LLM分析并检测漏洞。</p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>我们系统地分析了在模糊测试中使用LLM时面临的五个挑战，并通过对近期顶级会议论文的回顾确认了这些挑战的普遍性。这些挑战影响了基于LLM的模糊测试技术的有效性。为了解决这些问题，我们提供了一些建议，以帮助模糊测试的主要步骤，这些建议在我们的初步实验中已显示出有效性。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;LLM4Fuzz的综述&lt;/p&gt;
&lt;p&gt;本文总结了5个使用LLM辅助模糊测试的挑战，回顾了顶会论文并确认了挑战的广泛存在，提出了解决方案并在DBMS进行了评估，说明了推荐方法的有效性&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@inproceedings&amp;#123;jiang2024fuzzing,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  title=&amp;#123;When fuzzing meets llms: Challenges and opportunities&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  author=&amp;#123;Jiang, Yu and Liang, Jie and Ma, Fuchen and Chen, Yuanliang and Zhou, Chijin and Shen, Yuheng and Wu, Zhiyong and Fu, Jingzhou and Wang, Mingzhe and Li, Shanshan and others&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  booktitle=&amp;#123;Companion Proceedings of the 32nd ACM International Conference on the Foundations of Software Engineering&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  pages=&amp;#123;492--496&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  year=&amp;#123;2024&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="LLM" scheme="https://alleysira.github.io/tags/LLM/"/>
    
  </entry>
  
  <entry>
    <title>EVM_opcodes</title>
    <link href="https://alleysira.github.io/2024/07/17/EVM-opcodes/"/>
    <id>https://alleysira.github.io/2024/07/17/EVM-opcodes/</id>
    <published>2024-07-17T01:25:51.000Z</published>
    <updated>2024-08-07T10:54:23.215Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Ethereum virtual machine opcodes</p><span id="more"></span><p>根据以太坊主网最新分叉Cancun的定义，目前操作码共150个，可分为11类</p><p>进度记录: 10/11, 97/150</p><ul><li>arith 12</li><li>dup 16</li><li>push 33</li><li>exchange 16</li><li>compare and bitwise 14</li><li>sha3 1</li><li>logging 5</li><li>control flow 15</li><li>system 10</li><li>env 17</li></ul><h1 id="Stop-and-Arithmetic-Operations"><a href="#Stop-and-Arithmetic-Operations" class="headerlink" title="Stop and Arithmetic Operations"></a>Stop and Arithmetic Operations</h1><p>共12个，已完成</p><p>python spec：<a href="https://github.com/ethereum/execution-specs/blob/master/src/ethereum/cancun/vm/instructions/arithmetic.py">https://github.com/ethereum/execution-specs/blob/master/src/ethereum/cancun/vm/instructions/arithmetic.py</a></p><h1 id="Environmental-Information"><a href="#Environmental-Information" class="headerlink" title="Environmental Information"></a>Environmental Information</h1><p>共16个</p><ul><li>address: return the receiver address in evm cmd</li><li>balance:<ul><li>evm —debug —gas 0xffffff —nomemory=false —json —code 731c7cd2d37ffd63856a5bd56a9af1643f2bcf545f3160005260406000f3 —prestate ./genesis.json run</li><li>weird, when sender == balance(address), outputs = 0</li></ul></li></ul><ul><li>origin</li><li>caller</li><li>callvalue</li><li>calldataload</li><li>calldatasize: fixed wrong setting in sealevm</li><li>calldatacopy</li><li>codesize</li><li>codecopy</li><li>gasprice: fixed pyevm gas price error</li><li><p>extcodesize:</p><ul><li>sealevm issue: for non-existent address should return 0</li></ul></li><li><p>extcodecopy</p><ul><li>jsevm 2500 gas difference</li><li>fixed pyevm wrong init</li></ul></li><li><p>returndatasize: left with call</p></li><li>returndatacopy: left with call</li></ul><h1 id="Block-Information"><a href="#Block-Information" class="headerlink" title="Block Information"></a>Block Information</h1><ul><li>number: only pyevm return value</li><li>timestamp: geth and js return nothing</li><li>gaslimit: besu does not recognize the setting in genesis.json</li><li>prevnrandao: only besu outputs</li><li>chainid: of besu </li><li>coinbase: can’t set in ethereumjs/evm</li><li>blockhash</li><li>blobhash</li><li>blobbaseefee</li><li>basefee</li></ul><h1 id="Logging-Operations"><a href="#Logging-Operations" class="headerlink" title="Logging Operations"></a>Logging Operations</h1><p>finished 5 opcodes</p><h1 id="Duplication-Operations"><a href="#Duplication-Operations" class="headerlink" title="Duplication Operations"></a>Duplication Operations</h1><p>finished 16 opcodes</p><h1 id="Exchange-Operations"><a href="#Exchange-Operations" class="headerlink" title="Exchange Operations"></a>Exchange Operations</h1><p>python definition in <a href="https://github.com/ethereum/execution-specs/blob/master/src/ethereum/cancun/vm/instructions/stack.py">https://github.com/ethereum/execution-specs/blob/master/src/ethereum/cancun/vm/instructions/stack.py</a></p><p>finished 16 opcodes</p><h1 id="SHA3"><a href="#SHA3" class="headerlink" title="SHA3"></a>SHA3</h1><p>finished 1 opcode</p><h1 id="Push-Operations"><a href="#Push-Operations" class="headerlink" title="Push Operations"></a>Push Operations</h1><p>finished 33 opcodes</p><h1 id="System-operations"><a href="#System-operations" class="headerlink" title="System operations"></a>System operations</h1><ul><li><p>create：seal的地址输出与以太坊标准偏离，见<a href="https://github.com/SealSC/SealEVM/blob/a3860afcd00913af730eb98274e70c5b9a797464/example/memStorage.go#L48，create2相同">https://github.com/SealSC/SealEVM/blob/a3860afcd00913af730eb98274e70c5b9a797464/example/memStorage.go#L48，create2相同</a></p><p><img src="/2024/07/17/EVM-opcodes/image-20240720094239162.png" alt="image-20240720094239162"></p></li><li><p>create2</p></li><li><p>return</p></li><li><p>call</p></li><li><p>callcode</p></li><li><p>delegatecall</p></li><li><p>staticcall</p></li><li><p>revert</p></li><li><p>invalid</p></li><li><p>selfdstruct</p><ul><li>balance!=0, besu charges 5000</li><li>balance=0, besu charges 30000</li></ul></li></ul><h1 id="Comparison-amp-Bitwise-Logic-Operations"><a href="#Comparison-amp-Bitwise-Logic-Operations" class="headerlink" title="Comparison &amp; Bitwise Logic Operations"></a>Comparison &amp; Bitwise Logic Operations</h1><p>14个，已完成</p><p>定义分别在</p><ul><li><a href="https://github.com/ethereum/execution-specs/blob/master/src/ethereum/cancun/vm/instructions/bitwise.py">https://github.com/ethereum/execution-specs/blob/master/src/ethereum/cancun/vm/instructions/bitwise.py</a> </li><li><a href="https://github.com/ethereum/execution-specs/blob/master/src/ethereum/cancun/vm/instructions/bitwise.py">https://github.com/ethereum/execution-specs/blob/master/src/ethereum/cancun/vm/instructions/bitwise.py</a></li></ul><h1 id="Stack-Memory-Storage-and-Flow-Operations"><a href="#Stack-Memory-Storage-and-Flow-Operations" class="headerlink" title="Stack Memory Storage and Flow Operations"></a>Stack Memory Storage and Flow Operations</h1><p>定义：<a href="https://github.com/ethereum/execution-specs/blob/master/src/ethereum/cancun/vm/instructions/memory.py">https://github.com/ethereum/execution-specs/blob/master/src/ethereum/cancun/vm/instructions/memory.py</a></p><p>15个，已完成</p><p>pop</p><p>mload</p><p>mstore</p><p>mstore8 </p><p>sload</p><p>sstore</p><p>tload</p><p>tstore</p><p>pc</p><p>msize : sealevm has wrong memory expansion with ethereum spec, also opened an issue in execution-spec reppo.</p><p>gas</p><p>mcopy</p><p>jump</p><p>jumpi</p><p>jumpdest</p><h1 id="TO-DO"><a href="#TO-DO" class="headerlink" title="TO DO"></a>TO DO</h1><ul><li>exec-spec issue: check all expand the memory opcodes.</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Ethereum virtual machine opcodes&lt;/p&gt;</summary>
    
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="EVM" scheme="https://alleysira.github.io/tags/EVM/"/>
    
  </entry>
  
  <entry>
    <title>EVM: From Solidity to byte code, memory and storage</title>
    <link href="https://alleysira.github.io/2024/07/02/EVM-From-Solidity-to-byte-code-memory-and-storage/"/>
    <id>https://alleysira.github.io/2024/07/02/EVM-From-Solidity-to-byte-code-memory-and-storage/</id>
    <published>2024-07-02T11:08:40.000Z</published>
    <updated>2024-07-05T09:12:54.422Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>学习 EVM 字节码和合约的对应关系</p><p>source：<a href="https://youtu.be/RxL_1AfV7N4?si=oTGjUI0lQWkEqn0t">https://youtu.be/RxL_1AfV7N4?si=oTGjUI0lQWkEqn0t</a></p><span id="more"></span><h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>使用<code>Solidity</code>编写的智能合约已经超过90%</p><p>以太坊交易的接口</p><p><img src="/2024/07/02/EVM-From-Solidity-to-byte-code-memory-and-storage/image-20240702191910946.png" alt="image-20240702191910946"></p><p>对于合约部署的交易，目的地址必须为空且<code>Data</code>字段为<code>init code</code></p><p>对于合约调用的交易，目的地址为合约，<code>Data</code>字段为functioncall和参数</p><p><img src="/2024/07/02/EVM-From-Solidity-to-byte-code-memory-and-storage/image-20240702192319122.png" alt="image-20240702192319122"></p><h1 id="Stack-Memory-Storage-Code-CallData-amp-Logs"><a href="#Stack-Memory-Storage-Code-CallData-amp-Logs" class="headerlink" title="Stack, Memory, Storage, Code, CallData, &amp; Logs"></a>Stack, Memory, Storage, Code, CallData, &amp; Logs</h1><p>EVM是基于栈的处理器，输入从栈中来，输出pop到栈中</p><p>calldata是read-only的memory</p><p>EVM的log是write-only</p><p><img src="/2024/07/02/EVM-From-Solidity-to-byte-code-memory-and-storage/image-20240702192857556.png" alt="image-20240702192857556"></p><h1 id="Yellow-paper"><a href="#Yellow-paper" class="headerlink" title="Yellow paper"></a>Yellow paper</h1><p>操作码在yellow paper中被定义</p><p>操作码的数值越大，语义更可能是以太坊定义的</p><p><img src="/2024/07/02/EVM-From-Solidity-to-byte-code-memory-and-storage/image-20240702195923776.png" alt="image-20240702195923776"></p><p>6080604052是在初始化内存指针</p><p><img src="/2024/07/02/EVM-From-Solidity-to-byte-code-memory-and-storage/image-20240702200704617.png" alt="image-20240702200704617"></p><p>函数调用</p><p>检查calldata是否小于4bytes，涉及到函数选择器function selector</p><p>32bytes右移0xe0比特</p><p>function selector查询网站 <a href="https://www.4byte.directory/signatures/">https://www.4byte.directory/signatures/</a></p><p>solidity是按照函数签名的值排序jump table的，如果自己选择的函数名能够生成数值更小的函数签名，可以节约gas。如果函数签名超过4个，进行二分查找</p><p><img src="/2024/07/02/EVM-From-Solidity-to-byte-code-memory-and-storage/image-20240702203926364.png" alt="image-20240702203926364"></p><p>每次进入函数会push返回地址</p><p>get val1和val2的返回地址是相同的，代码复用（compiler开启代码优化后）</p><p>EVM client通过gas机制防御内存扩张造成的问题</p><p><img src="/2024/07/02/EVM-From-Solidity-to-byte-code-memory-and-storage/image-20240703151924150.png" alt="image-20240703151924150"></p><p>storage overwrite</p><p>solidity内存覆盖攻击</p><p>不同合约的storage是隔离的</p><ul><li>CODECOPY</li><li>EXTCODECOPY</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习 EVM 字节码和合约的对应关系&lt;/p&gt;
&lt;p&gt;source：&lt;a href=&quot;https://youtu.be/RxL_1AfV7N4?si=oTGjUI0lQWkEqn0t&quot;&gt;https://youtu.be/RxL_1AfV7N4?si=oTGjUI0lQWkEqn0t&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/categories/Blockchain/"/>
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
    <category term="SmartContract" scheme="https://alleysira.github.io/tags/SmartContract/"/>
    
  </entry>
  
  <entry>
    <title>csiam2024</title>
    <link href="https://alleysira.github.io/2024/06/22/csiam2024/"/>
    <id>https://alleysira.github.io/2024/06/22/csiam2024/</id>
    <published>2024-06-22T00:29:35.000Z</published>
    <updated>2024-07-05T09:15:27.900Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><strong>2024 CSIAM 区块链技术与应用高峰论坛 </strong></p><p><strong>CSIAM-BTAF 2024: CSIAM Blockchain Technology and Application Forum (Changchun)</strong></p><p>6月21日-23日，长春</p><span id="more"></span><h1 id="6月22日上午"><a href="#6月22日上午" class="headerlink" title="6月22日上午"></a>6月22日上午</h1><p><img src="/2024/06/22/csiam2024/image-20240625183741594.png" alt="image-20240625183741594" style="zoom:80%;"></p><h2 id="马超群-湖南大学-分布式数字金融风险监管技术与方法"><a href="#马超群-湖南大学-分布式数字金融风险监管技术与方法" class="headerlink" title="马超群 湖南大学 分布式数字金融风险监管技术与方法"></a>马超群 湖南大学 分布式数字金融风险监管技术与方法</h2><p>停电了- -</p><p>偏向于经济学</p><h2 id="谭林-湖南-天河国运科技公司-可信数据空间及应用探索"><a href="#谭林-湖南-天河国运科技公司-可信数据空间及应用探索" class="headerlink" title="谭林 湖南 天河国运科技公司 可信数据空间及应用探索"></a>谭林 湖南 天河国运科技公司 可信数据空间及应用探索</h2><p>产业界的代表</p><p>区块链的发展：公有链——联盟链——数据要素2024年4月8日</p><p>可信数据空间解决数据安全流通问题</p><h2 id="李颉-上海交通大学-区块链大数据人工智能融合助力新质生产力发展"><a href="#李颉-上海交通大学-区块链大数据人工智能融合助力新质生产力发展" class="headerlink" title="李颉 上海交通大学 区块链大数据人工智能融合助力新质生产力发展"></a>李颉 上海交通大学 区块链大数据人工智能融合助力新质生产力发展</h2><p>AI  大模型 联邦学习和区块链结合</p><h2 id="圆桌论坛：区块链的发展与展望"><a href="#圆桌论坛：区块链的发展与展望" class="headerlink" title="圆桌论坛：区块链的发展与展望"></a>圆桌论坛：区块链的发展与展望</h2><p>星火链网 火链科技</p><p>香港虚拟资产</p><h1 id="6月22日下午"><a href="#6月22日下午" class="headerlink" title="6月22日下午"></a>6月22日下午</h1><h2 id="分论坛一"><a href="#分论坛一" class="headerlink" title="分论坛一"></a>分论坛一</h2><p><img src="/2024/06/22/csiam2024/image-20240625183824759.png" alt="image-20240625183824759" style="zoom:80%;"></p><h2 id="分论坛二"><a href="#分论坛二" class="headerlink" title="分论坛二"></a>分论坛二</h2><p><img src="/2024/06/22/csiam2024/640-1719016365148-3.png" alt="图片" style="zoom: 80%;"></p><h2 id="分论坛三"><a href="#分论坛三" class="headerlink" title="分论坛三"></a>分论坛三</h2><p><img src="https://mmbiz.qpic.cn/mmbiz_png/Th3OGDN6T8NfRN7GQMRXhHFuIDXH1wapJLXHeH9bJ8ictSBbic8lQZ8mnPEOIusMzsRsYFSXSIViaapg7VIQUFMRw/640?wx_fmt=png&from=appmsg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:80%;"></p><h1 id="6月23日上午"><a href="#6月23日上午" class="headerlink" title="6月23日上午"></a>6月23日上午</h1><p><img src="/2024/06/22/csiam2024/image-20240625184111558.png" alt="image-20240625184111558" style="zoom:80%;"></p><p>张引 合约漏洞检测 来自于重点研发课题</p><p><strong>EFEVD: Enhanced Feature Extraction for Smart Contract Vulnerability Detection</strong></p><p><img src="/2024/06/22/csiam2024/image-20240623091044484.png" alt="image-20240623091044484" style="zoom: 80%;"></p><p>联邦忘却学习 unlearning</p><p>博弈论的方法介绍对双花攻击的建模</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;2024 CSIAM 区块链技术与应用高峰论坛 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CSIAM-BTAF 2024: CSIAM Blockchain Technology and Application Forum (Changchun)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;6月21日-23日，长春&lt;/p&gt;</summary>
    
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>WADIFF</title>
    <link href="https://alleysira.github.io/2024/05/23/WADIFF/"/>
    <id>https://alleysira.github.io/2024/05/23/WADIFF/</id>
    <published>2024-05-23T03:23:34.000Z</published>
    <updated>2024-06-25T03:21:33.854Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Zhou S, Jiang M, Chen W, et al. WADIFF: A Differential Testing Framework for WebAssembly Runtimes[C]//2023 38th IEEE/ACM International Conference on Automated Software Engineering (ASE). IEEE, 2023: 939-950.</p><span id="more"></span><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Wasm运行时的准确率和可靠性很重要</p><p>现有工作的不足：</p><ul><li>测试用例非法，无法通过有效性测试</li><li>合法测试用例是随机生成的，无法探索复杂的runtime实现</li><li>无法系统的建模运行时的状态，语义相关的未触发crash的漏洞可能不会被报告</li></ul><p>挑战</p><ul><li>如何生成测试用例，尽可能多地覆盖spec的内容<ul><li>使用wasm-spec来生成有效的测试用例：设计了DSL transformer将自然语言转化为DSL，基于转化的DSL，设计了符号执行引擎来生成测试用例</li><li>为了达到非法的测试用例，对测试用例进行变异</li></ul></li><li>确定性的差分模糊测试框架：确定需要比对执行结果的哪些内容<ul><li>增加了prologue语句来设置前置状态</li><li>建模wasm运行时，手动插桩哪些属性需要被丢弃，如果被丢弃的属性有difference，怎么存在不一致的指令</li></ul></li></ul><p>生成了1,395,091个测试用例，124,157触发了异常，417个指令触发了异常；仅发现了21个问题，8个被确认或修复了</p><p>贡献</p><ul><li>spec的transformer，将原来的语言转化为DSL，基于dsl进行程序分析</li><li>测试用例生成器：基于dsl采用符号执行生成wasm程序，设计了变异器对wasm进行变异</li><li>wasm运行时的学习和建模</li><li>差分测试框架：测试用例生成+确定性测试引擎</li></ul><h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><p>wasm运行时包括三个步骤</p><ul><li>decoding：字节码被翻译为模块module</li><li>validation：wasm运行时检查module是否有效</li><li>execution：有效后初始化模块，创建模块的实例，调用开始函数</li></ul><p>Wasm操作码会有不同的控制流，需要生成可以覆盖到各个流的测试用例，方法是将SPEC转化为DSL</p><p><img src="/2024/05/23/WADIFF/image-20240523170838410.png" alt="image-20240523170838410"></p><h1 id="Methodlogy"><a href="#Methodlogy" class="headerlink" title="Methodlogy"></a>Methodlogy</h1><p><img src="/2024/05/23/WADIFF/image-20240523180245843.png" alt="image-20240523180245843"></p><h1 id="测试用例生成器"><a href="#测试用例生成器" class="headerlink" title="测试用例生成器"></a>测试用例生成器</h1><p><img src="/2024/05/23/WADIFF/image-20240523180921117.png" alt="image-20240523180921117"></p><h1 id="差分测试引擎"><a href="#差分测试引擎" class="headerlink" title="差分测试引擎"></a>差分测试引擎</h1><p>比较变量的值来确定是否存在不一致性</p><p>差分测试的形式化定义</p><h1 id="其他材料"><a href="#其他材料" class="headerlink" title="其他材料"></a>其他材料</h1><p>开源仓库：<a href="https://github.com/erxiaozhou/WaDiff">https://github.com/erxiaozhou/WaDiff</a></p><h1 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h1><ul><li>生成调用多个指令的测试用例</li><li>覆盖率不高</li><li>生成测试用例的模板较为单一</li></ul><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul><li><p>以太坊操作码对应的spec在哪里</p><ul><li><a href="https://github.com/ethereum/execution-specs">https://github.com/ethereum/execution-specs</a></li><li>分不同版本利用python的语义 <a href="https://github.com/ethereum/execution-specs/blob/master/src/ethereum/shanghai/vm/runtime.py">https://github.com/ethereum/execution-specs/blob/master/src/ethereum/shanghai/vm/runtime.py</a></li><li>操作码的指令：<a href="https://github.com/ethereum/execution-specs/tree/master/src/ethereum/shanghai/vm/instructions">https://github.com/ethereum/execution-specs/tree/master/src/ethereum/shanghai/vm/instructions</a></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Zhou S, Jiang M, Chen W, et al. WADIFF: A Differential Testing Framework for WebAssembly Runtimes[C]//2023 38th IEEE/ACM International Conference on Automated Software Engineering (ASE). IEEE, 2023: 939-950.&lt;/p&gt;</summary>
    
    
    
    <category term="WebAssembly" scheme="https://alleysira.github.io/categories/WebAssembly/"/>
    
    
    <category term="WebAssembly" scheme="https://alleysira.github.io/tags/WebAssembly/"/>
    
  </entry>
  
  <entry>
    <title>PyRTFuzz</title>
    <link href="https://alleysira.github.io/2024/05/13/PyRTFuzz/"/>
    <id>https://alleysira.github.io/2024/05/13/PyRTFuzz/</id>
    <published>2024-05-13T06:44:39.000Z</published>
    <updated>2024-06-26T05:30:47.232Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Li W, Yang H, Luo X, et al. PyRTFuzz: Detecting Bugs in Python Runtimes via Two-Level Collaborative Fuzzing[C]//Proceedings of the 2023 ACM SIGSAC Conference on Computer and Communications Security. 2023: 1645-1659.</p><span id="more"></span><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>Python的runtime包括语言解释器和runtime的库</p><p>PyRTFuzz在编译器层和应用层分别采用了基于生成的fuzzing和基于变异的fuzzing，利用静态分析提取运行时的API，以格式/结构感知应用程序输入生成为导向的自定义类型引导的变异策略</p><p>针对Cpython实现，应用到了3个版本的runtime中，发现了61个可利用的bug</p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>现有的机器学习系统基本采用python实现，安全性和可靠性依赖于Python runtime，包括interpreter和runtime library</p><ul><li>compiler：代码执行之前，负责将一种语言写的源码转换成另一种计算机代码（通常是机器码）</li><li>interpreter：分析并执行代码；把源代码翻译为更高效率的中间码执行；执行解释器内部的编译器预编译后保存的代码</li></ul><p>现有的使用最广泛的CPython过去5年有2000个bug，但是缺乏自动化分析工具</p><h2 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work"></a>Related work</h2><p>现有对compiler和runtime的测试工具确实存在</p><ul><li>fuzzing JVM<ul><li>基于生成的fuzzer：JSfunfuzz，TreeFuzz，Skyfire，学习现有样例的语法特征生成有效的测试用例</li><li>基于变异的fuzzer：Superion、Fuzzil，通过编辑AST或其他IR</li></ul></li></ul><p>Python runtime fuzz的挑战</p><ul><li>对Python运行时进行测试需要同时测试解释器核心和语言的运行时库，只考虑生成有效的测试用例不够，还需要测试用例的输入。全面模糊测试Python运行时将需要两个不同层次（生成程序与具体程序输入）的模糊测试密切协作（即广泛地执行解释器和运行时库之间的交互）。然而，目前对于如何设计这样一个两级协作模糊测试技术的先前知识很少</li><li>测试解释器需要多样性但是语义有效的程序</li><li>为fuzz生成高质量的输入：普遍的挑战，尤其python是动态类型语言，数据类型不可用</li></ul><p>为了解决以上挑战，提出了PYRTFuzz，2层协同式模糊测试解决挑战2</p><p>第一级模糊测试通过基于规范的Python代码生成方法，根据使用静态和动态分析提取的Python运行时中每个API的描述，生成具有不同控制流复杂性的有效且多样化的Python应用程序，以解决挑战2</p><p>第二层，基于变异的fuzzing对给定的runtime进行插桩，收集覆盖率进行反馈，生成具体的python程序的输入。生成输入的过程中利用API的描述进行类型引导，解决挑战3</p><p>基于已有的python fuzzer Atheris和libFuzzer，测试了CPython的3个不同版本：3.7.15/3.8.15/3.9.15</p><p>调整被测试app的大小测试了可扩展性</p><p>测试了5*24小时，发现了61个bugs，分布在3个python版本中</p><p>程序生成部分：4.77 KLoC of code in 40 minutes with a memory usage of 291.71 MB</p><h1 id="Background-and-Motivation"><a href="#Background-and-Motivation" class="headerlink" title="Background and Motivation"></a>Background and Motivation</h1><h2 id="Greybox-fuzzing"><a href="#Greybox-fuzzing" class="headerlink" title="Greybox fuzzing"></a>Greybox fuzzing</h2><p>基于覆盖率的灰盒测试是常采用的技术，针对测试样例的生成方法，可以分为两类：Mutation和generation</p><p>Generation是基于语法和定义的规则生成输入，需要保证语法和语义的有效</p><p>基于变异的容易实施，基于生成的方法发现深层bug更有效</p><h2 id="compiler-testing"><a href="#compiler-testing" class="headerlink" title="compiler testing"></a>compiler testing</h2><p>关键挑战是生成有效且多样的程序，现有方法包括基于语法的和基于程序变异的</p><h2 id="Python-Runtime-Fuzzing"><a href="#Python-Runtime-Fuzzing" class="headerlink" title="Python Runtime Fuzzing"></a>Python Runtime Fuzzing</h2><p>工作动机包括Python的流行和实证研究结果</p><p>CPython是最流行的Python运行时，作者收集了98.3k个历史issue，发现了23.4k个bug相关的，分析了每年上报多少，上报的趋势</p><p>为了理解漏洞是如何检测出的，手工分析了500个issue，超过98%都是开发者发现的，说明确实需要漏洞检测工具；漏洞大多80%分布在library中</p><p>现有代码生成工作的缺陷：</p><ul><li>忽略了多样性</li><li>虽然通过各种Python应用程序覆盖不同领域很重要，但这对于有效地测试Python运行时来说还不够</li><li>缺乏整体性测试：Python应用程序在Python运行时的环境中运行，该环境包括解释器核心和运行时库。分别测试这两个部分对于全面测试来说是不够的。对于测试Python运行时来说，应该同时关注解释器核心、运行时库以及两者之间的交互作用。</li></ul><p>例子，不同输入下报错类型不一样，”%2u” 表示将一个无符号整数（unsigned integer）按照至少两位的宽度进行格式化输出，并在需要时在前面填充空格</p><p><img src="/2024/05/13/PyRTFuzz/image-20240513172117218.png" alt="image-20240513172117218"></p><p>这个例子说明如果我们不为特定的运行时模块（比如locale）生成应用程序，那么该模块内部的Bug可能无法被触发（限制L1）。此外，即使生成了各种不同领域的应用程序，如果不考虑应用程序的各种输入，可能还不足以检测出所有的Bug（限制L2）。最后，不同的结果显示了解释器核心和运行时库之间的相互作用和协作，凸显了对它们进行整体测试的重要性（限制L3）。</p><h1 id="Technique-Design"><a href="#Technique-Design" class="headerlink" title="Technique Design"></a>Technique Design</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>level1: generation-based fuzzing</p><p>level2: mutation-based fuzzing</p><p><img src="/2024/05/13/PyRTFuzz/image-20240513172550927.png" alt="image-20240513172550927"></p><p>输入包括3个，单元测试、和2部分源码</p><ul><li><p>获得Runtime的库的ABI，先是没有类型的，通过执行测试用例得到类型</p></li><li><p>通过声明式规范语言SLang来生成python程序，为每一个API生成一个APP，将所有APP整理为一个序列</p></li><li>为了在每个API的模糊测试深度和在所有API上的模糊测试广度之间取得平衡，L1核心会为每个APP的第2级模糊测试安排一个预算时间。一旦预算用完，L1核心会根据上一次第2级模糊测试的覆盖范围决定是否为相同的API生成另一个（更复杂的）APP，如果是，则触发APP生成，并根据上一次第2级模糊测试迭代中的覆盖情况选择下一个APP进行第2级模糊测试</li><li>L2核心最初会维护一个每个应用程序的种子队列，其中种子是随机生成的。随后，通过基于收集到的覆盖反馈的自定义变异方案，对种子进行变异以获取新的输入值。自定义变异器可以生成适应每个特定应用程序输入格式的值，这得益于在第2阶段应用程序生成过程中插入的探针。这些探针旨在根据应用程序中调用的API的（带类型的）描述，将字节序列解码为单独的参数值。任何触发的Bug以及触发的种子将作为PyRTFuzz的输出产生</li></ul><h2 id="Runtime-API-Description-Extraction"><a href="#Runtime-API-Description-Extraction" class="headerlink" title="Runtime API Description Extraction"></a>Runtime API Description Extraction</h2><p>python的官方文档给出了abi，但是是非结构化的文本形式，手工提取折磨，需要自动化方式</p><p>采用Python的AST parser进行提取，鉴于静态类型推断的不准确性，暂时将类型设置为None，并将在下一步进行细化。因此，静态提取以无类型的API描述结束。</p><p><img src="/2024/05/13/PyRTFuzz/image-20240513191947804.png" alt="image-20240513191947804"></p><p>对于异常字段，会尽可能全面地收集API可能抛出的明确异常以及从导入的模块中隐式抛出的异常。这些信息在应用程序生成期间指导API调用的异常处理，这对于避免在第2级模糊测试期间将异常错误地标识为Bug非常重要</p><p>动态改进：运行测试用例，提取返回值和参数的类型</p><p><img src="/2024/05/13/PyRTFuzz/image-20240513192621523.png" alt="image-20240513192621523"></p><p>算法每次处理一个单元测试，<code>inspect</code> 是 Python 标准库中的一个模块，能够获得对象的信息</p><p>问题：</p><ul><li>动态执行不一定可以覆盖全部的abi</li><li>python的动态特性，每个参数返回类型可能在不同执行中不同<ul><li>argue：只要有一个就足够生成有效的输入</li></ul></li></ul><h2 id="Level-1-fuzzing"><a href="#Level-1-fuzzing" class="headerlink" title="Level-1 fuzzing"></a>Level-1 fuzzing</h2><p>目的：生成多样化的有效的python程序</p><ul><li>API 覆盖率</li><li>APP多样性：测试到API的场景，控制流要复杂</li><li>APP有效性：语义和语法上有效，数据流可达性要从程序入口到call site</li></ul><p>使用SLang简单的声明性规范语言，SLang通过一组生成原语作为最低级语言构造来定义规范的语法和语义。使用SLang，开发人员可以表达规范要求，并通过SLang生成Python应用程序。SLang提供了一种简洁的方式来描述应用程序的要求和行为，以及如何生成满足这些要求的代码。</p><p>一个SLang程序（即APP规范）𝑃是一个语句序列𝑆∗。一个语句𝑆只有一种类型：赋值语句。在每个赋值语句中，右值𝐶(𝑒)∗表示一个取表达式𝑒的原语𝐶；左值𝑐表示𝐶(𝑒)∗的结果。这里的表达式𝑒可以是两种类型之一：一个变量𝑐或者对运行时API 𝐴的调用。</p><p><img src="/2024/05/13/PyRTFuzz/image-20240513195029215.png" alt="image-20240513195029215"></p><h3 id="Primitive-Derivation"><a href="#Primitive-Derivation" class="headerlink" title="Primitive Derivation"></a>Primitive Derivation</h3><p>SLang的原语是根据Python语言参考文档并参考解释器实现而推导出来的，总结了python程序的关键控制流结果，可分为基本原语和扩展原语</p><p>基本原语只接受运行时API的调用作为输入。它用于构建Python程序的基本（控制流）结构，该程序可以是面向对象或面向过程的，并定义程序的入口点。因此一个SLang程序应该以一个且仅有一个基本原语开始。</p><p><img src="/2024/05/13/PyRTFuzz/image-20240513195926563.png" alt="image-20240513195926563"></p><p>算法2的伪代码介绍了基本原语的一般操作，生成的P包含三部分T,D,M  包装ABI调用的D，主函数</p><p>扩展原语：扩展原语将其他原语的结果作为输入。它用于增加APP的复杂性，同时使其多样化。这些原语的推导还受到我们在现实世界中观察到的Python软件中的编程模式的影响。</p><p><img src="/2024/05/13/PyRTFuzz/image-20240513201138530.png" alt="image-20240513201138530"></p><p>通过自上而下的方式将输入程序𝑃包装起来生成新的应用程序。根据表2所示，推导出了七个原语，它们基于相关的Python抽象语法树（AST）操作进行实现。每个原语可以操作任何Python运行时API，而不依赖于特定API的语法或语义，这允许生成覆盖所有API的APP，从而满足需求R1。</p><p><img src="/2024/05/13/PyRTFuzz/image-20240513201204652.png" alt="image-20240513201204652"></p><h1 id="Implementation-and-limitation"><a href="#Implementation-and-limitation" class="headerlink" title="Implementation and limitation"></a>Implementation and limitation</h1><p><a href="https://github.com/awen-li/PyRTFuzz">https://github.com/awen-li/PyRTFuzz</a></p><p><a href="https://figshare.com/s/d5b8d5a7111abe4eafb1">https://figshare.com/s/d5b8d5a7111abe4eafb1</a></p><p>Brief Introduction and setup demonstration: <a href="https://youtu.be/cOhi9eG-IK0?si=p3ef3BDaMGGIwd4r">https://youtu.be/cOhi9eG-IK0?si=p3ef3BDaMGGIwd4r</a></p><h1 id="Ideas"><a href="#Ideas" class="headerlink" title="Ideas"></a>Ideas</h1><ul><li>实证研究，EVM的调研，不同EVM的issue整理</li><li>能否利用github的测试用例</li><li>大模型做abi提取</li><li>solidity的<a href="https://github.com/NomicFoundation/slang">slang</a></li><li>SLang的撰写依赖专家知识</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Li W, Yang H, Luo X, et al. PyRTFuzz: Detecting Bugs in Python Runtimes via Two-Level Collaborative Fuzzing[C]//Proceedings of the 2023 ACM SIGSAC Conference on Computer and Communications Security. 2023: 1645-1659.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Ethereum_in_30mins_from_DEVCON6</title>
    <link href="https://alleysira.github.io/2024/04/25/Ethereum-in-30mins-from-DEVCON6/"/>
    <id>https://alleysira.github.io/2024/04/25/Ethereum-in-30mins-from-DEVCON6/</id>
    <published>2024-04-25T09:45:44.000Z</published>
    <updated>2024-07-05T09:14:20.991Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>From DEVCON 2022</p><span id="more"></span><p><a href="https://archive.devcon.org/archive/watch/6/opening-ceremonies-vitalik/?playlist=Staff%20Picks&amp;tab=YouTube">https://archive.devcon.org/archive/watch/6/opening-ceremonies-vitalik/?playlist=Staff%20Picks&amp;tab=YouTube</a></p><p>在切换到PoS之后，仅出现了26个fail</p><p><img src="/2024/04/25/Ethereum-in-30mins-from-DEVCON6/image-20240425174737652.png" alt="image-20240425174737652"></p><p>Python在美学上比用 {} 的语言更好看（暴论</p><p><img src="/2024/04/25/Ethereum-in-30mins-from-DEVCON6/image-20240425175205207.png" alt="image-20240425175205207" style="zoom: 80%;"></p><p><img src="/2024/04/25/Ethereum-in-30mins-from-DEVCON6/image-20240425175652301.png" alt="image-20240425175652301" style="zoom:67%;"></p><p><img src="/2024/04/25/Ethereum-in-30mins-from-DEVCON6/image-20240425175744850.png" alt="image-20240425175744850"></p><p>目前的priority_fee 用户一般设置为1，如果当交易非常多的时候需要设置为更高的数值，每个区块的交易数量约为30000000/21000=1400，平均是700</p><p><img src="/2024/04/25/Ethereum-in-30mins-from-DEVCON6/image-20240425180018333.png" alt="image-20240425180018333"></p><p><img src="/2024/04/25/Ethereum-in-30mins-from-DEVCON6/image-20240425192121142.png" alt="image-20240425192121142"></p><p><img src="/2024/04/25/Ethereum-in-30mins-from-DEVCON6/image-20240425192258967.png" alt="image-20240425192258967"></p><p><img src="/2024/04/25/Ethereum-in-30mins-from-DEVCON6/image-20240425192748189.png" alt="image-20240425192748189"></p><p>出现sister block，两个区块可能有冲突的交易/相同的交易，目前的机制是计算不同分叉的区块及后续区块的证言数量</p><p>1epoch = 32slots=32*12s=6.4mins</p><p>对于一般的交易，等待一个epoch就足够安全了，等待2个epoch能够达到FFG</p><p><img src="/2024/04/25/Ethereum-in-30mins-from-DEVCON6/image-20240425193446442.png" alt="image-20240425193446442"></p><p>Merkle tree</p><p><img src="/2024/04/25/Ethereum-in-30mins-from-DEVCON6/image-20240425193531803.png" alt="image-20240425193531803"></p><p>Merkle tree是简洁的证明系统</p><p><img src="/2024/04/25/Ethereum-in-30mins-from-DEVCON6/image-20240425193651889.png" alt="image-20240425193651889"></p><p>Ethereum的state大概是40GB</p><p><img src="/2024/04/25/Ethereum-in-30mins-from-DEVCON6/image-20240425193847412.png" alt="image-20240425193847412"></p><p><img src="/2024/04/25/Ethereum-in-30mins-from-DEVCON6/image-20240425193939325.png" alt="image-20240425193939325"></p><p><img src="/2024/04/25/Ethereum-in-30mins-from-DEVCON6/image-20240425194000206.png" alt="image-20240425194000206"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;From DEVCON 2022&lt;/p&gt;</summary>
    
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>GPTScan</title>
    <link href="https://alleysira.github.io/2024/04/02/GPTScan/"/>
    <id>https://alleysira.github.io/2024/04/02/GPTScan/</id>
    <published>2024-04-02T12:10:20.000Z</published>
    <updated>2024-04-30T07:39:04.755Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Sun Y, Wu D, Xue Y, et al. GPTScan: Detecting Logic Vulnerabilities in Smart Contracts by Combining GPT with Program Analysis[C]//2024 IEEE/ACM 46th International Conference on Software Engineering ICSE, 2024. </p><span id="more"></span><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>现有漏洞检测工具主要目标是检测出具有固定控制/数据流模式的漏洞，根据综述，80%的Web3漏洞是无法审计出的逻辑漏洞，采用GPT探索如何检测逻辑漏洞。</p><p>解决思路：静态分析+GPT（直接使用GPT进行漏洞识别误报率过高，受限于预训练知识）</p><p>漏洞划分：scenario property</p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>研究现状</p><ul><li>Do you still need a manual smart contract audit? 使用 GPT3.5（比GPT4便宜20倍） 来为项目范围的“是或否”问题提供高级漏洞描述，已经比典型的函数级漏洞检测更容易了。<ul><li>误报率 96%</li></ul></li><li>本文利用GPT作为代码理解工具，将漏洞类型划分为 code-level scenarios and properties<ul><li>场景描述了在哪些代码功能下可能发生逻辑漏洞，而属性则解释了脆弱代码的特征或操作。</li><li>基于代码层的语义匹配候选函数中的漏洞<ul><li>然而，由于基于GPT的匹配仍然是粗粒度的，GPTScan进一步指示GPT智能识别关键变量和语句，然后通过专门的静态确认模块进行验证。</li></ul></li><li>智能合约项目可能由多个Solidity文件组成，直接将所有文件输入给GPT可能是不可行或成本高昂的。为了解决这个问题，GPTScan采用了多维过滤过程，有效地缩小了用于GPT匹配的候选函数范围。<ul><li>优化后可以使用默认的4k context token size，而不需要更昂贵的16k</li></ul></li></ul></li></ul><p>实现</p><ul><li>大模型：GPT3.5，4K，temperature=0<ul><li>prompt：提出了一种新的mimic-in-the back ground方法，基于 zero-shot chain of- thought prompting</li></ul></li><li>静态分析：<a href="https://www.antlr.org/">ANTLR</a> 和 <a href="https://github.com/crytic/crytic-compile">crytic-compile</a></li><li>数据集：共400个合约项目，3000个sol文件，472k行代码<ul><li>市值最高的 top200</li><li>web3bugs</li><li>Defihacks </li><li>相关实验结果已经开源：<a href="https://sites.google.com/view/gptscan">https://sites.google.com/view/gptscan</a></li><li>rules开源：<a href="https://github.com/MetaTrustLabs/GPTScan">https://github.com/MetaTrustLabs/GPTScan</a></li></ul></li></ul><p>结果</p><ul><li>发现漏洞<ul><li>测试没有漏洞的合约 假阳率4.39%</li><li>测试较大的合约项目，平均精度为57.14%</li><li>Web3Bugs：recall 83.33% ，F1分数 67.8%</li><li>发现了9个审计公司未发现的漏洞</li></ul></li><li>快速 划算<ul><li>每1000行代码平均14.39s 0.01$</li></ul></li><li>可用性<ul><li>已被集成到安全工具 <a href="https://metatrust.io/product/metascan">MetaScan</a> 中</li></ul></li></ul><h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><ul><li>合约漏洞类型：参考综述Demystifying Exploitable Bugs in Smart Contracts<ul><li>难以利用，不直接和项目相关</li><li>使用简单、不和项目逻辑相关的oracle即可检测<ul><li>重入 溢出</li></ul></li><li>业务逻辑相关的漏洞：<ul><li>价格操纵 标识违规 错误状态更新 原子性违反 权限提升 错误accounting</li></ul></li></ul></li><li>GPT在漏洞检测中的应用<ul><li>能够理解源代码，实现zero-shot learning</li><li>Do you still need a manual smart contract audit 用GPT-4-32k，给GPT提供漏洞描述，利用漏洞描述来检测整个项目中的漏洞，但是召回率较差</li></ul></li></ul><h1 id="Motivating-Examples"><a href="#Motivating-Examples" class="headerlink" title="Motivating Examples"></a>Motivating Examples</h1><p>发现GPT对于“before”这个概念的理解存在困难，因此仅依靠GPT可能会将已修复版本的转账函数误报为存在漏洞。因此，静态分析是必要的。</p><p>根据上述例子，发现静态分析无法理解高级语义信息，而GPT可能会忽视一些低级信息，分别可能导致较低的召回率和较高的误报率。将这两种技术结合起来可以互补彼此，并提高检测性能。</p><h1 id="GPTScan"><a href="#GPTScan" class="headerlink" title="GPTScan"></a>GPTScan</h1><p><img src="/2024/04/02/GPTScan/image-20240407160158405.png" alt="image-20240407160158405"></p><ul><li><p>蓝色 GPT模块</p></li><li><p>绿色 静态分析</p></li></ul><p>输入合约/合约项目后，采用静态分析方法进行语法分析、函数调用图来判断可达性、候选函数</p><p>利用GPT将候选函数与相关漏洞类型的预抽象场景和属性进行匹配。对于匹配的函数，GPTScan通过GPT进一步识别关键变量和语句，然后将其传递给专门的静态分析模块进行漏洞确认。</p><p>挑战</p><ul><li>项目中可能有很多函数，直接将所有函数作为GPT输入不现实，挑战是高效缩减候选函数的范围</li><li>现有的基于GPT的漏洞检测工具输入的是高层次的漏洞描述，依赖GPT对漏洞预训练的知识和推理能力，能否将漏洞类型分解，直接从语义层面理解漏洞</li><li>GPT的输出可能是不可信赖的，如何进一步确认 匹配漏洞类型</li></ul><h2 id="Scenario-and-Property-Matching"><a href="#Scenario-and-Property-Matching" class="headerlink" title="Scenario and Property Matching"></a>Scenario and Property Matching</h2><p>现有工具输入的漏洞描述例子</p><p>An attack where an attacker observes pending transactions and creates a new transaction with a higher gas price, enabling it to be processed before the observed transaction. This is often done to gain an unfair advantage in decentralized exchanges or other time-sensitive operations.”</p><p>方法：手动将漏洞分解为场景和属性</p><ul><li>场景：逻辑漏洞可能发生时的函数功能</li><li>属性：漏洞代码的操作</li></ul><p><img src="/2024/04/02/GPTScan/image-20240407162231964.png" alt="image-20240407162231964"></p><p>未来可以利用GPT4，从历史报告中提取场景和属性，利用原有代码验证，不断生成新的语句，直到通过漏洞验证。但是不同漏洞类型的Prompt必须手工设计</p><p><img src="/2024/04/02/GPTScan/image-20240407163615150.png" alt="image-20240407163615150"></p><p>每个scenario and property可以被划分为2类</p><ul><li>对函数功能的描述</li><li>函数行为的描述，与漏洞的根本原因相关（如缺少安全检查）</li></ul><p>如果满足Scenario再次发送给GPT，判断是否满足属性</p><p>匹配候选函数后，首先，仅对通过场景匹配的函数进行属性匹配。这种场景和属性的分离能够在单个提示中查询所有场景，从而节省了GPT的成本。其次，在属性匹配过程中，通过查询场景和属性的组合而不仅仅是属性本身，通过GPT对场景进行了双重确认。</p><p>考虑到GPT模型有时会提供模棱两可的答案或难以解析的文本，场景和属性匹配仅设计为是或否的问题，旨在最大限度地减少非结构化的GPT响应的影响。此外，指示GPT学习多项选择场景匹配的输出JSON格式，利用GPT的指令学习能力。</p><p>如何降低输出的随机性：设置温度，mimic in the background</p><h2 id="多维度函数过滤"><a href="#多维度函数过滤" class="headerlink" title="多维度函数过滤"></a>多维度函数过滤</h2><p>函数可达性分析</p><ul><li>筛选项目文件范围：从项目范围的文件过滤开始，其中包括排除非Solidity文件，例如位于“node_modules”目录下的文件、测试文件（例如各种“test”目录中的文件）和第三方库文件（例如来自诸如“openzeppelin”、“uniswap”和“pancakeswap”等知名库的文件）。一旦这些文件被过滤掉，GPTScan就可以专注于项目的Solidity文件本身</li><li>筛选OpenZeppelin：除了引入lib之外，还有直接cp OpenZeppelin项目代码的部分<ul><li>方法：分析OpenZepplin的源代码提取出API生成白名单，将候选函数和白名单对比，如果符合则筛掉</li><li>未来会加入基于代码克隆的筛选方法</li></ul></li><li>特定漏洞类别的过滤：设计了基于YAML的过滤规则规范</li></ul><p><img src="/2024/04/02/GPTScan/image-20240407171422364.png" alt="image-20240407171422364" style="zoom:67%;"></p><p>这些过滤规则涵盖了基本函数名称（FNK）、详细函数内容（FCE、FCNE、FCCE和FCNCE）、函数参数（FPT）和函数的调用关系（FPNC、FNM、CFN）。不同的漏洞将利用它们特定的过滤规则。过滤规则的选择主要基于对漏洞类型领域知识的理解。“Risky First Deposit”漏洞仅使用FCCE规则类型，选择与“total”、“supply”和“liquidity”的任意组合相关的函数，以确保存款与代币的总供应量或流动性的计算相关。另一方面，“AMM的价格操纵”与代币价格的计算有关。在这个规则中，使用FNK规则选择与价格计算相关的函数，并使用FCE规则选择包含关键字“price”、“value”和“liquidity”的函数。</p><p>可达性分析：利用call graph分析候选函数的可达性，利用ANTLR对智能合约项目的源代码进行解析，并生成抽象语法树（AST）。对于函数可见性进行分类</p><h2 id="GPT识别和静态确认"><a href="#GPT识别和静态确认" class="headerlink" title="GPT识别和静态确认"></a>GPT识别和静态确认</h2><p>GPT对句法可能不敏感，静态分析工具聚焦于变量和陈述</p><p>利用GPT的帮助来提取与提示中描述的特定业务逻辑相关的变量和语句的地方。有了这些变量和语句才可以使用静态分析来确认漏洞是否存在。</p><p><img src="/2024/04/02/GPTScan/image-20240407173445072.png" alt="image-20240407173445072"></p><p>对于每个提取的变量或语句，GPTScan指示GPT提供一个简短的描述。这个描述有助于确定给定的变量是否与问题相关，并有助于避免错误的答案。如果GPT提供的变量或语句在函数的上下文中不存在，或者描述与问题无关，GPTScan将终止判断过程，并认为漏洞不存在。另一方面，如果提供的变量和语句经过验证，GPTScan将将它们输入静态分析工具，使用静态数据流追踪和静态符号执行等方法来确认漏洞的存在。具体而言，设计了以下四种主要类型的静态分析方法</p><ul><li>静态数据流分析</li><li>Value Comparison Check 值比较检查</li><li>Other Check</li><li>函数调用参数检查</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>GPT-3.5-turbo</p><p>ANTLR 可以不需要编译进行源代码分析</p><h1 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h1><p>Top200的数据集和BlockScope类似</p><ul><li>假阳率：在没有漏洞的合约集中进行测试，4.39%，web3bugs的假阳率高一些</li></ul><p><img src="/2024/04/02/GPTScan/image-20240407192440828.png" alt="image-20240407192440828"></p><ul><li>准确率 90% TP/TP+FP<ul><li>12个漏报漏洞是由于缺少别名分析导致的</li><li>和现有静态分析对比<ul><li>Slither发现了124个误报，缺少对函数调用的考虑</li><li>MScan 仅支持一个漏洞类型</li></ul></li><li>和现有GPT工具对比，仅有一篇不开源的</li></ul></li></ul><p>静态分析确认部分的重要性：消融实验</p><ul><li><img src="/2024/04/02/GPTScan/image-20240407200409883.png" alt="image-20240407200409883"></li><li>筛掉了假阳模块，221/647</li><li>也删除了3个假阴性，说明影响较小</li></ul><p>运行时间和经济开销</p><ul><li>tiktoken，每千行代码时间和美元</li><li><img src="/2024/04/02/GPTScan/image-20240407201012352.png" alt="image-20240407201012352"></li></ul><p>漏洞发现：9个新漏洞</p><h1 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h1><p>局限性</p><ul><li>修饰符 过滤是白名单机制，没有利用语义分析（代码克隆）</li><li>对控制流和数据流分析的方法对路径不敏感，可能引入符号执行</li></ul><p>使用其他大模型</p><ul><li>GPT4：提升不明显，开销增加20倍</li><li>调参：temperature = 0？越高越有创造力</li><li>Google Bard, Claude self-trained LLaMA</li></ul><h1 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work"></a>Related work</h1><p>静态分析</p><p>符号执行</p><p>动态分析</p><p>形式化验证</p><p>基于NLP的工作</p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>本文提出了GPTScan，第一个将GPT与静态分析相结合的工具，用于智能合约逻辑漏洞检测。GPTScan利用GPT根据代码级别的场景和属性匹配候选的易受攻击函数，并进一步指导GPT智能识别关键变量和语句，然后通过静态确认进行验证。实验部分在三个不同的数据集上进行了评估，涵盖了约400个合约项目和3K个Solidity文件，结果显示GPTScan对于代币合约实现了高精确度（超过90%），对于大型项目实现了可接受的精确度（57.14%），并且在检测真实逻辑漏洞的召回率超过70% 。GPTScan快速、经济高效，并且能够发现被人工审计人员忽略的新漏洞。</p><h1 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h1><p><img src="/2024/04/02/GPTScan/image-20240408234042748.png" alt="image-20240408234042748"></p><p><img src="/2024/04/02/GPTScan/image-20240408234116856.png" alt="image-20240408234116856"></p><p><img src="/2024/04/02/GPTScan/image-20240408234127034.png" alt="image-20240408234127034"></p><h1 id="学术报告"><a href="#学术报告" class="headerlink" title="学术报告"></a>学术报告</h1><p><img src="/2024/04/02/GPTScan/image-20240430142604762.png" alt="image-20240430142604762"></p><p>Code lama</p><p>知识生成</p><ul><li>没有额外知识</li><li>相关漏洞报告 code4rena比赛</li><li>整理过的漏洞描述</li></ul><p>审计报告一般有代码和描述</p><p>基于代码相似度进行匹配</p><p>Tool former</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Sun Y, Wu D, Xue Y, et al. GPTScan: Detecting Logic Vulnerabilities in Smart Contracts by Combining GPT with Program Analysis[C]//2024 IEEE/ACM 46th International Conference on Software Engineering ICSE, 2024. &lt;/p&gt;</summary>
    
    
    
    
    <category term="SmartContract" scheme="https://alleysira.github.io/tags/SmartContract/"/>
    
    <category term="LLM" scheme="https://alleysira.github.io/tags/LLM/"/>
    
  </entry>
  
  <entry>
    <title>2024-literature-overview</title>
    <link href="https://alleysira.github.io/2024/03/28/202403-literature-overview/"/>
    <id>https://alleysira.github.io/2024/03/28/202403-literature-overview/</id>
    <published>2024-03-28T12:43:25.000Z</published>
    <updated>2024-07-05T09:19:48.762Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>literature review</p><span id="more"></span><p>电子科技大学 hezheyuan 的github仓库：</p><p><a href="https://github.com/hzysvilla/Academic_Smart_Contract_Papers">https://github.com/hzysvilla/Academic_Smart_Contract_Papers</a></p><h1 id="ICSE-2024"><a href="#ICSE-2024" class="headerlink" title="ICSE 2024"></a>ICSE 2024</h1><p>Not available</p><ul><li><a href="https://conf.researchr.org/track/ icse-2024/icse-2024-research-track?#">Improving Smart Contract Security with Contrastive Learning-based Vulnerability Detection</a> ok</li><li><a href="https://conf.researchr.org/track/icse-2024/icse-2024-research-track?#">PrettySmart: Detecting Permission Re-delegation Vulnerability for Token Behaviors in Smart Contracts</a> ok</li><li><a href="https://conf.researchr.org/track/icse-2024/icse-2024-research-track?#">SCVHunter: Smart Contract Vulnerability Detection Based on Heterogeneous Graph Attention Network </a>ok</li><li><a href="https://conf.researchr.org/track/icse-2024/icse-2024-research-track?#">Towards Finding Accounting Errors in Smart Contracts</a> ok</li></ul><h1 id="FSE-2024"><a href="#FSE-2024" class="headerlink" title="FSE 2024"></a>FSE 2024</h1><ul><li>SmartAxe: Detecting Cross-Chain Vulnerabilities in Bridge Smart Contracts via Fine-Grained Static Analysis</li></ul><h1 id="Security-24"><a href="#Security-24" class="headerlink" title="Security 24"></a>Security 24</h1><ul><li>All Your Tokens are Belong to Us: Demystifying Address Verification Vulnerabilities in Solidity Smart Contracts</li></ul><h1 id="INFOCOM24"><a href="#INFOCOM24" class="headerlink" title="INFOCOM24"></a>INFOCOM24</h1><ul><li>ConFuzz: Towards Large Scale Fuzz Testing of Smart Contracts in Ethereum</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;literature review&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>BrokenMetre</title>
    <link href="https://alleysira.github.io/2024/03/07/BrokenMetre/"/>
    <id>https://alleysira.github.io/2024/03/07/BrokenMetre/</id>
    <published>2024-03-07T09:10:55.000Z</published>
    <updated>2024-03-10T13:55:32.196Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>The report from <a href="https://www.ndss-symposium.org/ndss-paper/broken-metre-attacking-resource-metering-in-evm/">NDSS2020</a></p><span id="more"></span><h1 id="Broken-Metre-Attacking-Resource-Metering-in-EVM"><a href="#Broken-Metre-Attacking-Resource-Metering-in-EVM" class="headerlink" title="Broken Metre: Attacking Resource Metering in EVM"></a>Broken Metre: Attacking Resource Metering in EVM</h1><p>研究以太坊中gas测量与dos攻击之间的关系</p><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>由于gas的错误计价，导致了dos攻击，现有的例子</p><p><img src="/2024/03/07/BrokenMetre/image-20240307172446547.png" alt="image-20240307172446547"></p><ul><li><p><a href="https://www.evm.codes/?fork=shanghai">EXTCODESIZE</a>：输入地址，返回地址字节码的字节大小；读这个操作高度占用IO，攻击发生时仅需20gas，视频中20年的计价为700（现在是100~2600）</p></li><li><p>SUICIDE（SELF）：类似，最开始的要价为0，可以任意部署合约并自毁实现DOS，现在的要价为5000起步</p></li></ul><h2 id="Methodology"><a href="#Methodology" class="headerlink" title="Methodology"></a>Methodology</h2><p>研究的方法是fork aleth，记录操作码执执行时的CPU 内存占用情况</p><p>重放交易，研究gas具体和哪些物理资源相关性强。得出的结论</p><p><img src="/2024/03/07/BrokenMetre/image-20240307173221929.png" alt="image-20240307173221929"></p><p>执行时间变化较大的指令依赖于状态，均值和标准差甚至都接近了</p><p><img src="/2024/03/07/BrokenMetre/image-20240307205654017.png" alt="image-20240307205654017"></p><p>标准差大的原因来自于缓存cache，实验结果，如果有页缓存的话，合约运行速度会快28倍，因此可以构造dos攻击，设计一个合约尽可能不命中缓存</p><p><img src="/2024/03/07/BrokenMetre/image-20240307174328557.png" alt="image-20240307174328557"></p><p>本文的设计了资源耗尽攻击，问题转变成了搜索问题</p><p><img src="/2024/03/07/BrokenMetre/image-20240307174735032.png" alt="image-20240307174735032"></p><p>这里同样存在测试用例生成的问题</p><p>需要解决栈平衡，没有栈溢出以及内存合法访问；局限性是没有考虑循环</p><p><img src="/2024/03/07/BrokenMetre/image-20240307174911654.png" alt="image-20240307174911654"></p><p>对于指令初始化的问题，参考了经验研究的结果，通过吞吐量来定义权重和概率</p><p><img src="/2024/03/07/BrokenMetre/image-20240307175156521.png" alt="image-20240307175156521"></p><p>实验结果生成了比平均运行时间慢200倍的合约</p><p><img src="/2024/03/07/BrokenMetre/image-20240307175358841.png" alt="image-20240307175358841"></p><p>有了结果后，如何评估现实影响</p><p><img src="/2024/03/07/BrokenMetre/image-20240307175535332.png" alt="image-20240307175535332"></p><p>因为遗传算法是基于aleth做的，还评估了在其他EVM客户端上的影响</p><p><img src="/2024/03/07/BrokenMetre/image-20240307175951999.png" alt="image-20240307175951999"></p><p>改进方法包括提高gas计价、减少IO操作频率短期方法；长期方法有实现无状态的客户端和分片</p><p><img src="/2024/03/07/BrokenMetre/image-20240307180443576.png" alt="image-20240307180443576"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;The report from &lt;a href=&quot;https://www.ndss-symposium.org/ndss-paper/broken-metre-attacking-resource-metering-in-evm/&quot;&gt;NDSS2020&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>EtherDiffer</title>
    <link href="https://alleysira.github.io/2024/03/01/EtherDiffer/"/>
    <id>https://alleysira.github.io/2024/03/01/EtherDiffer/</id>
    <published>2024-03-01T07:53:45.000Z</published>
    <updated>2024-11-19T06:45:43.483Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Kim S, Hwang S. EtherDiffer: Differential Testing on RPC Services of Ethereum Nodes[C]//Proceedings of the 31st ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering. 2023: 1333-1344.</p><span id="more"></span><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>区块链上的DApp一般由链下的前端和链上的后端组成，以太坊节点对前端实现了RPC并提供了一系列接口</p><p>然而RPC的spec存在不足</p><ul><li>缺少对非确定性event的处理</li><li>缺少对无效参数的规定</li></ul><p>本工作对4种节点实现的RPC服务进行差分测试，首先通过多并发交易和传播延迟生成非确定性交易，采用基于属性的生成方法和类型保持的变异生成语义有效和无效的测试用例。</p><p>不一致性包括：client对异常处理和返回值的处理实现不同</p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>挑战</p><ul><li>测试用例生成（基于属性的生成和类型保留的变异），定义DSL<ul><li>语义有效的测试用例</li><li>语义无效但是可执行的测试用例：变异生成</li></ul></li><li>执行交易前的初始状态一致：也作为了challenge，可以是手动构造操作码的原因<img src="/2024/03/01/EtherDiffer/image-20240722102708245.png" alt="image-20240722102708245"></li></ul><p>测试对象是4个客户端的RPC服务，直观想法是是根据已有的SPEC规范来生成测试用例，实际贡献非常solid</p><p>项目开源：<a href="https://github.com/JosephK95/EtherDiffer-public">https://github.com/JosephK95/EtherDiffer-public</a></p><p>合约数据集：<a href="https://solidity-by-example.org/hello-world/">https://solidity-by-example.org/hello-world/</a></p><p>依赖：<a href="https://figshare.com/articles/software/EtherDiffer_Differential_Testing_on_RPC_Services_of_Ethereum_Nodes_Code_/23913096/1">https://figshare.com/articles/software/EtherDiffer_Differential_Testing_on_RPC_Services_of_Ethereum_Nodes_Code_/23913096/1</a> </p><p><a href="https://dl.acm.org/do/10.6084/m9.figshare.23913096.v1/full/">https://dl.acm.org/do/10.6084/m9.figshare.23913096.v1/full/</a></p><p>实验数据：<a href="https://figshare.com/articles/dataset/EtherDiffer_Differential_Testing_on_RPC_Services_of_Ethereum_Nodes_Data_/21936555/1">https://figshare.com/articles/dataset/EtherDiffer_Differential_Testing_on_RPC_Services_of_Ethereum_Nodes_Data_/21936555/1</a></p><p>PPT和视频资料：</p><ul><li><a href="https://2023.esec-fse.org/details/fse-2023-research-papers/10/EtherDiffer-Differential-Testing-on-RPC-Services-of-Ethereum-Nodes">https://2023.esec-fse.org/details/fse-2023-research-papers/10/EtherDiffer-Differential-Testing-on-RPC-Services-of-Ethereum-Nodes</a></li><li><a href="https://slideslive.com/39014005">https://slideslive.com/39014005</a></li></ul><h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><p>以太坊主网节点个数：<a href="https://ethernodes.org/">https://ethernodes.org/</a></p><h1 id="Methodolody"><a href="#Methodolody" class="headerlink" title="Methodolody"></a>Methodolody</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>针对4个客户端geth Nethermind Erigon Besu，本地部署一个网络，每4个节点组成一个私链，共识用的是PoW</p><p>测试用例生成依赖web3.js，仅使用了函数签名</p><p>rpc playground</p><p>定义了DSL，用于捕捉函数参数的语法和语义要求，并将库规范转换为$spec_{DSL}$。EtherDiffer首先从specDSL中选择一个方法，然后Generator生成符合语义要求的模板代码，其中所有参数都满足其要求。此外，Mutator以随机方式将其中一个参数更改为语义无效的值，同时保持其类型。最后，Test Case Converter通过将模板代码与每个目标节点绑定来实例化一组四个测试用例。一旦执行完成，Error Checker报告只有一部分节点引发错误，而其他节点返回值，并且Value Checker报告返回值是否彼此不一致。</p><p>测试用例使用try-catch语句包装，以正确识别错误，同时保持EtherDiffer的执行</p><p><img src="/2024/03/01/EtherDiffer/image-20240722155522178.png" alt="image-20240722155522178"></p><h2 id="非确定性链的生成"><a href="#非确定性链的生成" class="headerlink" title="非确定性链的生成"></a>非确定性链的生成</h2><p>考虑到多交易的并发和交易的传播时延</p><p>使用了Solidity by Example的简单程序生成了109个交易</p><h2 id="DSL"><a href="#DSL" class="headerlink" title="DSL"></a>DSL</h2><p>目的：理解函数参数的类型</p><h2 id="测试用例生成"><a href="#测试用例生成" class="headerlink" title="测试用例生成"></a>测试用例生成</h2><p>基于web3.js</p><p>为了自动化处理库规范，定义了一个领域特定语言，用于捕捉函数参数的类型和语义要求。规范s包括 类型定义、子类型关系、属性定义和方法声明。</p><p>类型t可以是基本类型t_p，对象类型，数组类型或两个类型的并集。对象类型是一组键-类型对的集合，其中一些可以是可选的。</p><p><img src="/2024/03/01/EtherDiffer/image-20240312155349225.png" alt="image-20240312155349225"></p><h1 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h1><p><img src="/2024/03/01/EtherDiffer/image-20240722195330674.png" alt="image-20240722195330674"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Kim S, Hwang S. EtherDiffer: Differential Testing on RPC Services of Ethereum Nodes[C]//Proceedings of the 31st ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering. 2023: 1333-1344.&lt;/p&gt;</summary>
    
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>consensus_fuzz</title>
    <link href="https://alleysira.github.io/2024/02/26/consensus-fuzz/"/>
    <id>https://alleysira.github.io/2024/02/26/consensus-fuzz/</id>
    <published>2024-02-26T01:48:02.000Z</published>
    <updated>2024-03-29T03:33:22.004Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>配置区块链共识漏洞检测工具</p><span id="more"></span><h1 id="Fluffy"><a href="#Fluffy" class="headerlink" title="Fluffy"></a>Fluffy</h1><p>Yang Y, Kim T, Chun B G. Finding consensus bugs in ethereum via multi-transaction differential fuzzing[C]//15th USENIX Symposium on Operating Systems Design and Implementation (OSDI 21). 2021: 349-365.</p><p>项目地址：<a href="https://github.com/snuspl/fluffy">https://github.com/snuspl/fluffy</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone  https://github.com/snuspl/fluffy</span><br><span class="line">sudo docker build -t fuzzer . </span><br></pre></td></tr></table></figure><p>发现存在ethereum-forkid和aes包的依赖问题</p><p>修改Cargo.toml，增加</p><p><code>ethereum-forkid = &quot;0.12.0&quot;</code></p><p>以及</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[patch.crates-io]</span><br><span class="line">syn = &#123; git = &quot;https://github.com/johnyangk/syn&quot;, branch = &quot;fix&quot;, optional = true &#125;</span><br><span class="line">aes = &#123; git = &quot;https://github.com/RustCrypto/block-ciphers&quot;,rev=&quot;aes-v0.3.2&quot;&#125;</span><br><span class="line">aes-soft = &#123; git = &quot;https://github.com/RustCrypto/block-ciphers&quot;,rev = &quot;aes-soft-v0.3.0&quot;&#125;</span><br><span class="line">aesni = &#123; git = &quot;https://github.com/RustCrypto/block-ciphers&quot;,rev = &quot;aesni-v0.6.0&quot;&#125;</span><br><span class="line">block-cipher-trait = &#123; git = &quot;https://github.com/RustCrypto/traits&quot;, rev = &quot;block-cipher-trait-v0.6.0&quot; &#125;</span><br><span class="line">stream-cipher = &#123; git = &quot;https://github.com/RustCrypto/traits&quot;, rev = &quot;stream-cipher-v0.3.0&quot;&#125;</span><br></pre></td></tr></table></figure><p>问题诸多，相关问题已经在<a href="https://github.com/snuspl/fluffy/issues/2">issue</a>中提出</p><h1 id="LOKI"><a href="#LOKI" class="headerlink" title="LOKI"></a>LOKI</h1><p><a href="https://github.com/ConsensusFuzz/LOKI/tree/main">https://github.com/ConsensusFuzz/LOKI/tree/main</a></p><p>缺少对Geth的实现以及与本地冲突</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;配置区块链共识漏洞检测工具&lt;/p&gt;</summary>
    
    
    
    
    <category term="consensus" scheme="https://alleysira.github.io/tags/consensus/"/>
    
  </entry>
  
  <entry>
    <title>ITYFuzz</title>
    <link href="https://alleysira.github.io/2024/02/22/ITYFuzz/"/>
    <id>https://alleysira.github.io/2024/02/22/ITYFuzz/</id>
    <published>2024-02-22T02:48:06.000Z</published>
    <updated>2024-03-11T16:56:56.426Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Shou C, Tan S, Sen K. Ityfuzz: Snapshot-based fuzzer for smart contract[C]//Proceedings of the 32nd ACM SIGSOFT International Symposium on Software Testing and Analysis. 2023: 322-333.</p><span id="more"></span><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>作者个人主页：<a href="https://scf.so/">https://scf.so/</a></p><p>代码仓库：<a href="https://github.com/fuzzland/ityfuzz">https://github.com/fuzzland/ityfuzz</a></p><p>对应的slides：<a href="https://docs.google.com/presentation/d/1Z7fQMSs-fMCpoYDIVE3iQv-I18rGuk7m8tOR3IFg8mU/edit?usp=sharing">https://docs.google.com/presentation/d/1Z7fQMSs-fMCpoYDIVE3iQv-I18rGuk7m8tOR3IFg8mU/edit?usp=sharing</a></p><p>因为智能合约依赖于复杂的区块链状态，难以fuzz。对交易序列进行变异很复杂，并且通常会导致对输入和程序空间的次优探索空间。</p><p>创新点：</p><ul><li><p>ItyFuzz是基于快照的模糊测试器，对状态和单个交易进行快照。</p></li><li><p>引入了数据流路径点（waypoint）机制来辨认更有潜力的状态。</p></li><li>利用比较航点机制来删减状态空间。</li></ul><p>结论：通过维护状态快照，ITYFUZZ能够综合考虑具体的漏洞（重入），响应时间快，支持对链上合约及时验证</p><p>实验：对真实世界合约和被黑的Defi项目进行了实验，指令覆盖率和发现的漏洞均优于现有fuzzer。</p><p>项目开源地址：<a href="https://github.com/fuzzland/ityfuzz">https://github.com/fuzzland/ityfuzz</a></p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>智能合约审计现在是十亿美元规模的行业，审计的目的是确保合约没有漏洞，不会导致存储在合约内的资产损失。目前的模糊测试工具仅支持在本地环境中模糊测试，而不是直接在区块链上。链上模糊测试的挑战在于对给定状态的探索要足够快，因为链上状态在不断变化；攻击者可能在任何时候发起攻击。现有fuzzer效率不够高，不能即时获得链上状态并迅速完成审计。</p><p>链上审计的必要性可以通过以下场景来说明：</p><ul><li>特定代码只能在特定的链上状态下才能到达（确实），本地执行永远无法到达</li><li>目前的合约依赖外部的合约作为信息来源，链上审计可以即时获得信息（如预言机）</li></ul><p>链上审计的挑战在于必须要在攻击者执行攻击前暂停合约</p><ul><li>链上审计需要的时间需要是秒级，现有的工具对时间优化不足，覆盖合约的全部指令需要若干小时<ul><li>ITYFuzz能在几秒内达到较高的覆盖率</li></ul></li><li>fuzz合约的挑战在于：合约依赖状态，合约的依赖复杂<ul><li>为了解决状态的问题，一些之前的工作每次fuzz均从全新状态开始，以一系列交易作为输入；变异阶段部分交易序列被变异，因此现有工具在重新执行交易以返回到先前状态时存在较高的开销。对于需要通过多个交易建立的深层状态进行探索，重新执行的成本呈线性增长。此外，现有工具只针对交易具有反馈机制，而不针对状态，然而状态和交易具有不同的探索难度。</li><li>作者认为，对于具有状态的模糊测试，状态的有趣性与事务的有趣性同样重要，而当前的状态模糊测试工具中不存在选择有趣状态进行探索的反馈机制。（即不再从fresh state开始）</li></ul></li></ul><p>快照（Snapshot）本质上是某些交易触发的中间状态的复制，通过将所有有趣的快照存储在状态语料库（corpus）中，能够以O(1)的复杂度“时间穿越”到先前的状态，支持对交易和状态空间的高效探索</p><p>重构了一个现有的EVM实现来支持快速的快照</p><p>由于运行时内存资源有限，将所有快照存储到语料库中仍然不现实，而快照的数量随着总执行时间的增加而线性增加。存储的快照大小可能在几秒钟内增长到几个千兆字节。为了解决这个问题并优先探索最有趣的状态，作者设计了两种反馈机制（即路径点）来对有趣的状态进行分类，并设计了一种语料库修剪技术，在必要时减少有趣状态的数量。</p><p>同样可以适用到其他领域，如现代硬件设计</p><p>贡献</p><ul><li>提出一种基于快照的模糊测试算法，以减少有状态智能合约模糊测试的重新执行开销</li><li>提出了新的路径点机制，支持高效程序探索<ul><li>数据流路径点：基于未来加载的内存</li><li>对比路径点：概率性采样和固定采样结合</li></ul></li><li>开发了模糊测试工具，展示了其有效性</li><li>提出了一种新的智能合约审计方法，该方法基于从区块链上获取的状态进行测试，检测和复现了价值数百万美元的在线项目的漏洞。</li></ul><h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><h2 id="fuzzing"><a href="#fuzzing" class="headerlink" title="fuzzing"></a>fuzzing</h2><p>为了提高探索效率，模糊测试器一般会采用启发式方法或反馈机制来变异已有的输入生成新的输入</p><p>算法例子：初始时的语料库为空，如果某次执行覆盖了新的点则该执行</p><p>这里的伪代码多少有点问题：</p><ul><li><code>if</code>后面一行应该是 $I\gets I\  \cup \ i_m$</li><li>corpus可能会变为空</li></ul><p><img src="/2024/02/22/ITYFuzz/image-20240222163752301.png" alt="image-20240222163752301"></p><p>合约的fuzzer必须输入为一系列的交易</p><h2 id="waypoint"><a href="#waypoint" class="headerlink" title="waypoint"></a>waypoint</h2><p>FuzzFactory[OOPSLA19]引入了一般化的反馈机制waypoint。路径点是在执行目标程序后提供有趣反馈的中间输入。例如，在覆盖引导的模糊测试算法中，如果运行目标程序产生新的覆盖，就会记录新的输入（路径点）。然而，路径点不仅限于覆盖点，其他常见的路径点还包括执行时间、内存使用和两个比较值之间的距离等。为了实现定制的路径点，需要在程序执行过程中收集其他目标动态信息，并提供一个新的谓词函数 <code>is_interesting</code>替换图1中的 第9行</p><h1 id="Motivating-Example"><a href="#Motivating-Example" class="headerlink" title="Motivating Example"></a>Motivating Example</h1><p><img src="/2024/02/22/ITYFuzz/image-20240223110801874.png" alt="image-20240223110801874"></p><p>对于上面的合约，调用inc 0, inc 1, buggy() 即可出发漏洞</p><p>现实世界中的交易序列可能会相当复杂和长，当T增大时，现有的漏洞检测工具 如SMARTIAN不能即时检测出漏洞</p><p>直观来想，如果随机调用函数，抵达某个指定深度的时间是指数级的，重复执行来到达某个指定状态的（比如目标是10，到达8）的操作架重执行。SMARTIAN中，重新执行占据了总模糊测试时间的90%以上。</p><p>如果在执行一系列交易后到达的状态可以被记忆，那么重新执行的时间可以被消除。然而，记忆化需要保存的状态数量与交易序列的指数成正比。ItyFuzz的关键在于是只能记忆化一组“有趣的状态”，称为快照，而不是记忆化所有中间状态，并且仅使用这些有趣的状态来探索新状态而无需重新执行。一个状态的“有趣程度”是通过两个新颖的航点概念来定义的。</p><p><img src="/2024/02/22/ITYFuzz/image-20240223112037082.png" alt="image-20240223112037082"></p><h1 id="Methodology"><a href="#Methodology" class="headerlink" title="Methodology"></a>Methodology</h1><h2 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h2><p><img src="/2024/02/22/ITYFuzz/image-20240225101344843.png" alt="image-20240225101344843"></p><p>可以把EVM理解为$S\times T \to S$，状态在输入交易下发生变化</p><p>和现有工具一样，ITYFuzz的输入是<strong>种子输入语料库</strong>，每次从库中选一个种子（交易和状态）作为输入交给EVM执行，执行后使用 <strong>执行路径点</strong> 来判断当前执行是否增加了覆盖率，如果增加了把(s,t)就加入到语料库中。(会记录当前的执行状态$s$，这就是快照的含义)</p><h2 id="snapshot-based-fuzzing"><a href="#snapshot-based-fuzzing" class="headerlink" title="snapshot-based fuzzing"></a>snapshot-based fuzzing</h2><p>为了返回到某个中间状态，现有方法是重新执行交易。本文直接记录状态并保存</p><p>由于快照仅记录执行交易前的状态s和交易，丢失了执行交易后的状态$s’$，本文设计了另外一个语料库infant state corpus”，来记录执行后的状态，以判断当前状态是否能导致未来的有趣的执行。</p><p><img src="/2024/02/22/ITYFuzz/image-20240225111932947.png" alt="image-20240225111932947"></p><p>变异有两种可能，变异后的st永远是sound的（交易可以随便造，状态是从历史状态中得到的，意味着可能从一个交易序列到达记录的状态）</p><ul><li>变异交易：变异器来执行</li><li>变异状态，从$C_s$ 中选一个</li></ul><p>执行完交易后进行两个路径点判断</p><h2 id="Dataflow-Waypoint"><a href="#Dataflow-Waypoint" class="headerlink" title="Dataflow Waypoint"></a>Dataflow Waypoint</h2><p>目前有了对输入有趣程度进行度量的waypoint机制（FuzzFactory），没有对状态的路程点定义。设置航点的目标是判断从这些状态出发的的未来执行是否有趣，因此设计需要获得关于状态有趣程度的语义信息。</p><p>主要从两个方面来思考</p><ul><li><p>如果内存是未来的load指令的目标，可能是有趣的</p></li><li><p>如果状态变化包括了对某些特殊内存位置的写</p></li></ul><p>作者利用字节码插桩来进行动态数据流分析，通过观察运行时的load和store指令。由于传统的数据流分析是通过对源代码进行静态分析来实现的。然而，静态分析工具在智能合约模糊测试中效果不佳，因为智能合约可能会动态地调用外部合约。然而，仅从目标合约获取的静态数据流信息是不够的。</p><p>由于决定内存位置的“有趣程度”的load指令发生在未来，因此目前无法确定store指令的“有趣程度”。为了解决这个问题，本文提出了利用过去的load来估计未来可能的有趣的地址。</p><p>ItyFuzz跟踪过去加载过的内存位置以及被加载的值的抽象。如果当前执行中的值存储操作写入了这样一个内存位置，并且被写入的值的抽象与该位置之前存储的所有抽象值都不同，那么我们称这个存储操作是有趣的，并且在存储之后产生的状态也是有趣的。</p><p>插桩算法维护了两个map，分别记录是否执行过load和是否执行过store以及store的值</p><p><img src="/2024/02/22/ITYFuzz/image-20240225164440432.png" alt="image-20240225164440432"></p><p>Loc % MAP_SIZE是对Loc的粗略抽象，为了创建一个较小的抽象地址空间。较小的抽象地址空间有助于降低存储和查找开销。</p><p>桶抽象是类似于AFL中使用的分桶机制。分桶有助于减少插入映射的总值量，从而减少存储和评估成本，以换取插入数据的粒度损失。每个桶是实际值域的一个分区，在EVM的上下文中，实际值是一个256位整数。使用桶来避免存储所有状态。执行Store(Loc, Value)时，首先抽象出值该在的桶，再检查S(loc%size)(bucket(v))是否为true。</p><p>执行后，如果存储map中的一个桶从false变为true，并且L(Loc % MAP_SIZE)的相应位置也为true（算法2的第2行），则认为新状态是有趣的。每个桶的大小和范围可以作为超参数进行调整。每个槽中的桶数量越多，评估为有趣的状态就越多，$C_s$的大小也会增加。随着$C_s$的增大，选择下一个要探索的状态变得更加困难，并且会引起存储开销。</p><p><img src="/2024/02/22/ITYFuzz/image-20240225164449714.png" alt="image-20240225164449714"></p><h2 id="Comparison-Waypoint"><a href="#Comparison-Waypoint" class="headerlink" title="Comparison Waypoint"></a>Comparison Waypoint</h2><p>只采用dataflow航点存在的问题，由于过于抽象，如果桶2-4已经有了2,3的状态就不再被认为是有趣的了。如果只使用数据流航点，如果域的划分（即桶）对于目标智能合约来说不够精细，那么可能无法包含某些状态。</p><p>细粒度划分的问题在于初始状态语料库中的状态数量庞大，这会导致对于大型智能合约而言，随着时间的推移内存使用开销巨大。为了有效地解决这个开销问题，本文提出使用比较航点。比较航点只考虑所有<strong>中间状态</strong>，其中一些比较指令的操作数相比之前的执行更接近彼此，这对于达到更高的覆盖率是必需的，被认为是有趣的。</p><p><img src="/2024/02/22/ITYFuzz/image-20240225174337363.png" alt="image-20240225174337363"></p><p>ItyFuzz使用最大可能值初始化一个局部映射$C_{local}$，该映射仅针对当前执行。在执行过程中，对于每个比较指令，ItyFuzz根据程序计数器%MAP_SIZE（即比较指令的位置）更新键值对应的距离（第4行less than和第6行）。距离反映了两个值在比较中实现平衡的接近程度，由它们之间差值的绝对值确定。例如，如果ItyFuzz处理EQ(1, 3)操作，距离将为2。当执行中的任何比较指令更有可能为真时，执行被认为是有趣的。换句话说，在算法4中描述的方式，如果当前执行在local映射中显示的距离比记录在先前执行中最小距离的映射（）中的距离更小，则认为该执行是有趣的。</p><p>比较点能够用于判断是否该将状态从$C_s$中移除，算法4是具体的投票算法，票数反应了状态的有趣程度。</p><p><img src="/2024/02/22/ITYFuzz/image-20240225192248662.png" alt="image-20240225192248662"></p><h1 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h1><p>基于LibAFL，revm作为EVM的执行引擎；支持从支持Geth的链的某个状态开始fuzz</p><p>开源地址：<a href="https://github.com/fuzzland/ityfuzz">https://github.com/fuzzland/ityfuzz</a></p><h1 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h1><p>考虑</p><ul><li>覆盖率：在3个数据集上，对比1个工具</li><li>能否发现现实世界中的漏洞<ul><li>36/42个项目中已知的漏洞</li><li>45000个合约项目（BSC和以太坊，均有&gt;100个交易），1384项目发现了漏洞</li></ul></li><li>存储快照带来的内存开销，以及能否被waypoint解决</li><li>链上审计对发现合约漏洞的帮助<ul><li>研究了两个被黑的defi项目，给出的实例证明了，仅仅在开发环境中测试室不够的，还需要链上审计</li><li><img src="/2024/02/22/ITYFuzz/image-20240305205240351.png" alt="image-20240305205240351"></li></ul></li><li>效率是否支持链上审计</li></ul><p>数据集</p><ul><li>论文里的数据集 57个合约<ul><li>Sunbeom So, Myungho Lee, Jisu Park, Heejo Lee, and Hakjoo Oh. 2020. VERISMART: A Highly Precise Safety Verier for Ethereum Smart Contracts. In 2020 IEEE Symposium on Security and Privacy, SP 2020, San Francisco, CA, USA, May 18-21, 2020. IEEE, 1678–1694. <a href="https://doi.org/10.1109/SP40000.2020.00032">https://doi.org/10.1109/SP40000.2020.00032</a></li></ul></li><li>以太坊收集的572个合约</li></ul><p>对比工作</p><ul><li>SMARTIAN：比较了覆盖率</li></ul><p>时间优势来源于快照缩减了re-execution时间；comparison waypoints能够快速提高覆盖率</p><p><img src="/2024/02/22/ITYFuzz/image-20240305203726288.png" alt="image-20240305203726288"></p><p><img src="/2024/02/22/ITYFuzz/image-20240305203735599.png" alt="image-20240305203735599" style="zoom:67%;"></p><p>对比实验不够，做消融实验ablation study</p><p><img src="/2024/02/22/ITYFuzz/image-20240305204523492.png" alt="image-20240305204523492"></p><p>为了研究对内存开销的依赖</p><p><img src="/2024/02/22/ITYFuzz/image-20240305204653257.png" alt="image-20240305204653257"></p><h1 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work"></a>Related work</h1><h2 id="反馈驱动的模糊测试"><a href="#反馈驱动的模糊测试" class="headerlink" title="反馈驱动的模糊测试"></a>反馈驱动的模糊测试</h2><ul><li>基于覆盖率的模糊测试：AFL HonggFuzz FairFuzz</li><li>自定义的waypoint：<ul><li>Validity fuzzing利用输入的有效性作为反馈</li><li>采用程序执行的深度；</li><li>FuzzFatory形式化了waypoint机制</li></ul></li></ul><h2 id="带状态的模糊测试"><a href="#带状态的模糊测试" class="headerlink" title="带状态的模糊测试"></a>带状态的模糊测试</h2><ul><li>SMARTIAN 从0状态开始，发送一系列交易到达目的状态</li><li>Nyx采用了操作系统层面的快照策略 Nyx-Net</li><li>CorbFuzz对web应用程序进行fuzz，对状态进行了建模</li></ul><h2 id="智能合约安全工具"><a href="#智能合约安全工具" class="headerlink" title="智能合约安全工具"></a>智能合约安全工具</h2><ul><li><p>ContractFuzzer</p></li><li><p>Echidna Harvey 工业界的fuzzer</p></li><li>SMARTIAN hybrid，混合了静态分析和动态 数据流分析</li></ul><h1 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h1><ul><li>什么是链上审计？如果链上进行模糊测试，支持的每秒测试次数是多少</li><li>快照带来的额外存储代价评估，有</li><li>从语料库中选择种子的算法</li><li>每个桶的大小和范围如何设置和调节<ul><li>参考了AFL的设计，AFL的桶是1-2,2-4,4-8</li></ul></li><li>本文的覆盖率和其他工作的覆盖率对比</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Shou C, Tan S, Sen K. Ityfuzz: Snapshot-based fuzzer for smart contract[C]//Proceedings of the 32nd ACM SIGSOFT International Symposium on Software Testing and Analysis. 2023: 322-333.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>conference deadlines</title>
    <link href="https://alleysira.github.io/2024/01/21/ddl/"/>
    <id>https://alleysira.github.io/2024/01/21/ddl/</id>
    <published>2024-01-21T08:30:43.000Z</published>
    <updated>2024-02-29T11:25:53.438Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>ddl是第一生产力</p><span id="more"></span><h1 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h1><ul><li><p>NDSS24</p><ul><li>开会时间：26 February to 1 March 2024</li><li>summer: Wed, 19 Apr 2023</li><li><strong>fall: Wed, 28 Jun 2023</strong></li></ul></li><li><p>USENIX Security24 </p><ul><li>开会时间：AUGUST 14–16, 2024</li><li><strong>Summer Deadline: Tuesday, June 6, 2023</strong></li><li><strong>Fall Deadline: Tuesday, October 17, 2023</strong></li><li>Winter Deadline: Thursday, February 8, 2024</li></ul></li><li><p>CCS 2024 </p><ul><li>开会时间：October 14-18</li><li>Jan 28, 2024 </li><li>April 29th Deadline</li></ul></li><li><p>S&amp;P 2024 </p><ul><li>开会时间：MAY 20-23</li><li>April 13 2023</li><li><strong>August 3 2023</strong></li><li><strong>December 6, 2023</strong></li></ul></li><li><p>ESORICS 2024</p><ul><li>开会：September 16-20, 2024</li><li>January 8, 2024</li><li>Sat Apr 20th 2024 19:59:59 CST (2024-04-19 23:59:59 UTC-12)</li></ul></li></ul><h1 id="Software-engineering"><a href="#Software-engineering" class="headerlink" title="Software engineering"></a>Software engineering</h1><ul><li>ICSE 2025 <ul><li>开会：April 26-May 4 2025 </li><li>Mar 22, 2024</li><li><strong>Aug 2, 2024</strong></li></ul></li><li>ASE 2024<ul><li>开会：Sun 27 October - Fri 1 November 2024</li><li><strong>Fri 7 Jun 2024</strong></li></ul></li><li>ESEC/FSE 2024<ul><li>开会：Mon 15 - Fri 19 July 2024</li><li><strong>Thursday, September 28, 2023</strong></li></ul></li><li>ISSTA 2024<ul><li>开会： Mon 16 - Fri 20 September 2024</li><li><strong>Fri 15 Dec 2023</strong></li><li>Fri 12 Apr 2024</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;ddl是第一生产力&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>WRTester</title>
    <link href="https://alleysira.github.io/2024/01/13/WRTester/"/>
    <id>https://alleysira.github.io/2024/01/13/WRTester/</id>
    <published>2024-01-13T14:33:54.000Z</published>
    <updated>2024-08-29T11:59:08.163Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Cao S, He N, She X, et al. WRTester: Differential Testing of WebAssembly Runtimes via Semantic-aware Binary Generation[J]. arXiv preprint arXiv:2312.10456, 2023.</p><span id="more"></span><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>现有的测试框架受到测试用例质量的限制，即它们在生成语义丰富和语法正确的Wasm二进制文件方面面临挑战，因此无法触发复杂的错误。对真实世界Wasm二进制文件的反汇编和汇编来生成复杂的Wasm测试用例，从而触发Wasm运行时之间的隐藏不一致性。为了进一步确定意外行为的根本原因，我们设计了一种与运行时无关的根本原因定位方法，可以准确地定位错误。广泛的评估表明，WRTester在效率和效果方面优于现有技术。</p><p>在流行的Wasm运行时中发现了33个漏洞，其中25个已经得到确认。</p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>尽管最近的自动化测试方法通过Wasm二进制生成在识别Wasm运行时错误方面取得了有希望的结果，但它们受到无法生成语义丰富二进制文件的限制，因此无法触发复杂的错误。</p><p>例如，WADIFF只能测试单个指令级别的实现错误，因为它无法生成具有大量指令的测试用例，而真实世界的Wasm二进制文件实际上要复杂得多。具体而言，Wasm中存在超过430种指令和13种具有不同功能的部分类型，这表明Wasm是一种具有丰富语义的字节码格式。为了进行全面的测试，确保生成的Wasm二进制文件尽可能涵盖多样的语义是至关重要和必要的。</p><p>此外，不可能任意生成Wasm二进制文件，因为每个Wasm二进制文件在执行之前都应该经过语法正确性验证，包括堆栈平衡验证等，这确保了生成的Wasm二进制文件应该是符合语法的。</p><p>主要工作：从真实世界的Wasm二进制文件中提取基本元素，并将它们随机组装成具有有效语法和丰富语义的Wasm二进制文件的算法。</p><p>NeoDiff是随机在已有字节码后拼接、翻转比特、插入字节或进行特殊操作</p><p><img src="/2024/01/13/WRTester/image-20240113223841937.png" alt="image-20240113223841937"></p><h1 id="不一致性根本原因定位"><a href="#不一致性根本原因定位" class="headerlink" title="不一致性根本原因定位"></a>不一致性根本原因定位</h1><p>不能简单将不一致性认为是bug（不同runtime对异常处理、支持SIMD、类型的实现有区别）</p><p>定义wasm二进制在生命周期内的不一致性行为</p><p><img src="/2024/01/13/WRTester/image-20240829185003634.png" alt="image-20240829185003634"></p><ul><li>编译失败</li><li>运行时失败：抛出异常</li><li>非预期输出：majority</li></ul><p>提出了一种运行时无关的二进制插桩方法进行根本原因定位</p><h2 id="函数级别定位"><a href="#函数级别定位" class="headerlink" title="函数级别定位"></a>函数级别定位</h2><p>针对编译失败和运行时失败</p><p>静态二进制插桩 执行call前后进行插桩，记录调用参数和返回值</p><h2 id="指令级别定位"><a href="#指令级别定位" class="headerlink" title="指令级别定位"></a>指令级别定位</h2><p>如果错误类型是output不同，进行指令级插桩</p><p>打印opcode和value</p><p>错误定位依然是定位到被执行文件的级别，我们期望定位到寻找到被测程序源代码</p><p>指令级定位</p><p>我们参考eip 进行了运行时插桩，不需要插桩</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Cao S, He N, She X, et al. WRTester: Differential Testing of WebAssembly Runtimes via Semantic-aware Binary Generation[J]. arXiv preprint arXiv:2312.10456, 2023.&lt;/p&gt;</summary>
    
    
    
    
    <category term="Wasm" scheme="https://alleysira.github.io/tags/Wasm/"/>
    
    <category term="Differential Testing" scheme="https://alleysira.github.io/tags/Differential-Testing/"/>
    
  </entry>
  
  <entry>
    <title>minGasPoc</title>
    <link href="https://alleysira.github.io/2024/01/13/minGasPoc/"/>
    <id>https://alleysira.github.io/2024/01/13/minGasPoc/</id>
    <published>2024-01-13T13:32:42.000Z</published>
    <updated>2024-01-13T15:12:38.043Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>尝试构造out of gas的攻击</p><span id="more"></span><h1 id="攻击概述"><a href="#攻击概述" class="headerlink" title="攻击概述"></a>攻击概述</h1><p>目的：使得jsevm run out of gas</p><p>方法：设置geth pyevm jsevm当前交易的gaslimt为0xccc，jsevm需要0x168a</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># geth 修改调用evm的gas不起作用，只能修改genesis.json中的gaslimit</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;gasLimit&quot;</span>: <span class="string">&quot;0xccc&quot;</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment"># pyevm runBytecode.py</span></span><br><span class="line">    call_txn = new_transaction(</span><br><span class="line">        chain.get_vm(),</span><br><span class="line">        SENDER,</span><br><span class="line">        simple_contract_address,</span><br><span class="line">        private_key=SENDER_PRIVATE_KEY,</span><br><span class="line">        gas=0xffff,</span><br><span class="line">        <span class="comment"># data=function_selector,</span></span><br><span class="line">        data=decode_hex(args.signature),</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line"><span class="comment"># runBytecode.js</span></span><br><span class="line">const results = await evm.runCall(&#123;</span><br><span class="line">gasLimit: BigInt(<span class="string">&#x27;0x&#x27;</span>+<span class="string">&#x27;ccc&#x27;</span>),</span><br><span class="line">data: hexToBytes(sig),</span><br><span class="line">to: contractAddress,</span><br><span class="line"><span class="built_in">caller</span>: new Address(hexToBytes(<span class="string">&quot;0x1c7cd2d37ffd63856a5bd56a9af1643f2bcf545f&quot;</span>))</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>给定输入<code>data=0xfe575a87000000000000000000000000bffd98ec9ba3dc965b8a97d876670bb367fa84c2</code>，执行函数<code>isBlacklisted()</code>，成功</p><p><img src="/2024/01/13/minGasPoc/image-20240113213936348.png" alt="image-20240113213936348"></p><p>但是目前的问题是geth和pyevm均是revert，交易没有真正执行</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># geth</span><br><span class="line">&#123;<span class="attr">&quot;pc&quot;</span>:<span class="number">23471</span>,<span class="attr">&quot;op&quot;</span>:<span class="number">253</span>,<span class="attr">&quot;gas&quot;</span>:<span class="string">&quot;0x2fe312&quot;</span>,<span class="attr">&quot;gasCost&quot;</span>:<span class="string">&quot;0x0&quot;</span>,<span class="attr">&quot;memSize&quot;</span>:<span class="number">192</span>,<span class="attr">&quot;stack&quot;</span>:[<span class="string">&quot;0xfe575a87&quot;</span>,<span class="string">&quot;0xcaf&quot;</span>,<span class="string">&quot;0xbffd98ec9ba3dc965b8a97d876670bb367fa84c2&quot;</span>,<span class="string">&quot;0x0&quot;</span>,<span class="string">&quot;0x3f94&quot;</span>,<span class="string">&quot;0x80&quot;</span>,<span class="string">&quot;0x80&quot;</span>,<span class="string">&quot;0x0&quot;</span>,<span class="string">&quot;0x7018&quot;</span>],<span class="attr">&quot;depth&quot;</span>:<span class="number">1</span>,<span class="attr">&quot;refund&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;opName&quot;</span>:<span class="string">&quot;REVERT&quot;</span>,<span class="attr">&quot;error&quot;</span>:<span class="string">&quot;execution reverted&quot;</span>&#125;</span><br><span class="line">&#123;<span class="attr">&quot;output&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="attr">&quot;gasUsed&quot;</span>:<span class="string">&quot;0xcc6&quot;</span>,<span class="attr">&quot;error&quot;</span>:<span class="string">&quot;execution reverted&quot;</span>&#125;</span><br><span class="line"># python</span><br><span class="line">&#123;<span class="attr">&quot;pc&quot;</span>: <span class="number">23471</span>, <span class="attr">&quot;op&quot;</span>: <span class="number">253</span>, <span class="attr">&quot;gas&quot;</span>: <span class="string">&quot;0x9f81&quot;</span>, <span class="attr">&quot;gasCost&quot;</span>: <span class="string">&quot;0x0&quot;</span>, <span class="attr">&quot;stack&quot;</span>: [<span class="string">&quot;0xfe575a87&quot;</span>, <span class="string">&quot;0xaf0c&quot;</span>, <span class="string">&quot;0xc284fa67b30b6776d8978a5b96dca39bec98fdbf&quot;</span>, <span class="string">&quot;0x0&quot;</span>, <span class="string">&quot;0x943f&quot;</span>, <span class="string">&quot;0x80&quot;</span>, <span class="string">&quot;0x8000000000000000000000000000000000000000000000000000000000000000&quot;</span>, <span class="string">&quot;0x0&quot;</span>, <span class="string">&quot;0x1870&quot;</span>, <span class="string">&quot;0x0&quot;</span>, <span class="string">&quot;0x0&quot;</span>], <span class="attr">&quot;depth&quot;</span>: <span class="number">0</span>, <span class="attr">&quot;opName&quot;</span>: <span class="string">&quot;REVERT&quot;</span>, <span class="attr">&quot;error&quot;</span>: <span class="string">&quot;None&quot;</span> &#125;</span><br><span class="line">&#123;<span class="attr">&quot;output&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="attr">&quot;gasUsed&quot;</span>: <span class="string">&quot;0xcc6&quot;</span>&#125;</span><br><span class="line"># jsevm</span><br><span class="line">&#123;<span class="attr">&quot;pc&quot;</span>:<span class="number">16225</span>,<span class="attr">&quot;gas&quot;</span>:<span class="string">&quot;0x107&quot;</span>,<span class="attr">&quot;gasCost&quot;</span>:<span class="string">&quot;0x0&quot;</span>,<span class="attr">&quot;memory&quot;</span>:<span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012800000000000000000000000000000000254879013500000000000019125315223615516322015091138151216118103111791032501321940000000000000000000000000000&quot;</span>,<span class="attr">&quot;memsize&quot;</span>:<span class="string">&quot;6&quot;</span>,<span class="attr">&quot;stack&quot;</span>:[<span class="string">&quot;0xfe575a87&quot;</span>,<span class="string">&quot;0xcaf&quot;</span>,<span class="string">&quot;0xbffd98ec9ba3dc965b8a97d876670bb367fa84c2&quot;</span>,<span class="string">&quot;0x0&quot;</span>,<span class="string">&quot;0x0&quot;</span>,<span class="string">&quot;0xfe575a87&quot;</span>,<span class="string">&quot;0xa4&quot;</span>,<span class="string">&quot;0x20&quot;</span>,<span class="string">&quot;0x80&quot;</span>,<span class="string">&quot;0x24&quot;</span>,<span class="string">&quot;0x80&quot;</span>,<span class="string">&quot;0x0&quot;</span>,<span class="string">&quot;0x107&quot;</span>],<span class="attr">&quot;depth&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;opName&quot;</span>:<span class="string">&quot;STATICCALL&quot;</span>&#125;</span><br><span class="line">&#123;<span class="attr">&quot;output&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="attr">&quot;gasUsed&quot;</span>:<span class="string">&quot;0xccc&quot;</span>,<span class="attr">&quot;error&quot;</span>:&#123;<span class="attr">&quot;error&quot;</span>:<span class="string">&quot;out of gas&quot;</span>,<span class="attr">&quot;errorType&quot;</span>:<span class="string">&quot;EvmError&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>问题似乎在于ethereumjs的staticcall的gas被计算了，而gas和pyevm执行staticcall的gas消耗被忽略了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// initializer is not initialized</span><br><span class="line">function isBlacklisted(address account) external view returns (bool) &#123;</span><br><span class="line"></span><br><span class="line">    return initializer.isBlacklisted(account);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在remix上不支持过长的合约，只能开启optimizer（200），然后调用isBlacklisted函数，注意到remix VM的gas消耗为5366</p><p><img src="/2024/01/13/minGasPoc/image-20240113220635216.png" alt="image-20240113220635216"></p><p>remix报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;error&quot;</span>: <span class="string">&quot;Failed to decode output: Error: hex data is odd-length (argument=&quot;</span>value<span class="string">&quot;, value=&quot;</span>0x0<span class="string">&quot;, code=INVALID_ARGUMENT, version=bytes/5.7.0)&quot;</span></span><br></pre></td></tr></table></figure><p>尝试了不同的地址依然存在问题</p><p>在remix中先执行setInitializer，依然执行错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function setInitializer(address init) public onlyOwner &#123;</span><br><span class="line"></span><br><span class="line">    require(!tradingEnabled);</span><br><span class="line"></span><br><span class="line">    require(init != address(this), &quot;Can&#x27;t be self.&quot;);</span><br><span class="line"></span><br><span class="line">    initializer = Initializer(init);</span><br><span class="line"></span><br><span class="line">    try initializer.getConfig() returns (address router, address constructorLP) &#123;</span><br><span class="line"></span><br><span class="line">        dexRouter = IRouter02(router); lpPair = constructorLP; lpPairs[lpPair] = true; </span><br><span class="line"></span><br><span class="line">        _approve(_owner, address(dexRouter), type(uint256).max);</span><br><span class="line"></span><br><span class="line">        _approve(address(this), address(dexRouter), type(uint256).max);</span><br><span class="line"></span><br><span class="line">    &#125; catch &#123; revert(); &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/01/13/minGasPoc/image-20240113222653503.png" alt="image-20240113222653503"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;尝试构造out of gas的攻击&lt;/p&gt;</summary>
    
    
    
    
    <category term="EVM" scheme="https://alleysira.github.io/tags/EVM/"/>
    
  </entry>
  
  <entry>
    <title>chainmaker</title>
    <link href="https://alleysira.github.io/2024/01/11/chainmaker/"/>
    <id>https://alleysira.github.io/2024/01/11/chainmaker/</id>
    <published>2024-01-11T06:03:35.000Z</published>
    <updated>2024-06-05T08:49:08.911Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>配置长安链</p><span id="more"></span><h1 id="长安链部署和配置"><a href="#长安链部署和配置" class="headerlink" title="长安链部署和配置"></a>长安链部署和配置</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装kubectl"><a href="#安装kubectl" class="headerlink" title="安装kubectl"></a>安装kubectl</h3><ul><li><a href="https://kubernetes.io/zh-cn/docs/reference/kubectl/">https://kubernetes.io/zh-cn/docs/reference/kubectl/</a></li><li>在根目录 <code>mkdir .kube</code>，将config文件cp到该目录下</li></ul><h3 id="本地安装长安链2-3-1"><a href="#本地安装长安链2-3-1" class="headerlink" title="本地安装长安链2.3.1"></a>本地安装长安链2.3.1</h3><ul><li><p>官方文档：<a href="https://docs.chainmaker.org.cn/v2.3.1/html/">https://docs.chainmaker.org.cn/v2.3.1/html/</a></p></li><li><p>安装go</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">wget https://golang.google.cn/dl/go1.18.10.linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">sudo rm -rf /usr/<span class="built_in">local</span>/go </span><br><span class="line">sudo tar -C /usr/<span class="built_in">local</span> -xzf go1.16.13.linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">vi /etc/profile</span><br><span class="line"><span class="comment"># 加入配置</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/go/bin</span><br><span class="line"><span class="comment"># 配置生效</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 换源</span></span><br><span class="line">go env GO11MODULE=on</span><br><span class="line">go env -w GOPROXY=https://goproxy.cn</span><br></pre></td></tr></table></figure></li><li><p>安装7.3版本以上的gcc</p></li><li><p>安装7zip </p><ul><li>```bash<br>sudo apt-get install p7zip-full p7zip-rar<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 安装docker，参考https://docs.docker.com/engine/install/ubuntu/#install-using-the-repository</span><br><span class="line">- 下载gitlab的pre仓库</span><br><span class="line">  - https://gitlab.distribute-compute.cn/chenzhu/pre</span><br><span class="line">- 安装完毕后测试智能合约是否能部署</span><br><span class="line"></span><br><span class="line">## 部署到云</span><br><span class="line"></span><br><span class="line">- 修改改k8sconfg/4.yml和Makefile里面的版本/命名空间</span><br><span class="line">- build docker </span><br><span class="line">  - `make docker-solo`</span><br><span class="line"></span><br><span class="line">- 提交docker，这部分需要</span><br><span class="line">  - `docker login -u xxx -p xxx xxx.myhuaweicloud.com`</span><br><span class="line"></span><br><span class="line">  - `make push`</span><br><span class="line"></span><br><span class="line">- 进入docker执行命令</span><br><span class="line">  - `kubectl exec docker-name -it /bin/bash -n mj`</span><br><span class="line"></span><br><span class="line">- 停止运行</span><br><span class="line">  - `make configFdown`</span><br><span class="line">- 在dockerfile中设置需要打包为docker的文件</span><br><span class="line"></span><br><span class="line"># SealEVM</span><br><span class="line"></span><br><span class="line">长安链EVM有两个开源仓库，不尽相同</span><br><span class="line"></span><br><span class="line">- github：https://github.com/SealSC/SealEVM</span><br><span class="line">- gitlab：https://git.chainmaker.org.cn/chainmaker/vm-evm</span><br><span class="line"></span><br><span class="line">gitlab的报错且没有文档</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line"># chainmaker.org/chainmaker/vm-evm/v2/evm-go/storage</span><br><span class="line">evm-go/storage/contractStorage.go:92:36: too many arguments in call to c.Ctx.CallContract</span><br><span class="line">        have (*common.Contract, *common.Contract, string, nil, map[string][]byte, number, common.TxType)</span><br><span class="line">        want (*common.Contract, string, []byte, map[string][]byte, uint64, common.TxType)</span><br><span class="line">evm-go/storage/contractStorage.go:206:13: undefined: &quot;chainmaker.org/chainmaker/utils/v2&quot;.NameToAddrInt</span><br><span class="line">evm-go/storage/contractStorage.go:351:36: too many arguments in call to c.Ctx.CallContract</span><br><span class="line">        have (*common.Contract, *common.Contract, string, []byte, map[string][]byte, uint64, common.TxType)</span><br><span class="line">        want (*common.Contract, string, []byte, map[string][]byte, uint64, common.TxType)</span><br><span class="line">evm-go/storage/contractStorage.go:359:36: too many arguments in call to c.Ctx.CallContract</span><br><span class="line">        have (*common.Contract, *common.Contract, string, []byte, map[string][]byte, uint64, common.TxType)</span><br><span class="line">        want (*common.Contract, string, []byte, map[string][]byte, uint64, common.TxType)</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>github的SealEVM能运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">go mod download </span><br><span class="line"><span class="built_in">cd</span> example</span><br><span class="line">./example</span><br><span class="line">go get: added chainmaker.org/chainmaker/common/v2</span><br></pre></td></tr></table></figure><ul><li><p>不支持PUSH0，因此虚拟机不支持shanghai分叉，支持使用solc 0.8.23 设定evm version为paris</p><ul><li>目前的sealevm已经支持</li></ul></li><li><p>gas计价混乱，只出现了0x3和SSTORE的两个值</p><ul><li>STOP计价为0x3</li><li><img src="/2024/01/11/chainmaker/image-20240204144319468.png" alt="image-20240204144319468"></li></ul></li><li>存在stack underflow at <a href="https://github.com/SealSC/SealEVM/issues/21">issue</a></li></ul><h2 id="vm-evm"><a href="#vm-evm" class="headerlink" title="vm-evm"></a>vm-evm</h2><p>单测可以通过</p><p><img src="/2024/01/11/chainmaker/image-20240204143844766.png" alt="image-20240204143844766"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;配置长安链&lt;/p&gt;</summary>
    
    
    
    
    <category term="Blockchain" scheme="https://alleysira.github.io/tags/Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>sp23_find_spec_blind_spots_via_fuzz_testing</title>
    <link href="https://alleysira.github.io/2024/01/10/sp23-find-spec-blind-spots-via-fuzz-testing/"/>
    <id>https://alleysira.github.io/2024/01/10/sp23-find-spec-blind-spots-via-fuzz-testing/</id>
    <published>2024-01-10T09:22:21.000Z</published>
    <updated>2024-01-19T07:21:16.556Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Ji R, Xu M. Finding Specification Blind Spots via Fuzz Testing[C]//2023 IEEE Symposium on Security and Privacy (SP). IEEE Computer Society, 2023: 2708-2725.</p><span id="more"></span><p>形式化验证能够证明保持验证过的程序和声明的spocifications(SPEC)保持一致，但是如何保证SPEC是完备的 没有逻辑漏洞？本文使用Fuzzing-Assisted Specification Testing来解决这个问题。</p><p>核心思路是利用形式化验证过的程序的冗余性和多想想进行交叉检查。 </p><p>具体来讲，在同一个代码库中，SPEC（规范）、实现（CODE）和测试套件都是从同一组业务需求中派生出来的。因此，如果某个意图在CODE和测试用例中被捕捉到，但在SPEC中没有，则这表明SPEC存在盲点。</p><p>FAST以自动化的方式检查SPEC中的不完整性问题：它首先通过变异测试来定位SPEC的缺口gap，即通过检查CODE变体是否符合原始的SPEC来确定是否存在缺口。如果是这样，FAST进一步利用测试套件来推断缺口是由意图引起还是由错误引起的。根据代码库的大小，FAST可以选择以枚举方式还是进化方式生成CODE变体。FAST被应用于两个具有形式验证特性的开源代码库，并且分别帮助确认了它们SPEC中的13个和21个盲点。这凸显了SPEC不完整性在真实应用中的普遍存在。</p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>形式验证通过数学方法检查程序的正确性，为计算系统提供高度保证，即程序的行为完全受限于描述为一组期望属性（规范）的形式建模语言。形式验证在硬件和软件系统中已经被广泛采用。典型的应用场景包括可能导致重大损失和不可逆后果的情况（例如航空领域），或者传统的滚动式程序升级模型不可行的情况，如区块链上的智能合约。</p><p>形式化验证可以分解为两步</p><ul><li>1 设计目标系统的一系列规范 SPEC</li><li>2 证明实际的实现 CODE 和规范 SPEC是否符合，即$SPEC \sqsubseteq CODE$</li></ul><p>目前学术界在2方面进展迅速，但是1被关注较少。这就存在着严重的问题，即使一个程序经过完善的验证工具链进行了彻底的验证，该程序的正确性也仅限于其规范，程序中可能存在着盲点。由于目前形式化验证的成本较高、技术门槛较高，进行SPEC编写的人员一般不是写代码发的，作者想传达的思想是不能盲目的相信形式化验证后的代码，还需要去理解SPEC完备性的重要性</p><p> 硬件领域对SPEC完整性的研究比较多，现有的工作基于mutation testing，即将CODE或者SPEC进行变异，检查变异体是否依然符合旧的内容，因此，任何存活的变异体都会引发一个信号，表明规范可能是不完整的</p><p>因此去可以去研究：</p><ul><li>变异测试 mutation testing 是否能够应用于软件安全</li><li>如果不能，可以采用怎样的改进</li><li>优化后来解决成熟的代码库中是否普遍存在规范不完备的问题</li></ul><p>本文的主要工作是首先确认了采用变异测试能够高效地发现SPEC的漏洞，但是对于复杂的程序，基于变异的测试不够有效</p><h2 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h2><ul><li>当mutant通过了验证，如何证明SPEC之间的gap是故意而为还是错误<ul><li>解决思路：利用形式化验证程序中的冗余性和多样性，即代码 SPEC和测试套件都是从一组需求来的，但是以不同的思维方式进行编程：例如，使用不同的编程语言（甚至是编程范式）实现的，具有不同的演进路径，一般不同且独立的团队进行编写。因此，这三个不太可能出现相同的错误。</li><li>可以通过相互比较来发现错误</li></ul></li><li>如何构造一个更容易通过验证的mutant<ul><li>解决思路：fuzzer的遗传算法，计算每个mutant的fitness，只有高质量的mutant才可能被多次变异，fitness的标准就是验证后触发的错误（这也太trivial了）</li></ul></li></ul><p>FAST无法保证一定没有完备性问题，但可以用于说明程序中不存在明显的逻辑漏洞</p><h2 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h2><p>本文的贡献包括</p><ul><li>概念：我们指出形式验证程序中规范、代码和测试套件的“冗余性”和“多样性”，并利用这种冗余性（通过将测试套件作为“裁判”）来解决判断规范中缺陷是故意还是错误的问题，。</li><li>设计：采用基于遗传的进化，每个新的mutant会更难被杀死<ul><li>如何保证输入的多样性</li></ul></li><li>影响：分别发现了DPN和S2N中13个和21个盲点</li></ul><h1 id="Background-and-related-work"><a href="#Background-and-related-work" class="headerlink" title="Background and related work"></a>Background and related work</h1><p>介绍形式验证和规范不完整性问题以及变异测试和模糊测试</p><h2 id="形式化验证"><a href="#形式化验证" class="headerlink" title="形式化验证"></a>形式化验证</h2><p>已经被广泛应用在软件和硬件、密码学库(HACL*)、编译器、网络协议和智能合约(diem)中</p><p>步骤</p><ul><li>采用抽象逻辑语言设计SPEC</li><li>开发形式化工具来推理SPEC和目标代码实现之间的关系</li></ul><p>矛盾在于，一个理想的规范集需要足够完整，能够捕捉到所有利益相关者的意图，同时又需要足够抽象，以便在实施选择方面具有灵活性。例如，如果需求是对数组排序，SPEC需要足够完备能够理解排序的语义，然而需要足够抽象能够支持快排和归并排序的实现</p><p>然而，开发一个高质量的规范集是困难的。一个与代码相对应的规范集在实际价值上几乎没有意义，只会使代码库臃肿，导致代码更改的摩擦和更高的维护成本。另一方面，如果规范过于抽象，可能无法捕捉到一些基本的设计要求，在代码中可能存在未被发现的潜在漏洞。</p><p>目前的工作都是基于启发式手动调整的checklist</p><h2 id="自动化函数验证"><a href="#自动化函数验证" class="headerlink" title="自动化函数验证"></a>自动化函数验证</h2><p>本文主要聚焦于具有前置条件和后置条件的函数正确性验证，有时也被称为“按设计实现”的验证</p><p>在函数验证中，规范的目标通常是构成单个函数的代码，开发人员以SPEC谓词的形式为函数体提供前置条件和后置条件，这些谓词通常包括对函数参数和/或可以由函数中的代码引用的环境状态的条件。规范可能包含没有具体可执行语义的构造，例如对无界域的量化。虽然针对单个函数进行规定的,前置条件和后置条件不仅限于仅确立一个函数的正确性，它们对整个程序正确性的确立作出贡献，因为前置条件在调用方验证，从而可以在调用后假设后置条件。</p><p><img src="/2024/01/10/sp23-find-spec-blind-spots-via-fuzz-testing/image-20240111192543156.png" alt="image-20240111192543156"></p><p>例子中的ensures是一个后置条件，验证工具的任务是将代码和规范融合为可以交给后端求解器（通常是SMT求解器）处理的证明义务。</p><h2 id="规范SPEC的完备性"><a href="#规范SPEC的完备性" class="headerlink" title="规范SPEC的完备性"></a>规范SPEC的完备性</h2><p>图1中的代码符合SPEC，但是SPEC忽略了一个问题，如果add1函数的实现方式与图2a中所示，在原始循环之后还有一个额外的pop()操作。当前的规范只检查向量中每个剩余元素的值是否增加了一，忽略了对数据长度的校验。完整的规范如图2b所示，其中还有一个额外的ensures子句，进一步限制了add1函数修改输入向量的能力。这个缺失的ensures子句代表了原始规范的不完整性问题。</p><p><img src="/2024/01/10/sp23-find-spec-blind-spots-via-fuzz-testing/image-20240111193038531.png" alt="image-20240111193038531"></p><p>这里的问题出现在写SPEC实际上是另一种形式的编程，如何保证SPEC没有bug也很重要。这个问题被称为<em>gauging the completeness of SPEC</em>，在硬件领域受到了较多的关注，硬件领域主要采用的方法是mutation testing。</p><h2 id="Mutation-testing"><a href="#Mutation-testing" class="headerlink" title="Mutation testing"></a>Mutation testing</h2><p>mutation testing的idea来自于对软件测试的测试用例的怀疑主义，代码的安全性由测试保证，测试用例的安全性如何保证呢？这与FAST旨在解决的规范不完整性问题类似。</p><p>其实mutation based testing是从1970年代就开始被研究的一种方法</p><p>代码测试可以分为</p><ul><li>单元测试</li><li>集成测试</li><li>端到端测试</li></ul><p>用于测试不同测试组件的质量</p><p>同样可以用于测试没有具体语义的程序</p><p>硬件测试中，变异测试的目的是通过引入功能变换来评估给定的硬件SPEC的完整性。</p><h2 id="fuzzing中的遗传策略"><a href="#fuzzing中的遗传策略" class="headerlink" title="fuzzing中的遗传策略"></a>fuzzing中的遗传策略</h2><p>由于输入的状态空间较大，完全随机的输入生成实际作用不大。</p><p>在现代模糊测试研究中，处理状态探索问题的一种方式是模拟自然选择过程，结合随机变异和适者生存。具体而言，在每个变异轮次中，随机变异被用于增加探索尚未探索的路径的机会。适者生存的过程通过根据反馈（例如，在大多数模糊测试中的代码或路径覆盖）有效地对不同的种子进行排序，并给予排名较高的种子更好的机会来生成未来测试轮次的输入。</p><p>在模糊测试器的所有构建模块中（例如变异规则、种子调度、反馈机制），提供对种子质量的客观评估的度量标准对于模糊测试器的有效性至关重要。</p><p>AFL用了代码覆盖率，FAST提出了一种新的度量标准：利用求解器中的验证错误数量和多样性。</p><p>Language fuzzing好像和目前的虚拟机比较接近？语言模糊测试旨在发现编译器或解释器（例如虚拟机或JIT引擎）中的问题，这几篇可以再看一看</p><p><img src="/2024/01/10/sp23-find-spec-blind-spots-via-fuzz-testing/image-20240113193234749.png" alt="image-20240113193234749"></p><ul><li>Superion: Grammar-aware Greybox Fuzzing.</li><li>Soyeon Park, Wen Xu, Insu Yun, Daehee Jang, and Taesoo<br>Kim. Fuzzing Javascript Engines with Aspect-preserving<br>Mutation. In Proceedings of the 41st IEEE Symposium on<br>Security and Privacy (Oakland), San Francisco, CA, May<br>2020.</li><li>JQF: Coverage-guided Property-based Testing in Java.</li></ul><h1 id="The-Tale-SPEC-CPDE-and-Tests"><a href="#The-Tale-SPEC-CPDE-and-Tests" class="headerlink" title="The Tale SPEC CPDE and Tests"></a>The Tale SPEC CPDE and Tests</h1><p>生成多样的mutant不是挑战，评价生成的mutant的有效性是更重要的问题，本文中指通过了SPEC的mutant，在这里还需要判断这个mutant是否故意设计的gap</p><p>核心idea或者假设是：SPEC（来自于spec团队）、CODE（来自于开发者）、test suites（来自于QA质量保证团队）、三者不太可能犯同样的错，可以通过运行其中一个，和另外两个交叉对比检查正确性，实际上在测试用例中运行并检查SPEC就是一个例子</p><h1 id="变异"><a href="#变异" class="headerlink" title="变异"></a>变异</h1><ul><li><p>类型保留的变异：为了产生有效的CODE变异体，保证至少应该能够编译和执行，不具有参考价值</p></li><li><p>枚举变异：根据表1中讨论的有限的变异规则集合，对于在原始CODE中没有太多指令的小型代码，即使用算法1中描述的算法尝试所有可能的变异策略</p><ul><li>不支持一次修改多个运算符</li><li>改变循环结构的方法<ul><li>if else对换</li><li>continue break对换</li><li>三目运算符 对换</li></ul></li></ul></li></ul><p><img src="/2024/01/10/sp23-find-spec-blind-spots-via-fuzz-testing/image-20240113194902827.png" alt="image-20240113194902827"></p><p><img src="/2024/01/10/sp23-find-spec-blind-spots-via-fuzz-testing/image-20240113201033819.png" alt="image-20240113201033819"></p><h2 id="案例：Diem-支付网络"><a href="#案例：Diem-支付网络" class="headerlink" title="案例：Diem 支付网络"></a>案例：Diem 支付网络</h2><p>居然是区块链的例子，泪目了</p><p><img src="/2024/01/10/sp23-find-spec-blind-spots-via-fuzz-testing/image-20240113201711218.png" alt="image-20240113201711218"></p><ul><li>首先，静态分析AST，寻找所有可能的变异的地方</li><li><p>迭代地检查每个变异点，并按照表1中的通用变异规则生成CODE mutant。对于常量变异，CODE随机选择表1中列出的三个变异规则之一作为变异目标</p></li><li><p>对于每个生成的CODE突变，FAST将其传递给证明器，与原始的SPEC一起进行验证，并检查Move证明器的验证结果。Move证明器将报告验证状态以及验证错误的详细说明，即在CODE的哪一行违反了哪个SPEC属性</p></li></ul><p>结果：发现了404个可以进行变异的地方</p><h1 id="基于遗传策略的CODE变异"><a href="#基于遗传策略的CODE变异" class="headerlink" title="基于遗传策略的CODE变异"></a>基于遗传策略的CODE变异</h1><p>问题：当代码规模过大时，不适合将所有可能的突变点进行变异</p><p>遗传算法需要回答的两个问题：</p><ul><li>变异的对象<ul><li>solution：在进化开始之前，预先收集CODE中的潜在变异点。在这个信息收集步骤中，FAST从头到尾扫描给定的CODE，并将每个指令与表1中定义的可能的变异模式进行匹配</li></ul></li><li>哪个mutant更加适合作为下一轮的种子<ul><li>适度fitness评估：出现更少的错误，发现先前未知的验证错误均是好的mutant的表现</li><li>SPEC覆盖率是通过CODE变异体触发的验证错误来衡量的。对于每个未通过验证的CODE变异体，FAST期望从验证器那里得到一个报告来描述失败的原因。这个报告可以是一个简单的二进制通过/失败信号，也可以是一个包含 $SPEC \ X$ 在 $CODE$ 位置 $Y$ 由于原因 $Z$ 失败的记录的元组$(X, Y, Z)$列表。信息越详细，FAST对变异体的“适应度”测量就越好。</li><li>幸运的是，在实践中，大多数形式化验证工具都可以给出非常详细的验证错误解释，甚至包括可以具体执行以确定错误的反例。</li><li>CODE变异体都被分配了一个初始分数，该分数与两个因素成反比：1）剩余的验证错误数量和2）变异trace的长度。对于相同的验证错误集，FAST偏向于较小的变异体（即与原始CODE的编辑距离较小，类似于NeoDiff）</li></ul></li></ul><h2 id="fuzz的流程"><a href="#fuzz的流程" class="headerlink" title="fuzz的流程"></a>fuzz的流程</h2><p>seed pool保存着有意义来进行后续变异的种子code，种子都是根据分数排序的，每轮首先是种子选择算法，排序给出当前轮的种子并进行变异</p><ul><li>如果验证通过，分析是否为误报</li><li>如果验证失败，评估新code的适度，如果适合则保存该种子。同时，更新父种子的分数，并将父种子也加回到池子中<ul><li>如何保证种子的多样性？多给一些CODE，初始权重一样</li></ul></li></ul><p>值得一提的是，与可以从具有许多测试用例的种子池中启动的传统模糊测试不同，FAST的种子池在开始时只有一个种子，即没有任何变异的原始CODE。FAST给予这个创世种子足够高的分数，以便快速填充种子池中大量的单变异种子。但是在引导期之后，从FAST的角度来看，这个创世种子与其他种子没有区别。</p><p><img src="/2024/01/10/sp23-find-spec-blind-spots-via-fuzz-testing/image-20240113204315985.png" alt="image-20240113204315985"></p><h1 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h1><ul><li>测试套件的有效性</li><li>遗传算法的有效性：图6显示了在S2N上继续运行进化变异测试时，FAST发现的存活变异体数量的累积情况，大概在2^16秒时饱和</li></ul><p><img src="/2024/01/10/sp23-find-spec-blind-spots-via-fuzz-testing/image-20240113210923890.png" alt="image-20240113210923890" style="zoom:67%;"></p><h1 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h1><ul><li>变异SPEC：目前的方法是变异code而不是SPEC，理论上是可以反过来发现同样的gap<ul><li>然而，CODE和SPEC变异的对称性仅适用于发现SPEC中的差距，并不适用于判断差距是有意的还是错误的过程。在FAST中，可以通过对CODE变异体运行测试来对差距进行分类。但对于SPEC变异体来说，运行测试是徒劳的，因为CODE没有修改。这是FAST不采用SPEC变异方法的主要原因。</li><li>将对称性扩展到差距分类过程的解决方案是SPEC嵌入，即在适当的CODE位置嵌入SPEC并运行测试套件。</li></ul></li><li>基于coverage的SPEC完备性测试工具：<ul><li>目前流行用覆盖度（行覆盖度、指令覆盖度或分支覆盖度）来表示完整性，开源项目的谨慎维护者甚至可能要求任何新的CODE都必须附带测试用例，以保持代码库中的CODE覆盖率高。</li><li>目前没有用于测量SPEC的CODE覆盖度的工具，挑战在于似乎每个CODE片段都会参与到证明一些SPEC属性的过程中，很难解开复杂的逻辑公式。</li></ul></li><li>FAST的应用<ul><li>可应用的对象具备：验证系统是完全自动化的；FAST可以修改某种形式的CODE表示（LLVM IR）</li><li>FAST的普适性受到限制，因为形式验证尚未成为标准的工业实践，大多数软件中缺少SPEC</li></ul></li><li>可能错过一些gap的原因：<ul><li>变异演化方法本质上是不完整的。类似于为什么模糊测试无法找到软件中的所有错误一样，进化变异策略无法产生能够揭示SPEC中所有差距的CODE变异体——搜索空间太大无法枚举。</li><li>某些SPEC差距需要手动确认，特别是在第5种情况下，CODE变异体的验证失败——需要手动检查验证失败是由于不同步的证明提示（隐藏了SPEC差距）还是真正的SPEC违规引起的。</li></ul></li></ul><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>本文介绍了FAST工具，用于揭示形式SPEC中的不完整问题。FAST展示了如何通过交叉检查将形式验证程序（SPEC、CODE和测试套件）中的“冗余”和“多样性”协同起来，并通过枚举和进化变异测试提供了具体的设计和实现，用于检测SPEC中的盲点。本文将FAST应用于DPN和S2N，并分别确认了它们SPEC中的13个和21个盲点。这凸显了SPEC不完整在现实世界应用中的普遍存在。作者希望FAST的发现可以一定程度上呼吁社会，引起更多关于测量和确保形式验证代码库中SPEC质量的关注。</p><h2 id="可参考论文"><a href="#可参考论文" class="headerlink" title="可参考论文"></a>可参考论文</h2><p>mutation testing的</p><ul><li>Assessment of class mutation operators for c++ with the mucpp mutation system</li><li>Users guide to the pilot mutation system</li><li>W Eric Wong. Mutation Testing for the New Century, volume 24. Springer Science &amp; Business Media, 2001.</li><li>Timothy Alan Budd. Mutation Analysis of Program Test Data. Yale University, 1980.</li><li>Pedro Reales Mateo and Macario Polo Usaola. Reducing<br>mutation costs through uncovered mutants. Software Testing, Verification and Reliability, 25(5-7):464–489, 2015.</li><li>Baowen Xu, Xiaoyuan Xie, Liang Shi, and Changhai Nie.<br>Application of genetic algorithms in software testing. In<br>Advances in Machine Learning Applications in Software<br>Engineering, pages 287–317. IGI Global, 2007.</li></ul><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><ul><li>种子选择<ul><li>根据适度进行排序</li></ul></li><li>种子变异<ul><li>可以参考具体的对运算符进行的变异策略、改变循环结构</li><li>evmfuzz是每次变异一个位置后就执行，根据变异造成的效果改变变异器的权重；FAST是每次将所有能变异的地方进行变异，高阶变异是3个点同时变异</li></ul></li><li>种子评估：剩余的验证错误数量和变异trace的长度，倾向于发现新的验证错误、尽可能短</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Ji R, Xu M. Finding Specification Blind Spots via Fuzz Testing[C]//2023 IEEE Symposium on Security and Privacy (SP). IEEE Computer Society, 2023: 2708-2725.&lt;/p&gt;</summary>
    
    
    
    
    <category term="Mutation Testing" scheme="https://alleysira.github.io/tags/Mutation-Testing/"/>
    
  </entry>
  
</feed>
